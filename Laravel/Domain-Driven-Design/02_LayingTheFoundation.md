## 라라벨에서의 DDD

### agnostic(불가지론적인) 접근방식
#### 시스템 아키텍처에 대한 불가지론적 접근 방식
- 언어, 프레임워크, 데이터베이스, 데이터베이스가 계속 존재하는지 아닌지 등의 부분은 도메인 로직과는 관계가 없는 부분이다. DDD는 도메인 로직의 설계를 하기 위한 방법이다.
- 불가지론적 접근 방식이라는 것은 어떤 언어를 사용할지, 어떤 프레임워크를 사용할지, 어떤 데이터베이스, 어떤 데이터를 사용할지 미리 결정하지 않는 방식이다.
- 언어, 프레임워크, 데이터베이스, 데이터베이스의 데이터를 사용하는 계층과 이와 독립적으로 만들어진 도메인 로직을 구현을 위한 계층이 존재하도록 만들어야 한다. 레이어가 나눠져서 도메인 로직만을 구현할 수 있어야 한다.
- DDD는 언어, 프레임워크, 데이터베이스, 데이터베이스에 관계 없이 확장 가능한 엔터프라이즈 시스템을 설계하기 위한 방식이며 이에 종속되지 않고 설계가 가능한 일반적인 접근 방식으로 이해 되어야 한다.

### 불가지론적 접근방식인데 왜 라라벨인가?
- Laravel과 라라벨의 Eloquent는 도메인레이어를 구축하는 것에 집중할 수 있는 툴을 제공한다.
- 웹 프로그래밍에서는 최근에서야 DDD와 프레임워크가 웹 기반의 응용 프로그램을 작성하는데 잘 결합 될 수 있을 만큼 가까워 지게 되었다.
- 라라벨은 DDD를 구현하는데 아주 유용하다.

### 웹 어플리케이션에서의 DDD
- DDD의 불가지론적 접근방식은 웹 어플리케이션과 맞지 않는다. 왜냐하면 웹 프레임워크가 가지고 있는 기본적인 구조가 이미 있기 때문에 DDD로 설계한 개념을 그대로 적용할 때 웹 프레임워크의 기본 구조와 맞지 않는 영역이 있다.
- 도메인 디자인에 대한 일반적인 지식이 있다고 하더라도 웹 어플리케이션에 적용하기 위해서는 웹 어플리케이션의 기본 구조에 맞게 변형된 도메인 디자인을 적용할 줄 알아야 한다. (도메인 주도 설계 책만 본다고 해서 웹 어플리케이션에서 제대로 DDD를 설계하기 어렵다. 웹 어플리케이션 영역에서의 DDD를 소개하는 책의 가이드를 받는 것이 올바르게 DDD를 웹 어플리케이션에 적용하기 위한 방법이 될 수 있다.)

### 라라벨에서의 DDD
- 라라벨에 도메인 주도 설계를 적용하기 위해서는 repositorie, DTO, factory, job 등의 DDD에서 다루는 Technical Strategies이 필요하다.
- DDD의 Technical Strategies는 Laravel의 구성 요소 및 내부 동작과 부합하는 부분이 많기 때문에 라라벨은 DDD를 적용하기에 적합한 구조이다.
- DDD를 구현하기 위해서는 많은 사전 작업이 필요하고 상황에 따라 많은 시간을 투자해야 한다. 따라서 DDD의 도입은 아주 신중하게 결정해야 한다.
- 하지만 라라벨과 같은 웹 프레임워크를 사용하는 경우에는 DDD 구현에 필요한 도구들이 이미 존재하므로 스타트업에서도 DDD를 투자할만하다.
- 라라벨이라는 웹 어플리케이션 프레임워크라는 컨텍스트 안에서 어떤 구성요소를 만들어 봄으로써 도메인 주도 설계에 대한 견고한 이해를 바탕으로 도메인 주도 설계를 잘못 했을 때 당면하는 재난을 피하는 방법을 학습할 필요가 있다.

### DDD 구현에서 주의 사항
- 반쯤 학습된 DDD 구현은 위험할 수 있다. 왜냐하면 DDD의 기술들에 대한 잘못된 이해로 소프트웨어를 만들어 나갈 경우, 이후 이를 바로잡기 위해 많은 리펙토링 비용을 지불하게 될 수 있기 때문이다.
- 잘못된 DDD의 개념 적용 인해 어플리케이션의 많은 코드를 재작성 해야 하는 문제를 발생 시킬 수 있다. 
- DDD 기반 디자인을 사용하기로 결정하려면 도메인 모델의 요구 사항과 기본 비즈니스 모델이 소프트웨어로 얼마나 복잡하게 표현될 것인지 신중하게 검토한 후에 이를 분명한 로직으로 변화를 이끌어 낼 수 있을 때 적용 해야 한다.
- DDD는 비용이 많이드는 작업이므로 이 비용을 최소화 하기 위해 도메인 주도 설계에 대한 균형잡힌 지식을 학습하고 도메인 주도 설계의 오용 및 남용이 없도록 배워야 한다.

### DDD의 장점
- 하나의 도메인에 너무 많은 개념과 아이디어 구체화 등이 담겨 있을 경우 도메인의 해석이 잘못되거나 개념적 혼란이 생길 수 있다. 하지만 도메인 주도 설계를 배워두면 이런 문제의 발생이 최소화 된다.
- 소프트웨어의 생산성과 품질을 높이는 아이디어를 얻을 수 있다.

### DDD의 단점
- DDD를 배우기 위해 알아야 할 개념들이 많고 해당 개념에 따라 구현해야 할 코드들이 늘어난다. 이를 오버헤드가 있다고 표현한다.

### 유비 쿼터스 언어
- DDD는 불가지론적인 방식이므로 실제 구현에 관한 요소 언어, 디비 등과는 별도의 도메인의 지식적인 설계가 필요하다. 이런 도메인 설계를 표현하기 위한 수단이 유비쿼터스 언어이다.
- 도메인 전문가들이 참여해서 모델을 구축해야 하기 때문에 잘 구축된 유비쿼터스 언어는 저렴하지 않다.

### 도메인 주도 설계가 실패하는 이유
- 비즈니스의 용어 및 관점을 애플리케이션 레벨에서 구현할 때, 원래의 의도와는 다르게 쓰여 진짜 필요한 비즈니스적인 관점이 무엇인지 모르게 되어 버릴 수 있다.
- 시스템을 만들 때 도메인 전문가가 참여하지 않아 도메인이 잘못 만들어져 있을 경우 잘못된 디자인의 연쇄가 발생할 수 있다.
- 도메인 전문가가 아닌 개발자의 가정을 통한 개발이 이뤄지고 개발자가 생각하는 방향으로 프로젝트가 진행되기 때문에 잘못 구현되는 일이 발생한다.
- 도메인 로직을 개발하기 전에 충분히 해당 도메인에 대한 검토와 생각을 해야 하지만 그렇지 않아서 잘못된 구성요소와 모듈을 만들게 된다.

### 앞으로 배워 나갈 것
- 다양한 모범 사례를 통해 실현 가능한 방식으로 도메인 모델을 구축하는 방법을 배울 것.
- DDD 도메인의 방대한 양의 지식 가운데 정제된 지식을 얻을 수 있을 것.
- DDD에 대한 잘못된 설계가 초래하는 문제점에 대해 살펴 볼 것.

### 바퀴를 재발명하지 말자.
- DDD는 어떤 면에서 일반적인 웹 어플리케이션의 개발 방식에 비해서 훨씬 더 많은 비용을 초래할 수 있다. DDD를 통한 비용의 증가를 최소화 하기 위해서 잘 개발된 모듈을 재사용하는 방식을 사용할 필요가 있다.
- 특정 비즈니스 모델에 잘 맞춰진 유비쿼터스 언어를 만들고 entities, value objects, domain-level components를 만들어 재사용성을 증가시키기 위한 개발을 하는 방법을 배울 필요가 있다.
- 프레임워크에는 이미 많은 기능이 만들어져 있기 때문에 프레임워크의 기능을 최대한 활용한다면 바퀴를 다시 만들 필요가 없어서 생산성이 증가한다. 프레임워크의 기능을 최대한 활용한다면 도메인 모델을 빌드하는데만 집중할 수 있다.

## Eloquent ORM
- 라라벨에서 도메인 중심 디자인을 개발하는 데 가장 중요한 도구 중 하나는 Eloquent이다.

### DDD와 ORM
- 데이터 질의어(Data Definition Language)를 코드를 작성할 때 직접 사용하는 것은 도메인 주도 설계의 내부 관행과 가치에 맞지 않는다. 왜냐하면 DDD는 불가지론적인 방법인데 데이터 정의어를 직접 사용하는 것은 특정 DB등에 종속되는 것이기 때문이다.
- 다양한 데이터베이스에 대한 데이터 조작을 동일한 방식으로 할 수 있는 엑티브 레코드 곧 ORM을 사용하는 것은 디비의 질의어에 종속되지 않기 때문에 DDD에 적합하다.
- 디비 등의 저장소의 데이터를 조작해야 하는 도메인의 이벤트를 허용한다.

### ORM의 장점
- 모델 간의 관계를 생성 및 관리가 편리하다.
- 모델의 생성 및 관리를 편리하게 하여 복잡한 질의어가 아닌 간단한 표현적인 구문을 사용하여 쿼리 처리를 할 수 있다.
- ORM은 데이터를 가져와서 객체에 저장을 하고 있다. 모델을 통해서 업데이트 작업이 일어나면 객체에 데이터를 다시 저장하는 로직이 필요하다. 이러한 작업을 ORM이 자동으로 해 준다.

### Eloquent ORM의 특성
- 대량 할당 (messive assignment)
- 쿼리 스코프
- Eager loading
- 컬렉션
- 모델 이벤트
- 모델 옵저버
- 모델이 유효하고 일관된 상태인지 체크
- 잘못된 사용을 방지하기 위해 적절한 제한이 있는지 확인하는 유효성 검사 구성 요소가 존재

### 객체
- 기본적으로 클래스에는 멤버 변수와 멤버 메소드가 존재한다. 멤버 변수는 객체의 상태를 저장하는 부분이며, 멤버 메서드는 객체의 상태를 변경하기 위한 조작 기능을 정의한 곳이다.
- 기본적으로 객체는 데이터를 저장하는 부분과 데이터의 변경하는 기능을 동시에 가지고 있다. 하지만 현재 프로그래밍에서는 객체의 데이터와 동작을 분리하는 방식을 고안하는 경향이 커졌다.
- 객체의 데이터와 데이터를 변경하는 기능을 분리하는 방식의 프로그래밍을 DTO라고 한다. 이는 나중에 다루게 될 것.
- 기본적으로는 객체의 멤버를 다루기 위한 getter와 setter가 존재하는 객체로 이해를 한다.

### DTO
- 기본적인 객체의 특성을 가지고 있으면서 데이터를 객체에 매핑한 객체이다. 
- 단순 매핑의 기능을 담당하는 개념을 가진 대상이기 때문에 디비의 데이터를 저장하고 읽고 변경하는 로직만 존재한다.
- Data Transfer Object라고 부르는데 데이터의 CURD를 다루를 객체를 의미한다. 보통은 디비의 데이터를 객체로 다루기 위한 방식이다.
- 다량의 쿼리 요청을 방지하기 위해서 영속성 계층(영속성 계층 : 데이터 베이스 등 영구적으로 데이터가 저장되는 계층)에서 데이터를 한 번만 가져와서 저장한 데이터에 대한 getter, setter 등의 동작을 제공한다.
- 데이터는 멤버 변수에 매핑이 되어 있으며, 데이터를 가져올 때는 getter를 통해서 디비의 데이터를 가져오며, 데이터를 변경할 때는 setter를 통해서 디비의 데이터를 조작한다.
- 어떤 객체에 직접적인 쿼리나 쿼리 빌더 등을 통해서 데이터를 가져오는 getter를 만들 수도 있고, 데이터를 수정하는 setter를 만들 수도 있다. 데이터를 한 번 가져와서 저장하기 때문에 보통은 생성자에 데이터를 가져오는 로직을 만든다.
- DTO 객체는 영속성 계층(데이터 베이스 등 영구적으로 데이터가 저장되는 계층)에서 데이터를 가져와서 멤버에 저장하는 방식으로 사용되므로 단순 쿼리를 사용하게 좋게 모듈화한 인터페이스는 아니다.

#### DTO 계층을 만드는 이유
- 한번 가져온 데이터를 여러 번의 엑세스를 하는 경우, 매번 쿼리를 사용하여 가져올 필요가 없다. 영속성 계층의 데이터의 변경이 일어나기 전까지는 한번 데이터를 가져와서 저장한 객체에 접근하여 데이터를 가져오면 훨씬 효율적이다.
- 하지만 데이터의 변경이 이뤄지는 경우 이를 감지하여 DTO의 데이터를 리프레시 해 줘야 한다. 라라벨의 Eloquent ORM은 모델 옵저버 기능을 활용해 데이터의 변경이 일어났을 경우, ORM의 데이터를 변경해 주는 기능을 가지고 있다.

#### 라라벨에서의 DTO
- 라라벨의 Eloquent ORM은 완벽한 DTO가 아니다. 디비의 데이터를 가져오기 위한 제약 및 관계를 만들기 위한 기능 등 실용적인 쓰임을 위해서 만든 객체이다.
- ORM에서 사용할 수 없는 쿼리의 세부적인 컨트롤 등을 위해서 ORM과 영속성 계층 사이 DTO를 정의하여 쿼리를 세부적으로 컨트롤 하는 인터페이스를 제공하는 객체를 만들 수 있다. 하지만 대개의 경우, ORM이 제공하는 기능을 활용해서 편리하게 레포지토리 인터페이스를 만들 수 있기 때문에 DTO 계층을 따로 만들 필요는 없다.


### Eloquent 모델의 예
```
<?php
namespace App\Models;
use Illuminate\Database\Eloquent\Model;
class Custormer extends Model
{
  public $table = 'customers';
  protected $fillable = ['name', 'phone', 'phone_type'];
}
```
