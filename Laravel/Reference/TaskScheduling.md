## 라라벨 스케쥴러란?
- 리눅스의 크론에 이해하기 어려운 표현으로 장황하게 스케쥴링 할 대상을 정의하는 어려움을 개선하기 위해 라라벨의 스케쥴러를 통해서 크론 작업을 실행하게 한 것이다.
- 이를 위해서 리눅스의 크론에 라라벨의 스케쥴러를 매분 실행하는 한 줄의 스케쥴을 추가해 주어야 한다.

### 라라벨 스케쥴러의 장점
- 리눅스 크론을 사용하기 위해서는 리눅스 크론을 동작시키기 위한 크론 문법을 알아야 한다. 하지만 라라벨 스케쥴러를 사용하면, 리눅스 크론에 한 줄의 라라벨 크론을 동작시키는 코드를 등록하는 것으로 라라벨을 통해서 크론을 활성화 시킬 수 있다. 좀 더 구조화 되어 있고 적절한 메소드명으로 제공되는 인터페이스를 통해서 이해하기 쉬운 표현으로 크론을 스케쥴링을 할 수 있다.
- 스케쥴링의 코드가 변경될 때 일일이 리눅스 크론을 재정의 할 필요가 없이 서버의 라라벨 코드 변경만으로도 스케쥴링을 변경할 수 있다.

## 라라벨 스케쥴러 등록
- 리눅스 크론텝에 다음 코드를 넣는다.
```
* * * * * cd /path-to-your-project && php artisan schedule:run >> /dev/null 2>&1
```
- path-to-your-project 부분은 라라벨 프로젝트 폴더, `php artisan` 명령어를 실행할 수 있는 부분으로 연결 해 줘야 한다.
- `* * * * * `는 매 분마다 크론 잡을 실행하라는 의미이다.
- `php artisan schedule:run >> /dev/null`는 `php artisan schedule:run` 리눅스 크론이 실행한는 명령어이고 라라벨의 스케쥴러를 실행하고 실행한 출력 결과가 `/dev/null`라는 파일에 추가로 기록된다는 것을 의미한다. `>>`가 실행 결과를 파일에 추가로 기록한다는 의미이다.
- `/dev/null`이란 파일은 기록을 하지 않는 파일을 의미한다. 따라서 전달된 결과 값은 기록을 하지 않는다는 의미이다.
- 리눅스에는 표준입력, 표준출력, 표준에러라는 개념이 있다. 0은 표준입력을 의미하며, 1은 표준출력을 의미하며, 2는 표준에러를 의미한다.
- `>`는 파일의 내용을 비우고 전달한 값을 기록한다는 의미를 갖는다. 기본적으로 `>` 다음에는 파일을 지정하며 표준출력으로 전송한 값을 지정한 파일로 보낸다는 의미를 가진다. 이 때 파일을 지정하는 것이 아니라 표준출력으로 전송할 값을 다른 값으로 바꾼다는 의미를 갖게 하려면 `&값`의 표현을 사용한다. 
- `2>&1`는 표준에러를 표준출력으로 바꾼다는 의미를 가진다. 쉘 스크립트를 실행하는 과정에서 오류가 발생하면 뭔가 대단한 사건이 일어난 것 처럼 느껴진다. 따라서 라라벨에서 나온 실패는 라라벨 자체적으로 처리할테니 쉘에서는 애러라고 판단하여 뭔가 일어난 것처럼 난리 피우지 말고 그냥 에러 메시지를 문자열로 출력하라는 의미에서 지정한다.
- 곧, 전체 의미는 라라벨의 스케쥴러 명령어를 실행한 결과 로그는 라라벨에서 기록하니까 OS에서는 기록하지 말라는 의미이며, 이 때 에러가 발생한 경우 에러로 쉘에서 에러 났다고 소란 피우지 않도록 문자열로 로그를 전달하도록 설정한다는 의미이다.
- Reference : https://stackoverflow.com/questions/10508843/what-is-dev-null-21

## 라라벨 스케줄러의 특징
- 리눅스의 크론은 매 분마다 라라벨의 `php artisan schedule:run`이란 명령어를 실행한다. php는 기본적으로 하나의 실행 프로세스를 만들어낸다. 스케쥴러의 로직도 하나의 프로세스로 동작한다. 크론이 매 분마다 돌고 있기 때문에 매 분마다 하나의 실행 프로세스가 생성된다. 그런데 스케쥴러의 작업의 길이가 분 단위를 넘어가는 경우에는 매 분마다 실행되는 다음 스케쥴러의 실행으로 실행 프로세스가 여러 개 실행이 되는 경우가 생긴다. 이렇게 여러 개의 테스크가 누적 되는 경우 시스템의 CPU라든가 메모리 자원의 문제가 생길 수 있다.
- 하나의 스케줄러에는 여러 개의 작업이 등록된다. 스케줄러는 스케줄러에 정의한 순서대로 작업을 실행한다. 예를 들어 매 분마다 A작업과 B작업을 돌린다고 해 보자. 그럼 매 분마다 리눅스 크론이 실행되면서 라라벨 스케줄러 프로세스를 기동하며 스케줄러 프로세스는 A작업을 처리한 후 B작업을 처리하는 순서로 실행된다. A작업을 처리하는데 시간이 걸린다면 B작업은 그 이후 실행되기 때문에 B작업을 처리하는데도 시간이 걸리게 된다.
- 또한 간단한 작업이라도 스케줄러에 작업이 쌓이게 되면 전체 스케줄러의 정의된 작업이 다 실행되기까지 상당한 시간이 걸릴 수 있다. 따라서 실행이 되고 조건이 만족하지 않으면 끝나는 작업이라도 작업이 쌓이면서 스케줄러의 처리 시간이 늘어나고 작업시간이 분 단위 이상으로 늘어나면 복수의 스케줄러 프로세스가 실행이 되므로 정해진 시스템 리소스 이상의 작업을 수행하게 되면서 서버가 터질 수 있다. 따라서 매분 실행하는 로직을 피하는 편이 좋다. 스케줄러에 의한 작업 실행의 시간을 최소화하기 위해서 큐-잡 방식으로 스케줄러의 처리 시간을 줄이는 방향으로 코드를 작성하자.
- 스케줄러의 실행시간이 긴 경우 크론에 의해 스케줄러가 중복실행 되면서 시스템 리소스를 한계 이상으로 사용하여 서버가 터지는 상황이 일어날 수 있다. 이를 방지하기 위해서는 가장 좋은 방법은 스케줄러의 실행 시간을 최소화하여 작업이 쌓여도 분 단위 내로 처리될 수 있도록 실행시간이 긴 작업은 큐-잡으로 넘기고, 실행시간이 분 단위를 넣어가면 스케줄러 실행을 2분, 2분을 넘어가면 3분 단위로 실행되는 전략을 세워서 복수의 스케줄러가 동작하는 상황을 피하는 전략을 사용할 수 있다. 하지만 상황에 따라 스케줄러의 작업 시간이 들쭉날쭉하다면 스케줄러의 실행 간격을 늘려 실행 빈도를 줄이는 전략은 고정된 수치의 시간 간격을 사용하기 때문에 스케줄러의 작업이 빨리 끝나는 경우 리소스의 여유가 생긴다. 스케줄러의 작업 시간을 들쭉날쭉하지 않게 하는 것이 스케줄러를 통해 리소스를 관리하는 방법이므로 스케줄러는 스케줄을 설정하는 역할을 담당하고 작업은 스케줄러에서 처리하지 않고 큐-잡으로 넘기는 전략을 사용하는 것이 좋다.
- 스케줄러에 정의된 작업 중에서 긴 시간을 요구하는 작업이 생성되었다면, 그 다음 크론에 의해 실행되는 스케줄링 또한 긴 시간을 요구하는 작업이 생성될 것이다. 따라서 스케줄러를 실행하는 프로세스가 복수개 실행되어 쌓일 것이다. 이런 문제를 방지하기 위해서 스케줄러에 의해서 한 번 실행된 작업은 그 작업이 종료될 때까지 다른 스케줄러 프로세스에서 실행되지 않도록 하여 한 번에 많은 리소스를 소비하는 스케줄러 프로세스가 쌓아지 않도록 하는 전략(`withoutOverlapping() 메소드 사용`)을 사용할 수 있다. 하지만 역시나 이런 작업은 큐-잡을 쓰는 구조로 변경하는 것이 좋다.

## 커널 정의하기
- App\Console\Kernel.php 파일에 스케쥴링을 설정한다. 
```
<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
use Illuminate\Support\Facades\DB;

class Kernel extends ConsoleKernel
{
    /**
     * The Artisan commands provided by your application.
     *
     * @var array
     */
    protected $commands = [
        //
    ];

    /**
     * Define the application's command schedule.
     *
     * @param  \Illuminate\Console\Scheduling\Schedule  $schedule
     * @return void
     */
    protected function schedule(Schedule $schedule)
    {
        $schedule->call(function () {
            DB::table('recent_users')->delete();
        })->daily();
    }
}
```

#### 클로저 부분
```
function () {
            DB::table('recent_users')->delete();
        }
```

```
 $schedule->call(function () {
            DB::table('recent_users')->delete();
        })->daily();
```
- 스케쥴링의 등록은 $schedule 객체의 call 메소드를 호출하여 스케쥴에 관한 로직이 들어 있는 클로저를 인자로 할당하여 스케쥴링 로직을 등록한다.
- \_\_invoke 메소드를 사용한 객체의 경우 `$schedule->call(new DeleteRecentUsers)->daily();`와 같이 클로저 대신 객체를 사용할 수도 있다.


### artisan 커멘드 등록하기
```
$schedule->command('emails:send Taylor --force')->daily();
```
- php artisan 으로 등록한 커멘드라인 명령어로 만들어진 스케쥴러를 등록할 수 있다.
- 리눅스 커멘드라인 명령어를 등록할 수도 있다.

### ??
```
$schedule->command(EmailsCommand::class, ['Taylor', '--force'])->daily();
```




## Reference
- https://laravel.kr/docs/8.x/scheduling
