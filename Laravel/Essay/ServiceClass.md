# 서비스 클래스

많은 프레임워크에서 서비스 객체는 싱글턴으로 만든다. 이는 애플리케이션이 한 번 기동한 후 여러번 그리고 다양하게 데이터를 처리하는데, 컨트롤러, 유즈케이스, 서비스 클래스는 반복적으로 사용하기 때문에 한 번 객체를 애플리케이션에서 띄워준 후 클래스를 인스턴스화 하지 않고 계속 재사용을 하기 위해서이다.

## php에서는?

php는 기본적으로 CGI로 동작한다. 일련의 작업이 갖는 라이프 사이클을 하나의 프로세스가 처리하기 때문에 한 번에 모든 컨트롤러, 유즈케이스, 서비스 클래스를 싱글톤으로 만들어 놓으면, 애플리케이션 기동시에 모두 실행이 되기 때문에 애플리케이션의 부트스트레핑 시간이 늘어난다.

기본적으로 php와 같은 CGI 방식의 프로세스를 사용하는 애플리케이션에서는 부트스크레핑을 최소화하기 위해서 꼭 싱글턴으로 사용해야 하는 컨트롤러, 유즈케이스, 서비스 클래스만을 선택적으로 사용하고, 라우터의 정의에 따라 사용할 대상 컨트롤러의 경로만 실행하게 하여 부하를 줄이는 것이 좋다.

## 애플리케이션 재사용하기

Roadrunner, FrankenPHP 등을 사용해서 라라벨 옥테인을 사용하는 경우에는 한 번 기동된 애플리케이션이 수 많은 리퀘스트를 처리한 후 종료된다. 이 때는 애플리케이션의 부트스트레핑에 가능한 많은 컨트롤러, 유즈케이스, 서비스 클래스 등을 싱글톤으로 올려 두고 객체 인스턴스를 최소화하는 방식으로 코드를 실행하도록 할 수 있다.

## Stateless

다수의 독립된 처리를 하나의 라이프 사이클에서 처리하는 애플리케이션의 경우 메모리 릭을 방지하기 위해서, 컨트롤러, 유즈케이스, 서비스 클래스에 객체의 상태를 부여하지 않는 방식의 코딩이 권장된다.

하지만 CGI 방식을 사용하는 경우에는 객체에 상태를 부여하는 것이 그렇게 문제가 되지는 않는다. 다만 객체의 상태를 부여하는데 단일 setter가 아닌 여러 setter를 사용하는 경우 객체의 상태 세팅에서 실수가 발생할 수 있기 때문에 권장되는 코딩 스타일은 아니다. 생성자를 사용하여 객체의 상태를 세팅하는 것이 좋지만, IOC로 의존성 주입이 이뤄지는 경우 직접 생성자에 값을 전달할 수 없기 때문에 서비스 객체를 동작시키는 하나의 메소드를 만들고 파라메터로 옵션을 지정해서 호출하는 방식으로 만든다.

## 서비스 프로바이더

라라벨에서 new 키워드로 생성하지 않고, 프레임워크에 의해서 생성자 주입(IOC)가 이뤄지는 경우, 해당 클래스의 생성자의 모든 매개변수는 클래스 타입이 선언되어 있을 때, 생성자의 매개변수로 클래스 타입을 주형으로 한 인스턴스들이 전달된다.

만약, 라라벨에서 클래스가 아닌, 인터페이스로 타입을 만들고 싶은 경우, 프레임워크는 어떤 인스턴스를 자동으로 주입해야하는지를 알지 못하기 때문에 라라벨의 서비스 프로바이더에 생성자 주입의 대상이 되는 인터페이스 타입에 어떤 구현된 인스턴스가 생성될지 정해주어야 생성자를 주입할 수 있다.

## 인터페이스 주입의 문제점

우리가 객체를 만들 때 항상 완벽하게 만드는 것은 아니다. 우선은 만들고, 비즈니스의 사양 변경에 따라 약간씩 변화하는 경우가 있다. 한 번 만들 때 비즈니스의 변화에 맞춰 대응할 필요가 없는 완벽한 사양의 클래스를 만드는 것이 좋지만, 개발자도 비즈니스에 대한 완벽한 이해를 하지 못하는 경우도 있고, 운용을 해 보니 원래 의도와 약간 다르게 동작해야 해서 바꿔야 할 경우도 있고, 장기간 운용 후에 개선의 방향을 생각할 수도 있다.

만약 생성자 주입을 위해 초기 부터 인터페이스를 만들게 되면, 변경해야 할 때 클래스, 인터페이스, 서비스 프로바이더 3곳의 수정을 해야 한다. 이런 코딩 방식은 클린아키텍처에서 유래되어 무분별하게 사용되곤한다. 기본적으로 인터페이스를 만들지 않고, 클래스만 만들면 라라벨의 IOC의 자동 생성자 메소드 주입에 의해 인터페이스와 서비스프로바이더를 작성할 필요가 없다.
