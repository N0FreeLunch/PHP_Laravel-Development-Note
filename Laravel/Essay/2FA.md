# 2요소 인증

## 아이디 패스워드 입력의 문제점

아이디 패스워드의 문제점은, 아이디, 패스워드만 알면 누구나 로그인을 할 수 있다는 점이다.

여러 웹 사이트에서 동일한 아이디, 비밀번호를 쓰는 경우도 있어서 하나의 사이트의 아이디 비밀번호가 해커에 의해 취득되면 다른 사이트에도 로그인을 할 수 있는 문제가 발생할 수 있다. 서비스별로 비밀번호를 다르게 해야 한다는 권장 사항이 있지만, 일반 유저들은 보안 보다는 비밀번호를 잊어 버려 로그인을 할 수 없다는 것에 더 큰 문제점을 느끼기 때문에 동일한 비밀번호를 사용하는 경우가 많다.

또는 다른 컴퓨터에서 구글 로그인을 했는데 로그인 정보를 동기화를 해 버려 아이디, 비밀번호가 다른 컴퓨터에 유출되어 보안이 뚫리는 등의 문제가 존재한다.

또는 해커는 레인보우 테이블 등을 이용한 무차별 대입을 통한 방식으로 비밀번호를 알아낼 수 있다. 대부분의 사이트에서 계정 정보 입력이 지정한 횟수 이상 잘못되면 일정 시간 동안 로그인을 하지 못하도록 락을 걸기 때문에 비밀번호를 알아내기 어려울 수 있으나 장기간 사용하지 않는 계정에 일정 시간 간격으로 계속 대입 시도를 하면 시간이 걸리더라도 뚫릴 수 있는 문제점이 생긴다.

## 2단계 인증이란?

기존의 아이디, 비밀번호를 사용한 로그인 방식 이외의 로그인을 하기 위해 하나의 단계를 더 추가해서 검증하는 것을 2단계 인증이라고 한다.

## 2단계 인증의 핵심

'아무나 인증 수단에 접근할 수 없다'는 것이다. 가능하면 물리적으로 구분된 별도의 인증 수단 등을 사용하여, 인증 수단에 접근하기 어려운 방식을 이용하는 것이 포인트이다.

## 2단계 인증의 종류

- 메일을 이용하여 인증
- 구글 어센티케이터를 이용한 인증
- 자사의 모바일 앱을 이용한 인증
- 소셜 로그인(외부 웹 서비스의 계정 정보를 통해서 로그인)을 이용하여 소셜 로그인 제공 업체의 2단계 인증을 이용
또는 자사 서비스의 모바일 앱을 이용해서 로그인을 하는 방식이 있다.

## 메일 인증의 문제

2단계 인증의 핵심은 '아무나 인증 수단에 접근할 수 없다.'인데 메일 서비스는 웹에서 로그인을 해서 접근을 할 수도 있기 때문에 물리적으로 구분된 별도의 인증 수단을 사용하지 않는다는 문제가 있다.

메일 서비스에서 2단계 인증에 대한 제약사항이 없는 도메인일 경우, 2단계 인증을 제한하는 편이 좋다. 모든 어카운트에 2단계 인증을 도입하게 하는 것이 목표인 경우가 많은데, 메일의 도메인 문제로 인증이 제한되는 경우가 존재할 수 있으므로 메일 인증 이외의 별도의 2단계 인증을 추가해야 하는 경우가 생길 수 있다.

또한 메일 인증에 2단계 인증이 되더라도 일회성 로그인이 아닌 신뢰할 수 있는 기기로 설정 등과 같은 장기 로그인이 되어 있는 경우, 해당 컴퓨터를 해킹한, 또는 이 컴퓨터가 공용 컴퓨터일 경우 제 3자에 의한 접근이 가능하므로 안전한 추가 인증 수단이 될 수 없다.

서비스에 따라 로그인 어카운트가 메일로 설정되지 않을 수도 있고, 메일이 등록되지 않을 수도 있기 때문에, 2단계 인증을 위해서는 메일을 추가적으로 요구해야 한다.

## 소셜 로그인의 문제

소셜 로그인의 경우도 메일 인증과 유사한 문제를 가지고 있다. 또한 소셜 로그인을 제공하는 기관에서 2단계 인증에 대한 API를 제공하지 않는다면, 자사 서비스에서 2단계 인증을 자사 정책에 의해 강제할 수 없는 경우가 있고, 소셜 로그인 업체의 정책에 따르는 수 밖에 없다.

## 자사의 모바일 앱을 이용한 인증의 문제

자사의 모바일 앱이 없는 경우 사용할 수 없으며, 자사의 모바일 앱이 있더라도 서비스의 종류가 다르면 인증 수단으로서 활용할 수 없다. 모바일 앱이 자사의 중심 서비스이고 나머지 서비스가 모바일 앱을 중심으로 이뤄질 때 적절한 인증 수단이 될 수 있다.

## 구글 어센티케이터

스마트 폰 앱의 인증을 이용해서 식별된 개인만이 접근 가능하므로 스마트폰은 별도의 분리된 물리적 인증 수단이므로 '아무나 인증 수단에 접근할 수 없다.'의 요구사항을 만족한다.

하지만 구글 어센티케이터를 이용한 인증 방식에 익숙하지 않은 사람이 많다는 문제점 때문에 보급에 교육이나 설명하는 자료가 필요하다.

## 라라벨에서 google authenticator 인증 구현

### 라이브러리 선정

라라벨에서 구글 어센티케이터를 설치하기 위해서는 'pragmarx/google2fa'라는 라이브러리를 사용한다.

이 라이브러리는 라라벨의 fortify에서 사용하고 있으므로, 라라벨이 유지되는 한 지속되는 라이브러리의 메인테인스가 이뤄질 것이라고 기대할 수 있다는 장점이 있다.

라이브러리를 직접 설치하지 않고, 라라벨의 fortify를 설치하면 내부에서 'pragmarx/google2fa'라이브러리를 사용하기 때문에 라이브러리 버전을 라라벨 쪽에서 대신 관리해 준다는 장점이 있다.

### 보안상 고려할 점

기본적으로 구글 어센티케이터 코드를 입력하는 창은 로그인을 한 이후에 별도의 화면을 통해서 인증을 하는데, 그 이유는 아이디와 패스워드를 입력했다는 사실을 서버측에서 기억하고 있다가, 반복되는 인증 코드 입력의 실패에도 아이디와 패스워드를 재입력하지 않게 하기 위해서이다. 또는 2단계 인증 기기를 가지러 가기위해 자리를 잠시 이탈할 수도 있고, 이 때 브라우저에 입력된 아이디와 패스워드를 탈취하는 시도가 일어나는 것을 방지하기 위해서이다.

### 로그인 설계

아이디와 비밀번호를 임시 토큰을 전달하는 방법 로그인후 리다이렉트가 될 때 임시 토큰을 발행하여 세션에 토큰을 저장을 하고 리다이렉트로 전달되는 리퀘스트에 토큰을 넣어 발행한 토큰과 비교를 한다.

리다이렉트는 서버가 브라우저로 하여금 특정 페이지로 이동하라는 지시를 한다. 서버에서 리다이렉트 지시를 할 때 헤더 값을 설정하면 브라우저에 리스폰스로 전달이 되고, 브라우저는 해당 리스폰스의 이동할 URL 정보로 리퀘스트를 보낸다. 따라서 리퀘스트 헤더에 토큰을 전달할 수 없다는 문제가 있다. 

이를 위해서 헤더나 바디가 아닌, 쿼리 파라메터로 토큰을 전달하는 방법 또는 자바스크립트로 헤더의 토큰 정보를 취득해서 리퀘스트에 포함을 시켜 주어야 한다.

그럼 방금 전 로그인을 통해서 TOTP 입력 화면으로 넘어온 사람인지, 로그인을 하지 않고 TOTP 입력 화면으로 넘어온 사람인지 알 수가 있다. 로그인 페이지의 정보 입력을 하지 않고 넘어온 경우 페이지 엑세스를 차단한다.

취득한 토큰에 해당하는 대상을 디비에 저장한 대상에서 찾고, 이 때 세션 발급 세션의 일치 여부를 확인한다. 토큰일 발급된 세션과 토큰이 전달된 세션이 일치하지 않으면 의도하지 않은 방식으로 전달된 토큰이므로 차단한다.

토큰과 함께 디비에 저장된 정보에서 로그인을 해도 된다는 승인 정보가 들어 있는지 확인을 하고, 승인 정보가 있다면 로그인 세션을 발급 후, 로그인 후의 메인페이지로 이동한다.

이때, 디비에 세션 아이디를 저장하지 않는다면 하나의 어카운트로 여러 브라우저에서 로그인 해야 하는 경우, 토큰이 서로 공유 되면서 인증이 꼬이는 경우가 발생할 수 있다.

### 해시화의 여부 고려

발행하고 세션에 저장한 토큰과 리다이렉트로 리퀘스트로 전송한 토큰 간의 일치만을 확인하면 되므로 토큰을 해시화 하는 방법을 생각해 볼 수 있다. 

토큰을 발행할 때 해시화를 해야 하는가? 리다이렉트 리퀘스트 내의 토큰을 취득한 후 할 수 있는 것이 있는가? 

토큰의 목적은 단순히 TOTP 화면에 엑세스하고 로그인 정보를 애플리케이션 내부에서 취득하기 위한 것으로 TOTP 화면에 접속했다면 토큰을 무효화된다. 리다이렉트 도중에 토큰을 취득하고, TOTP 코드 입력 화면으로 이동하는 것을 차단하고, 나중에 해당 토큰을 이용할 수 있도록 한다? 하지만 동일 세션에서 이뤄져야 하기 때문에 특별히 어떤 목적으로 사용하기 어렵다. 굳이 리소스가 드는 해시화를 할 필요는 없다.

### 디비에 토큰과 인증 허가 유무를 저장

세션에 아이디와 비밀번호를 직접 저장하는 것은 세큐리티 문제가 있다. 다른 건의 문제로 인해 레디스에 접근할 때, 레디스에 저장된 값을 확인하는 것으로 로그인 정보가 유출될 수 있다. 결국 비밀번호를 그대로 발급을 하는 것이 아니라, 로그인을 정보를 비교한 뒤 토큰을 발급한다.

2FA 인증 코드에 문제가 없다면, 전달된 토큰으로 로그인을 해야 하는데, 토큰으로 로그인을 하기 위해서는 토큰이 어떤 아이디와 연결되어 있는지 알아야 한다. 또한 아이디, 비밀번호로 로그인 한 결과가 인증 성공인지 인증 실패인지 알아야 한다. 하지만, 레디스의 인증 실패를 인증 성공으로 바꾸면 로그인을 할 수 있다.

세큐리티 중요도의 티어를 따지면, 인증 정보가 저장된 디비가 가장 중요하고, 그 다음이 레디스이다. 디비가 털리면 어차피 다 털리는 것이므로 어쩔 수 없다지만, 레디스가 털리면 디비 정보는 유출되지 않으므로 레디스에는 중요 정보를 저장하지 않는 편이 좋다.

따라서 인증에 관한 정보라면 가능한 레디스 보다는 디비를 이용하는 편이 좋다. 또한 세션과 달리 디비가 토큰의 유효기간 및 주기적인 토큰 삭제를 편리하게 할 수 있는 로직을 만들기 쉽기 때문에 레디스 보다는 디비를 사용해서 인증 정보르 저장하는 편이 좋다.

로그인이란 세션별로 이뤄진다. 디비에 세션 정보를 별도로 저장하지 않는다면, 디비만으로는 어떤 세션에서 요청된 토큰인지 구분하기 어려운 문제가 발생한다. 발급한 토큰을 다른 브라우저 또는 기기에서 사용하는 경우를 생각하면, 동일 세션에서 발급된 토큰인지 확인하는 과정을 추가하는 편이 좋다.

따라서 디비에 토큰과 함께 세션 아이디를 저장하고, 해당 토큰에 대한 인증 성공 실패, 유저 아이디 등의 정보는 디비에 저장하도록 한다.

### 구글 어센티케이터 등록

구글 어센티케이터에 등록하기 위해서는 먼저 시크릿 키를 생성해야 한다. 보안상 2단계 인증 활성화를 한 이후에는 2단계 인증 상태를 해제할 수 없도록 한다.

어카운트 설정 화면에서 2단계 인증 활성화를 해야 한다. 어카운트 설정 화면에 들어가는 순간, 시크릿 키가 없다면 시크릿 키가 발급되고 시크릿 키가 발급된다고 해서 인증 활성화를 하지는 않는다.

어카운트 설정 화면에서 유저가 2단계 인증 활성화를 하면, 어센티케이터 등록을 위한 QR을 보여주고 유저의 원타임 패스워드 등록이 완료되면, QR을 더이상 보여주지 않도록 한다. 이 때 시크릿 키는 유저가 로그인 할 때마다 TOTP 인증을 할 때 사용하기 때문에 남겨 두어야 한다.

구글 어센티케이터 등록이 완료된 후 QR 코드를 더 이상 보여주지 않는 것은, QR 코드가 유출되지 않도록 하기 위해서이다. 유저가 로그인을 한 이후, 잠시 자리를 이탈했을 때 제 3자가 어카운트 설정화면을 보고 QR을 통해서 구글 어센티케이터 등록이 될 수 있기 때문에 이런 문제가 발생할 여지를 원천 차단하도록 한다.

초기 등록시 유저에게 구글 어센티케이터 등록 방법에 대해 안내하는 메시지를 표시하여, 구글 어센티케이터 등록 방법을 쉽게 알 수 있도록 절차를 제시한다. 초기 등록시 주변에 다른 사람이 있어서 QR 코드가 유출 가능성도 있기 때문에 이에 대한 주의 사항과 함께, 리프레시 버튼을 두어 시크릿 키를 재발급할 수 있도록 하여, 초기 등록시 유출을 방지할 수 있도록 하자.

페이지를 리로드 할 때마다 QR이 바뀌게 되면, 등록 중에 QR이 바뀐 것을 파악하지 못하고, 등록이 안 되는 것으로 인식할 수 있다. 따라서 유저가 의도한 갱신을 할 때만 QR을 갱신하게 하기 위해서 리프레시 버튼과 함께 QR 코드를 갱신할 때 API를 사용하는 것이 일반적이지만, API 개발의 시간을 줄이고 싶다면, 쿼리 파라메터를 전달하여 새로운 QR을 발급하는 페이지를 만드는 방식을 사용할 수도 있다. 이 때 리로드를 통한 갱신을 막기 위해서 시간 정보를 함께 전달하고, 쿼리 파라메터를 삭제하는 자바스크립트 코드를 만들던가 30초 정도 지난 경우 리프레시가 되지 않도록 하는 등의 방법을 생각해야 한다.

QR을 발급 받고, 어플을 통해서 코드를 발급 받은 후에, TOTP 코드를 2번 입력하도록 요구하는 케이스가 있다. 사용자가 잘못 입력한 코드가 입력 값을 맞추는 경우가 있을 수 있으므로 이런 상황의 발생되지 않게 하기 위해서 2번의 인증 코드를 요구하지만, 1번만 입력한 후 리커버리 코드를 입력하는 방식을 사용하기도 한다.

2번 인증 하기 위해서는, 한 번 코드를 입력하고 인증을 한 후, 그 다음 코드를 입력 받기 위해 시간을 대기해야 하는 문제점이 있지만, 999999분의 n 확률이 999999^2분의 n이 되어 버리기 때문에 실수할래야 할 수 없는 확률이 되어서 확실하다. (n은 입력 시도 횟수에 해당한다.)

어카운트 관리자가 있는 경우, 관리자의 어카운트를 통해서 인증 초기화 등을 할 수 있기 때문에 1번만 입력해도 충분할 수 있다.

### 리커버리 코드의 발행

백업 코드를 다운로드 할 때, 주의 사항을 잘 기입하고, 주의 사항이 기입된 문서와 함께 다운로드 하게 한다.

리커버리 코드는 아직 다운로드를 하지 않은 초기 1회만 발급하게 하며, 브라우저 탭을 닫기 전 또는 브라우저를 닫기 전까지는 다운로드 할 수 있도록 한다. 다운로드를 받았을 때, 세션이 소멸되면 더 이상 다운로드 받지 못하게 한다. 다운로드 받지 않았을 때는 다운로드가 이뤄질 때까지 다운로드 받을 수 있도록 한다.
