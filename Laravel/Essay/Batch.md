# 라라벨에서의 배치 처리

# 소개

웹 개발에 입문하는 사람들은 MVC 패턴을 배운다. 유저에게 인터페이스를 제공하고 유저의 조작에 따라 (view), 저장소에 저장된 각종 데이터를 (model), 애플리케이션 서버의 가공 처리 (Controller)의 결과를 받아 볼 수 있는 MVC 패턴을 배우지만, 유저와의 상호작용 없이 서버에서 실행되는 배치 처리에 대해 공부하거나 배우지 않는 경우가 많다.

웹 프로그래밍의 경우 언어나 프레임워크에 관계 없이 MVC라는 기본적인 패턴을 사용하고 필요에 따라 MVC 패턴을 확장하는 방식으로 아키텍처를 정하기 때문에, 어떠한 언어나 프레임워크를 목표로 공부를 하더라도 기본적인 MVC 패턴 필수로 배워야 하는 것과 달리, 배치 처리는 언어나 프레임워크에서 지원하는 배치 처리 방식이 달라서 공통적으로 익혀두어야 할만한 패턴이 제시되지는 않는다.

배치 처리에 유명한 아키텍처로는 자바 스프링의 스프링 배치의 처리 방식이 있지만, 언어와 프레임워크마다 잘 지원되는 배치 처리 방식이 다르기 때문에 그대로 이식을 할 수는 없다. 이 글은 배치 처리를 배울 때 기본적으로 알아야 하는 개념들을 배우는 것과 함께, 라라벨 프레임워크에서 배치처리를 어떻게 설계하면 좋을지에 대한 패턴을 제시한다.

# 본론

## 배치 처리란?

일반적으로 프로그램은 유저와의 상호작용을 통해서 데이터를 생성, 저장, 변경하는 방식을 제공하는 컴퓨터 시스템이다.

유저와 시스템 간의 상호작용이 일어날 때 시스템에서 작업을 처리하기에 시간이 걸려 상호작용에 불편함을 주는 경우 또는 유저와의 상호작용 시점에 아닌 별도의 시점에 실행되어야 하는 작업의 경우 특정한 시간 패턴을 지정하여 유저와의 상호작용 없이 작업을 실행하는 방식이 배치 처리이다.

곧, ***유저와의 직접적인 상호작용 없는 시스템의 데이터 처리 방식***이 배치 처리라고 할 수 있다.

일반적으로 배치 처리는 시스템 리소스 소모가 적은 시간을 정해 유저와의 상호작용으로 처리할 수 없는 처리를 실행한다.

## 배치처리와 유저 인터페이스를 통한 처리

웹 개발은 잘 알려진 MVC 패턴 위에서 개발하는 것이 기본이다. 이 구조는 누구나 잘 알고 있고, 유저의 설정으로 로직을 처리하는데 필요한 각종 값을 입력 받을 수 있다. 이 때문에 배치 처리에 비해서 상대적으로 쉽게 코드를 작성할 수 있다.

유저에게 제공되는 인터페이스로 부터 받는 각종 값을 통해서 로직을 실행하는 프로그래밍과 달리, 배치 처리는 데이터베이스의 데이터 상태 및 서버의 상태 등을 고려해서 처리에 필요한 설정을 프로그래머가 직접 지정해 주어야 한다. 이 때문에 동작에 필요한 조건을 설정하는 것이 까다롭고, 스케쥴러, 큐, 잡 등에 대한 이해가 요구된다.

또한 스케쥴러에 의존하는 기능을 실행하기 위해 커멘드라인 등의 명령어를 만들어야 하는 등 더 많은 보일러 플레이트를 갖는 등의 어려움도 있다.

배치 처리를 만들기 위해서는 MVC 패턴보다 더 많은 보일러 플레이트가 필요한 경우도 많다. 배치 처리를 만들기에 앞서, 유저 인터페이스에서 처리하는 게 나은지 배치 처리를 통해서 만들는 게 나은지 판단할 필요가 있다.

### 유저 인터페이스로 처리하면 좋은 작업

배치 처리를 만들기 보다는 유저 인터페이스를 제공해서 처리하기 쉬운 작업은 유저 인터페이스를 제공하여 처리하도록 한다.

예를 들어 리퀘스트와 리스폰스 사이의 시간이 그다지 걸리지 않아 유저가 결과물을 얻기 까지 시간을 크게 불편하지 않게 여길 수 있는 정도의 작업이 이에 해당한다. 유저는 결과를 리스폰스에 담긴 결과로 즉시 받아 볼 수 있다는 장점이 있다.

배치 처리는 유저의 입장에서는 비동기로 동작한다. 웹 리퀘스트의 결과가 리스폰스에 포함되지 않고 별도의 배치 처리를 동작 시킨다. 배치 처리 작업이 언제 완료될지 정확히 알 수 없으며 대략적인 시간 추정을 통해서 얼마 후에 완료 된다 정도만을 알 수 있다.

### 배치 처리로 처리하면 좋은 작업

#### 작업이 완료되기 전에 빠른 리스폰스 주기

요청한 작업을 처리하는데 많은 시간이 걸리면, 리퀘스트부터 리스폰스의 라이프사이클이 길면 유저는 불편함을 느낀다. 이 때는 배치 처리로 테스크를 넘기고 빠른 응답 후 유저에게 얼마 후 확인하라는 메시지를 주면 유저는 안정감을 느낄 수 있다.

#### 유저가 요청하기 전에 미리 처리해 놓기

많은 시간이 걸리는 작업은 유저가 요청하기 전에 작업 처리 조건이 갖춰지는 대로 배치 처리로 작업을 처리한다. 사전 작업을 통해 유저가 원하는 때에 처리된 결과만 즉각적으로 볼 수 있다.

#### 특정 타이밍에 처리해야 하는 작업 처리하기

특정 실행 시점에 의존하는 정보들이 존재한다. 예를 들어 어떤 테이블의 정보는 계속 변하는데 특정 월에 실행하지 않고 나중에 실행하게 되는 경우, 시간이 지남에 따라 처리 결과물이 달라진다면 처리 되어야 할 타이밍을 놓칠 수 있다.

물론 기존 값이 갱신되지 않게 하고 데이터를 쌓는 방식이 좋지만, 경우에 따라 값이 계속 변경되는 케이스도 있다. 미리 실행되어야 할 타이밍에 스케쥴러를 통해 배치처리를 실행하여 적절한 타이밍에 결과물 생성하고 남길 때 배치 처리를 사용한다.

## 라라벨에서 배치 처리

라라벨에서 배치 처리를 위해 제공하는 기능은 스케쥴러, 잡, 큐, 아티산 커멘드가 있다.

### 스케쥴러

지정한 스케쥴에 따라 프로그램이 실행되도록 하는 기능을 스케쥴러라고 한다. 매일 몇 시, 매달 몇 일 등, 한 시간에 동일 간격으로 몇 번 등의 설정을 통해서 원하는 시간에 원하는 작업이 실행되도록 한다.

라라벨에서는 리눅스 cron을 기반의 스케쥴러를 제공하며, `app/Console/Kernel.php` 파일에 '아티산 콘솔'[^1]을 추가하여 리눅스 크론이 아티산 콘솔의 php 코드를 실행하도록 한다.

#### 스케쥴러 코드의 예 [^2]

```php
namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

final class Kernel extends ConsoleKernel
{
    protected function schedule(Schedule $schedule): void
    {
        $schedule->command('billing:dispatch-issue-invoices')
            ->dailyAt('01:00')
            ->withoutOverlapping(30)
            ->onOneServer();
    }
}
```

- `->dailyAt('01:00')` : 매일 01:00에 인보이스 발행 Job들을 큐에 적재
- `->withoutOverlapping(30)`: 한 서버에서 크론 작업을 중첩하여 실행되는 것을 방지한다. (최대 30분 락을 건 코드)
- `->onOneServer()`: 복수의 배치 서버에서 동일한 스케쥴러를 중복으로 실행하는 것을 방지 (레디스와 같은 캐시 드라이버가 요구된다.)

### 큐(Queue)란?

큐는 선입 선출의 구조를 가진 자료구조를 의미한다. 바구니에 서로 다른 색의 공을 넣고 먼저 들어간 색의 공을 먼저 꺼내는 것과 같다.

웹 프로그래밍에서 보통 큐라고 하는 것은 어떤 처리 로직을 적재한 뒤 순차적으로 실행하는 것을 의미한다. (설정에 따라 순서를 보장하지 않을 수도 있다.)

라라벨에서 큐는 데이터베이스 등의 저장소에 시리얼라이징된 코드를 저장한 후, 저장된 순서에 따라 시리얼라이징된 코드를 디시리얼라이징하여 실행하는 과정을 의미한다.

### 잡(Job)이란?

큐에 한 단위의 시리얼라이징 된 코드가 저장된 것을 잡(Job)이라고 한다.

### Artisan Command란?

라라벨에서 `php artisan CustomCommand`로 커멘드 라인 명령어로 실행할 수 명령어를 만들 수 있는 기능이다. 스케줄러(`app/Console/Kernel.php`)에 아티산 커멘드를 등록하면 지정한 시간에 아티산 커멘드가 실행된다.

배치 처리가 실패한 후, 수정 코드를 디플로이 했지만, 스케쥴러에 의한 실행 시점을 지났을 때, 서버의 커멘드 라인을 통해서 직접 배치를 실행하는 용도로도 사용할 수 있다.

## 라라벨에서 배치 처리 구성하기

### 잡(Job)

라라벨 프레임워크에서 배치처리를 깔끔하게 구현하는 방법에 대해 생각해 보자. 다음 내용은 라라벨에서의 특징이므로 Job에 대한 일반적인 개념은 아닐 수 있다는 것에 주의하자.

#### 잡(Job)의 특징

라라벨에서 job이란 하나의 코드 실행 단위를 뜻한다. 이 단위 코드는 시리얼라이징 되어 디비와 같은 저장소에 저장되어 워커(worker)라는 프로세스에 의해 저장된 순서대로 디시리얼라이징 된 코드를 실행한다.

#### 잡의 실패

잡 코드를 실행하는 도중에 예외 또는 에러가 적절히 처리되지 않으면 실행되고 있는 잡은 중단되며 실패한 잡으로 취급된다. 만약 잡이 성공적으로 실행된다면 저장소에서 제거된다.

실패한 잡은 리트라이 가능하며 리트라이 할 경우 리트라이 카운트가 1 증가한 동일한 테스크의 잡을 새로 큐에 추가하고 실패한 잡은 삭제한다. 이 과정을 지정한 리트라이 횟수만큼 반복하며 실패한 잡은 큐에서 제거되고 별도의 장소 (라라벨 디폴트는 failed_jobs 테이블)에 저장한다. 잡의 테스크가 정상적으로 동작하면 완료 후 큐에서 제거된다.

잡의 테스크를 처리 중에 실패하면, 다시 재실행 할 수 있어야 하기 때문에 잡을 실행하기 전 상태로 되돌아가야 한다. 이를 위해서 한 단위의 잡은 트랜젝션으로 묶어서 처리하는 편이 좋다.

라라벨 큐에서 제공되는 리트라이 옵션은 빠르게 실패한 배치를 다시 실행하기 때문에 일시적인 장애로 인한 실패에도 장애가 계속되어 처리가 또 실패할 수 있다. 그래서 동일한 테스크를 스케쥴러를 활용해 몇 분 및 몇 시간 정도의 간격으로 재실행하는 편이 좋다.

#### 작은 로직 만들기

트랜젝션은 데이터베이스의 자원을 점유한다. 긴 트랜젝션이 많아지면 데이터베이스의 자원을 많이 점유하여 성능 저하 및 다른 처리의 타임 아웃을 유발한다. 하나의 잡을 실행할 때 로직이 많아지면 트랜젝션 처리에도 오랜 시간이 걸릴 수 있다. 가능한 잡은 짧은 트랜젝션 단위로 사용하는 것이 좋다.

작은 로직은 트랜젝션 시간을 줄일 수 있기 때문에 롤백과 커밋에 대한 부담감을 줄인다. 처리에 대한 커밋의 단위가 작다면 실패한 단위에 대해서만 실패 이유를 개선 한 후 재처리하기도 쉽기 때문에 컴퓨팅 리소스를 줄일 수 있는 장점 및 관리하기 좋다는 장점도 있다.

#### 잡(Job)에 상태 부여하기

라라벨에서 잡은 기본적으로 잡 클래스를 객체화하여 객체의 시리얼라이징 데이터를 저장소에 저장한다. 객체로서 저장되기 때문에 객체에 상태를 부여할 수 있고 객체의 프로퍼티에 잡이 동작할 옵션을 저장할 수 있다. 동일한 클래스 기반의 잡이라도 객체에 지정한 프로퍼티에 따라 정의된 로직의 분기 처리에 따라 다양한 동작의 잡을 실행할 수 있다.

상품 구매자에 대한 배치 처리를 생각해 보자. 예를 들어 "주문 완료 후 후처리(영수증 발행, 포인트 적립, 배송 요청, 알림 발송)"의 대략적인 흐름은 같다.

- 주문이 유효한지 확인한다.
- 이미 처리된 주문인지 확인한다(중복 처리 방지).
- 결제 방식/배송 방식/회원 등급/프로모션 적용 여부에 따라 세부 처리가 달라진다.
- 처리가 끝나면 ‘처리 완료’ 상태를 남긴다.

즉 로직의 뼈대는 동일하지만, 구매자/주문 데이터의 조건에 따라 “어떤 하위 작업을 실행할지”만 달라지는 경우가 많다.

이럴 때 라라벨의 Job은 객체로 큐에 적재되므로, 잡 객체에 `orderId` 뿐 아니라 `paymentMethod`, `shippingType`, `isFirstPurchase`, `campaignId` 같은 상태(옵션)를 함께 넣어 디스패치할 수 있다. 워커는 동일한 Job 클래스를 실행하되, 잡 객체가 가진 상태에 따라 분기하여 각 주문에 맞는 후처리를 수행한다.

### 워커

라라벨의 큐는 워커라는 프로세스에 의해서 실행되는데, 로컬 환경에서는 하나의 잡의 처리를 하나의 프로세스가 실행하여 코드 변경을 즉각 반영할 수 있는 `php artisan queue:listen`을 사용하여 실행할 수 있고, 프로덕션 환경에서는 프로세스가 죽으면 다시 살려주는 리눅스 기반 supervisor를 또는 도커 CMD를 통해 `php artisan queue:work`, `php artisan queue:listen` 명령으로 실행된다.

큐에서 잡을 꺼내어 처리하는 과정에서 문제가 발생해서 워커 프로세스가 죽더라도 다시 살려내는 supervisor를 이용해서 워커를 실행을 하거나, 컨테이너의 PID 1의 작업이 종료 되었을 때 도커가 재시작 될 수 있도록 도커 CMD에 `php artisan queue:work` 명령을 주어 워커를 동작시키도록 하자. [^3]

### 워커의 옵션 설계

php는 php 엔진이 php 파서를 실행하고 종료하는 방식으로 동작하는데 특화되어 있다. 웹의 리퀘스트를 처리하여 리스폰스를 응답하고 프로세스를 종료하는 라이프 사이클이 끝나면, 실행 과정에서 메모리에 등록된 데이터를 모두 지우는 방식으로 동작한다. 이 방법의 장점은 다음과 같다.

- 프로세스와 프로세스 사이의 메모리 공유가 없기 때문에, 독립적으로 실행되는 두 프로세스 간의 영향을 최소화 할 수 있어, 의도한 대로 동작하는 것을 기대하기 좋다.
- 프로세스의 종료에 따라 의도치 않은 불필요한 메모리 점유를 방지할 수 있어서 장기 서비스 제공에 안정성을 준다.
- 코드를 작성할 때 메모리 점유를 덜 신경써도 된다는 이점이 있다.

하나의 php 프로세스는 장기 코드 실행 보다는 한 번에 실행되어야 하는 최소한의 단위 코드를 여러 번 실행하는 편이 안정적이다. 하나의 프로세스의 실행 시간이 길어지면 php 코드가 실행될 때 발생할 수 있는 메모리 누수로 어느 시점 프로세스가 강제 종료되어 진행중인 작업의 무결성을 잃을 수 있기 때문이다. [^4]

큐에 적재된 순서대로 잡을 처리하면서 하나의 잡을 처리할 때 하나의 프로세스만 사용하는 워커를 라라벨에서는 `php artisan queue:listen`로 사용할 수 있다. 하나의 잡이 실행되고 잡을 실행하는 자식 프로세스가 종료되기 때문에 부모 프로세스인 워커가 여러 잡을 처리해도 메모리 리셋이 이뤄지므로 메모리 누수 문제를 근본적으로 해결한다.

하지만 `listen` 방식은 각각의 잡을 실행할 때 라라벨의 프레임워크를 기동시키므로 속도가 느리다는 단점이 있다. 이를 위해서 워커 프로세스가 여러 잡을 처리하되 특정 메모리 사용량을 초과하면 다음 잡을 처리하지 않고 종료 시키는 `php artisan queue:work --memory=256`, 작업을 일정횟수 반복 후 워커를 종료시키는 `php artisan queue:work --max-jobs=1000`, `php artisan queue:work --max-time=3600` 등으로 메모리 문제를 미연에 방지하는 전략을 함께 사용한다.

#### 싱글 워커와 멀티 워커

큐는 선입 선출의 순서로 잡을 처리한다. 하나의 잡이 완료된 이후 다음 잡을 처리하기 위해서는 하나의 큐는 하나의 워커로 동작시켜야 한다.

하나의 큐를 (하나의 디비 테이블에 저장된 시리얼라이징 된 잡 리스트) 여러 워커로 처리할 수 있는데, 이 때 적재된 작업이 A, B, C, D, E, F라고 할 때 3개씩 처리되면 A, B, C가 세개의 워커 각각에 할당되고, A는 처리 되고 B, C가 처리되지 않았을 때 D가 A를 처리한 워케에서 처리하며 D가 처리 완료될 때까지 B가 처리 되지 않았다면 A->C->D->B ...의 순서로 순차적인 처리가 이뤄지지 않을 수 있다.

작업의 순서가 중요한 경우 하나의 큐에는 싱글 워커를 할당하고, 작업의 순서를 고려하지 않아도 되는 경우 멀티 워커를 통해 빠르게 처리하도록 한다.

## 스프링 배치와 php 배치의 전략 차이

일반적으로 배치 처리의 표준은 자바 스프링 프레임워크의 스프링 배치이다. php가 작은 단위의 잡을 통해서 배치 처리를 실행하는 전략을 주로 채용하는 것과 달리, 스프링 배치는 방대한 양의 데이터를 처리하는 것에 초점을 맞추고 있다.

저장소에서 처리할 수 있는 만큼의 데이터 묶음 (청크)을 배치 애플리케이션에 가져온 뒤, 그 뒤로는 가능한 속도 저하를 초래하는 외부 연결을 최소화하고 컴파일 언어의 연산 성능을 최대한 이용하여 한 번에 방대한 결과를 생성한 뒤, 결과를 청크 단위로 트랜젝션하여 저장하는 방식으로 구성된다.

php에서도 스프링 배치와 같은 대량 처리 방식을 사용할 수 있다. 하지만 php는 상대적으로 컴퓨팅 리소스 효율이 낮은 인터프리터 언어이기 때문에 초거대 스케일의 배치처리 보다는 비즈니스 흐름을 정확하게 드러낼 수 있는 로직을 만드는 것이 적합한 경우가 많다.

대부분의 php 프로젝트는 배치 결과물을 생성할 때 컴퓨팅 성능을 최대한 활용하기 위해, 한 번에 다량의 데이터를 가져오고 다량의 처리 결과를 저장할 수 있는 단위로 청크 처리를 만드는 전략은 어울리지 않는 경우가 많다. 비즈니스 흐름을 잘 드러낼 수 있는 로직을 구성하며 로직의 흐름의 단계에 맞게 애플리케이션 외부에서 데이터를 가져오는 로직을 만드는 편이 좋다. I/O 발생으로 속도 저하가 일어나더라도 비즈니스 로직을 잘 드러내는 코드를 만드는 것이다.

## 프레임워크 내에서의 구조

라라벨에서는 큐, 잡, 스케줄러, 아티산 커멘드라는 기능을 제공할 뿐 공식적인 배치 처리 전략이 없다.

앞서 논의한 점들을 고려해서 php에 적합한 배치처리 전략을 구성하기 위해서 배치 유닛, 잡 클래스, 잡 트리거, 아티산 커멘드라는 개념으로 나누어 배치 처리를 구성해 보았다.

### 배치 유닛 (`Batches/Units/*`)

- 잡 클래스에서 배치 유닛 객체를 가져와 실행하는 용도로 사용된다.
- 배치 유닛은 한 단위의 잡을 처리하기 위한 코드를 정의한 부분이다.
- 한 단위의 잡을 정의하는 용도이기 때문에 하나의 배치 유닛 클래스의 실행은 실패 시 초기 상태로 돌아갈 수 있는 트랜젝션 단위로 만든다.

#### 배치 유닛 도입의 이점

잡 클래스에 모든 것을 정의하지 않고 배치 유닛을 별도로 만들어 잡 클래스에 가져와 사용하는 이유는 유사한 로직이 배치 처리 뿐만 아니라 유저와의 상호 작용에 따라 실행하는 경우도 있기 때문이다.

하나의 유닛은 배치 처리를 위해 잡(Job)에서 쓰이기도 하고, 유저 인터렉션을 담당하는 서비스 레이어 또는 컨트롤러(또는 유즈케이스)에서 불러다 쓸 수도 있다. 이 때문에 유닛을 따로 분리하여 재사용성을 높이는 방식으로 코드를 짜는 편이 좋다.

이렇게 코드를 만들면 특정 배치처리가 어떤 조건 미달로 실패했을 때, 사용자 측에서 직접 재실행 할 수 있는 기능을 제공하기도 쉽다.

잡은 비동기로 디스패치 되기 때문에 테스트가 어렵지만, 상세 로직을 배치 유닛이란 클래스로 옮기면 단순 객체가 되어 테스트 코드를 작성하기도 쉽다.

#### 배치 유닛의 예 [^5]

```php
namespace App\Batches\Units\Billing;

use App\Models\Invoice;
use App\Models\Subscription;
use Illuminate\Support\Facades\DB;

final class IssueInvoiceUnit
{
    public function run(int $subscriptionId, string $billingDate): void
    {
        DB::transaction(function () use ($subscriptionId, $billingDate) {
            $subscription = Subscription::query()
                ->whereKey($subscriptionId)
                ->lockForUpdate()
                ->firstOrFail();

            $alreadyIssued = Invoice::query()
                ->where('subscription_id', $subscription->id)
                ->where('billing_date', $billingDate)
                ->exists();

            if ($alreadyIssued) {
                return;
            }

            Invoice::query()->create([
                'subscription_id' => $subscription->id,
                'billing_date' => $billingDate,
                'amount' => $subscription->monthly_fee,
                'status' => 'issued',
            ]);
        });
    }
}
```

### 잡 클래스 (`Job/*`)

잡 클래스는 `Batches/Job/*`에 정의하고 싶지만, 라라벨의 제약으로 인해서 `Job/*` 폴더에 잡 클래스를 정의해야 큐에 적재할 수 있기 때문에 기존의 폴더 위치를 그대로 사용한다. [^6]

잡은 데이터베이스와 같은 저장소에 시리얼라이징 된 잡 객체를 저장하고 저장한 순서대로 디시리얼라이징하여 잡 로직을 큐에 적재된 순으로 실행하게 하기 위한 코드를 작성하는 부분이다.

처리에 관한 상세한 로직은 배치 유닛에 정의하며 배치 유닛을 가져와 잡이라는 코드 베이스에서 실행하기 위한 용도로 사용한다.

#### 잡 클래스의 예 [^7]

```php
namespace App\Jobs\Billing;

use App\Batches\Units\Billing\IssueInvoiceUnit;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

final class IssueInvoiceJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        public readonly int $subscriptionId,
        public readonly string $billingDate,
    ) {}

    public function handle(IssueInvoiceUnit $unit): void
    {
        $unit->run(
            subscriptionId: $this->subscriptionId,
            billingDate: $this->billingDate,
        );
    }
}
```

### 잡 트리거 (`Batches/JobTriggers/*`)

잡을 실행하기 위한 대상 리스트를 뽑아 리스트의 각각 대상의 정보로 잡에 옵션을 주어 디스패치(큐에 적재)하는 목적으로 정의한다.

잡을 디스패치 할 때, 디스패치 옵션을 통해서 잡 객체에 상태를 부여하고, 잡은 배치 유닛에 이 옵션을 전달하여 옵션에 맞는 분기 처리를 수행한다.

배치 유닛은 잡을 통해서만 큐에 등록될 수 있다. 잡 트리거는 여러 대상을 뽑아 각 대상의 정보를 잡 유닛에게 전달하여 배치 처리를 실행하는데, 큐에 적재하기 위해서 배치 유닛을 직접 실행하지 않고 잡을 디스패치하는 방식으로 구성된다.

#### 설계상의 주의점

배치 처리가 중간에 멈추었을 때, 처리되지 않은 남은 잡을 다시 디스패치해야 한다. 트리거에서 대상 리스트를 뽑을 때 실행이 완료된 대상인지 아닌지 구분하여 처리 대상을 선택하는 것이 중요하다.

배치 처리의 완료 표기 플레그를 배치 처리 진행 상태나 결과를 남기는 테이블에 남길 수 있도록 컬럼을 추가하는 것을 고려하자.

재시도 끝에도 실패한 잡이 있을 수 있다. 별도의 로그와 통지를 통해서 개발자가 후속 대응 할 수 있도록 구성하자.

잡트리거는 기본적으로 아직 처리되지 않은 잡을 처리하기 위한 용도로 사용한다. 그러나 배치 작업의 문제가 생겼을 때의 대응을 위해, 배치 작업을 클리어하거나 리프레시할 수 있는 기능도 추가하는 편이 좋다.

#### 잡 트리거의 예 [^8]

```php
namespace App\Batches\JobTriggers\Billing;

use App\Jobs\Billing\IssueInvoiceJob;
use App\Models\Subscription;

final class IssueInvoicesJobTrigger
{
    public function dispatchForDate(string $billingDate): void
    {
        Subscription::query()
            ->where('status', 'active')
            ->orderBy('id')
            ->chunkById(500, function ($subscriptions) use ($billingDate) {
                foreach ($subscriptions as $subscription) {
                    IssueInvoiceJob::dispatch(
                        subscriptionId: $subscription->id,
                        billingDate: $billingDate,
                    )->onQueue('billing');
                }
            });
    }
}
```

### 아티산 커멘드

잡 트리거를 배치 처리 흐름에 맞게 정의하기 위해서 사용한다.

배치 처리를 실행할 시점을 정의하기 위해서는 스케쥴러에 등록을 해야 한다.

스케쥴러에 등록하기 위해서는 아티산 커멘드를 통해서 실행할 수 있도록 정의가 되어야 한다.

아티산 커멘드로 정의할 때는 일괄 처리를 실행하기 위한 잡 트리거를 직접 가져다 사용한다.

아티산 커멘드가 정의되었다면 스케쥴러에 언제 실행할 것인지 등록한다.

#### 아티산 커멘드의 예 [^9]

```php
namespace App\Console\Commands\Billing;

use App\Batches\JobTriggers\Billing\IssueInvoicesJobTrigger;
use Illuminate\Console\Command;

final class DispatchIssueInvoices extends Command
{
    protected $signature = 'billing:dispatch-issue-invoices {--date= : billing date (YYYY-MM-DD)}';
    protected $description = 'Dispatch invoice issuing jobs to the queue for a given billing date.';

    public function handle(IssueInvoicesJobTrigger $trigger): int
    {
        $billingDate = $this->option('date') ?: now()->toDateString();

        $trigger->dispatchForDate($billingDate);

        $this->info("Dispatched invoice issuing jobs for date={$billingDate}.");

        return self::SUCCESS;
    }
}
```

## 전체 실행의 흐름

1. 리눅스의 cron 서비스가 동작한다.
2. cron의 실행에 따라 라라벨의 스케쥴러가 동작한다.
3. 라라벨 스케쥴러에 등록된 아티산 커멘드는 특정한 타이밍에 정의된 아티산 커멘드를 실행한다.
4. 아티산 커멘드는 잡 트리거를 실행한다.
5. 잡 트리거는 다양한 상태를 갖는 배치 유닛을 큐-잡의 형태로 등록하기 위해서 다수의 잡을 큐 방식으로 저장되는 저장소에 등록한다.
6. 등록된 잡은 순차적으로 실행되면서 유닛으로 정의된 단위로 로직을 처리한다.

## 폴더 구조

```
app
 |- Console
 |    |- Commands
 |         |- Batches
 |              |- Billing
 |                   |- DispatchIssueInvoices.php
 |              |- Maintenance
 |                   |- DispatchDataRepair.php
 |
 |    |- Kernel.php
 |
 |- Batches
 |    |- JobTriggers
 |    |     |- Billing
 |    |     |    |- IssueInvoicesJobTrigger.php
 |    |     |- Maintenance
 |    |          |- DataRepairJobTrigger.php
 |    |
 |    |- Units
 |          |- Billing
 |          |    |- IssueInvoiceUnit.php
 |          |- Maintenance
 |               |- RepairRecordUnit.php
 |
 |- Jobs
 |    |- Billing
 |    |    |- IssueInvoiceJob.php
 |    |- Maintenance
 |         |- RepairRecordJob.php
 |
 |- Models
      |- Subscription.php
      |- Invoice.php
      |- SomeDomainModel.php
```

## 서비스 개선

현 회사에서 메인으로 담당한 프로젝트는 라라벨 스케줄러 기반으로 돌아가는 2년차 서비스였다. 기존 구조에서는 1분마다 크론이 실행되어 한 번에 단건씩 트랜잭션을 처리했는데, 전체 배치 처리 속도가 매우 느려 비개발자가 결과를 검증하기도 어려운 상황이었다.

서비스 규모가 커지면서 일부 배치 작업의 완료 시간이 5\~10분까지 길어졌고, 크론이 1분마다 중첩 실행되다 보니 순간 서버에 5\~10개의 배치가 동시에 동작하며 과부하로 서버가 다운되는 장애가 발생했다.

또한 실패한 테스크를 복구하는데도 많은 시간이 걸렸다.

큐와 잡을 사용하지 않는 스케쥴러만을 사용한 배치는 실행 중첩과 실패 격리가 어렵기 때문에, 서비스 규모가 커질수록 운영 리스크가 빠르게 커졌다.

이 문제를 해결하기 위해, **배치 구조를 큐-잡 기반으로 전면 개선**하였다. 그 결과,

- 몇 시간이 걸리던 배치가 수십 초 내로 완료되었고,
- 비개발자도 배치 동작과 결과를 쉽게 검증할 수 있게 되었으며,
- 테스크가 순차적으로 안정되게 처리되어 메모리 사용량도 예측 가능한 범위에서 안정적으로 관리 되었다.
- 이후 현재까지도 특별한 장애 없이 배치 처리를 안정적으로 운영하고 있다.
- 또한 배치 처리를 패턴화하여 다른 개발자들이 패턴을 따라 좋은 코드를 작성할 수 있도록 하였다.

# 마지막으로

자바의 스프링 프레임워크와 같이 배치 처리의 구성이 잘 알려진 패턴을 따르는 경우도 있지만, 언어나 프레임워크, 사용하는 라이브러리에 따라 배치 처리의 툴의 기능이 다르기 때문에 배치 처리의 전략은 언어나 프레임워크마다 다를 수 있다. 또한 프레임워크나 라이브러리에서 명확한 가이드라인을 제공하지 않거나 프로젝트의 특징에 따라 배치 처리의 구성 방법은 달라질 수 있다.

여기서 소개한 방법은 내가 담당하고 있는 프로젝트에서 지난 4년간 실무에서 별다른 문제 없이 사용해 온 패턴이다. 참고가 되길 바란다.

[^1]: 아티산 콘솔이란 라라벨의 기능을 커멘드라인 명령어로 실행할 수 있는 기능을 제공하며, 라라벨 내장의 `php artisan SomeCommand` 명령 이외의 개발자가 제작한 아티산 커멘드를 `php artisan CustormCommand`으로 실행할 수 있는 기능이다. [아티산 콘솔의 작성법](https://laravel.com/docs/12.x/artisan)은 공식 문서를 참고하자.
[^2]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^3]: `ENTRYPOINT`를 사용하면 `exec` 명령으로 `php artisan queue:work`를 사용해야 한다. `entrypoint.sh` 파일이 PID 1로 실행되므로 도커는 쉘 명령을 (exec 명령을 사용하지 않으면) `php artisan queue:work`으로 실행된 워커를 PID 1이 아닌 자식 프로세스 실행하게 되고, 기존 컨테이너가 새로운 컨테이너로 교체될 때 PID가 1이 아닌 경우 도커가 프로세스 종료 신호인 SIGTERM을 워커에 전달하는데 수신하지 못하여 워커의 정상 종료를 기다리지 않고 종료될 수 있다. 컨테이너를 교체할 때 기존 컨테이너의 마지막 잡 처리를 기다리지 않고 교체하여 레디스 락이나 트랜젝션의 롤백이 일어나지 않는 경우가 발생할 수 있다.
[^4]: 메모리 릭이 발생하지 않도록 코드를 잘 만들면 되지만, 레거시 코드, 라이브러리 및 프레임워크 사용에서 장기 실행을 고려하지 않은 코드가 있을 가능성이 높은 언어 생태계이므로 항상 메모리 릭이 발생한다는 전제로 접근하는 편이 좋다.
[^5]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^6]: 폴더 위치를 바꿀 수 있는 방법을 발견하지 못했으나, 폴더 위치를 바꿀 수 있는 방법을 발견했다면 구조상 `Job/*` 보다는 `Batches/Job/*`에 코드를 정의하는 것을 추천한다.
[^7]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^8]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^9]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
