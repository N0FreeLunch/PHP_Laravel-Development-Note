# 라라벨에서의 배치 처리

웹 개발에 입문하는 사람들은 MVC 패턴 유저에게 인터페이스를 제공하고, 유저의 인터페이스에 따라 동작을 하는 MVC 패턴을 배우지만, 유저와의 상호작용 없이 서버에서 실행되는 배치 처리에 대해 공부하거나 배우지 않는 경우가 많다.

웹 프로그래밍의 경우 언어나 프레임워크에 관계 없이 MVC라는 기본적인 패턴을 사용하고 필요에 따라 이를 확장하는 방식으로 아키텍처를 정하기 때문에, 어떠한 언어 프레임워크를 목표로 공부를 하더라도 기본적인 MVC 패턴 필수로 배워야 하는 것과 달리, 배치 처리는 언어나 프레임워크에서 지원하는 배치 처리 방식이 달라서 공통적으로 익혀두어야 할만한 패턴이 제시되지는 않는다.

배치 처리에 유명한 아키텍처로는 자바 스프링의 스프링 배치의 처리 방식이 있지만, 언어와 프레임워크마다 잘 지원되는 배치 처리 방식이 다르기 때문에 그대로 이식을 할 수는 없다. 이 글은 배치 처리를 배울 때 기본적으로 알아야 하는 개념들을 배우는 것과 함께, 라라벨 프레임워크에서 배치처리를 어떻게 설계하면 좋을지에 대한 패턴을 제시한다.

## 배치 처리란?

일반적으로 프로그램은 유저와의 상호작용을 통해서 데이터를 생성, 저장, 변경하는 방식을 제공하는 컴퓨터 시스템이다.

유저와 시스템 간의 상호작용이 일어날 때 시스템에서 작업을 처리하기에 시간이 걸려 상호작용에 불편함을 주는 경우 또는 유저와의 상호작용 시점에 아닌 별도의 시점에 실행되어야 하는 작업의 경우 특정한 시간 패턴을 지정하여 유저와의 상호작용 없이 작업을 실행하는 방식이 배치 처리이다.

곧, ***유저와의 직접적인 상호작용 없는 시스템의 데이터 처리 방식***이 배치처리라고 할 수 있다.

일반적으로 배치 처리는 시스템이 리소스 소모가 적은 시간을 정해 유저와의 상호작용으로 처리할 수 없는 처리를 실행하게 한다.

## 배치처리와 유저 인터페이스를 통한 처리

웹 개발은 잘 알려진 MVC 패턴 위에서 개발하는 것이 기본이고, 이 구조는 누구나 잘 알고 있기 때문에 배치 처리에 비해서 상대적으로 쉽게 개발된다. 또한 유저의 설정에 의한 데이터 전송으로 로직의 실행에 필요한 각종 값을 입력 받을 수 있으므로 로직을 처리하는데 필요한 옵션을 상대적으로 쉽게 받을 수 있다.

유저에게 제공되는 인터페이스로 부터 받는 각종 값을 통해서 로직을 실행하는 프로그래밍과 달리, 배치 처리는 데이터베이스의 상태 및 서버의 상태 등을 고려해서 처리에 필요한 상태나 옵션을 프로그래머가 직접 설정해 주어야 하기 때문에 동작에 필요한 조건을 설정하는 것이 까다롭고, 스케쥴러, 큐, 잡 등에 대한 이해가 요구된다.

또한 스케쥴러에 의존하는 기능을 실행하기 위해 커멘드라인 등의 명령어를 만들어야 하는 등 더 많은 보일러 플레이트를 갖는 등의 문제를 가지기도 한다. 배치처리를 만드는 것도 여러 까다로운 문제들이 있어 배치처리를 앞서 유저 인터페이스에서 처리하는 게 나은 기능인지 배치처리를 통해서 만들어야 하는 기능인지 미리 판단할 필요가 있다.

### 유저 인터페이스로 처리하면 좋은 작업

배치 처리를 만들기 보다는 유저 인터페이스를 제공해서 처리하기 쉬운 작업은 유저 인터페이스를 제공하여 처리하도록 한다.

예를 들어 리퀘스트와 리스폰스 사이의 시간이 그다지 걸리지 않아 유저가 결과물을 얻기 까지 시간을 크게 불편하지 않게 여길 수 있는 정도의 작업이 이에 해당한다. 유저는 결과를 리퀘스트 이후 즉시 받아 볼 수 있다는 장점이 있다.

배치 처리는 유저의 입장에서는 비동기로 동작한다. 리퀘스트의 신청 결과가 동일 라이프 사이클의 리스폰스의 결과물에 포함되지 않고 별도의 테스크로 동작을 하며 요청한 작업이 언제 완료될지 정확히 알 수 없으며 대략적인 시간 추정을 통해서 얼마 후에 완료 된다 정도만을 알 수 있다.

### 배치 처리로 처리하면 좋은 작업

#### 작업이 완료되기 전에 빠른 리스폰스 주기

유저가 요청한 작업을 처리하는데 많은 시간이 걸리는 경우, 리퀘스트부터 리스폰스의 라이프사이클이 길어지면 유저는 불편함을 느낀다. 이 때는 배치 처리로 테스크를 넘기고 빠른 응답 후 유저에게 얼마 후 확인하라는 메시지를 주면 유저는 안정감을 느낄 수 있다.

#### 유저가 요청하기 전에 미리 처리해 놓기

많은 시간이 걸리는 작업은 유저가 요청하기 전에 작업 처리 조건이 갖춰지는 대로 배치 처리로 작업을 처리하고 유저는 원하는 때에 처리된 결과만 즉각적으로 볼 수 있도록 처리하는 것이 좋다.

#### 특정 타이밍에 처리해야 하는 작업 처리하기

특정 실행 시점에 의존하는 정보들이 존재한다. 예를 들어 어떤 테이블의 정보는 계속 변하는데 특정 월에 실행하지 않고 나중에 실행하게 되는 경우, 시간이 지남에 따라 값이 달라진다면 처리 되어야 할 타이밍을 놓쳐 결과물이 잘못될 가능성이 존재한다.

물론 기존 값이 갱신되지 않게 하고 데이터를 쌓는 방식이 좋지만, 경우에 따라 값이 계속 변경되는 케이스도 있다. 이럴 때 미리미리 실행되어야 할 타이밍에 스케쥴러를 통해 배치처리를 실행하여 적절한 타이밍에 결과물을 얻는 과정은 배치처리로 처리하는 것이 좋다. 

## 라라벨에서 배치 처리

라라벨에서 배치 처리를 위해 제공하는 기능은 스케쥴러, 잡, 큐가 있다.

### 스케쥴러

커멘드라인 명령어를 리눅스 cron으로 지정한 시간 패턴에 따라 실행하도록 하는 기능이다.

라라벨 프레임워크에서 작성된 아티산 콘솔 코드 형식으로 작성된 php 파일을 `php artisan`으로 시작되는 커멘드라인 명령어로 실행하도록 하는 기능이다.

### 큐(Queue)와 잡(Job)

큐(Queue)는 데이터베이스 등과 같은 저장소에 실행할 코드를 저장한 다음 저장한 순서대로 저장된 코드를 실행 시키는 기능이다.

이 때 순서에 따라 한 단위로 실행되는 작업을 잡(Job)이라고 한다.

## 잡(Job) 정의하기

라라벨 프레임워크에서 배치처리를 깔끔하게 구현하는 방법에 대해 생각해 보자.

### 잡(Job)의 특징

라라벨에서 job이란 하나의 코드 실행 단위를 뜻한다. 이 코드 실행 단위를 실행하는 도중에 에러가 발생하면 잡은 중단되며 실패한 잡은 지정한 횟수의 재실행을 할 수 있다.

잡은 정상적인 동작의 완료 후 큐에서 제거된다. 잡을 실행하는 도중에 에러가 나거나 서버 문제가 생겨 실행이 끊기는 경우 완료 되지 않는다. 이 때 처리 도중에 문제가 발생하면 초기 상태로 돌아가서 다시 실행하는 전략이 베스트이기 때문에 한 단위의 잡은 트렌젝션 처리가 되는 전략을 세우는 편이 좋다.

라라벨에서 잡은 기본적으로 잡 클래스를 객체화하여 저장소에 저장한다. 객체화를 하기 때문에 잡 클래스를 정의할 때의 정의에 따라 객체의 상태를 지정할 수 있고 저장소에 저장되는 잡 단위마다 상태에 따른 다양한 동작을 지정할 수 있다.

하나의 작업에 대한 로직이 많아지게 되면 실행된 많은 처리의 실패에 대한 롤백과 성공에 커밋을 정의해야 하며 실행 시간도 오래 걸린다. 잡을 사용하는 것은 반복적인 패턴의 처리를 나누어 실행하여 롤백과 커밋에 대한 부담감을 줄이기 위한 방편이 된다. 처리에 대한 커밋의 단위가 작다면 실패한 단위에 대해서만 실패 이유를 개선 한 후 재처리를 할 수도 있기 때문에 컴퓨팅 리소스를 줄일 수 있는 장점 및 관리하기 좋다는 장점도 있다.

### 잡의 상태

웹에는 다양한 유형의 고객이 존재한다. 예를 들어 상품을 사는 사람이 존재하며 상품을 파는 사람도 존재할 것이다. 상품을 사는 사람의 정산 기능, 상품을 파는 사람의 정산 기능 등이 존재하며 주로 정산 기능은 배치처리작업을 통해서 정산 결과가 도출된다.

상품 구매자에 대한 배치 처리 로직과 상품 판매자에 대한 배치 처리 로직은 서로 다를 것이다. 그러나 상품 구매자들 각각에 대한 처리 로직은 상품 구매자가 가진 상태만이 달라질 뿐 처리 되어야 하는 로직은 동일하게 정의될 것이다. 각 상품구매자에 대해서 동일한 유형에 대한 처리 로직이 유저의 데이터의 차이 및 상태에 따라 달라질 뿐이므로 잡으로 정의하게 되면 각각의 유저에 대한 처리를 한 단위로 끝낼 수 있으며 모든 유저에 대한 처리도 할 수 있다. 이는 상품판매자에 대해서도 마찬가지이다.

## 큐(queue)

잡을 저장하고 저장한 순서대로 실행하는 패턴으로 하나의 작업이 끝나면 다음 작업을 실행하는 방식이다.

### 큐의 특징

저장된 잡을 순차적으로 실행하므로 하나의 큐는 하나의 CPU 스레드만을 사용한다. 또한 하나의 잡이 자치하는 메모리가 한계이기 때문에 메모리 사용량도 일정 수준 내에서 컨트롤 할 수 있다는 장점이 있다. 따라서 갑작스런 서버의 과부하를 일으킬 가능성을 줄여주는 역할을 한다.

만약 큐에서 처리해야 할 잡이 너무 많다면 큐를 여러개 사용하면 된다. 각각의 큐는 순서대로 실행되지만, 서로 다른 큐의 잡은 뭐가 먼저 실행될지 명확하게 알 수 없다. 따라서 서로 순서의 관련이 없는 작업은 별도의 큐를 만들어 각각의 큐에 데이터를 저장하는 방식으로 큐의 작업 속도를 빠르게 할 수 있다.

---

## 프레임워크 내에서의 구조

라라벨에서 공식적으로 지원하는 폴더 배치는 아니다. 그러나 배치 유닛, 잡 클래스, 잡 트리거, 아티산 커멘드로 배치 처리를 구성하는 것이 배치 처리를 구조화 할 때 좋은 설계 방법이다.

라라벨의 다양한 소스들을 살펴 보았지만, 배치처리를 어떤식으로 구조화 할 것인지에 대한 규칙은 없어 보인다. 배치 작업을 정의했던 경험에서 낸 아이디어를 제시하고자 한다.

### 배치 유닛 (`Batches/Units/*`)

잡 클래스에서 배치 유닛의 작업을 가져와서 실행하는 용도로 사용된다.

배치 유닛은 한 단위의 잡을 처리하기 위한 코드를 정의한 부분이다. 한 단위의 잡을 정의하는 용도이기 때문에 하나의 유닛 클래스의 실행은 실패 시 초기 상태로 돌아갈 수 있는 트렌젝션 단위로 만들어져야 한다.

잡 클래스에 모든 것을 정의하지 않고 배치 유닛만을 따로 만드는 이유는 기본적으로 배치 처리의 단위로 쓰는 용도도 있지만, 시스템의 유저와의 상호작용에 따라 실행하는 경우도 존재하기 때문이다. 하나의 유닛은 트렌젝션 단위의 작은 처리이기 때문에 배치 처리를 위해 잡(Job)에서 불러다 쓰기도 하고, 유저 인터렉션을 담당하는 서비스레이어 또는 컨트롤러에서 불러다 쓸 수도 있기 때문에 유닛을 따로 분리하여 재사용성을 높이는 방식으로 코드를 짜는 편이 좋다.

큐에 의해 실행 순서가 정해진 로직을 처리해야 하는 경우, 배치 유닛만을 따로 실행하게 되면 큐의 어떤 잡 다음에 처리 되어야 하는데 먼저 처리는 문제가 생길 수 있다. 이런 경우를 방지하기 위해 배치 유닛은 클래스 그 자체로 실행하는 것 보다는 잡 클래스에 배치 유닛을 정의한 단위로 실행하여 실행 순서가 뒤죽박죽 될 가능성을 줄여주는 방향으로 사용하는 편이 좋다.

### 잡 클래스 (`Job/*`)

잡은 데이터베이스와 같은 저장소에 잡을 저장하고 저장한 순서대로 잡 로직을 실행하게 하기 위한 로직을 처리하는 부분이다.

잡은 배치 유닛의 로직을 잡 저장소에 저장하고 저장한 순서대로 실행하는 큐 자료구조의 형태로 사용하기 위해 만들어진다.

처리에 관한 상세한 로직은 배치 유닛에 정의하며 배치 유닛을 사용하기 위한 용도로 쓰는 것이 좋다.

### 잡 트리거 (`Batches/JobTriggers/*`)

배치 처리는 일괄처리라고도 말한다. 일괄처리란 여러 작업을 한 번에 처리한다는 의미이다.

배치 유닛의 클래스를 여러 상태의 객체로 실행하여 다수의 대상에 대한 처리를 하기 위한 도구이다.

이 때 배치 유닛을 직접 실행하는 것이 아닌 잡 클래스를 통해서 배치 처리를 실행한다. 잡 클래스를 통해서 큐 저장소에 실행할 배치 유닛이 잡의 형태로 등록되어야 하기 때문이다.

잡을 실행하기 위한 대상 리스트를 뽑아서 각각의 리스트를 배치 유닛 단위로 잡을 실행하기 위한 목적으로 정의한다.

배치 처리가 중간에 멈추었을 때 남은 작업만을 실행하기 위해서 잡을 실행하기 위한 대상 리스트를 뽑을 때 잡에 의해 실행이 완료된 대상인지 아닌지 구분하는 표식을 넣는 것이 중요하다. 대상 테이블에 완료 표기 플레그를 기입하는 컬럼을 추가하는 것을 고려하자. 실패한 잡의 처리를 위해 실패한 대상이 보고되면 잡 트리거를 다시 실행하여 남은 대상에 대한 배치처리를 실행하는 방안을 고려하자.

잡트리거는 기본적으로 남은 작업만을 처리하기 위한 용도로 정의하는 것이 기본적이지만, 배치 작업의 문제가 생겼을 때 대응을 위해 배치 작업을 클리어하거나 리프레시할 수 있는 기능도 추가하는 편이 좋다.

### 아티산 커멘드

배치 처리를 실행할 시점을 정의하기 위해서는 스케쥴러에 등록을 해야 한다.

스케쥴러에 등록하기 위해서는 아티산 커멘드를 통해서 실행할 수 있도록 정의가 되어야 한다.

아티산 커멘드로 정의할 때는 일괄 처리를 실해하기 위한 잡 트리거를 직접 가져다 사용한다.

아티산 커멘드가 정의되었다면 스케쥴러에 언제 실행할 것인지 등록한다.

---

## 실행의 흐름
1. 리눅스의 cron 서비스가 동작한다.
2. cron의 실행에 따라 라라벨의 스케쥴러가 동작한다.
3. 라라벨 스케쥴러에 등록된 아티산 커멘드는 특정한 타이밍에 정의된 아티산 커멘드를 실행한다.
4. 아티산 커멘드는 잡 트리거를 실행한다.
5. 잡 트리거는 다양한 상태를 갖는 배치 유닛을 큐-잡의 형태로 등록하기 위해서 다수의 잡을 큐 방식으로 저장되는 저장소에 등록한다.
6. 등록된 잡은 순차적으로 실행되면서 유닛으로 정의된 단위로 로직을 처리한다.

---

## 폴더 구조
- 라라벨의 주요 비즈니스 로직들은 app 폴더 하단에 위치한다.
- 기본적으로 job의 경우 job 폴더가 라라벨에서 제공되기 때문에 배치 유닛을 사용하는 잡 클래스도 `app/job` 폴더 안에 정의하도록 한다. `app/job/baches` 폴더를 만들어 배치 유닛을 사용하는 잡 클래스를 정의하도록 하자. (job 폴더를 사용하는 이유는 `php artisan make:job job파일명`으로 job 클래스 파일을 만드는데 `app/job/*` 경로가 아니면 artisan 명령어로 잡 클래스를 만들지 못하는 제한이 있다. 다른 폴더에 정의해도 잡이 동작하는지는 알 수 없으나, `php artisan make:model`이 `app` 폴더 내의 다양한 경로를 지정할 수 있는 것에 반해 `job` 폴더로 제한이 되어 있으므로 만들어 둔 제한대로 쓰자는 생각이다.) 
- `app/Batches/Units` 폴더에 배치 유닛 클래스 파일을 정의한다. 또한 `app/batches/JobTriggers` 폴더에 배치 서비스 클래스 파일을 정의하도록 한다.

---

## 스프링 배치와의 비교

#### 스프링 배치의 구조

- 스프링 배치의 `Job` 클래스는 `ItemReader`, `ItemProcessor`, `ItemWriter` 인터페이스를 구현한 클래스를 사용한다.
- `ItemReader`는 데이터를 읽어들이는 역할을 한다. 데이터베이스에서 데이터를 가져올 수도 있고, 파일에서 데이터를 가져올 수도 있고, 기타 다양한 저장소에서 데이터를 하나씩 가공하는 구조이다.
- `ItemReader`는 데이터를 읽는 기능을 담당한다. 데이터 저장소의 다양햔 포멧의 데이터를 처리할 수 있도록 읽기 위한 기능이 제공되는 곳으로 데이터를 읽을 때의 포멧을 지정할 수도 있다. 원본 데이터의 형태에 의존적인 코드가 위치하는 곳이다. 반복되는 읽기 작업을 한 단위로 하여 여러 번 반복해서 일정량의 데이터를 메모리에 올려둔다.
- `ItemProcessor`는 `ItemReader`으로 읽어 메모리에 일정량이 모여진 데이터를 하나씩 처리하는 로직을 정의하는 부분으로 주로 비즈니스 로직이 위치한다.
- `ItemReader`와 `ItemProcessor`는 분리 되어 있는데, 저장소에 따라 달라질 수 있는 데이터 취득 구조와 다양한 곳에서 온 데이터를 특정한 비즈니스 처리를 위해서 가공하는 과정을 분리하기 위해서라고 볼 수 있다. 저장소에서 데이터를 가져오는 로직은 A 비즈니스 로직에서는 a 포멧의 데이터로 B 비즈니스 로직에서는 b 포멧의 데이터로 데이터의 변환을 해야 하는 경우가 생길 수 있다. 각 비즈니스 로직의 목적에 맞게 데이터를 다양하게 가공하기 위한 것이 `ItemProcessor`의 목적이기 때문에 `ItemReader`와 분리하여 재사용성을 높이는 구조라고 할 수 있다. 이 때, `ItemReader` 출력 포멧과, `ItemProcessor`의 입력 포멧은 동일한 타입을 설정하는 것을 통해서 프로토콜을 맞춘다.
- `ItemProcessor`에서 비즈니스 로직을 처리하고 처리된 결과를 저장하기 위한 부분이 `ItemWriter`부분에 해당한다.
- `ItemReader`, `ItemProcessor`, `ItemWriter`의 모두 컴퓨터의 메모리 상에서의 데이터 변환이 이뤄진다. 어떤 결과물을 만드는 과정이기 때문에 도중에 실패해면 해당 데이터는 메모리에서 날라가서 자연스런 롤백이 된다. 

#### 라라벨 배치와 스프링 배치의 차이

- 트랜잭션은 한 묶음의 명령을 실행하는데 있어 하나라도 명령을 실행하는데 문제가 있다면 전체 과정이 실행되지 않도록 하는 것이다. 트랜젝션의 단위가 크면 실패의 가능성이 높기 때문에 트랜잭션은 한 번에 처리해야 하는 최소한의 단위로 구성을 한다.
- 라라벨의 배치이든 스프링의 배치이든 `job` 단위로 배치를 실행한다는 것은 하나의 `job`이 최소한의 트랜잭션 단위를 가지고 있다는 의미를 가지고 있다.
- 라라벨 배치의 트랜잭션과 스프링 배치의 트랜잭션은 모두 `job` 단위로 트랜잭션을 부여하고 있지만 라라벨의 배치는 `job`을 스프링배치와 같이 `ItemReader`, `ItemProcessor`, `ItemWriter`로 세분화, 구조화하는 패턴이 정해져 있지 않고 자유롭게 구현할 수 있다.
- 라라벨의 배치도 `job`에 스프링과 같이 `ItemReader`, `ItemProcessor`, `ItemWriter`으로 세분화해서 사용할 수 있을 것이다. 하지만 스프링 배치는 구조가 정해져 있기 때문에 해당 구조에 맞게 처리하려는 로직을 맞춰줘야 한다. 이런 스프링의 구조는 비즈니스 로직과 데이터 가공의 로직을 좀 더 분리할 수 있는 장점을 제공하는 장점도 있다.
- 라라벨 배치에서는 `JobTrigger`를 만들었지만, 스프링 배치에서는 `ItemReader` 처리 완료된 목록을 제외한 다음 목록을 가져오는 방식으로 만들었으므로 잡 처리의 대상을 여럿 만드는 `JobTrigger`와 같은 로직 없이 만든 것으로 보인다. 스프링 배치에서는 `JobLauncher`라는 것이 있지만 `ItemReader`에서 실행되지 않은 대상을 선택하게 되므로 라라벨의 `JobTrigger`와 하나의 잡이 처리해야 할 조건을 여럿 만드는 방법은 아닌 모양이다. `JobTrigger`는 배치를 돌려야 할 대상을 미리 뽑아 트랜잭션 단위로 만들어 큐에 미리 적재하는 방식으로 사용한다. `JobLauncher`는 단순히 잡을 데이터베이스에 적재하는 역할을 하는 것으로 보인다. 스프링에서도 `JobTrigger`와 같은 방식을 만들기 위해서는 따로 배치를 돌리기 위한 클래스 구조를 만들어 줄 필요가 있어 보인다.
- 만약 `JobTrigger`와 같은 기능을 하는 것이 없다면, 스캐쥴러는 매번 모든 배치가 완료된 상태인지 아닌지 체크하는 로직이 들어가야 하고 이는 `ItemReader` 부분에서 처리하게 될 것이다. 그리고 일정 시간마다 이를 체크하는 스케쥴러도 계속 실행해야 하는 단점이 생긴다.
- 라라벨에서는 스프링과 같이 잡의 구조가 나눠지지 않았기 때문에 클래스와 폴더구조 등을 사용해서 `JobTrigger`->`Job`->`JobUnit`의 연결 관계를 갖는 구조화를 하는 것이 나을 수도 있다고 본다.
