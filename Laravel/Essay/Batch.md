## 배치처리
- 일반적으로 프로그램은 유저와의 상호작용을 통해서 데이터를 생성, 저장, 변경하는 방식을 제공하는 컴퓨터 시스템이다.
- 유저와 시스템 간의 상호작용이 일어날 때 시스템에서 작업을 처리하기에 시간이 걸려 상호작용에 불편함을 주는 경우 또는 유저와의 상호작용 시점에 아닌 별도의 시점에 실행되어야 하는 작업의 경우 특정한 시간 패턴을 지정하여 유저와의 상호작용 없이 작업을 실행하는 방식이 배치 처리이다.
- 곧, 유저와의 직접적인 상호작용 없는 시스템의 데이터 처리 방식이 배치처리라고 할 수 있다.
- 일반적으로 배치 처리는 시스템이 리소스 소모가 적은 시간을 정해 유저와의 상호작용으로 처리할 수 없는 처리를 실행하게 한다.

---

## 라라벨에서 배치 처리
- 라라벨에서 배치 처리를 위해 제공하는 기능은 스케쥴러, 잡, 큐가 있다.

### 스케쥴러
- 커멘드라인 명령어를 리눅스 cron으로 지정한 시간 패턴에 따라 실행하도록 하는 기능이다.
- 라라벨 프레임워크에서 작성된 아티산 콘솔 코드 형식으로 작성된 php 파일을 `php artisan`으로 시작되는 커멘드라인 명령어로 실행하도록 하는 기능이다.

### 큐(Queue)와 잡(Job)
- 큐(Queue)는 데이터베이스 등과 같은 저장소에 실행할 코드를 저장한 다음 저장한 순서대로 저장된 코드를 실행 시키는 기능이다.
- 이 때 순서에 따라 한 단위로 실행되는 작업을 잡(Job)이라고 한다.

## 잡(Job) 정의하기
- 라라벨 프레임워크에서 배치처리를 깔끔하게 구현하는 방법에 대해 생각해 보자.

### 잡(Job)의 특징
- 라라벨에서 job이란 하나의 코드 실행 단위를 뜻한다. 이 코드 실행 단위를 실행하는 도중에 에러가 발생하면 잡은 중단되며 실패한 잡은 지정한 횟수의 재실행을 할 수 있다.
- 잡은 정상적인 동작의 완료 후 큐에서 제거된다. 잡을 실행하는 도중에 에러가 나거나 서버 문제가 생겨 실행이 끊기는 경우 완료 되지 않는다. 이 때 처리 도중에 문제가 발생하면 초기 상태로 돌아가서 다시 실행하는 전략이 베스트이기 때문에 한 단위의 잡은 트렌젝션 처리가 되는 전략을 세우는 편이 좋다.
- 라라벨에서 잡은 기본적으로 잡 클래스를 객체화하여 저장소에 저장한다. 객체화를 하기 때문에 잡 클래스를 정의할 때의 정의에 따라 객체의 상태를 지정할 수 있고 저장소에 저장되는 잡 단위마다 상태에 따른 다양한 동작을 지정할 수 있다.
- 하나의 작업에 대한 로직이 많아지게 되면 실행된 많은 처리의 실패에 대한 롤백과 성공에 커밋을 정의해야 하며 실행 시간도 오래 걸린다. 잡을 사용하는 것은 반복적인 패턴의 처리를 나누어 실행하여 롤백과 커밋에 대한 부담감을 줄이기 위한 방편이 된다. 처리에 대한 커밋의 단위가 작다면 실패한 단위에 대해서만 실패 이유를 개선 한 후 재처리를 할 수도 있기 때문에 컴퓨팅 리소스를 줄일 수 있는 장점 및 관리하기 좋다는 장점도 있다.

### 잡의 상태
- 웹에는 다양한 유형의 고객이 존재한다. 예를 들어 상품을 사는 사람이 존재하며 상품을 파는 사람도 존재할 것이다. 상품을 사는 사람의 정산 기능, 상품을 파는 사람의 정산 기능 등이 존재하며 주로 정산 기능은 배치처리작업을 통해서 정산 결과가 도출된다.
- 상품 구매자에 대한 배치 처리 로직과 상품 판매자에 대한 배치 처리 로직은 서로 다를 것이다. 그러나 상품 구매자들 각각에 대한 처리 로직은 상품 구매자가 가진 상태만이 달라질 뿐 처리 되어야 하는 로직은 동일하게 정의될 것이다. 각 상품구매자에 대해서 동일한 유형에 대한 처리 로직이 유저의 데이터의 차이 및 상태에 따라 달라질 뿐이므로 잡으로 정의하게 되면 각각의 유저에 대한 처리를 한 단위로 끝낼 수 있으며 모든 유저에 대한 처리도 할 수 있다. 이는 상품판매자에 대해서도 마찬가지이다.

## 큐(queue)
- 잡을 저장하고 저장한 순서대로 실행하는 패턴으로 하나의 작업이 끝나면 다음 작업을 실행하는 방식이다.

### 큐의 특징
- 저장된 잡을 순차적으로 실행하므로 하나의 큐는 하나의 CPU 스레드만을 사용한다. 또한 하나의 잡이 자치하는 메모리가 한계이기 때문에 메모리 사용량도 일정 수준 내에서 컨트롤 할 수 있다는 장점이 있다. 따라서 갑작스런 서버의 과부하를 일으킬 가능성을 줄여주는 역할을 한다.
- 만약 큐에서 처리해야 할 잡이 너무 많다면 큐를 여러개 사용하면 된다. 각각의 큐는 순서대로 실행되지만, 서로 다른 큐의 잡은 뭐가 먼저 실행될지 명확하게 알 수 없다. 따라서 서로 순서의 관련이 없는 작업은 별도의 큐를 만들어 각각의 큐에 데이터를 저장하는 방식으로 큐의 작업 속도를 빠르게 할 수 있다.

---

## 프레임워크 내에서의 구조
- 라라벨에서 공식적으로 지원하는 폴더 배치는 아니다. 그러나 배치 유닛, 잡 클래스, 잡 트리거, 아티산 커멘드로 배치 처리를 구성하는 것이 배치 처리를 구조화 할 때 좋은 설계 방법이다.
- 라라벨의 다양한 소스들을 살펴 보았지만, 배치처리를 어떤식으로 구조화 할 것인지에 대한 규칙은 없어 보인다. 배치 작업을 정의했던 경험에서 낸 아이디어를 제시하고자 한다.

### 배치 유닛 (`Batches/Units/*`)
- 잡 클래스에서 배치 유닛의 작업을 가져와서 실행하는 용도로 사용된다.
- 배치 유닛은 한 단위의 잡을 처리하기 위한 코드를 정의한 부분이다. 한 단위의 잡을 정의하는 용도이기 때문에 하나의 유닛 클래스의 실행은 실패 시 초기 상태로 돌아갈 수 있는 트렌젝션 단위로 만들어져야 한다.
- 잡 클래스에 모든 것을 정의하지 않고 배치 유닛만을 따로 만드는 이유는 기본적으로 배치 처리의 단위로 쓰는 용도도 있지만, 시스템의 유저와의 상호작용에 따라 실행하는 경우도 존재하기 때문이다. 하나의 유닛은 트렌젝션 단위의 작은 처리이기 때문에 배치 처리를 위해 잡(Job)에서 불러다 쓰기도 하고, 유저 인터렉션을 담당하는 서비스레이어 또는 컨트롤러에서 불러다 쓸 수도 있기 때문에 유닛을 따로 분리하여 재사용성을 높이는 방식으로 코드를 짜는 편이 좋다.
- 큐에 의해 실행 순서가 정해진 로직을 처리해야 하는 경우, 배치 유닛만을 따로 실행하게 되면 큐의 어떤 잡 다음에 처리 되어야 하는데 먼저 처리는 문제가 생길 수 있다. 이런 경우를 방지하기 위해 배치 유닛은 클래스 그 자체로 실행하는 것 보다는 잡 클래스에 배치 유닛을 정의한 단위로 실행하여 실행 순서가 뒤죽박죽 될 가능성을 줄여주는 방향으로 사용하는 편이 좋다.

### 잡 클래스 (`Job/*`)
- 잡은 데이터베이스와 같은 저장소에 잡을 저장하고 저장한 순서대로 잡 로직을 실행하게 하기 위한 로직을 처리하는 부분이다.
- 잡은 배치 유닛의 로직을 잡 저장소에 저장하고 저장한 순서대로 실행하는 큐 자료구조의 형태로 사용하기 위해 만들어진다.
- 처리에 관한 상세한 로직은 배치 유닛에 정의하며 배치 유닛을 사용하기 위한 용도로 쓰는 것이 좋다.

### 잡 트리거 (`Batches/JobTriggers/*`)
- 배치 처리는 일괄처리라고도 말한다. 일괄처리란 여러 작업을 한 번에 처리한다는 의미이다.
- 배치 유닛의 클래스를 여러 상태의 객체로 실행하여 다수의 대상에 대한 처리를 하기 위한 도구이다.
- 이 때 배치 유닛을 직접 실행하는 것이 아닌 잡 클래스를 통해서 배치 처리를 실행한다. 잡 클래스를 통해서 큐 저장소에 실행할 배치 유닛이 잡의 형태로 등록되어야 하기 때문이다.
- 잡을 실행하기 위한 대상 리스트를 뽑아서 각각의 리스트를 배치 유닛 단위로 잡을 실행하기 위한 목적으로 정의한다.
- 배치 처리가 중간에 멈추었을 때 남은 작업만을 실행하기 위해서 잡을 실행하기 위한 대상 리스트를 뽑을 때 잡에 의해 실행이 완료된 대상인지 아닌지 구분하는 표식을 넣는 것이 중요하다. 대상 테이블에 완료 표기 플레그를 기입하는 컬럼을 추가하는 것을 고려하자. 실패한 잡의 처리를 위해 실패한 대상이 보고되면 잡 트리거를 다시 실행하여 남은 대상에 대한 배치처리를 실행하는 방안을 고려하자.
- 잡트리거는 기본적으로 남은 작업만을 처리하기 위한 용도로 정의하는 것이 기본적이지만, 배치 작업의 문제가 생겼을 때 대응을 위해 배치 작업을 클리어하거나 리프레시할 수 있는 기능도 추가하는 편이 좋다.

### 아티산 커멘드
- 배치 처리를 실행할 시점을 정의하기 위해서는 스케쥴러에 등록을 해야 한다.
- 스케쥴러에 등록하기 위해서는 아티산 커멘드를 통해서 실행할 수 있도록 정의가 되어야 한다.
- 아티산 커멘드로 정의할 때는 일괄 처리를 실해하기 위한 잡 트리거를 직접 가져다 사용한다.
- 아티산 커멘드가 정의되었다면 스케쥴러에 언제 실행할 것인지 등록한다.

---

## 실행의 흐름
1. 리눅스의 cron 서비스가 동작한다.
2. cron의 실행에 따라 라라벨의 스케쥴러가 동작한다.
3. 라라벨 스케쥴러에 등록된 아티산 커멘드는 특정한 타이밍에 정의된 아티산 커멘드를 실행한다.
4. 아티산 커멘드는 잡 트리거를 실행한다.
5. 잡 트리거는 다양한 상태를 갖는 배치 유닛을 큐-잡의 형태로 등록하기 위해서 다수의 잡을 큐 방식으로 저장되는 저장소에 등록한다.
6. 등록된 잡은 순차적으로 실행되면서 유닛으로 정의된 단위로 로직을 처리한다.

---

## 폴더 구조
- 라라벨의 주요 비즈니스 로직들은 app 폴더 하단에 위치한다.
- 기본적으로 job의 경우 job 폴더가 라라벨에서 제공되기 때문에 배치 유닛을 사용하는 잡 클래스도 `app/job` 폴더 안에 정의하도록 한다. `app/job/baches` 폴더를 만들어 배치 유닛을 사용하는 잡 클래스를 정의하도록 하자. (job 폴더를 사용하는 이유는 `php artisan make:job job파일명`으로 job 클래스 파일을 만드는데 `app/job/*` 경로가 아니면 artisan 명령어로 잡 클래스를 만들지 못하는 제한이 있다. 다른 폴더에 정의해도 잡이 동작하는지는 알 수 없으나, `php artisan make:model`이 `app` 폴더 내의 다양한 경로를 지정할 수 있는 것에 반해 `job` 폴더로 제한이 되어 있으므로 만들어 둔 제한대로 쓰자는 생각이다.) 
- `app/Batches/Units` 폴더에 배치 유닛 클래스 파일을 정의한다. 또한 `app/batches/JobTriggers` 폴더에 배치 서비스 클래스 파일을 정의하도록 한다.

---

## 스프링 배치와의 비교
- 웹 프레임워크는 데이터베이스 연결을 필수로 하고 데이터베이스가 연결이 되어 있기 때문에 ORM의 청크를 통해서 일정량의 데이터를 뽑아 각 레코드에 대한 처리를 한다.
- 스프링 프레임워크는 단순히 웹만을 위한 프레임워크가 아니다. 데이터베이스의 커넥션 없이도 배치처리를 할 수 있게 만들어 두었다. 스프링 배치도 마찬가지로 배치의 속도도 높이고 메모리의 용량 한계를 고려하여 청크 단위로 배치프로세스를 돌려야 하지만, 청크 단위로 데이터베이스에서 데이터를 가져온다는 개념이 핵심은 아니다.

#### 스프링 배치의 구조
- 스프링 배치의 `Job` 클래스는 `**ItemReader`메소드, `**ItemProcessor`메소드, `**ItemWriter`메소드를 사용한다. `ItemReader`, `ItemProcessor`는 데이터 단위 하나를 읽어들이는 역할을 한다. 데이터베이스에서 데이터를 가져올 수도 있고, 파일에서 데이터를 가져올 수도 있고, 기타 다양한 저장소에서 데이터를 하나씩 가공하는 구조이다.
- `ItemReader`는 데이터를 일정량 꺼내는 과정이고 `ItemProcessor`는 꺼낸 일정량의 데이터를 배치 처리를 하기 위한 적절한 구조로 변경하기 위한 가공 처리를 하는 과정이다. `ItemReader`, `ItemProcessor`를 통해 가공된 데이터를 지정한 청크 사이즈 만큼 쌓는 과정이 스프링 배치에서의 청크에 해당한다. 그리고 이 청크 단위로 `ItemWriter`를 실행하여 최종 결과물을 얻도록 한다.
- `ItemReader`에서 꺼내는 데이터의 양은 `ItemProcessor`에서 지정한 양만큼 쌓으므로 보다 작거나 같다.
- `ItemWriter`는 쌓인 데이터를 청크 단위로 트랜잭션을 걸어 실행한다.
- 물론 `ItemReader`를 여러번 반복하기 전에 저장소로 부터 일정량의 데이터를 한 꺼번에 데이터를 가져오는 전처리를 하는 경우가 있으므로 쿼리를 `ItemReader`는 여러번 실행되더라도 쿼리 실행은 그 만큼 실행이 되지 않도록 최적화 한다.

#### 라라벨 배치의 특징
- 이에 반해 라라벨은 웹 프레임워크이다. 라라벨은 엘로퀀트라는 ORM을 기본으로 동작하도록 만들어져 있으며, ORM의 청크 단위로 데이터를 취득할 수 있는 기능을 제공한다. 그리고 각각의 레코드의 정보로 한 단위의 트렌젝션을 처리하는 잡을 만들어 배치처리를 한다. 라라벨에서도 ORM을 사용하지 않고도 배치처리 할 수 있지만 ORM이 간단한 청크 메소드를 지원하기 때문에 청크단위의 데이터를 가져오기 위해 복잡하게 코드를 짤 필요가 없다는 장점이 있다. 따라서 데이터를 저장할 때 다른 저장소 보다도 RDBMS에 데이터를 저장하는 것이 프로그래밍에 효과적이다.

#### 트랜젝션의 단위
- 라라벨의 배치의 트렌젝션은 잡 단위로 이뤄진다. 그에 반해 스프링 배치의 배치는 청크 단위의 가공된 데이터로 이뤄진다. 이러한 차이는 라라벨의 배치 처리가 어떤 트랜잭션으로 처리 되어야 최소 단위 또는 작은 단위를 처리를 하는 것이었다면 스프링의 배치 처리는 대량의 데이터를 배치 처리하기 위해 청크 단위 만큼 한 번에 처리를 하고 만약 도중에 실패되는 청크 단위의 처리가 있다면 이를 배치를 정지 시키거나 배치를 다시 진행하여 누락되는 대상이 없도록 하는 것에 목적이 있는 것으로 보인다.
- 스프링의 배치는 한 단위의 트랜잭션 무척 크다. 이는 대용량 데이터를 처리하기 위해 큰 단위로 통신을 하기 위함으로 보인다. 그에 반해 라라벨의 배치는 한 단위의 트랜잭션이 작다. 이는 하나하나 완료된 처리를 쌓아가기 위함이다.

