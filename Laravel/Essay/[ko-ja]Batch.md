# 라라벨에서의 큐를 사용한 배치 설계: Trigger–Job–Unit 패턴
# Laravelのキューでバッチを設計する：Trigger–Job–Unitパターン

# 소개
# はじめに

웹 개발에 입문하는 사람들은 MVC 패턴을 배운다. 유저에게 인터페이스를 제공하고 유저의 조작에 따라 저장소에 저장된 각종 데이터를, 애플리케이션 서버의 가공 처리의 결과를 받아 볼 수 있는 MVC 패턴을 배우지만, 유저와의 상호작용 없이 서버에서 실행되는 배치 처리에 대해 공부하거나 배우지 않는 경우가 많다.

Web開発に入門すると、多くの人はMVCパターンを学びます。ユーザーにインターフェースを提供し、ユーザーの操作に応じて、保存先に格納された各種データをアプリケーションサーバー側で加工した結果を返す、という形でMVCを理解していく一方で、ユーザーとの相互作用なしにサーバー上で実行される「バッチ処理」については、あまり学ばないまま進むことも多いです。

웹 프로그래밍의 경우 언어나 프레임워크에 관계 없이 MVC라는 기본적인 패턴을 사용하고 필요에 따라 MVC 패턴을 확장하는 방식으로 아키텍처를 정하기 때문에, 어떠한 언어나 프레임워크를 목표로 공부를 하더라도 기본적인 MVC 패턴 필수로 배워야 하는 것과 달리, 배치 처리는 언어나 프레임워크에서 지원하는 배치 처리 방식이 달라서 공통적으로 익혀두어야 할 패턴이 제시되지는 않는다.

Webプログラミングは、言語やフレームワークに関係なくMVCという基本パターンを使い、必要に応じて拡張しながらアーキテクチャを決めていきます。そのため、どの言語・フレームワークを目標にしていても、MVCは必須として学びやすいです。一方で、バッチ処理は言語やフレームワークが提供する方式がそれぞれ違うため、共通して覚えておくべきパターンが提示されにくい、という事情があります。

배치 처리에 유명한 아키텍처로는 자바 스프링의 스프링 배치의 처리 방식이 있지만, 언어와 프레임워크마다 잘 지원되는 배치 처리 방식이 다르기 때문에 그대로 이식을 할 수는 없다. 이 글은 배치 처리를 배울 때 기본적으로 알아야 하는 개념들을 배우는 것과 함께, 라라벨 프레임워크에서 배치처리를 어떻게 설계하면 좋을지에 대한 패턴을 제시한다.

バッチ処理の有名なアーキテクチャとしてはJava SpringのSpring Batchがありますが、言語・フレームワークごとに得意なバッチ処理の仕組みは異なるので、そのまま移植できるわけではありません。この記事では、バッチ処理を学ぶうえで基本となる概念を整理しつつ、Laravelでバッチ処理をどう設計するとよいか、ひとつのパターンを紹介します。

라라벨 뿐만 아닌 비슷한 방식의 배치처리를 하는 레일즈나 장고 등의 프레임워크의 프로젝트에서도 적용할 수 있는 방식이라고 본다.

この考え方はLaravelに限らず、似た方式でバッチ処理を行うRailsやDjangoなどのプロジェクトでも応用できると思います。

# 본론
# 本編

## 배치 처리란?
## バッチ処理とは？

일반적으로 프로그램은 유저와의 상호작용을 통해서 데이터를 생성, 저장, 변경하는 방식을 제공하는 컴퓨터 시스템이다.

一般的にプログラムは、ユーザーとの相互作用を通してデータを作成・保存・変更する仕組みを提供するコンピュータシステムです。

유저와 시스템 간의 상호작용이 일어날 때 시스템에서 작업을 처리하기에 시간이 걸려 상호작용에 불편함을 주는 경우 또는 유저와의 상호작용 시점에 아닌 별도의 시점에 실행되어야 하는 작업의 경우 특정한 시간 패턴을 지정하여 유저와의 상호작용 없이 작업을 실행하는 방식이 배치 처리이다.

ユーザーとシステムの相互作用が発生したとき、処理に時間がかかって操作体験が悪くなる場合があります。また、ユーザーが操作したタイミングではなく、別のタイミングで実行したい処理もあります。そういった処理を、特定の時間パターンを指定して、ユーザーとの相互作用なしに実行する方式がバッチ処理です。

곧, ***유저와의 직접적인 상호작용 없는 시스템의 데이터 처리 방식***이 배치 처리라고 할 수 있다.

つまり、***ユーザーとの直接的な相互作用なしに行うシステムのデータ処理方式*** がバッチ処理と言えます。

일반적으로 배치 처리는 시스템 리소스 소모가 적은 시간을 정해 유저와의 상호작용으로 처리할 수 없는 처리를 실행한다.

一般的には、システムリソース消費が少ない時間帯を選び、ユーザー操作の中では処理しづらい作業を実行します。

## 배치처리와 유저 인터페이스를 통한 처리
## バッチ処理とユーザーインターフェースによる処理

웹 개발은 잘 알려진 MVC 패턴 위에서 개발하는 것이 기본이다. 이 구조는 누구나 잘 알고 있고, 유저의 설정으로 로직을 처리하는데 필요한 각종 값을 입력 받을 수 있다. 이 때문에 배치 처리에 비해서 상대적으로 쉽게 코드를 작성할 수 있다.

Web開発は、よく知られているMVCパターンの上で開発するのが基本です。この構造は多くの人に馴染みがあり、ユーザー設定などからロジックに必要な値を入力してもらえます。そのため、バッチ処理に比べると比較的コードを書きやすいです。

유저에게 제공되는 인터페이스로 부터 받는 각종 값을 통해서 로직을 실행하는 프로그래밍과 달리, 배치 처리는 데이터베이스의 데이터 상태 및 서버의 상태 등을 고려해서 처리에 필요한 설정을 프로그래머가 직접 지정해 주어야 한다. 이 때문에 동작에 필요한 조건을 설정하는 것이 까다롭고, 스케쥴러, 큐, 잡 등에 대한 이해가 요구된다.

ユーザーに提供するインターフェースから受け取った値でロジックを実行するのに対し、バッチ処理ではデータベースの状態やサーバーの状態などを考慮して、処理に必要な設定をプログラマー側で指定する必要があります。その分、動作条件の設計が難しくなり、スケジューラー、キュー、ジョブなどへの理解も求められます。

또한 스케쥴러에 의존하는 기능을 실행하기 위해 커멘드라인 등의 명령어를 만들어야 하는 등 더 많은 보일러 플레이트를 갖는 등의 어려움도 있다.

また、スケジューラーに依存する機能を動かすためにコマンドラインの命令を用意するなど、ボイラープレートが増えやすい点も悩みどころです。

배치 처리를 만들기 위해서는 MVC 패턴보다 더 많은 보일러 플레이트가 필요한 경우도 많다. 배치 처리를 만들기에 앞서, 유저 인터페이스에서 처리하는 게 나은지 배치 처리를 통해서 만들는 게 나은지 판단할 필요가 있다.

バッチ処理はMVCより多くのボイラープレートが必要になるケースもあります。作り始める前に、ユーザーインターフェースで処理するのがよいか、バッチ処理にするのがよいかを判断する必要があります。

### 유저 인터페이스로 처리하면 좋은 작업
### ユーザーインターフェースで処理するとよい作業

배치 처리를 만들기 보다는 유저 인터페이스를 제공해서 처리하기 쉬운 작업은 유저 인터페이스를 제공하여 처리하도록 한다.

バッチ処理を作るよりも、ユーザーインターフェースを提供したほうが処理しやすい作業は、UIで扱うようにします。

예를 들어 리퀘스트와 리스폰스 사이의 시간이 그다지 걸리지 않아 유저가 결과물을 얻기 까지 시간을 크게 불편하지 않게 여길 수 있는 정도의 작업이 이에 해당한다. 유저는 결과를 리스폰스에 담긴 결과로 즉시 받아 볼 수 있다는 장점이 있다.

たとえば、リクエスト〜レスポンスの時間がそれほど長くなく、ユーザーが結果を得るまでの待ち時間が大きな負担にならない作業が該当します。ユーザーはレスポンスに含まれる結果をすぐ確認できる、というメリットがあります。

배치 처리는 유저의 입장에서는 비동기로 동작한다. 웹 리퀘스트의 결과가 리스폰스에 포함되지 않고 별도의 배치 처리를 동작 시킨다. 배치 처리 작업이 언제 완료될지 정확히 알 수 없으며 대략적인 시간 추정을 통해서 얼마 후에 완료 된다 정도만을 알 수 있다.

バッチ処理はユーザー視点では非同期で動きます。Webリクエストの結果がレスポンスに含まれず、別途バッチ処理が動きます。いつ完了するかを正確に知るのは難しく、「しばらくしてから確認してください」といった案内になりがちです。

### 배치 처리로 처리하면 좋은 작업

### バッチ処理に向いている作業

#### 작업이 완료되기 전에 빠른 리스폰스 주기
#### 作業完了前に素早くレスポンスを返したい

요청한 작업을 처리하는데 많은 시간이 길면 유저는 불편함을 느낀다. 이 때는 배치 처리로 테스크를 넘기고 빠른 응답 후 유저에게 얼마 후 확인하라는 메시지를 주면 유저는 안정감을 느낄 수 있다.

要求された作業に長い時間がかかる場合、リクエスト〜レスポンスのライフサイクルが長くなりユーザーは不便に感じます。その場合はバッチ処理にタスクを渡して素早く応答し、ユーザーには「しばらくしてから確認してください」と伝えるほうが安心感につながります。

#### 유저가 요청하기 전에 미리 처리해 놓기
#### ユーザーが要求する前に先に処理しておきたい

많은 시간이 걸리는 작업은 유저가 요청하기 전에 작업 처리 조건이 갖춰지는 대로 배치 처리로 작업을 처리한다. 사전 작업을 통해 유저가 원하는 때에 처리된 결과만 즉각적으로 볼 수 있다.

時間のかかる作業は、ユーザーが要求する前に、条件が揃い次第バッチ処理で実行しておきます。事前処理によって、ユーザーは必要なタイミングで処理済みの結果だけをすぐ見られます。

#### 특정 타이밍에 처리해야 하는 작업 처리하기
#### 特定のタイミングで処理しないといけない作業

특정 실행 시점에 의존하는 정보들이 존재한다. 예를 들어 어떤 정보는 계속 변하는데 특정 타이밍에 실행하지 않고 나중에 실행하게 되는 경우, 타이밍을 놓치면 처리 결과물이 달라지고 원한 시점의 결과물을 얻지 못할 수 있다.

特定の実行タイミングに依存する情報もあります。たとえばある情報が継続的に変化していて、特定のタイミングで実行しないまま後から実行すると、処理結果が変わってしまい、欲しかった時点の結果を得られないことがあります。

물론 기존 값이 갱신되지 않게 하고 데이터를 쌓는 방식이 좋지만, 경우에 따라 값이 계속 변경되는 케이스도 있다. 미리 실행되어야 할 타이밍에 스케쥴러를 통해 배치처리를 실행하여 적절한 타이밍에 결과물 생성하고 남길 때 배치 처리를 사용한다.

もちろん値を更新しないようにして履歴を積む設計が望ましいですが、状況によっては値が更新され続けるケースもあります。そういうときは、実行すべきタイミングでスケジューラーからバッチ処理を実行し、適切なタイミングの結果を生成・保存するためにバッチ処理を使います。

## 라라벨에서 배치 처리
## Laravelにおけるバッチ処理

라라벨에서 배치 처리를 위해 제공하는 기능은 스케쥴러, 잡, 큐, 아티산 커멘드가 있다.

Laravelがバッチ処理のために提供している機能には、スケジューラー、ジョブ、キュー、Artisanコマンドがあります。

### 스케쥴러
### スケジューラー

지정한 스케쥴에 따라 프로그램이 실행되도록 하는 기능을 스케쥴러라고 한다. 매일 몇 시, 매달 몇 일 등, 한 시간에 동일 간격으로 몇 번 등의 설정을 통해서 원하는 시간에 원하는 작업이 실행되도록 한다.

指定したスケジュールに従ってプログラムを実行する機能をスケジューラーと言います。毎日何時、毎月何日、1時間に一定間隔で何回、といった設定で、狙った時間に狙った作業を実行できます。

라라벨에서는 리눅스 cron을 기반의 스케쥴러를 제공하며, `app/Console/Kernel.php` 파일에 '아티산 콘솔'[^1]을 추가하여 리눅스 크론이 아티산 콘솔의 php 코드를 실행하도록 한다.

LaravelではLinuxのcronをベースにしたスケジューラーを提供しており、`app/Console/Kernel.php` に「Artisanコンソール」[^1] を追加して、Linux cronがArtisanコンソールのPHPコードを実行するようにします。

#### 스케쥴러 코드의 예 [^2]
#### スケジューラーのコード例 [^2]

```php
namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;

final class Kernel extends ConsoleKernel
{
    protected function schedule(Schedule $schedule): void
    {
        $schedule->command('billing:dispatch-issue-invoices')
            ->dailyAt('01:00')
            ->withoutOverlapping(30)
            ->onOneServer();
    }
}
```

- `->dailyAt('01:00')` : 매일 01:00에 인보이스 발행 Job들을 큐에 적재
- `->dailyAt('01:00')` : 毎日01:00に請求書発行のJobをキューに積む
- `->withoutOverlapping(30)`: 한 서버에서 크론 작업을 중첩하여 실행되는 것을 방지한다. (최대 30분 락을 건 코드)
- `->withoutOverlapping(30)`: 同一サーバーでcronジョブが重複実行されるのを防ぐ（最大30分ロック）
- `->onOneServer()`: 복수의 배치 서버에서 동일한 스케쥴러를 중복으로 실행하는 것을 방지 (레디스와 같은 캐시 드라이버가 요구된다.)
- `->onOneServer()`: 複数のバッチサーバーで同じスケジューラーが重複実行されるのを防ぐ（Redisなどのキャッシュドライバが必要です）

### 큐(Queue)란?
### キュー（Queue）とは？

큐는 선입 선출의 구조를 가진 자료구조를 의미한다. 바구니에 서로 다른 색의 공을 넣고 먼저 들어간 색의 공을 먼저 꺼내는 것과 같다.

キューは先入れ先出しの構造を持つデータ構造です。カゴに色の違うボールを入れて、先に入れた色のボールを先に取り出すようなイメージです。

웹 프로그래밍에서 보통 큐라고 하는 것은 어떤 처리 로직을 적재한 뒤 순차적으로 실행하는 것을 의미한다. (설정에 따라 순서를 보장하지 않을 수도 있다.)

Webプログラミングで一般に「キュー」と言う場合、ある処理ロジックを積んでおいて、順番に実行することを指します（設定によって順序を保証しない場合もあります）。

라라벨에서 큐는 데이터베이스 등의 저장소에 시리얼라이징된 잡 데이터를 저장한 후, 저장된 순서에 따라 잡 데이터를 디시리얼라이징하여 실행하는 과정을 의미한다.

Laravelのキューは、データベースなどの保存先にシリアライズされたジョブデータを保存し、保存された順にジョブデータをデシリアライズして実行する流れを指します。

이 때 큐에 하나씩 넣고 꺼내는 시리얼라이징된 잡 데이터를 페이로드라고 부른다.

このとき、キューに1つずつ入れて取り出すシリアライズ済みのジョブデータを「ペイロード」と呼びます。

### 잡(Job)이란?
### ジョブ（Job）とは？

잡은 큐에 적재할 수 있는 코드 단위이며, 라라벨에서는 잡 클래스에 실행할 코드를 정의한다.

ジョブはキューに積める処理単位で、Laravelではジョブクラスに実行するコードを定義します。

잡을 디스패치하면 큐 저장소에 잡 객체의 정보가 저장되며 이를 페이로드라고 한다. 큐의 페이로드로 잡 객체를 복원할 수 있다. 큐에 저장하기 전에 잡 객체의 프로퍼티에 설정된 값을 저장하고 실행할 수 있는 잡 객체로 복원할 수 있다.

ジョブをディスパッチすると、キューの保存先にジョブオブジェクトの情報が保存され、これをペイロードと呼びます。キューのペイロードからジョブオブジェクトを復元できます。キューに保存する前にジョブオブジェクトのプロパティに設定した値も含めて、実行可能なジョブとして復元できます。

### Artisan Command란?
### Artisan Commandとは？

라라벨에서 `php artisan CustomCommand`로 커멘드 라인 명령어로 실행할 수 명령어를 만들 수 있는 기능이다.

Laravelでは `php artisan CustomCommand` のように、コマンドラインから実行できる命令を作れます。

스케줄러(`app/Console/Kernel.php`)에 아티산 커멘드를 등록하면 지정한 시간에 아티산 커멘드가 실행된다.

スケジューラー（`app/Console/Kernel.php`）にArtisanコマンドを登録すると、指定した時間にそのコマンドが実行されます。

스케줄러로 사용되는 것 뿐만 아니라, 배치 처리가 실패한 후, 수정 코드를 디플로이 했지만, 스케쥴러에 의한 실행 시점을 지났을 때, 서버의 커멘드 라인을 통해서 직접 배치를 실행하는 용도로도 사용할 수 있다.

スケジューラー用途だけでなく、バッチ処理が失敗したあとに修正コードをデプロイしたものの、スケジューラーの実行タイミングを過ぎてしまった場合に、サーバーのコマンドラインから手動でバッチを実行する用途にも使えます。

## 배치 처리를 생각하기 위한 사전 지식
## バッチ処理を考えるための前提知識

### 잡(Job)
### ジョブ（Job）

라라벨 프레임워크에서 배치처리를 깔끔하게 구현하는 방법에 대해 생각해 보자.

Laravelフレームワークでバッチ処理をきれいに実装する方法を考えてみます。

#### 잡(Job)의 특징
#### ジョブの特徴

라라벨에서 job이란 큐에서 하나의 데이터를 꺼내어 실행할 코드 실행 단위를 뜻한다. 이 단위 코드는 시리얼라이징 되어 디비와 같은 저장소에 저장되며 워커(worker)라는 프로세스에 의해 저장된 순서대로 디시리얼라이징 된 코드를 실행한다.

LaravelのJobは、キューから1つのデータを取り出して実行する処理単位です。このデータはシリアライズされてDBなどの保存先に格納され、ワーカー（worker）プロセスが順番に取り出してデシリアライズし、実行します。

#### 잡의 실패
#### ジョブの失敗

잡 코드를 실행하는 도중에 예외 또는 에러가 적절히 처리되지 않으면 실행되고 있는 잡은 중단되며 실패한 잡으로 취급된다. 만약 잡이 성공적으로 실행된다면 저장소에서 제거된다.

ジョブの実行中に例外やエラーが適切に処理されないと、実行中のジョブは中断され、失敗したジョブとして扱われます。ジョブが成功すれば保存先から削除されます。

실패한 잡은 리트라이 가능하며 리트라이 카운트가 1 증가한 동일한 테스크의 잡을 새로 큐에 추가하고 실패한 잡은 삭제한다. 이 과정을 지정한 리트라이 횟수만큼 반복했음에도 실패한 잡은 큐에서 제거되고 별도의 장소 (라라벨 디폴트는 failed_jobs 테이블)에 저장한다. 잡의 테스크가 정상적으로 동작하면 완료 후 큐에서 제거된다.

失敗したジョブはリトライ可能で、リトライするとリトライ回数が1増えた同一タスクのジョブが新たにキューへ追加され、失敗したジョブは削除されます。この流れを指定回数リトライしても失敗する場合、ジョブはキューから外れて別の場所（Laravelデフォルトではfailed_jobsテーブル）に保存されます。タスクが正常に動作すれば完了後にキューから削除されます。

잡의 테스크를 처리 중에 실패하면, 다시 재실행 할 수 있어야 하기 때문에 잡을 실행하기 전 상태로 되돌아가야 한다. 이를 위해서 한 단위의 잡은 트랜잭션으로 묶어서 처리하는 편이 좋다.

ジョブのタスクが失敗した場合、再実行できるように「ジョブ実行前の状態」に戻せる必要があります。そのため、ジョブはトランザクション単位でまとめて処理するほうがよいです。

라라벨 큐의 리트라이는 설정에 따라 일시적인 장애가 해소되지 않은 시점에 다시 실행될 정도로 촘촘해질 수 있기 때문에 동일한 테스크를 스케쥴러를 활용해 몇 분 및 몇 시간 정도의 간격으로 재실행하는 편이 좋다.

Laravelキューのリトライは、設定によっては一時障害が解消する前に再実行されるほど間隔が短くなることがあります。その場合は、同じタスクをスケジューラーで数分〜数時間間隔で再実行するほうが運用しやすいこともあります。

#### 작은 로직 만들기
#### 小さなロジックにする

트랜잭션은 데이터베이스의 자원을 점유한다. 긴 트랜잭션이 많아지면 데이터베이스의 자원을 많이 점유하여 성능 저하 및 다른 처리의 타임 아웃을 유발한다. 하나의 잡을 실행할 때 로직이 많아지면 트랜잭션 처리에도 오랜 시간이 걸릴 수 있다. 가능한 잡은 짧은 트랜잭션 단위로 사용하는 것이 좋다.

トランザクションはデータベースのリソースを占有します。長いトランザクションが増えるとDBリソースを多く使い、性能低下や他処理のタイムアウトにつながります。ジョブ内のロジックが多いほどトランザクションも長くなるので、できるだけ短いトランザクション単位でジョブを作るのがよいです。

작은 로직은 트랜잭션 시간을 줄일 수 있기 때문에 롤백과 커밋에 대한 부담감을 줄인다. 처리에 대한 커밋의 단위가 작다면 실패한 단위에 대해서만 실패 이유를 개선 한 후 재처리하기도 쉽다.

ロジックを小さくするとトランザクション時間を短縮でき、ロールバックやコミットの負担を減らせます。コミット単位が小さければ、失敗した部分だけ原因を直して再処理しやすい、というメリットもあります。

#### 잡(Job)에 상태 부여하기
#### ジョブに状態を持たせる

라라벨에서 잡은 기본적으로 잡 클래스를 객체화하여 객체의 시리얼라이징 데이터를 저장소에 저장한다. 객체로서 저장되기 때문에 객체에 상태를 부여할 수 있고 객체의 프로퍼티에 잡이 동작할 옵션을 저장할 수 있다. 동일한 클래스 기반의 잡이라도 객체에 지정한 프로퍼티에 따라 정의된 로직의 분기 처리에 따라 다양한 동작의 잡을 실행할 수 있다.

LaravelのJobは、ジョブクラスをオブジェクト化し、そのシリアライズデータを保存先に格納します。オブジェクトとして保存されるため状態を持てて、プロパティにジョブの動作オプションを入れられます。同じクラスのジョブでも、プロパティの値により分岐して様々な動作が可能です。

상품 구매자에 대한 배치 처리를 예로 들어 보자. 예를 들어 “특정 년월(processYearMonth)의 주문 데이터를 집계하는 배치”의 흐름은 대략 다음과 같다.

商品購入者に対するバッチ処理を例に考えてみます。たとえば「特定の年⽉（processYearMonth）の注文データを集計するバッチ」の大まかな流れは次の通りです。

- 집계 대상이 되는 유저를 선택한다.
- 集計対象となるユーザーを選定する
- 유저의 주문 데이터가 집계 대상 조건을 만족하는지(유효한지) 확인한다.
- ユーザーの注文データが集計対象条件を満たすか（有効か）を確認する
- 지정한 년월(processYearMonth)에 대한 집계가 이미 완료되었는지 확인한다(중복 처리 방지).
- 指定した年⽉（processYearMonth）に対する集計がすでに完了しているか確認する（重複処理防止）
- 결제 방식 / 배송 방식 / 회원 등급 / 프로모션 적용 여부에 따라 집계 방식이나 포함 범위 등 세부 처리를 달리한다.
- 決済方法／配送方法／会員ランク／プロモーション適用有無に応じて、集計方法や対象範囲などの詳細処理を変える
- 처리가 끝나면 “처리 완료” 상태를 남긴다. 이때 스케줄러에 의한 실행인지, 유저 요청(수동 실행)에 의한 실행인지도 함께 기록한다.
- 処理が終わったら「処理完了」状態を残す。このとき、スケジューラーによる実行か、ユーザー要求（手動実行）による実行かも併せて記録する
- 배치 처리 완료 후 통지 여부를 결정한다. 예를 들어 관리자가 수동으로 실행한 배치는 메일 통지를 생략하고, 스케줄러에 의한 정기 배치는 완료 결과를 메일로 통지한다.
- バッチ処理完了後に通知するかどうかを決める。たとえば管理者が手動実行したバッチではメール通知を省略し、スケジューラーによる定期実行では完了結果をメール通知する

이럴 때 Laravel의 Job은 객체로 큐에 적재(디스패치)되므로, 잡 객체에 `userId`뿐 아니라 `processYearMonth`, `sendMailNotification`, `executionMode` 같은 상태(옵션)를 필요에 따라 포함해 디스패치할 수 있다. 이러한 옵션은 잡을 디스패치하는 시점에서 정해지는 의도(처리 대상 기간, 실행 트리거, 통지 정책 등)에 따라 결정된다.

このときLaravelのJobはオブジェクトとしてキューに積まれる（ディスパッチされる）ので、Jobオブジェクトに `userId` だけでなく、`processYearMonth`、`sendMailNotification`、`executionMode` といった状態（オプション）も必要に応じて含めてディスパッチできます。これらのオプションは、ジョブをディスパッチする時点で定まる意図（処理対象期間、実行トリガー、通知ポリシーなど）に応じて決定されます。

예를 들어 스케줄러에 의해 자동 실행되는 정기 배치라면 `executionMode=OrderAggregateMode::Scheduled`로 디스패치하고, 관리자가 콘솔에서 수동으로 실행하는 배치라면 `executionMode=OrderAggregateMode::Manual`로 디스패치할 수 있다. 또한 잘못된 배치 작업을 복구할 때는 `executionMode=OrderAggregateMode::Recovery`로 디스패치한 뒤, 필요하다면 `sendMailNotification=false`로 메일 통지를 비활성화하는 등의 설정을 할 수 있다.

たとえばスケジューラーによって自動実行される定期バッチであれば `executionMode=OrderAggregateMode::Scheduled` としてディスパッチし、管理者がコンソールから手動実行するバッチであれば `executionMode=OrderAggregateMode::Manual` としてディスパッチできます。また、誤ったバッチ処理を復旧する場合には `executionMode=OrderAggregateMode::Recovery` としてディスパッチしたうえで、必要に応じて `sendMailNotification=false` によりメール通知を無効化する、といった設定もできます。

반대로 잡 실행 시점에 DB 조회 등으로 결정할 수 있는 값은 굳이 페이로드로 전달하지 않고, 실행 시점의 최신 상태를 조회해 분기하는 편이 좋다. 위 예에서 결제 방식 / 배송 방식 / 회원 등급 / 프로모션 적용 여부가 이에 해당한다.

一方で、ジョブ実行時点にDB参照などで決定できる値は、あえてペイロードとして渡さず、実行時点の最新状態を参照して分岐するほうがよいです。上の例では、決済方法／配送方法／会員ランク／プロモーション適用有無がこれに該当します。

#### 설계상의 주의점
#### 設計上の注意点

잡에 상태를 전달할 때는, 유저 아이디처럼 식별에 필요한 값이나 현재 정보만으로는 특정할 수 없는 과거의 특정 시점을 나타내는 값 등, 큐에서 잡을 꺼내 실행할 때 스스로 결정할 수 없는 데이터 위주로 상태 정보를 최소화하는 것이 좋다.

ジョブに状態を渡す場合は、対象ユーザーを特定するためのユーザーIDのような識別子や、現在の情報だけでは特定できない過去の特定時点を表す値など、キューからジョブを取り出して実行する段階では自力で決められないデータを中心に、状態情報を最小化するのがよいです。

왜냐하면 실행 시점에 DB 조회 등으로 결정할 수 있는 분기 조건까지 디스패치 시점에 전달하면, 페이로드에 저장되는 상태 정보가 불필요하게 커져 저장/전송 비용과 디시리얼라이징 오버헤드로 이어질 가능성이 있기 때문이다.

なぜなら、実行時点にDB参照などで決められる分岐条件までディスパッチ時点で渡してしまうと、ペイロードに保存される状態情報が不必要に大きくなり、保存／転送コストやデシリアライズのオーバーヘッドにつながる可能性があるためです。

### 워커
### ワーカー

라라벨의 큐는 워커라는 프로세스에 의해서 실행되는데, 로컬 환경에서는 하나의 잡의 처리를 하나의 프로세스가 실행하여 코드 변경을 즉각 반영할 수 있는 `php artisan queue:listen`을 사용하여 실행할 수 있고, 프로덕션 환경에서는 프로세스가 죽으면 다시 살려주는 리눅스 기반 supervisor를 또는 도커 CMD를 통해 `php artisan queue:work`, `php artisan queue:listen` 명령으로 실행된다.

Laravelのキューはワーカーというプロセスによって実行されます。ローカル環境では、ジョブごとにプロセスを起動してコード変更を即時反映しやすい `php artisan queue:listen` で動かせます。プロダクション環境では、プロセスが落ちたら復帰させるLinuxのsupervisor、またはDockerのCMDで `php artisan queue:work` / `php artisan queue:listen` を実行して動かします。

큐에서 잡을 꺼내어 처리하는 과정에서 문제가 발생해서 워커 프로세스가 죽더라도 다시 살려내는 supervisor를 이용해서 워커를 실행을 하거나, 컨테이너의 PID 1의 작업이 종료 되었을 때 도커가 재시작 될 수 있도록 도커 CMD에 `php artisan queue:work` 명령을 주어 워커를 동작시키도록 하자. [^3]

キューからジョブを取り出して処理する際に問題が起きてワーカーが落ちても復帰できるように、supervisorでワーカーを動かすか、コンテナのPID 1が終了したらDockerが再起動できるようにCMDで `php artisan queue:work` を実行してワーカーを動かすのがよいです。[^3]

### 워커의 옵션 설계
### ワーカーのオプション設計

php는 php 엔진이 php 파서를 실행하고 종료하는 방식으로 동작하는데 특화되어 있다. 웹의 리퀘스트를 처리하여 리스폰스를 응답하고 프로세스를 종료하는 라이프 사이클이 끝나면, 실행 과정에서 메모리에 등록된 데이터를 모두 지우는 방식으로 동작한다. 이 방법의 장점은 다음과 같다.

PHPは、PHPエンジンがPHPパーサーを起動して実行し、終了する、という動きに向いています。Webリクエストを処理してレスポンスを返し、プロセスが終了するライフサイクルが終わると、実行中にメモリに載っていたデータはすべて破棄されます。この方式のメリットは次の通りです。

- 프로세스와 프로세스 사이의 메모리 공유가 없기 때문에, 독립적으로 실행되는 두 프로세스 간의 영향을 최소화 할 수 있어, 의도한 대로 동작하는 것을 기대하기 좋다.
- プロセス間でメモリを共有しないため、独立に動くプロセス同士の影響を最小化でき、意図通りに動くことを期待しやすい
- 프로세스의 종료에 따라 의도치 않은 불필요한 메모리 점유를 방지할 수 있어서 장기 서비스 제공에 안정성을 준다.
- プロセス終了により不要なメモリ占有を避けられ、長期運用の安定性が上がる
- 코드를 작성할 때 메모리 점유를 덜 신경써도 된다는 이점이 있다.
- コードを書くときにメモリ占有をそこまで気にしなくてよい

하나의 php 프로세스는 장기 코드 실행 보다는 한 번에 실행되어야 하는 최소한의 단위 코드를 여러 번 실행하는 편이 안정적이다. 하나의 프로세스의 실행 시간이 길어지면 php 코드가 실행될 때 발생할 수 있는 메모리 누수로 어느 시점 프로세스가 강제 종료되어 진행중인 작업의 무결성을 잃을 수 있기 때문이다. [^4]

1つのPHPプロセスは、長時間動かすよりも、短い単位の処理を何度も実行するほうが安定しやすいです。実行時間が長くなると、PHPコード実行時のメモリリークによって、ある時点でプロセスが強制終了され、進行中作業の整合性を失う可能性があるためです。[^4]

큐에 적재된 순서대로 잡을 처리하면서 하나의 잡을 처리할 때 하나의 프로세스만 사용하는 워커를 라라벨에서는 `php artisan queue:listen`로 사용할 수 있다. 하나의 잡이 실행되고 잡을 실행하는 자식 프로세스가 종료되기 때문에 부모 프로세스인 워커가 여러 잡을 처리해도 메모리 리셋이 이뤄지므로 메모리 누수 문제를 근본적으로 해결한다.

キューに積まれた順にジョブを処理しつつ、ジョブごとに子プロセスを起動して実行するワーカーは、Laravelでは `php artisan queue:listen` で動かせます。ジョブ実行後に子プロセスが終了するため、親プロセスのワーカーが複数ジョブを処理してもメモリがリセットされ、メモリリーク問題を根本的に避けられます。

하지만 `listen` 방식은 각각의 잡을 실행할 때 라라벨의 프레임워크를 기동시키므로 속도가 느리다는 단점이 있다. 이를 위해서 워커 프로세스가 여러 잡을 처리하되 특정 메모리 사용량을 초과하면 다음 잡을 처리하지 않고 종료 시키는 `php artisan queue:work --memory=256`, 작업을 일정횟수 반복 후 워커를 종료시키는 `php artisan queue:work --max-jobs=1000`, `php artisan queue:work --max-time=3600` 등으로 메모리 문제를 미연에 방지하는 전략을 함께 사용한다.

ただし `listen` はジョブごとにLaravelフレームワークを起動するため遅い、というデメリットがあります。そこで、`php artisan queue:work --memory=256` のようにメモリ使用量が一定を超えたら終了させたり、`php artisan queue:work --max-jobs=1000` や `php artisan queue:work --max-time=3600` のように一定回数／一定時間で終了させたりして、メモリ問題を事前に防ぐ戦略も併用します。

#### 싱글 워커와 멀티 워커
#### シングルワーカーとマルチワーカー

큐는 선입 선출의 순서로 잡을 처리한다. 하나의 잡이 완료된 이후 다음 잡을 처리하기 위해서는 하나의 큐는 하나의 워커로 동작시켜야 한다.

キューは先入れ先出しの順でジョブを処理します。1つのジョブが完了してから次のジョブを処理するためには、1つのキューは1つのワーカーで動かす必要があります。

하나의 큐를 (하나의 디비 테이블에 저장된 시리얼라이징 된 잡 리스트) 여러 워커로 처리할 수 있는데, 이 때 적재된 작업이 A, B, C, D, E, F라고 할 때 3개씩 처리되면 A, B, C가 세개의 워커 각각에 할당되고, A는 처리 되고 B, C가 처리되지 않았을 때 D가 A를 처리한 워커에서 처리하며 D가 처리 완료될 때까지 B가 처리 되지 않았다면 A->C->D->B ...의 순서로 순차적인 처리가 이뤄지지 않을 수 있다.

1つのキュー（DBテーブルに保存されたシリアライズ済みジョブ一覧）を複数ワーカーで処理できますが、このときキューに A, B, C, D, E, F が積まれていて3並列で処理すると、A, B, C が各ワーカーに割り当てられます。Aが先に終わってB, Cが終わっていない場合、Aを処理したワーカーがDを処理します。もしDが終わるまでBが終わらなければ、A→C→D→B... のように順序通りに処理されない場合があります。

작업의 순서가 중요한 경우 하나의 큐에는 싱글 워커를 할당하고, 작업의 순서를 고려하지 않아도 되는 경우 멀티 워커를 통해 빠르게 처리하도록 한다.

順序が重要な作業は1つのキューにシングルワーカーを割り当て、順序を気にしなくてよい作業はマルチワーカーで高速に処理します。

라라벨의 Job Chaining을 사용하면 멀티 워커 환경에서도 특정 잡의 흐름을 순차적으로 처리할 수 있다. 하지만 체인 기능을 구성하려면 동일한 대상에 대해 역할이 다른 여러 잡을 쪼개고 연결하는 설계가 필요해 복잡성이 올라갈 수 있다. 방대한 처리가 필요하지 않다면 다른 책임을 가진 잡을 서로 다른 시간에 스케줄러로 실행하는 방식이 문제가 발행했을 때 단계별로 원인 파악과 대응을 하기에 좋다.

LaravelのJob Chainingを使うと、マルチワーカー環境でも特定のジョブの処理フローを順番に実行できます。ですが、チェーン機能を組むには、同じ対象に対して役割の異なる複数のジョブを分割してつなげる設計が必要になり、複雑さが増えることがあります。大規模な処理が不要であれば、異なる責務を持つジョブを異なる時間にスケジューラーで実行する方法のほうが、問題が発生したときに段階ごとに原因を把握して対応しやすいです。

## 스프링 배치와 php 배치의 전략 차이
## Spring BatchとPHPバッチの戦略の違い

일반적으로 배치 처리의 표준은 자바 스프링 프레임워크의 스프링 배치이다. php가 작은 단위의 잡을 통해서 배치 처리를 실행하는 전략을 주로 채용하는 것과 달리, 스프링 배치는 방대한 양의 데이터를 처리하는 것에 초점을 맞추고 있다.

一般にバッチ処理の標準として語られることが多いのが、Java SpringのSpring Batchです。PHPが小さな単位のジョブでバッチ処理を進める戦略を取りやすいのに対し、Spring Batchは大量データの処理に重点があります。

저장소에서 처리할 수 있는 만큼의 데이터 묶음 (청크)을 배치 애플리케이션에 가져온 뒤, 그 뒤로는 가능한 속도 저하를 초래하는 외부 연결을 최소화하고 컴파일 언어의 연산 성능을 최대한 이용하여 한 번에 방대한 결과를 생성한 뒤, 결과를 청크 단위로 트랜잭션하여 저장하는 방식으로 구성된다.

保存先から処理可能な量のデータ塊（チャンク）をバッチアプリに取り込み、その後は速度低下につながる外部接続をできるだけ減らし、コンパイル言語の計算性能を最大限使って一気に大量の結果を作り、結果をチャンク単位でトランザクションしながら保存する、という構成になっています。

php에서도 스프링 배치와 같은 대량 처리 방식을 사용할 수 있다. 하지만 php는 상대적으로 컴퓨팅 리소스 효율이 낮은 인터프리터 언어이기 때문에 초거대 스케일의 배치처리 보다는 비즈니스 흐름을 정확하게 드러낼 수 있는 로직을 만드는 것이 적합한 경우가 많다.

PHPでもSpring Batchのような大量処理はできます。ただしPHPはインタプリタ言語で、相対的に計算リソース効率が低いので、超巨大スケールのバッチよりも、ビジネスの流れを正確に表現できるロジックを作るほうが向くことが多いです。

대부분의 php 프로젝트는 배치 결과물을 생성할 때 컴퓨팅 성능을 최대한 활용하기 위해, 한 번에 처리에 필요한 모든 데이터를 대략으로 가져오고 대략의 처리 결과를 저장할 수 있는 단위로 청크 처리를 만드는 전략은 어울리지 않는 경우가 많다.

多くのPHPプロジェクトでは、計算性能を最大限活かすために、必要なデータを一度に大量に取り込み、大量の結果をまとめて保存できる単位でチャンク処理を作る戦略は、あまり合わないことがあります。

비즈니스 흐름을 잘 드러낼 수 있는 로직을 구성하며 로직의 흐름의 단계에 맞게 애플리케이션 외부에서 데이터를 가져오는 로직을 만드는 편이 좋다. I/O 처리로 속도 저하가 일어나더라도 메인터넌스를 고려한 코드를 만든다.

ビジネスの流れが分かりやすいロジックを組み、ステップに合わせてアプリケーション外部からデータを取り込むようにするのがよいです。I/Oによる速度低下があっても、メンテナンス性を考えたコードを優先します。

스프링 배치에서도 read - process - write 구조를 따르더라도, process 단계에서 비즈니스 로직의 흐름에 맞춘 I/O 처리가 들어가는 배치 케이스도 많다. 이는 스프링 배치가 제공하는 기본 구조 안에서, 프로젝트의 요구사항에 맞게 구현 방식이 달라지기 때문이다.

Spring Batchでも、read - process - write の構造に沿っていても、process段階でビジネスロジックの流れに合わせたI/O処理が入るバッチケースは多いです。これは、Spring Batchが提供する基本構造の中で、プロジェクトの要件に応じて実装方法が変わるためです。

## 프레임워크 내에서의 구조
## フレームワーク内での構造

라라벨에서는 큐, 잡, 스케줄러, 아티산 커멘드라는 기능을 제공할 뿐 공식적인 배치 처리 전략이 없다.

Laravelはキュー、ジョブ、スケジューラー、Artisanコマンドといった機能を提供しますが、公式のバッチ処理戦略はありません。

앞서 논의한 점들을 고려해서 php에 적합한 배치처리 전략을 구성하기 위해서 배치 유닛, 잡 클래스, 잡 트리거, 아티산 커멘드라는 개념으로 나누어 배치 처리를 구성해 보았다.

ここまでの内容を踏まえ、PHPに合うバッチ処理戦略として「バッチユニット」「ジョブクラス」「ジョブトリガー」「Artisanコマンド」という概念に分けて構成してみます。

### 배치 유닛 (`Batches/Units/*`)
### バッチユニット（`Batches/Units/*`）

- 잡 클래스에서 배치 유닛 객체를 가져와 실행하는 용도로 사용된다.
- ジョブクラスからバッチユニットのオブジェクトを取得して実行するために使います。
- 배치 유닛은 한 단위의 잡을 처리하기 위한 코드를 정의한 부분이다.
- バッチユニットは、1つのジョブを処理するためのコードを定義する部分です。
- 한 단위의 잡을 정의하는 용도이기 때문에 하나의 배치 유닛 클래스의 실행은 실패 시 초기 상태로 돌아갈 수 있는 트랜잭션 단위로 만든다.
- 1つのジョブを定義する用途なので、バッチユニットクラスの実行は、失敗時に初期状態へ戻せるトランザクション単位で作ります。

#### 배치 유닛 도입의 이점
#### バッチユニット導入のメリット

잡 클래스에 모든 것을 정의하지 않고 배치 유닛을 별도로 만들어 잡 클래스에 가져와 사용하는 이유는 유사한 로직이 배치 처리 뿐만 아니라 유저와의 상호 작용에 따라 실행하는 경우도 있기 때문이다.

ジョブクラスにすべてを書かず、バッチユニットを別に用意してジョブから呼ぶ理由は、似たロジックがバッチ処理だけでなく、ユーザーとの相互作用で実行する場合にも使えるからです。

하나의 유닛은 배치 처리를 위해 잡(Job)에서 쓰이기도 하고, 유저 인터렉션을 담당하는 서비스 레이어 또는 컨트롤러(또는 유즈케이스)에서 불러다 쓸 수도 있다. 이 때문에 유닛을 따로 분리하여 재사용성을 높이는 방식으로 코드를 짜는 편이 좋다.

1つのユニットは、バッチ処理用にJobから使うこともできますし、ユーザーインタラクションを担当するサービスレイヤーやコントローラ（またはユースケース）から呼ぶこともできます。このためユニットを分離して再利用性を上げるほうがよいです。

이렇게 코드를 만들면 특정 배치처리가 어떤 조건 미달로 실패했을 때, 사용자 측에서 직접 재실행 할 수 있는 기능을 제공하기도 쉽다.

こうしておくと、あるバッチ処理が条件不足で失敗した場合に、ユーザー側で再実行する機能を提供しやすくなります。

잡은 비동기로 디스패치 되기 때문에 테스트가 어렵지만, 상세 로직을 배치 유닛이란 클래스로 옮기면 단순 객체가 되어 테스트 코드를 작성하기도 쉽다.

ジョブは非同期でディスパッチされるのでテストが難しいですが、詳細ロジックをバッチユニットへ移すと単純なオブジェクトになり、テストコードも書きやすくなります。

#### 배치 유닛의 예 [^5]
#### バッチユニットの例 [^5]

```php
namespace App\Batches\Units\Billing;

use App\Models\Invoice;
use App\Models\Subscription;
use Illuminate\Support\Facades\DB;

final class IssueInvoiceUnit
{
    public function run(int $subscriptionId, string $billingDate): void
    {
        DB::transaction(function () use ($subscriptionId, $billingDate) {
            $subscription = Subscription::query()
                ->whereKey($subscriptionId)
                ->lockForUpdate()
                ->firstOrFail();

            $alreadyIssued = Invoice::query()
                ->where('subscription_id', $subscription->id)
                ->where('billing_date', $billingDate)
                ->exists();

            if ($alreadyIssued) {
                return;
            }

            Invoice::query()->create([
                'subscription_id' => $subscription->id,
                'billing_date' => $billingDate,
                'amount' => $subscription->monthly_fee,
                'status' => 'issued',
            ]);
        });
    }
}
```

### 잡 클래스 (`Job/*`)
### ジョブクラス（`Job/*`）

잡 클래스는 `Batches/Job/*`에 정의하고 싶지만, 라라벨의 제약으로 인해서 `Job/*` 폴더에 잡 클래스를 정의해야 큐에 적재할 수 있기 때문에 기존의 폴더 위치를 그대로 사용한다. [^6]

ジョブクラスは `Batches/Job/*` に置きたいのですが、Laravelの制約で `Job/*` 配下に置かないとキューに積めないため、既存の配置をそのまま使います。[^6]

잡은 데이터베이스와 같은 저장소에 시리얼라이징 된 잡 객체를 저장하고 저장한 순서대로 디시리얼라이징하여 잡 로직을 큐에 적재된 순으로 실행하게 하기 위한 코드를 작성하는 부분이다.

ジョブは、データベースのような保存先にシリアライズ済みのジョブオブジェクトを保存し、保存順にデシリアライズして、キューに積まれた順でジョブロジックを実行するためのコードです。

처리에 관한 상세한 로직은 배치 유닛에 정의하며 배치 유닛을 가져와 잡이라는 코드 베이스에서 실행하기 위한 용도로 사용한다.

処理の詳細ロジックはバッチユニットに定義し、ジョブはそれを呼び出して実行するために使います。

#### 성능 팁

DB와의 통신 횟수가 많아질수록 처리 시간이 길어질 수 있다. 이를 줄이기 위해 잡 클래스는 여러 개의 ID를 배열로 전달받아 여러 유닛을 한 번에 처리하도록 설계할 수도 있다.

DBとの通信回数が増えるほど、処理時間が長くなる可能性があります。これを抑えるために、ジョブクラスは複数のIDを配列として受け取り、複数ユニットの処理をまとめて実行するように設計することもできます。

다만 여기서 다루는 작업은 비즈니스 로직 단위의 처리이므로, 디비 통신 외에도 애플리케이션 로직이 함께 수행되어 트랜잭션이 길어질 수 있다. 따라서 많은 유닛을 한 잡에서 한꺼번에 처리하기보다는, 소수의 유닛만 하나의 트랜잭션으로 묶는 방식으로 디비 통신 지연을 줄이면서도 트랜잭션을 짧게 유지해 성능을 조절하는 것이 좋다.

ただし、ここで扱うのはビジネスロジック単位の処理であり、DB通信だけでなくアプリケーション側のロジックもあわせて実行されるため、トランザクションが長くなりやすい点には注意が必要です。そのため、多くのユニットを1つのジョブで一度に処理するのではなく、少数のユニットのみを1つのトランザクションにまとめることで、DB通信の遅延を抑えつつトランザクションを短く保ち、パフォーマンスを調整するのがよいです。

#### 잡 클래스의 예 [^7]
#### ジョブクラスの例 [^7]

```php
namespace App\Jobs\Billing;

use App\Batches\Units\Billing\IssueInvoiceUnit;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

final class IssueInvoiceJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        public readonly int $subscriptionId,
        public readonly string $billingDate,
    ) {}

    public function handle(IssueInvoiceUnit $unit): void
    {
        $unit->run(
            subscriptionId: $this->subscriptionId,
            billingDate: $this->billingDate,
        );
    }
}
```

### 잡 트리거 (`Batches/JobTriggers/*`)
### ジョブトリガー（`Batches/JobTriggers/*`）

잡을 실행하기 위한 대상 리스트를 뽑아 리스트의 각각 대상의 정보로 잡에 옵션을 주어 디스패치(큐에 적재)하는 목적으로 정의한다.

ジョブを実行する対象リストを取得し、対象ごとの情報をオプションとしてジョブに渡しながらディスパッチ（キューに積む）するために定義します。

잡을 디스패치 할 때, 디스패치 옵션을 통해서 잡 객체에 상태를 부여하고, 잡은 배치 유닛에 이 옵션을 전달하여 옵션에 맞는 분기 처리를 수행한다.

ジョブをディスパッチするとき、ディスパッチオプションによりジョブオブジェクトに状態を持たせられます。ジョブはそのオプションをバッチユニットへ渡し、条件に応じて分岐処理を行います。

배치 유닛은 잡을 통해서만 큐에 등록될 수 있다. 잡 트리거는 여러 대상을 뽑아 각 대상의 정보를 잡 유닛에게 전달하여 배치 처리를 실행하는데, 큐에 적재하기 위해서 배치 유닛을 직접 실행하지 않고 잡을 디스패치하는 방식으로 구성된다.

バッチユニットはジョブ経由でのみキューに登録できます。ジョブトリガーは複数対象を抽出して、対象ごとの情報をジョブへ渡しながらバッチ処理を進めます。キューに積むために、バッチユニットを直接実行せずジョブをディスパッチする構成にします。

#### 설계상의 주의점
#### 設計上の注意点

배치 처리가 중간에 멈추었을 때, 처리되지 않은 남은 잡을 다시 디스패치해야 한다. 트리거에서 대상 리스트를 뽑을 때 실행이 완료된 대상인지 아닌지 구분하여 처리 대상을 선택하는 것이 중요하다.

バッチ処理が途中で止まったとき、未処理のジョブを再ディスパッチする必要があります。トリガーで対象リストを取るときに、処理済みか未処理かを区別して対象を選ぶことが重要です。

배치 처리의 완료 표기 플래그를 배치 처리 진행 상태나 결과를 남기는 테이블에 남길 수 있도록 컬럼을 추가하는 것을 고려하자.

バッチ処理の完了を示すフラグを、進行状況や結果を保存するテーブルに残せるよう、カラム追加も検討します。

재시도 끝에도 실패한 잡이 있을 수 있다. 별도의 로그와 통지를 통해서 개발자가 후속 대응 할 수 있도록 구성하자.

リトライしても失敗するジョブは出るので、ログや通知を用意して、開発者が後続対応できるようにします。

잡트리거는 기본적으로 아직 처리되지 않은 잡을 처리하기 위한 용도로 사용한다. 그러나 배치 작업의 문제가 생겼을 때의 대응을 위해, 배치 작업을 클리어하거나 리프레시할 수 있는 기능도 추가하는 편이 좋다.

ジョブトリガーは基本的に未処理ジョブを処理するために使いますが、トラブル対応のためにバッチをクリアしたりリフレッシュしたりできる機能を用意するのもよいです。

#### 멱등성 (Idempotency)
#### 冪等性 （べきとうせい、Idempotency）

멱등성이란 여러번 반복 실행을 하더라도 결과가 동일하다는 것을 뜻한다. 수식으로는 `f(f(x)) = f(x)`인데, `x`라는 상태에서 어떤 처리 `f`를 하여 `f(x)`라는 상태가 되었다고 하자. `f(x)`라는 상태에서 `f`를 처리해도 `x`란 상태에서 `f`를 한 번 처리한 결과와 같아야 한다는 의미이다.

冪等性とは、何度繰り返して実行しても結果が同じになることを指します。数式では `f(f(x)) = f(x)` で表せます。状態`x`に対して処理`f`を行い `f(x)` になったとします。このとき `f(x)` の状態でさらに `f` を実行しても、`x`の状態で一度だけfを実行した結果と同じであるべき、という意味です。

큐 기반 처리에서는 워커 장애, 재시도, 스케줄 중복 실행, 중복 디스패치 등의 실수나 장애로 인해 잡이 두 번 이상 실행될 수 있다. 예를 들어 결과 데이터가 이미 생성되었는데, 잡이 중복 실행되면서 결과 데이터를 한 번 더 생성했다고 하자. 의도대로라면 '한 번 처리한 결과'와 같아야 하지만, 실제로는 테이블에 동일한 데이터가 2개 생성되는 문제가 생긴다.

キュー処理では、ワーカー障害、リトライ、スケジュールの重複実行、重複ディスパッチといったミスや障害により、ジョブが2回以上実行されることがあります。たとえば結果データがすでに作られているのに、ジョブが重複実行されて同じ結果データをもう一度作ってしまうと、本来は「1回実行した結果」と同じであるべきところ、テーブルには同じデータが2件できてしまいます。

결과 데이터를 생성하는 잡이라면, 잡이 중복 실행되더라도 결과가 중복되지 않도록 대비하는 것이 추천된다. 대표적인 방법은 다음과 같다.

結果データを作るジョブでは、ジョブが重複実行されても結果が重複しないように備えるのがおすすめです。代表的な方法は次の通りです。

- 결과 데이터에 유니크한 식별값을 부여할 수 있다면 DB에 유니크 키를 두어 중복 생성을 차단한다.
- 結果データにユニークな識別子を付与できるなら、DBにユニークキーを置いて重複生成を防ぐ
- 잡을 실행할 때 가드 형태로 동일한 결과가 이미 존재하는지 사전 체크하고, 존재하면 실행을 건너뛴다.
- ジョブ実行時にガードとして、同じ結果がすでに存在するかを事前チェックし、存在するなら実行をスキップする

#### 잡 트리거의 예 [^8]
#### ジョブトリガーの例 [^8]

```php
namespace App\Batches\JobTriggers\Billing;

use App\Jobs\Billing\IssueInvoiceJob;
use App\Models\Subscription;

final class IssueInvoicesJobTrigger
{
    public function dispatchForDate(string $billingDate): void
    {
        Subscription::query()
            ->where('status', 'active')
            ->orderBy('id')
            ->chunkById(500, function ($subscriptions) use ($billingDate) {
                foreach ($subscriptions as $subscription) {
                    IssueInvoiceJob::dispatch(
                        subscriptionId: $subscription->id,
                        billingDate: $billingDate,
                    )->onQueue('billing');
                }
            });
    }
}
```

### 아티산 커멘드
### Artisanコマンド

잡 트리거를 배치 처리 흐름에 맞게 정의하기 위해서 사용한다.

ジョブトリガーをバッチ処理の流れに合わせて定義するために使います。

배치 처리를 실행할 시점을 정의하기 위해서는 스케쥴러에 등록을 해야 한다.

バッチ処理の実行タイミングを決めるには、スケジューラーに登録する必要があります。

스케쥴러에 등록하기 위해서는 아티산 커멘드를 통해서 실행할 수 있도록 정의가 되어야 한다.

スケジューラーに登録するには、Artisanコマンドとして実行できるように定義する必要があります。

아티산 커멘드로 정의할 때는 일괄 처리를 실행하기 위한 잡 트리거를 직접 가져다 사용한다.

Artisanコマンドを定義するときは、バッチを実行するジョブトリガーを直接呼び出します。

아티산 커멘드가 정의되었다면 스케쥴러에 언제 실행할 것인지 등록한다.

Artisanコマンドを定義したら、スケジューラーにいつ実行するかを登録します。

#### 아티산 커멘드의 예 [^9]
#### Artisanコマンドの例 [^9]

```php
namespace App\Console\Commands\Billing;

use App\Batches\JobTriggers\Billing\IssueInvoicesJobTrigger;
use Illuminate\Console\Command;

final class DispatchIssueInvoices extends Command
{
    protected $signature = 'billing:dispatch-issue-invoices {--date= : billing date (YYYY-MM-DD)}';
    protected $description = 'Dispatch invoice issuing jobs to the queue for a given billing date.';

    public function handle(IssueInvoicesJobTrigger $trigger): int
    {
        $billingDate = $this->option('date') ?: now()->toDateString();

        $trigger->dispatchForDate($billingDate);

        $this->info("Dispatched invoice issuing jobs for date={$billingDate}.");

        return Command::SUCCESS;
    }
}
```

## 전체 실행의 흐름
## 全体の実行フロー

1. 리눅스의 cron 서비스가 동작한다.
2. cron의 실행에 따라 라라벨의 스케쥴러가 동작한다.
3. 라라벨 스케쥴러에 등록된 아티산 커멘드는 특정한 타이밍에 정의된 아티산 커멘드를 실행한다.
4. 아티산 커멘드는 잡 트리거를 실행한다.
5. 잡 트리거는 다양한 상태를 갖는 배치 유닛을 큐-잡의 형태로 등록하기 위해서 다수의 잡을 큐 방식으로 저장되는 저장소에 등록한다.
6. 등록된 잡은 순차적으로 실행되면서 유닛으로 정의된 단위로 로직을 처리한다.

---

1. Linuxのcronサービスが動きます。
2. cronの実行によりLaravelのスケジューラーが動きます。
3. スケジューラーに登録されたArtisanコマンドが、指定タイミングで実行されます。
4. Artisanコマンドがジョブトリガーを実行します。
5. ジョブトリガーが、多数のジョブをキュー保存先に登録します（キュー／ジョブの形で積みます）。
6. 登録されたジョブが順に実行され、ユニット単位でロジックを処理します。

## 폴더 구조
## フォルダ構成

```
app
 |- Console
 |    |- Commands
 |         |- Batches
 |              |- Billing
 |                   |- DispatchIssueInvoices.php
 |              |- Maintenance
 |                   |- DispatchDataRepair.php
 |
 |    |- Kernel.php
 |
 |- Batches
 |    |- JobTriggers
 |    |     |- Billing
 |    |     |    |- IssueInvoicesJobTrigger.php
 |    |     |- Maintenance
 |    |          |- DataRepairJobTrigger.php
 |    |
 |    |- Units
 |          |- Billing
 |          |    |- IssueInvoiceUnit.php
 |          |- Maintenance
 |               |- RepairRecordUnit.php
 |
 |- Jobs
 |    |- Billing
 |    |    |- IssueInvoiceJob.php
 |    |- Maintenance
 |         |- RepairRecordJob.php
 |
 |- Models
      |- Subscription.php
      |- Invoice.php
      |- SomeDomainModel.php
```

## 서비스 개선
## サービス改善

현 회사에서 메인으로 담당한 프로젝트는 라라벨 스케줄러 기반으로 돌아가는 2년차 서비스였다. 기존 구조에서는 1분마다 크론이 실행되어 한 번에 단건씩 트랜잭션을 처리했는데, 전체 배치 처리 속도가 매우 느려 비개발자가 결과를 검증하기도 어려운 상황이었다.

現職でメイン担当していたプロジェクトは、Laravelスケジューラーを中心に回っている2年目のサービスでした。以前の構造では、1分ごとにcronが実行され、1回に1件ずつトランザクション処理していたため、全体のバッチ処理が非常に遅く、非エンジニアが結果を検証しづらい状況でした。

서비스 규모가 커지면서 일부 배치 작업의 완료 시간이 5\~10분까지 길어졌고, 크론이 1분마다 중첩 실행되다 보니 순간 서버에 5\~10개의 배치가 동시에 동작하여 메모리 부족 문제로 서버가 다운되는 장애가 발생했다.

サービス規模が大きくなるにつれ、一部のバッチ処理が完了するまでに5〜10分かかるようになり、cronが1分ごとに重複実行されて、瞬間的にサーバー上で5〜10個のバッチが同時に動いてメモリ不足問題でサーバーがダウンする障害が発生しました。

또한 실패한 테스크를 복구하는데도 작은 단위로 테스크를 처리하지 않았기 때문에 많은 시간이 걸렸다.

また、失敗したタスクを復旧する際も、タスクを小さな単位に分割して処理していなかったため、復旧に多くの時間がかかりました。

이 문제를 해결하기 위해, **배치 구조를 큐-잡 기반으로 전면 개선**하였다. 그 결과,

この問題を解決するため、**バッチ構造をキュー／ジョブベースに全面改善**しました。その結果、

- 일부 케이스에 대해 몇 시간이 걸리던 배치가 수십 초 내로 완료되었고, 수 시간의 대부분의 작업이 수 분, 수십 분 이내로 감소하였다.
- 一部のケースでは、数時間かかっていたバッチが数十秒で完了し、数時間かかっていた作業の多くも数分〜数十分以内に短縮されました。
- 비개발자도 배치 동작과 결과를 쉽게 검증할 수 있게 되었다.
- 非エンジニアでもバッチ動作と結果を検証しやすくなりました。
- 테스크가 순차적으로 안정되게 처리되어 메모리 사용량도 예측 가능한 범위에서 안정적으로 관리 되었다.
- タスクが順に安定して処理され、メモリ使用量も予測可能な範囲で安定して管理できるようになりました。
- 문제가 발생했을 때 작은 단위를 복구하는 과정을 단계적으로 진행하기 좋았다.
- 問題が発生したときに、小さな単位で復旧作業を段階的に進めやすかったです。
- 이후 현재까지도 특별한 장애 없이 배치 처리를 안정적으로 운영하고 있다.
- その後も現在まで、目立った障害なくバッチ処理を安定運用できています。
- 또한 배치 처리를 패턴화하여 다른 개발자들이 패턴을 따라 좋은 코드를 작성할 수 있도록 하였다.
- さらに、バッチ処理をパターン化して、他の開発者も同じ型で良いコードを書けるようにしました。

# 마지막으로
# おわりに

자바의 스프링 프레임워크와 같이 배치 처리의 구성이 잘 알려진 패턴을 따르는 경우도 있지만, 언어나 프레임워크, 사용하는 라이브러리에 따라 배치 처리의 툴의 기능이 다르기 때문에 배치 처리의 전략은 언어나 프레임워크마다 다를 수 있다. 또한 프레임워크나 라이브러리에서 명확한 가이드라인을 제공하지 않기 때문에 배치처리의 구성 방식은 서로 다를 수 있고 프로젝트의 특징에 따라 속도를 중시할지 메인터넌스를 중요시할지 등의 가치가 달라 배치 처리의 구성 방법은 달라질 수 있다.

Springのようにバッチ処理構成がよく知られたパターンに沿う場合もありますが、言語・フレームワーク・利用ライブラリによってバッチ処理のツール機能が違うため、戦略は言語やフレームワークごとに変わり得ます。また、フレームワークやライブラリが明確なガイドラインを出していないこともあり、バッチ処理の構成はプロジェクトの特徴によって変わります。たとえば、速度を重視するか、メンテナンス性を重視するか、といった価値観でも設計は変わります。

여기서 소개한 방법은 내가 담당하고 있는 프로젝트에서 지난 4년간 실무에서 별다른 문제 없이 사용해 온 패턴으로 Trigger-Job-Unit 패턴이라 명명한다.

ここで紹介した方法は、私が担当しているプロジェクトで過去4年間、実務で大きな問題なく使ってきたパターンです。ここではこれを Trigger-Job-Unit パターンと呼ぶことにします。

요약하자면, Trigger–Job–Unit 패턴은 ‘대상 선정(Trigger)–큐 실행(Job)–트랜잭션 단위 로직(Unit)’으로 책임을 분리하는 것이다.

要するに、Trigger–Job–Unitパターンは、「対象選定（Trigger）–キュー実行（Job）–トランザクション単位のロジック（Unit）」として責務を分離することです。

[^1]: 아티산 콘솔이란 라라벨의 기능을 커멘드라인 명령어로 실행할 수 있는 기능을 제공하며, 라라벨 내장의 `php artisan SomeCommand` 명령 이외의 개발자가 제작한 아티산 커멘드를 `php artisan CustomCommand`으로 실행할 수 있는 기능이다. [아티산 콘솔의 작성법](https://laravel.com/docs/12.x/artisan)은 공식 문서를 참고하자.
[^1]: Artisanコンソールは、Laravelの機能をコマンドラインから実行できる仕組みです。Laravel標準の `php artisan SomeCommand` だけでなく、開発者が作成したArtisanコマンドも `php artisan CustomCommand` として実行できます。作り方は[公式ドキュメント](https://laravel.com/docs/12.x/artisan)を参照してください。
[^2]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^2]: サンプルコードはOpenAIのChatGPT（"ChatGPT 5.2"）を参考に下書きを作成し、最終的には筆者が確認・修正しました。
[^3]: `ENTRYPOINT`를 쓰는 경우 `entrypoint.sh`라는 쉘 스크립트가 컨테이너의 PID 1로 실행된다. 이때 스크립트에서 `php artisan queue:work`를 `exec` 명령 없이 실행하면 워커가 자식 프로세스로 실행될 수 있고, 컨테이너 종료/교체 시 Docker가 PID 1인 쉘 스크립트에 전달한 SIGTERM(종료 신호)이 워커까지 전달되지 못하는 경우가 있어 워커가 정상 종료(graceful shutdown)하지 못할 수 있다. 따라서 `exec php artisan queue:work ...` 형태로 워커가 PID 1로 실행되도록 구성하는 편이 안전하다. 그렇지 않으면 마지막 잡 처리를 마무리하지 못하거나(중단), 애플리케이션 레벨 정리 로직(락 해제 등)이 실행되지 않아 Redis 락이 남는 등의 문제가 생길 수 있다.
[^3]: `ENTRYPOINT` を使う場合、`entrypoint.sh` のようなシェルスクリプトがコンテナのPID 1で動きます。このときスクリプト内で `php artisan queue:work` を `exec` なしで起動すると、ワーカーが子プロセスとして動く場合があります。コンテナ終了／入れ替え時に、DockerがPID 1へ送るSIGTERM（終了シグナル）がワーカーまで届かず、ワーカーが正常終了（graceful shutdown）できないことがあります。そのため `exec php artisan queue:work ...` のように、ワーカーがPID 1として動くように構成するほうが安全です。そうしないと最後のジョブを完了できず中断したり、アプリケーション側の後処理（ロック解除など）が走らずRedisロックが残る、といった問題が起きる可能性があります。
[^4]: 메모리 릭이 발생하지 않도록 코드를 잘 만들면 되지만, 레거시 코드, 라이브러리 및 프레임워크 사용에서 장기 실행을 고려하지 않은 코드가 있을 가능성이 높은 언어 생태계이므로 항상 메모리 릭이 발생한다는 전제로 접근하는 편이 좋다.
[^4]: メモリリークが起きないようにコードを作れれば理想ですが、レガシーコードやライブラリ、フレームワーク側の実装まで含めると、長時間実行を前提にしていないコードが混ざる可能性が高い言語生態系です。そのため、常にメモリリークが起き得る前提で考えるほうが安全です。
[^5]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^5]: サンプルコードはOpenAIのChatGPT（"ChatGPT 5.2"）を参考に下書きを作成し、最終的には筆者が確認・修正しました。
[^6]: 폴더 위치를 바꿀 수 있는 방법을 발견하지 못했으나, 폴더 위치를 바꿀 수 있는 방법을 발견했다면 구조상 `Job/*` 보다는 `Batches/Job/*`에 코드를 정의하는 것을 추천한다.
[^6]: フォルダ位置を変える方法は見つけられていませんが、もし可能なら構造上は `Job/*` より `Batches/Job/*` に置くほうが分かりやすいと思います。
[^7]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^7]: サンプルコードはOpenAIのChatGPT（"ChatGPT 5.2"）を参考に下書きを作成し、最終的には筆者が確認・修正しました。
[^8]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^8]: サンプルコードはOpenAIのChatGPT（"ChatGPT 5.2"）を参考に下書きを作成し、最終的には筆者が確認・修正しました。
[^9]: 예시 코드는 OpenAI의 ChatGPT("ChatGPT 5.2")를 참고해 초안을 작성했으며, 최종 코드는 작성자가 검토·수정했습니다.
[^9]: サンプルコードはOpenAIのChatGPT（"ChatGPT 5.2"）を参考に下書きを作成し、最終的には筆者が確認・修正しました。
