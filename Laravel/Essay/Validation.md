# 유효성 검사

클라이언트 (브라우저, API)는 서버로 리퀘스트를 보낸다. 웹 애플리케이션은 이 리퀘스트를 처리하기에 앞서, 리퀘스트가 처리하기에 유효한 값인지 아닌지 판단하는 벨리데이션 시스템을 가지고 있다.

벨리데이션을 통과하지 못하면, 웹 애플리케이션은 클라이언트에게 리퀘스트의 어떤 값이 벨리데이션을 통과하지 못했기 때문에, 에러가 발생한다고 알려 준다.

## 벨리데이션의 특징

벨리데이션은 애플리케이션 내부로 전달된 리퀘스트의 값이 애플리케이션에서 처리하기에 적절한 형태의 값인지를 확인하며, 라라벨의 벨리데이션은 리퀘스트로 전달된 파라메터가 PHP 프로그래밍 언어로 표현될 수 있는 값으로 매핑이 된 값의 타입, 범위 등 다양한 특성에 대한 검사를 할 뿐이며, PHP에 매핑된 값을 변경하지는 않는다. 리퀘스트가 언어에 매핑된 값은 리퀘스트 데이터가 벨리데이션을 통과하기 전에 이미 이뤄져 있다.
 
## 벨리데이션 다음에 assert가 필요한 이유

라라벨에서 리퀘스트의 어떤 파라메터가 벨리데이션을 통과했다고 하자. 그럼, 해당 값의 타입은 mixed가 된다. 특정 벨리데이션을 통과했다면, 데이터의 타입이나, 범위가 어느정도 정해졌을 텐데 mixed 타입으로 처리하는 것은 IDE의 정적 분석을 이용하지 못하므로 좋은 방법이 아니다.

이 때문에 벨리데이션 이후 assert로 타입 Assertion을 이용해서, mixed로 되어 있는 값의 타입 범위를 좀 더 좁혀주고 이를 통해서 IDE의 정적 분석을 통해서 휴먼 미스를 방지하는 방식의 코딩을 하도록 한다.

## 벨리데이션의 2가지 처리 방식

여러 값에 대한 벨리데이션을 하면 할수록 벨리데이션 처리에 드는 시스템 리소스는 늘어난다. 하나의 벨리데이션이 실패했는데, 모든 벨리데이션 메시지를 표시하는 것은 리소스 낭비라고 생각할 수도 있다.

벨리데이션의 통과 및 실패는 시스템 내부에서 이용할 수 있는 값인지 아닌지를 구별하여 시스템에서 이용할 수 있는 값만 받아서 값의 범위를 한정하여, 처리 로직을 단순화하고 명확하게 하는 역할도 하지만, 통과되지 못했을 경우 유저 또는 API 이용자에게 무엇이 잘못되어서 처리할 수 없는지 알려주는 역할을 한다.

단순히, 시스템 리소스만을 생각하면, 벨리데이션을 진행하다가 잘못된 것 하나가 생기면 벨리데이션 메시지를 포함한 메시지를 보내면 되지만, 클라이언트는 제출할 때 실패한 모든 값의 벨리데이션 통과 여부를 알고 싶어 한다. 만약 모든 벨리데이션아 이나라 통과되지 못한 벨리데이션 하나의 메시지만 전달 받는다면 이를 고쳐 새로 리퀘스트를 송신할 때, 하나는 고쳤지만, 이전 리퀘스트 송신에서 앞선 벨리데이션에 걸려 실행되지 않은 다른 벨리데이션을 통과되지 못한 것이 생기게 되어 클라이언트는 또 제출할 데이터를 수정하는 과정을 반복하는 문제가 발생한다.

기본적으로는 클라이언트를 위해서 가능한 많은 벨리데이션 메시지를 전달하는 것이 좋으며, 리소스가 드는 벨리데이션의 처리를 하기 전에 다른 벨리데이션이 통과하지 못하게하여 리소스를 줄이고자 할 때는 별도로 벨리데이션을 배치하도록 한다.

## 라라벨의 벨리데이션 시스템

### 리퀘스트 객체를 통한 벨리데이션

`Illuminate\Foundation\Http\FormRequest`의 상속을 받는 객체를 정의하는 방식으로 `public function rules(): array` 시그니처를 추가하여 벨리데이션을 정의하여 사용한다.

### 인라인 벨리데이션

`Illuminate\Http\Request`를 이용하여 리퀘스트 객체 내부의 저장된 리퀘스트에 대한 벨리데이션을 사용할 수 있다. 이를 인라인 벨리데이션이라고 한다.

### 벨리데이션 파사드를 사용한 벨리데이션

`Illuminate\Support\Facades\Validator`를 이용하여 리퀘스트로 전달된 데이터와 관계 없이 키-벨류 쌍의 연관 배열을 전달하여 벨리데이션을 사용할 수 있다.
