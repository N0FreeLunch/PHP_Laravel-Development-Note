# php엔지니어가 알아야 할 리눅스의 기초

## 도입

인터프리터 언어에서 파일 업로드를 할 때 일반적으로 S3와 같은 외부 저장소를 사용하지만, 웹 애플리케이션이 동작하고 있는 서버에 직접 저장을 할 때도 있다. 애플리케이션 서버에 업로드한 파일을 저장을 할 때는 파일에 대한 처리를 임시적으로 하고 처리가 완료된 파일을 외부 저장소로 옮기기 전의 작업에 사용하는데, 이 때, 유저가 업로드한 파일을 통해서 파일 인젝션 공격이 이뤄질 수 있다. 리눅스의 파일 및 폴더 설정을 적절히 하는 것을 통해서 파일 인젝션을 막을 수 있는데 이 보안 설정의 기본을 알기 위한 기초 지식을 습득해 보자.

## 사전 지식

### 파일 권한

리눅스의 파일에 대한 권한은, 읽기(r), 쓰기(w), 실행(x) 3가지의 권한으로 나뉘어 있다.

#### 읽기 (r)

파일의 데이터를 읽을 수 있는 권한이다. 파일에 담겨 있는 이진 데이터를 바이트 단위로 취득하기 위해 사용한다.

#### 쓰기 (w)

파일에 담긴 데이터를 추가, 변경, 삭제하기 위한 권한이다.

#### 실행 (x)

파일에 담긴 데이터를 프로그램으로 실행을 하기 위한 권한이다.

### 폴더 권한

#### 읽기 (r)

폴더 내의 파일 및 폴더 이름이나 메타 정보를 확인할 수 있는 권한이다.

터미널에서 `ls`라는 명령어로 폴더 안의 파일 및 폴더의 리스트를 확인하는 명령어가 일기 권한의 영향을 받는다.

#### 쓰기 (w)

폴더 내의 파일을 생성하거나 삭제하며, 파일 이름을 변경할 수 있는 권한이다. 읽기 권한이 없다면 파일 내부에 어떤 파일이 있는지 확인할 수 없지만, 파일 경로를 지정해서 생성, 삭제, 이름 변경을 할 수 있다.

터미널에서 `mv` 명령어로 파일을 옮기거나 `rm` 명령어로 파일을 삭제하거나  `touch` 명령어로 빈 파일을 생성하는 명령어가 쓰기 권한의 영향을 받는다.

#### 실행 (x)

폴더에 엑세스하는 권한이다. 파일을 프로그램으로 실행하는 권한에 영향을 주지는 않는다.

`cd` 라는 명령어로 폴더 안으로 접근하는 명령어가 실행 권한의 영향을 받는다.

### 유저

리눅스에는 루트(Root), 시스템(System), 일반(Regular)의 사용자 유형이 존재한다. 

#### Root user

모든 파일 및 폴더에 관한 엑세스 권한을 갖는다. 파일 및 폴더에 대한 읽기(r) 쓰기(w) 실행(x) 권한을 모두 가지고 있다.

#### System user

특정 프로그램에 파일 및 폴더에 대한 엑세스 권한을 부여한다. 일반 사용자 계정에 의해 프로그램이 실행되지 않고, 프로그램이 독립적으로 실행 되면서 파일 및 폴더에 관한 읽기(r) 쓰기(w) 실행(x)를 해야 할 경우 프로그램에 부여한 시스템 사용자 계정을 이용한다. 웹 서버에서는 [Apache](https://httpd.apache.org/)를 사용할 때는 www-data의 시스템 사용자를 가지며, [nginx](https://nginx.org/)를 사용할 때는 nginx의 시스템 사용자를 가진다.

#### Regular user

일반 사용자로, 우리가 OS에 로그인을 해서 작업할 때 사용되는 계정이다. 일반적으로 `/home` 디렉토리에 각각의 사용자 계정에서 사용할 수 있는 `/home/{user_name}` 폴더가 주어진다. 일반 사용자는 이 폴더 내에서 파일 및 폴더를 관리하는 권한을 갖는다.

### 유저 설정 방법

#### 유저 생성하기

리눅스의 유저는 다음 명령어로 생성할 수 있다.

```sh
sudo adduser user_name
```

#### 로그인 설정하기

생성한 유저에 로그인 기능을 부여하려면 `-s` 옵션을 통해서 로그인 쉘을 지정해야 한다. 이 때 로그인 쉘은 sh, bash, zsh, fish 등의 쉘을 실행하는 파일을 지정해 줘야 한다. 보통은 `/bin` 폴더에 위치해 있다.

```sh
sudo adduser user_name -s /bin/bash
```

로그인 기능을 만들지 않으려면, `/usr/sbin/nologin` 파일을 지정해 준다.

```sh
sudo adduser user_name -s /usr/sbin/nologin
```

#### 유저 아이디 설정하기

리눅스의 유저는 유저를 구별하기 위한 고유한 uid를 발급 받는다. 보통 시스템 유저의 경우 uid를 999번 이하의 수를 발급을 받고, 일반 유저의 경우 1000번 부터의 수를 발급 받는다.

유저 아이디를 설정하지 않으면 자동으로 생성된다. 그런데 시스템 유저의 경우, 999번 이하의 수를 일반적으로 설정하므로 가능한 낮은 유저 아이디 `-r`을 사용하면 된다.

```sh
sudo adduser user_name -r
```

유저 아이디를 임의로 정하고 싶은 경우 `-u` 옵션을 사용한다.

```
sudo adduser user_name -u 1234
```

### System 유저와 Regular 유저

System 유저와 Regular 유저의 차이는 프로그램이 사용할 것인지, 사람이 사용할 것인지 목적에 따라 구분되고, 이 구분에 따라 리눅스 유저 계정을 생성할 때 로그인을 할지 하지 않을지, 아이디를 999 이하로 할지 1000 이상으로 할지를 정한다.

## 권한 설정

리눅스에서 권한 설정에 관한 명령어로 대표적인 것은 chmod와 chown가 있다.

### chown

파일 및 폴더에는 소유자, 소유자 그룹, 소유자 이외의 유저의 권한을 chmod로 정할 수 있는데, chown으로 설정한 소유자, 소유자 그룹을 정할 수 있다.

chown의 명령어 구조는 'chown 소유자:소유자_그룹 파일_및_폴더의_경로'가 된다. 파일 및 폴더에는 소유자와 소유자 그룹을 하나씩만 정할 수 있다.

### chmod

파일 및 폴더에 대한 읽기(r), 쓰기(w), 실행(x)의 권한을 설정할 수 있다. 이 때 각각의 권한을 이진법으로 읽기 권한을 001, 쓰기 권한을 010, 실행 권한을 100으로 부여한다. 각 권한 별로 이진법의 다른 자리를 갖고 있는데, 이는 비트 단위 OR 연산을 하기 위해서이다. 그리고 chmod 명령을 사용할 때 이진법 권한을 십진법으로 환산한 값으로 권한을 설정한다.

#### 명령어의 구조

chmod의 명령어의 구조는 'chmod XYZ 파일_및_폴더의_경로'가 된다. X, Y, Z는 숫자로, X는 파일 및 폴더의 소유자 권한, Y는 파일 및 폴더의 소유자 그룹 권한, Z는 파일 및 폴더의 소유자가 아닌 유저의 권한이다.

#### 읽기(r) 권한

```
100 = 4
```

```
r--
```

읽기 권한 100은 십진법으로 4이 된다.

#### 쓰기(w) 권한

```
010 = 2
```

```
-r-
```

쓰기 권한 010은 십진법으로 2가 된다.

#### 실행(x) 권한

```
001 = 1
```

```
--x
```

실행 권한 001은 십진법으로 1가 된다.

#### 읽기와 쓰기 권한

```
100 | 010 = 110
```

```
r-- | -w- = rw-
```

읽기와 쓰기 권한은 110 이므로 십진법으로 6이 된다.

#### 읽기과 실행 권한

```
100 | 001 = 101
```

```
r-- | --x = r-x
```

읽기과 실행 권한은 101이므로 십진법으로 5가 된다.

#### 쓰기와 실행 권한

```
010 | 001 = 011
```

```
-w- | --x = -wx
```

쓰기와 실행 권한은 011이므로 십진법으로 3이 된다.

#### 읽기 쓰기 실행 모두 가질 때

```
100 | 010 | 001 = 111
```
```
r-- | -w- | --x = rwx
```

읽기와 쓰기와 실행 권한은 111이므로 십진법으로 7이 된다.

#### chmod 명령어의 예

```
chmod 777 file.ext
```

file.ext 파일의 소유자, 소유자그룹, 소유자 이외의 다른 유저 모두 7의 권한을 가지므로 file.ext 파일에 대해 읽기, 쓰기, 실행 권한을 갖는다.

```
chmod 755 file.ext
```

file.ext 파일의 소유자는 7의 권한을 가지므로 file.ext 파일에 대해 읽기, 쓰기, 실행 권한을 갖는다.

file.ext 파일의 소유자 그룹은 5의 권한을 가지므로 file.ext 파일에 대해 읽기와 실행 권한을 갖는다.

file.ext 파일 이외의 다른 유저 그룹은 5의 권한을 가지므로 file.ext 파일에 대해 읽기와 실행 권한을 갖는다.

```
chmod 644 file.ext
```

file.ext 파일의 소유자는 6의 권한을 가지므로 file.ext 파일에 대해 읽기와 쓰기 권한을 갖는다.

file.ext 파일의 소유자 그룹은 4의 권한을 가지므로 file.ext 파일에 대해 읽기 권한을 갖는다.

file.ext 파일 이외의 다른 유저 그룹은 4의 권한을 가지므로 file.ext 파일에 대해 읽기 권한을 갖는다.

## 서버

컴퓨터와 컴퓨터는 서로 연결될 수 있다. 이를 네트워크라고 하는데, 하나의 컴퓨터가 폴더를 공유하면 다른 컴퓨터에서는 공유된 폴더에 접근하여 파일을 올리고 내려 받을 수 있다.

웹 브라우저를 통한 인터넷 접속도 이와 비슷한 방식의 동작 방식을 갖는데, 123.456.789.123/sub_folder/index.html 라는 주소로 접근을 하면, 네트워크 상의 123.456.789.123이란 IP 주소를 가진 서버로 접근을 하고, 공유 폴더의 sub_folder 내의 index.html 파일을 다운로드 한다. 브라우저는 이 파일을 다운로드 하여, 파일의 html 구문을 파싱하여 화면에 표시한다.

## php의 동작

php는 웹 서버의 php 파일에 대한 리퀘스트가 전달되면, php-fpm은 url의 path와 일치하는 경로의 php 파일 읽어 스크립트를 실행한다. php 엔진은 스크립트를 실행한 결과를 텍스트로 생성하여 php-fpm에 전달하고, php-fpm은 이 결과를 리스폰스로 브라우저에 전달한다. 브라우저는 이 파일의 html을 파싱하여 웹 페이지를 랜더링한다.

php엔진이 php 파일을 실행할 때는 파일의 코드를 읽어서 파일에 기록된 스크립트를 실행한다. 프로그램을 실행하는 것 처럼 php 파일을 그대로 실행을 하는 것이 아닌 php 파일을 읽고 읽은 내용을 바탕으로 실행하기 때문에 php 파일은 실행 권한 (`001 = 1`)은 필요하지는 않으며 읽기(`100 = 4`) 권한이 필요하다.

## 데몬과 유저 권한

데몬은 리눅스에서 백그라운드에서 동작하는 프로그램이다. nginx, apache, cron, mysql 등의 프로그램은 한 번 실행되면 백그라운드에서 동작을 하게 된다. 프로그램이 종료되기 전까지 nginx나 apache라면 http 요청을 받아서 처리하고, cron이면 매 분마다 실행을 하고, mysql면 데이터베이스로 오는 요청을 처리한다.

apache라면 apache 유저로 데몬이 실행되고, nginx라면 nginx 유저로 데몬이 실행된다. 데몬을 실행할 때는, `sudo service` 또는 `sudo systemctl`를 통해서 (sudo 명령어를 사용하므로) 루트 권한으로 실행하지만, 데몬에서 필요한 리눅스의 기능들을 연결한 이후에는 특정 시스템 유저로 실행 되도록 한다.

프로그램이 특정 유저의 권한으로 실행되면, 동일한 유저가 소유자로 되어 있는 파일 및 폴더에 대한 엑세스 권한을 갖는다. nginx 데몬은 nginx 유저 권한으로 실행되고, apache 데몬은 www-data 유저로 실행된다. nginx는 nginx가 소유자로 등록된 파일 및 폴더를 제어할 수 있고, apache는 www-data가 소유자로 등록된 파일 및 폴더를 제어할 수 있다.

서버에 http 요청이 오면, nginx 또는 apache가 실행이 되고, nginx 또는 www-data의 유저 권한으로 php-fpm이 실행되며 지정한 경로의 php 파일도 동일한 유저 권한으로 실행된다.

## 파일 업로드와 실행 권한

서버가 웹 요청을 받으면 백그라운드로 실행되고 있는 데몬 nginx 또는 apache를 통해서 실행된다. 이들이 파일 및 폴더에 접근을 할 때는 nginx 또는 www-data 유저로 접근을 한다. 파일을 업로드 할 때도 실행한 프로그램의 권한으로 추가 되는 것이기 때문에 소유자가 nignx 또는 apache 권한을 가진 폴더에 동일한 소유자의 파일이 저장된다.

### 경로를 통한 파일 실행

만약 이 파일이 서버의 공유 폴더에 있다면 기본적으로 url의 path에 대응되는 서버의 공유 폴더의 path의 파일을 매칭한다. 유저가 업로드 한 파일이 공유 폴더의 sub_folder 폴더 내의 file.php 파일이라고 하자. 그러면 url의 path로 sub_folder/file.php을 경로로 접근하는 순간 유저가 업로드한 file.php 파일을 실행하면서 서버의 각종 정보를 취득할 수 있다.

해커는 서버에 업로드 한 파일을 실행하는 것을 통해서 서버의 각종 정보를 취득할 수 있게 된다. 따라서 업로드 한 파일을 공유 폴더에 저장하지 않도록 주의하도록 하자. 보통 웹 프레임워크에서 최상단의 public 폴더가 공유 폴더가 된다.

### 경로 문자열을 통한 파일 실행

php에는 외부 파일의 경로를 지정해서 파일을 실행할 수 있는 명령어가 존재한다. 다른 php 파일을 가져와 함수를 호출한 php 파일의 코드에서 실행할 수 있는 `include()` 나 `require()` 함수를 사용한 코드에 업로드한 파일 경로를 전달하거나 또는 커멘드라인 명령어를 실행할 수 있는 `exec` 함수에 업로드한 파일을 실행하는 명령어를 전달하는 방법으로 해킹을 시도할 수 있다.

이런 함수에 외부의 문자열이 전달되지 않도록 시큐어 코딩을 하는 것이 중요하지만, 혹시라도 개발자의 부주의로 외부의 문자열이 전달 될 가능성도 있기 때문에 업로드한 파일이 이런 명령어에 의해 실행되지 않도록, 웹 통신을 통한 리눅스 권한인 nginx나 www-data에 의해 실행될 수 없도록 실행 권한(`100 = 4`)을 차단한 폴더에 업로드한 파일이 저장될 수 있도록 한다.

## root 권한이 위험한 이유

서버 애플리케이션에서 실행할 코드가 담긴 파일 및 폴더의 소유자 및 소유자 그룹이 root로 되어 있다고 하자. 이 파일을 nginx 또는 apache로 유저로 실행하기 위해서는 파일 권한의 소유자, 소유그룹, 모든 유저 중에서 다른 유저 권한을 설정해야 한다. 'chmod XYZ'에서 모든 유저에 해당하는 Z 부분의 값을 6 또는 7로 설정하여, '읽기, 쓰기' 권한 또는 '읽기, 쓰기, 실행' 권한을 부여해 주어야 하는데, nginx 또는 www-data 뿐만 아니라 다른 권한을 가진 유저도 접근할 수 있다는 문제점이 생긴다.

리눅스에는 다양한 시스템이 동작하고 있고, 각각의 시스템은 서로 다른 유저 권한으로 실행된다. 애플리케이션 로직을 실행하는 파일이 들어 있는 폴더가 리눅스의 다른 프로그램에 의해서도 읽기, 쓰기, 실행이 일어날 수 있다는 것이고, nginx나 www-data 뿐만 아닌, OS 위에서 동작하는 모든 시스템에서 어느 것 하나라도 시큐어 문제가 발생했을 때, 애플리케이션 로직이 다른 프로그램에 의해 실행되는 문제가 생길 수 있다. 그래서 웹 애플리케이션 로직이 동작하는 파일이 담긴 폴더는 별도의 소유권을 부여하여 특정한 유저 권한으로만 실행될 수 있게 하여 시큐어 문제가 발생할 여지를 최소화 한다.

파일 및 폴더의 권한을 chown으로 nginx나 www-data 등으로 설정을 하고, chmod로 'chmod XYZ'의 소유 권한 X와 소유자 그룹 권한 Y만을 설정하고, 다른 유저(X)의 접근 권한은 최대한 차단한다.

## 권한 7이 위험한 이유

권한 7은, 읽기(`100 = 4`), 쓰기(`010 = 2`), 실행(`001 = 1`)을 사용하는 코드이다. 이 중에서 소스 코드에 대한 쓰기(w) 권한을 갖는 것은 위험할 수 있다. 해커가 웹 통신으로 접근을 하면 www-data 또는 nginx 유저의 권한으로 접근하게 되는데, 소스에 대한 쓰기 권한을 부여하면 취약점을 통해서 소스 코드를 변경할 수 있다. 따라서 www-data 또는 nginx 유저의 권한에 대해서는 소스 코드를 변경할 수 없도록 만드는 편이 좋다.

프로덕션 서버에 올린 소스코드는 일반적으로 수정할 일이 없어야 하고, 수정하지 않는 방식으로 만드는 것이 가장 좋다. php에서는 긴급할 때 (JIT나 Opcache 옵션을 사용하지 않을 때) 서버에서 동작하는 코드를 직접 변경하여 버그를 수정할 수 있는 방법을 사용할 수도 있는데 이 방법은 동작이 충분히 검증되지 않은채로 변경하는 것이기 때문에 더 큰 문제를 불러 일으킬 수 있다. 프로젝트가 발전하면서 자동화된 테스트 및 동작 확인 절차를 명확히 하는 등의 과정을 추가하여 긴급한 버그 수정이 발생하지 않도록 하고 서버의 코드는 수정할 수 없도록 만드는 것이 좋다.

만약 프로덕션 서버의 권한을 수정할 수 있도록 만드는 편이 나은 경우, www-data 또는 nginx 유저의 쓰기 권한은 차단하여 읽기(`100`)와 실행(`001`)만 할 수 있도록 권한을 5(`=101`)로 부여하고, 파일 수정을 할 수 있는 별도의 유저를 만들도록 하자.

### 임시 파일

만약 php가 파일을 생성하면서 임시 파일을 생성해야 한다면, 외부에서 엑세스가 가능한 공유 폴더가 아닌 별도의 폴더를 사용해서 url을 통해 임시 파일에 엑세스 할 수 없도록 해야 하며, 임시 파일을 생성할 별도의 폴더를 지정해서 해당 폴더에서만 쓰기 작업을 할 수 있도록 프로젝트 규약을 정한다. 또한 생성된 파일은 서버에서 직접 실행되지 않도록 실행 권한을 제거하는 편이 좋다.

임시 파일을 저장하는 폴더에 유저가 업로드한 파일을 위치시키지 않도록 주의해야 한다. 유저가 업로드 한 파일에 실행 권한이 부여되지 않도록 주의를 기울여야 한다.

## 로그인 할 수 있는 유저 만들기

파일 및 폴더의 권한은 소유자에게 가장 많은 권한을 부여하고, 소유자 그룹은 소유자 그룹과 같거나 적은 권한을 부여하고, 나머지 유저는 소유자 그룹과 같거나 적은 권한을 부여하는 것이 일반적이다.

www-data 또는 nginx 유저에 쓰기 권한이 없어야 한다면, 이들은 소스 코드에 대한 소유자 그룹 권한을 부여하는 것이 적절하고 로그인을 할 수 있는 유저에게 쓰기 권한을 부여하도록 한다. 로그인 할 수 있는 유저를 앞으로 appuser라고 하자. 파일 및 폴더의 소유자를 appuser 소유자 그룹을 www-data로 만들도록 한다. 애플리케이션에 접근해야 하는 리눅스 유저가 여럿인 경우에는 소유 그룹을 appusers로 설정하는 방식도 고려될 수 있다.

### 유저 생성 명령어

```bash
useradd -m --no-user-group -g www-data -u 1000 appuser -s /usr/sbin/nologin
```

프로젝트 폴더는 www-data 또는 nginx 유저 권한으로 실행될 수 있어야 한다. 그러나 www-data 및 nginx는 가능한 실행 권한만을 주고, 쓰기나 읽기 권한은 부여하지 않도록 하고, 터미널에 엑세스 가능한 별도의 권한에 대해 읽기 및 쓰기 권한을 추가한다. 이를 위해서 유저 그룹은 www-data 또는 nginx 권한을 부여하는 유저를 생성한다.

유저 아이디는 1000을 부여하는데, 로그인 가능한 일반 계정을 만들기 위해서이다. 일반 계정은 1000번 이상의 번호를 부여하는 것이 관례이다.

`-m`은 사용자 계정에 부여되는 홈 디렉토리를 생성한다. www-data 및 nginx 에서는 접근하지 못하지만, 생성한 유저 계정으로는 접근할 수 있는 파일을 저장해서 사용할 필요가 있을 때 사용한다. 이 옵션의 사용은 NodeJS를 설치할 때 [NVM](https://github.com/nvm-sh/nvm) 설치를 위해서 `-m`을 사용하였다.

`--no-user-group`은 유저명과 동일한 그룹명을 자동생성하여 유저의 소속 그룹을 정하는데, `appuser` 유저의 유저 그룹으로 `appuser`가 아닌 기존의 `www-data` 그룹을 사용하기 위한 명령이다.

`-s /usr/sbin/nologin`를 통해서 root 계정으로 엑세스 해서 root 계정으로만 appuser 권한으로 전환할 수 있도록 하며, 별도로 appuser로 접근하지 못하도록 한다.

### 프로젝트 환경 구성 권한

php의 패키지 매니저인 composer를 실행할 때 root 권한으로 실행하면 'Do not run composer install as root super user!'라는 메시지가 나온다. 단순히 패키지를 다운로드해서 vendor 폴더에 넣는 것 뿐만 아니라, 패키지를 use 키워드로 import 할 수 있는 설정 및 패키지 별로 실행하는 추가 설정 등이 있는 경우가 있고 이를 위해 php 코드가 실행된다. 

패키지에는 다양한 php 코드가 섞여 있고, 불순한 목적의 코드가 담긴 패키지가 포함되어 있을 수 있다. root 권한으로 composer를 실행하면 패키지가 설치될 때 php 코드를 실행할 수 있기 때문에 악의적인 코드가 실행되는 경우도 있어 시스템에 치명적인 영향을 줄 수 있다.

composer로 설치되는 패키지가 설치될 때 실행되는 php 코드가 프로젝트 폴더 내부에서만 영향력을 가질 수 있도록 파일 및 폴더 권한을 제한된 유저 권한으로 설정하여 패키지를 설치 해 주어야 하며, 악의적인 코드가 프로젝트 폴더를 벗어난 파일 및 폴더를 건드릴 수 없도록 한다.

composer로 설치할 때는 프로젝트 폴더에 대한 영향력은 가져야 라이브러리를 설치 및 각종 구성을 완료할 수 있기 때문에 프로젝트 폴더 내부의 파일 및 폴더 권한 제한은 걸지 않는다.

웹 통신에 사용되는 www-data나 nginx 권한은 실행만 가능하게 하고 파일 및 폴더를 추가할 수 없도록 만드는 것이 좋은데, 패키지를 설치하는 composer 명령은 웹 통신으로 실행될 여지를 원천 차단하고, 웹 엑세스가 아닌 다른 유저(appuser) 권한으로 composer를 실행하도록 한다.

php의 패키지 매니저 뿐만 아니라, NodeJS의 패키지 설치 및 빌드 등도 통신을 하는데 쓰이는 www-data 또는 nginx 권한으로 실행할 필요는 없다. 별도로 만든 유저 권한(appuser)을 통해서 애플리케이션 초기 구성에 필요한 설치를 하도록 하자.

### 파일 및 폴더 권한 부여

다음 예는 라라벨 프로젝트를 기준으로 한다. 각자 설정하는 환경이 다를 수 있기 때문에 그대로 사용하지 않고, 담당하는 프로젝트에 적합한 권한을 세팅하도록 하자.

#### 전체 쉘 명령어

```bash
useradd -m --no-user-group -g www-data -u 1000 appuser -s /usr/sbin/nologin

# laravel project file and folder setting

# install composer package

# install NodeJS package

mkdir -p ${PROJECT_PATH}/storage

chown appuser:www-data -R ${PROJECT_PATH}

find ${PROJECT_PATH} -mindepth 1 -type d -exec chmod 751 {} \;
find ${PHP_FPM_SOCK_FOLDER_PATH} -type d -exec chmod 751 {} \;
find ${PROJECT_PATH}/public -type d -exec chmod 751 {} \;
find ${PROJECT_PATH} -type f -exec chmod 640 {} \;
find ${PROJECT_PATH}/public -type f -exec chmod 644 {} \;

chmod -R 770 ${PROJECT_PATH}/storage ${PROJECT_PATH}/bootstrap/cache
```

경우에 따라 `find ${PHP_FPM_SOCK_FOLDER_PATH} -type d -exec chmod 751 {} \;`, `find ${PROJECT_PATH}/public -type d -exec chmod 751 {} \;`는 사용하지 않아도 된다.

### 각각 명령어의 해설

라라벨 프로젝트의 폴더 구조를 예를 들어 설명한다. 이 예제 코드는 root 권한으로 쉘 커멘드를 실행하는 경우의 예이다. `chmod`, `chown`의 -R은 지정한 폴더 하위의 모든 파일 및 폴더에 적용한다는 의미를 갖고 있다.

```
mkdir -p ${PROJECT_PATH}/storage
```

라라벨의 경우 애플리케이션이 실행할 때 `storage` 폴더에 캐시나 로그 파일 등을 저장한다. 파일이 생성되고 변경되므로 쓰기 권한이 필요하다. 경우에 따라 `storage` 폴더가 없을 수 있기 때문에 폴더가 없다면 `-p` 옵션을 추가한다. 이후 전체 프로젝트 폴더 권한을 부여하는 작업에 `storage` 폴더도 함께 권한 부여가 될 수 있도록 미리 폴더를 만들어 둔다.

```
chown appuser:www-data -R ${PROJECT_PATH}
```

프로젝트의 파일 및 폴더의 권한이 `root:root` 으로 되어 있을 수 있다. `root` 권한의 파일에 권한 부여를 시도할 때 이들 파일의 소유 권한을 소유자 `appuser` 소유권한 `www-data`으로 만든다.

```
find ${PROJECT_PATH} -mindepth 1 -type d -exec chmod 751 {} \;
```

지정한 프로젝트 폴더 하위의 모든 폴더의 소유자 권한에 읽기, 쓰기, 실행 권한 7(`100 | 010 | 001 = 111`)을, 소유자 그룹에 읽기, 실행 권한 5(`100 | 001 = 101`)을, 그 외 다른 유저들에게는 읽기 권한 1(`001`)을 부여한다.

nginx 또는 apache를 사용할 때 php-fpm의 소켓을 연결해서 동작을 구성하는 경우 소유자 이외의 권한으로 폴더 경로에 엑세스 할 수 있도록 폴더의 실행 권한 `001`을 부여해야 하는 경우가 있다. 만약 php-fpm 쪽에서 'permission denied'가 발생하는 경우 폴더 실행 권한 1을 설정하자. (부여하지 않아도 잘 실행되는 경우도 있으니 0으로 세팅 후 되지 않으면 1로 세팅하자. 권한은 가능한 최소한으로 부여하는 것이 좋지만, 폴더 권한의 1 정도는 보안상 위험을 초래하지는 않는다.)

프로젝트 폴더는 root 권한을 갖거나 소유자도 수정할 수 없도록 만드는 경우도 있기 때문에 지정한 폴더는 포함하지 않고 하위 폴더만 적용될 수 있도록 `-mindepth 1` 옵션을 부여해 준다.

소유자 권한은 기본적으로는 개발 환경을 고려하여 쓰기 권한이 들어간 7을 세팅하지만, 실제 디플로이 되었을 때의 쓰기를 허용하지 않는 환경을 위해 5를 세팅할 수도 있다.

```
find ${PHP_FPM_SOCK_FOLDER_PATH} -type d -exec chmod 751 {} \;
```

nginx와 php-fpm을 간의 연결에 소켓을 사용할 때는 소켓 파일이 있는 폴더의 권한도 부여해 주어야 한다.

```
find ${PROJECT_PATH}/public -type d -exec chmod 751 {} \;
```

apache나 nginx를 사용하는 php는 url의 path에 맞는 폴더 경로의 파일을 매칭한다. 라라벨의 경우 url이 `domain/sub_folder/file.js`으로 전달 되었을 때, public 폴더를 기준으로 `sub_folder` 폴더의 `file.js`를 매칭한다. 이 때 경로는 nginx나 apache 유저 권한이 아닌 퍼블릭 엑세스가 되기 때문에 소유자 소유그룹 이외의 폴더에 실행권한(1)을 준다.

```
find ${PROJECT_PATH} -type f -exec chmod 640 {} \;
```

지정한 프로젝트 폴더 내의 모든 파일에 대해 파일 소유자 권한에 읽기와 쓰기 권한 6(`100 | 010 = 110`)을, 소유자 그룹에 실행 권한 4(`100`)를 부여한다.

소유자 권한은 기본적으로는 개발 환경을 고려하여 쓰기 권한이 들어간 6(`110`)을 세팅하지만, 실제 디플로이 되었을 때의 쓰기를 허용하지 않는 구성을 만들 수 있기 때문에 4(`010`)를 세팅할 수도 있다. php 파일은 인터프리터가 실행되어 파일 내용을 읽기 때문에 읽기 권한이 필요(`100`)하며 실행 권한(`001`)이 필요하지 않다.

가끔 경우에 따라 파일을 실행해야 하는 경우도 있는데 이런 경우는 실행 권한(`001`)을 별도로 세팅하는 편이 좋다. 어떤 php의 코드가 php가 아닌 어떤 프로그램을 실행해서 동작해야 하는 경우 실행 권한을 요구할 때가 있다.

```
find ${PROJECT_PATH}/public -type f -exec chmod 644 {} \;
```

```
chmod -R 770 ${PROJECT_PATH}/storage ${PROJECT_PATH}/bootstrap/cache
```

웹의 네트워크 통신을 통해서 www-data나 nginx 유저 권한으로 실행되므로 이들 권한에 의한 변경이 이뤄질 수 있도록 7(`100 | 010 | 001 = 111`)의 권한을 부여한다.

유저가 직접 서버에 엑세스해서 php 명령을 실행하거나 유저 권한의 쉘 스크립트를 통해서 코드를 실행할 때 `storage` 폴더 안에 파일 및 폴더가 생성될 수 있기 때문에 쓰기 권한까지 부여된 7을 부여한다.

`bootstrap/cache` 폴더는 라라벨 애플리케이션이 동작할 때의 필요한 여러 캐시 파일을 생성한다. 따라서 웹 통신으로 캐시 파일이 생성될 수 있도록 www-data나 nginx 유저 권한에 7을 부여한다.

애플리케이션의 세팅이 완료됨에 따라 `${PROJECT_PATH}/bootstrap/cache/pagkages.php` 파일과 `${PROJECT_PATH}/bootstrap/cache/services.php` 파일이 생성되고 애플리케이션의 실행에 따라 캐시될 필요가 있는 파일이 추가 되며, 라라벨의 각종 설정 및 코드 실행에 따라 파일 및 폴더가 생성된다.

```
chmod 770 -R ${PROJECT_PATH}/bootstrap/cache
```

`php artisan` 명령 또는 `composer` 명령 등에 의해 캐시가 생성되는 경우가 있고, 웹 엑세스로도 캐시가 생성될 수 있기 때문에 `www-data`와 `nginx` 권한과 `appuser` 권한 모두 7(`100 | 010 | 001 = 111`)의 권한을 부여한다.

## 도커와 파일 및 폴더 권한

도커 시스템을 구성할 때 호스트와 컨테이너 내부의 환경이 나눠져 있다. 이 때, 호스트 환경의 파일 및 폴더의 권한과 컨테이너 환경의 파일 및 폴더의 권한이 일치하지 않으면 'permission denied'가 발생할 수 있다. 도커 환경의 파일 및 폴더 권한을 설정했다면 그에 맞게 호스트 환경의 볼륨을 공유하는 프로젝트의 파일 및 폴더 권한을 부여할 필요가 있다.

## References
- https://stackoverflow.com/questions/30639174/how-to-set-up-file-permissions-for-laravel
