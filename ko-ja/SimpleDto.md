## DTO와 VO

### 좋은 코드란?
- 어떤 코드를 보았을 때 이해하기 쉬운 코드는 어떤 코드일까? 초보자의 단계를 지났다면 단순한 문법을 사용해서 만든 코드가 이해하기 쉬운 코드는 아니다. 어떤 의도인지 잘 드러나도록 만드는 코드가 잘 만들어진 코드이다. 어떤 의도인지 잘 드러날 수 있게 하는 방법 중 하나는 다른 것으로 해석될 여지를 최대한 줄이는 코딩을 하는 것이다.
- 간단하게 자바스크립트의 변수 선언 키워드로 `var`와 `let` `const`가 있다. 최근의 자바스크립트 프로그래밍에서는 `var`의 사용을 최대한 지양하고 `let`과 `const`의 사용을 권장한다. `let`과 `const`가 한 번 선언된 변수명을 같은 스코프 내에서는 다시 선언할 수 없는 것과 달리 `var`는 동일한 변수명으로 다시 선언될 수 있기 때문에 코드가 길어질 때 실수를 유발할 수 있기 때문이다.
- 실수를 유발할 가능성이 있는 것과 다른 것으로 해석 될 가능성이 높은 것은 어떤 관계일까? 어떤 코드의 변수의 값의 변화를 추적하는데, `var`로 선언된 값이 있다면, `var`로 선언되기 이전에 또 선언된 곳이 있는지 확인을 해 봐야 한다. 하지만, `const`나 `let`으로 선언되어 있다면, 이전의 코드에서는 동일한 변수명으로 선언된 곳이 없기 때문에 더 이상 찾을 수고를 할 필요가 없다.
- 또한 `let`과 달리 `const`로 선언 되었다면 재할당되지 않기 때문에 오브젝트라면 동일한 오브젝트이며, 스칼라 값이라면 동일한 스칼라 값이 되므로 오브젝트로 할당 되었다면 값의 재할당을 고려할 필요가 없고 스칼라값으로 할당되었다면 굳이 데이터의 변경을 고려할 필요가 없다.

### 배열의 문제점
- PHP에서 여러 데이터들을 하나로 묶는 용도로 주로 연관 배열을 사용한다. 하지만 연관 배열은 키가 고정된 형태가 아니라, 런타임에 키를 얼마든지 추가 및 제거할 수 있기 때문에 배열 안에 어떤 값이 들어가 있는지 알기 위해서는 로직의 전개 과정을 추적하여 확인하거나 런타임에서 얻어지는 값을 확인할 필요가 있다. 연관 배열의 키는 가변적인 특성을 가지기 때문에 연관 배열을 이용한 로직이 길어지면 길어질 수록 해당 코드가 어떤 의도로 쓰였고 연관 배열의 어떤 값을 사용해야 하는지 판단하기 어려워질 수 있다.

### 익명 클래스의 문제점
- 연관 배열의 대안으로 익명 클래스를 생각해 볼 수 있는데, 익명 클래스는 키의 값이 고정되어 있지만 다양한 문맥의 코드에서 IDE가 객체 내부에 담긴 멤버를 추론하지 못하는 일이 흔하다. IDE가 내부의 멤버 값을 추론할 수 있도록 만들기 위해서는 타입힌트로 사용 가능한 클래스로 만들어 주어야 한다. 익명 클래스로는 타입힌트를 만들 수 없기 때문에 별도의 클래스를 만들어 사용해야 타입힌트로 사용할 수 있고, 타입힌트에 의해 내부의 멤버를 100% IDE가 자동 완성으로 제공한다.

### 배열과 익명 클래스의 대안
- 이런 데이터의 묶음은 하나의 php 파일 내에서만 사용하는 것이 아니며 여러 php 파일로 데이터의 전달이 이뤄지기 때문에 여러 파일에서 IDE에 의한 멤버의 접근의 자동완성을 하려면 사용하는 파일마다 타입힌트를 사용할 수 있도록 별도의 네임스페이스를 가진 클래스로 만들 필요가 있다.

### IDE의 배열 키 또는 객체의 멤버 추론
```php
$item = [
    'fruit' => 'apple',
    'price' => 500,
    'amount' => 2
];
```
- `$item['']` 이렇게 연관 배열 내의 키를 입력하려고 할 때 IDE는 배열 안의 키의 리스트를 제공해 주기 때문에 연관 배열의 구조를 기억하지 않아도 원하는 값을 취득할 수 있다.
```php
$item = new class {
    public string $fruit = 'apple';
    public string $price = 500;
    public string $amount = 2;
};
```
- `$item->`으로 익명 클래스 내의 멤버를 접근하려고 할 때 IDE는 클래스 멤버 리스트를 제공해 주기 때문에 배열의 구조를 기억하지 않아도 원하는 값을 취득할 수 있다.
- 하지만 다른 값으로 전환이 되어 다시 원본 값으로 돌아오는 경우나 로직이 연결되지 않은 경우 또는 다른 파일에 위치한 경우 IDE는 연관 배열에 어떤 값이 있는지 추론하지 못하는 경우가 많다.

#### IDE가 추론하지 못하는 경우 : 다른 값으로 전환되어 되돌아 가는 예
```php
$serializedItem = serialize($item);
$unserializedItem = unserialize($serializedItem);
```
- 위의 예제에서 `$unserializedItem`에서 `$unserializedItem['']`을 입력했을 때, 추론이 잘 되지 않을 것이다.

#### IDE가 추론하지 못하는 경우 : 로직이 연결되어 있지 않은 예
```php
class Buy
{
    private object $item;

    public function setItem(): void
    {
        $this->item = new class () {
          public string $fruit = 'apple';
          public string $price = 500;
          public string $amount = 2;
        };
    }

    public function do(): void
    {
        $this->setItem();
        $this->item->fruit;
    }
}
```
- `do` 메소드에서 `$this->item->;`으로 입력을 하더라도 IDE의 자동완성이 표시되지 않는 것을 확인 할 수 있다. 조금 복잡한 문법의 형태로만 가도 IDE는 자동완성을 제공하지 못한다.

## 문제 해결하기
- 데이터의 구조를 고정하기 위해서 데이터를 저장하는 집합으로 배열을 사용하지 않고 객체를 사용한다.
- IDE의 자동 완성을 위해서 타입힌트로 사용할 수 있는 클래스를 사용한다.
- 다양한 파일에서 타입힌트로 사용할 수 있도록 네임스페이스가 있는 클래스를 만들어야 한다.
