## 예외처리

모든 로직을 만들 때 일어날 수 있는 모든 경우의 수를 파악하고 그에 따른 처리를 할 수 있도록 만들면 어떠한 에러도 발생하지 않을 것이다. 어떤 로직이나 코드에 관해서는 모든 경우의 수를 파악할 수 없고 그로 인해서 미리 구비해 둔 로직으로는 처리할 수 없는 경우가 생긴다.

대부분의 프로그램은 미리 준비한 로직으로 처리를 할 수 없는 경우가 발생했을 때 예외 또는 에러를 발생시키며 해당 처리과정을 중단 시킨다. 이 때 프로그래머는 로그를 남기고 로그가 남겨졌다면, 에러나 예외 케이스에 대한 처리를 추가하여 해당 케이스에 대한 에러나 예외가 더 이상 발생하지 않도록 처리할 수 있다.

### 커스텀 예외

어떤 로직을 처리할 때 이러한 경우의 값이 전달되는 경우, 해당 로직에서는 충분한 처리 방안이나 로직이 갖춰져 있지 않기 때문에 더 이상 로직을 해당 맥락에서 처리하지 않고, 별도의 로직으로 전달하여 별개의 처리를 하는 방식을 사용할 때 커스텀 예외를 발생시킨다.

어떤 처리를 함에 있어서 로직을 처리하는 목적이나 맥락과는 다른 처리를 해야 할 때, 사용자 정의 예외를 발생 시켜서 별도의 로직에서 처리를 할 수 있다. 적절하게 예외를 사용함으로써 로직의 목적과 맥락에 맞지 않는 처리를 별도 뽑아내어 처리를 할 수 있으므로, 도메인 중심적인 로직을 나타내는데 불필요한 처리 과정을 함께 기술하지 않는 것으로 굉장히 깔끔한 로직을 만들 수 있다.

### 제공되는 커스텀 예외

프로그래밍 언어나 라이브러리에서 어떤 처리를 하는데 어떤 케이스가 발생했을 때, 언어나 라이브러리 내부에서 이러한 문제를 처리하지 않고 사용자에게 직접 예외를 처리하도록하기 위해서 일부러 커스텀 예외를 만들어 둔다.

물론 처리를 하는데 문제가 발생하면, 예외를 발생시키지 않고, 객체의 인터페이스나 센티널(`null` `false` 반환과 같은 구분값) 반환값을 사용할 수도 있을 것이다. 예외를 발생 시키면 일단 처리가 멈추기 때문에 처리를 중단하지 않고 해당 예외 케이스에 대한 처리를 하기 위해 반드시 예외를 포착하여 예외 처리를 해야하지만, 예외가 발생하지 않고 결과를 객체의 인터페이스 또는 함수의 반환값으로 주는 경우에는 이들 값에 대한 별도의 처리를 하지 않으면 처리가 멈추지 않기 때문에 문제가 발생했지만 문제가 발생하지 않았을 때의 로직을 그대로 실행할 가능성이 생길 수 있다. 물론 이런 경우 원하는 결과 값을 얻을 수 없기 때문에 대부분 실행 처리 과정에서 뭔가 예외가 발생하여 그 원인을 추적하겠지만 때때로 로직의 실행이 완료되어 문제가 발생했을 때 바로 알아채지 못하고 한참 뒤에 운용자 또는 서비스 사용자의 보고를 통해서 알게 되는 경우가 생길 수 있다. 이러한 문제를 방지하기 위해서 문제가 발생했을 때 일부러 커스텀 예외를 정의하여 반환해 실행을 멈춰서 알리도록 한다.

프로그래밍 언어의 디폴트로 내장된 예외 객체 라이브러리에서 정의한 예외 객체를 발생시키면 이 예외 객체는 예외가 발생하는 코드를 감싼 try-catch 문을 통해서 해당 예외를 포착할 수 있다. 물론 try-catch 문을 사용하지 않으면 예외가 발생했으므로 프로그래밍 언어에 의해 예외가 포착이 되어 멈추거나, 라이브러리에 의해 예외가 포착되어 멈추게 되고, 예외가 발생했을 때 별도의 처리를 해 줘야 한다면 try-catch로 예외를 잡아서 처리를 해 주면 된다.

### 예외의 구현

예외를 사용할 때는 인터페이스로 php언어에서 제공하는 [`Throwable`](https://www.php.net/manual/en/class.throwable.php) 인터페이스를 사용하고, 클래스로는 php 언어에서 제공하는 [`Exception`](https://www.php.net/manual/en/class.exception.php) 클래스를 사용한다.

예외는 프로그래밍 언어에 기본적으로 내장된 예외 객체를 상속하여 만들어지며, `Throwable` 인터페이스로 직접 예외 객체를 구현하여 만들 수 없다. `Throwable`이란 `throw`라는 문법을 통해서 던질 수 있다는 의미를 갖고 있으며, 모든 php의 예외 클래스는 php 언어의 기본 `Exception` 클래스를 상속 받아 만들어지고 php 기본 `Exception`은 `Throwable` 인터페이스를 구현하고 있기 때문에 모든 예외 클래스는 자동으로 `Throwable` 인터페이스에 부합한다. 따라서 모든 예외 객체는 `throw` 문법을 통해서 던질 수 있다.

### 예외의 캐치

예외는 예외를 던진 부분을 실행하는 코드에서 실행된다. A라는 코드가 B를 실행하고, B라는 코드가 C를 실행하고, C라는 코드에서 예외를 던지게 되면, C의 예외 발생한 부분을 감싸는 `catch` 문이 있다면 `catch`문에서 예외를 잡고, C를 감싸는 `catch` 문이 없다면, B라는 코드를 감싸는 `catch` 문이 있는지 확인하고 있다면 예외를 잡고, 없다면 A라는 코드를 감싸는 `catch`문이 있는지 확인을 하고 있다면 예외를 잡고, 없다면 php의 전역 예외 처리기에 예외를 던지고 예외를 처리하지 못하면, php 프로세스는 종료가 된다. (이렇게 코드를 실행하는 맥락을 거슬러 올라가는 것을 버블링이라고 부른다.)

예외는 예외를 실행하는 코드를 둘러싼 부분에서 코드를 처리한다. A, B, C를 둘러싼 어디서 코드를 처리한다는 것이다. 하지만 발생한 에외를 처리하는 곳이 A, B, C 중의 한 곳을 선택한다고 처리 로직의 맥락과 흐름에 맞는가를 생각해 봐야 한다. 아키텍처적으로 C에서 발생한 예외를 B에서 처리하도록 하면 좋은 구조를 특별히 만들지 않는한, 예외를 처리할 부분으로 적당한 곳을 선정하기 어려운 문제가 있다.

로직을 실행하는 구조나 계층에 따라 동일한 예외에 대한 처리를 다르게 처리해야 하는 경우가 있다.

```php
try {
    try {
        throw new CustomException();
    } catch(CustomException $e) {
        // B : $e에 대한 예외 처리 로직
        throw $e;
    }
} catch(CustomException $e) {
    // A : $e에 대한 예외 처리 로직
}
```

위 로직에서 B에서 예외를 잡아서 처리를 하고 다시 이를 B에서 처리할 수 있도록 예외를 다시 던지는 경우를 생각해 볼 수 있다. 계층형 아키텍처를 사용할 경우, 각각의 계층에서 동일한 예외라도 처리를 달리해야 하는 경우가 있을 수 있다. 이런 경우, 예외를 잡은 후 다시 예외를 던지는 방식으로 코드를 짤 수도 있다.

#### throwable 인터페이스로 케치

```php
try {
} catch(Throwable $e) {
}
```

모든 예외는 php의 `Throwable` 인터페이스의 구현인 내장 `Exception` 객체를 통해서 상속을 받아 만들어지기 때문에 `Throwable` 인터페이스는 모든 예외를 케치할 수 있다.

php에는 예외(`Exception`) 뿐만 아니라 에러(`Error`)가 존재한다. 예외와 에러는 모두 `Throwable` 인터페이스의 구현체이다. 예외 뿐만 아니라 에러도 잡고 싶다면 `Throwable`을 사용하면 된다.

여러 인터페이스 유형을 상속 받는 관계를 생각해 보자. `Throwable` 인터페이스는 모든 예외 객체가 갖고 있는 값이지만, 어떤 예외 객체는 다른 유형을 함께 구현했다고 하자. 그럼 해당 인터페이스만 구현된 예외 객체의 그룹을 선택적으로 catch 할 수 있다. php는 다중상속을 지원하지 않지만, 인터페이스를 통해서 상위-하위 관계가 아닌 여러 타입을 가질 수 있다. 상위-하위 관계는 아니지만 특정 유형의 예외를 그룹화 하고 싶을 때 인터페이스를 이용한 예외를 만들어 유형별로 케치를 할 수 있다.

```php
try {
} catch(CustomAddtionalMethodExceptionInterface $e) {
}
```

하지만 예외 처리는 `Throwable&CustomAddtionalMethodExceptionInterface`과 같은 교차 유형을 지원하지는 않는데, 이런 기능 도입에 미흡한 것을 보면 인터페이스를 통해서 예외를 케치하는 것을 자주 사용하는 것 같지는 않아 보인다.

하지만 인터페이스를 활용해 그룹화 하는 것 보다 보통은 `|` 파이프 기호로 `catch`할 대상들을 나열하는 방식, 여러 타입의 예외를 받을 수 있는 구문을 자주 사용한다.

```php
try {
} catch(Exception1 | Exception2 | Exception3 $e) {
}
```

위의 방식으로 여러 타입의 대상을 하나의 케치문에서 받아서 해당 `catch` 문에서 공통된 처리를 할 수 있다.

#### 예외 객체로 캐치
```php
try {
} catch(Exception $e) {
}
```

`Throwable` 인터페이스를 사용하지 않더라도 php의 디폴트 내장 `Exception` 객체를 사용하여 모든 객체를 잡을 수 있다.

`Exception $e`에서 `Exception` 부분은 케치하는 대상의 타입을 지정하는 부분이다. 타입힌트와 마찬가지로 자신의 하위 타입을 모두 받을 수 있는 특징을 갖는다.

하위 타입은 상위 타입의 인터페이스를 포함한다. 하위 타입에서는 상위 타입이 가지지 못한 인터페이스를 추가할 수 있다. 컴파일 언어의 경우, `Exception`으로 하위 타입의 예외 객체를 받으면 추가된 인터페이스에 접근 불가능한 특성이 있으나, php와 같은 동적 언어는 `Exception` 타입으로 캐치를 할 때 하위 타입에 접근할 수 있다.

`catch` 구문에서 상위 타입을 지정하게 되면, 하위 타입은 모두 받게 되고 하나의 try-catch 문에서 catch를 여러번 사용했을 때 먼저 실행 된 `catch` 문에서 예외를 포착했다면, 다음으로 실행된 `catch` 문에서 동일한 타입의 예외를 캐치할 수 없다.

```php
try {
} catch(Exception1 $e) {
} catch(Exception2 $e) {
} catch(Exception3 $e) {
} 
```

위의 코드에서 `catch` 문은 단 한 곳에서만 실행이 된다. `Exception1`에서 예외를 잡았다면 다음 catch 문에서 잡을 수 없고, `Exception2`에서 예외를 잡았다면 다음 `catch` 문에서 잡을 수 없다.

#### 커스텀 예외 캐치

```php
class CustomException extends Exception
{
    public function __toString() {
        return "Custom Exception";
    }
}

class CustomException2 extends Exception
{
    public function __toString() {
        return "Custom Exception2";
    }
}
```

위의 코드는 아래의 예제에서 사용할 커스텀 예외 클래스를 정의한 것이다.

```php
try {
    throw new CustomException();
    echo "try completed\n";
} catch(Exception $e) {
    echo "all Exception catch\n";
} catch(CustomException $e) {
    echo "$e catch\n";
} finally {
    echo "finally is always run\n";
}
```

위 코드는 상위 타입 `Exception`에서 하위 타입 `CustomException`을 받기 때문에 `catch(Exception $e) { echo "all Exception catch\n"; }` 부분이 실행되며, `catch(CustomException $e) { echo "custom Exception catch\n"; }` 부분이 예외를 케치 할 수 있는 부분임에도 불구하고 앞선 `catch` 문이 먼저 예외를 케치하여 실행되지 않는다.

```php
catch(CustomException $e) {
    echo "$e catched\n";
} catch(Exception $e) {
    echo "all Exception catched\n";
}
```

위와 같이 하면 `CustomException`가 먼저 실행되고 나머지 에러에 대해 포착하는 `Exception`가 실행되는 순서가 되므로 나머지 모든 에러를 잡아서 처리하고 싶을 때 그에 앞서 특정한 에러를 먼저 잡아 낼 수 있다. 곧, `catch`를 작성하는 순서는 더 작은 범위 부터 큰 범위 순의 에러를 포착하는 방향으로 만들어야 큰 범위의 `catch`에서 포착되어 작은 범위의 `catch`에서 포착할 수 없는 일이 발생하지 않는다.

```php
try {
    throw new CustomException2();
    echo "try completed\n";
} catch(CustomException $e) {
    echo "$e catched\n";
} catch(CustomException2 $e) {
    echo "$e $e catched\n";
} finally {
    echo "finally is always run\n";
}
```

`throw new CustomException2();`로 예외를 던진 케이스를 보면, `catch(CustomException $e) { echo "$e catched\n"; }`에서는 타입 불일치로 예외를 잡지 않고, `catch(CustomException2 $e) { echo "$e catched\n"; }`에서는 예외를 잡는다.

### 예외 트리

예외를 그룹화 하기 위해서는 예외를 잘 분류해야 한다. `catch` 문에서는 슈퍼 타입을 타입힌트로 적어 주면 서브 타입은 모두 예외로 포착할 수 있다. 따라서 슈퍼 타입으로 서브 타입을 그룹화 하여 그룹에 해당하는 예외를 포착할 수 있는 것이다.

가장 먼저 `Exception`이라는 php의 내장 최상위 예외 클래스를 베이스로 상속하는 예외 클래스를 여럿 만든 후 이 예외 클래스의 상속을 받는 예외들을 만들어 나간다. 이러한 예외 생성과정은 트리의 형태를 띄고 있기 때문에 '예외 트리'라고 부를 수 있다.

```php
Exception -- Exception-A -- Exception-A-A -- Exception-A-A-A
          |              |                -- Exception-A-A-B
          |              |                -- Exception-A-A-C
          |              |- Exception-A-B -- Exception-A-B-A
          |                               -- Exception-A-B-B
          |                               -- Exception-A-B-C
          |- Exception-B -- Exception-B-A -- Exception-B-A-A
                         |                -- Exception-B-A-A
                         |                -- Exception-B-A-C
                         |- Exception-B-B -- Exception-B-B-A
                         |- Exception-B-C -- Exception-B-C-A
```

위의 예외 트리를 보면, `Exception-A-A`라는 예외는 이를 상속하는 `Exception-A-A-A`, `Exception-A-A-B`, `Exception-A-A-C`의 예외를 받을 수 있다. 이러한 예외 트리를 생성하는 것을 통해서 예외를 분류 및 그룹화 할 수 있다.

### 처리의 중단과 상태 복구

어떤 처리를 함에 있어서 예외가 발생하면 catch로 잡아서 처리하지 않는 한 에러가 발생하고 프로세스는 종료된다. 하나의 프로세스에서 여러 스레드로 리퀘스트를 처리하는 php 이외의 다른 여러 프로그래밍 언어의 프레임워크들은 예외를 하나의 리퀘스트틑 처리 단위로 자동으로 잡아서 에러 로그를 남기고 해당 리퀘스트 처리를 종료 시킨다. 이는 하나의 리퀘스트가 독립된 처리 단위이며 다른 리퀘스트에 영향을 주지 않기 때문에 채택되는 방식이다.

처리를 중단하게 되면, 에러가 나서 처리가 중단된 이전 부분까지의 로직의 진행 과정에서 상태 변경(데이터베이스의 값의 변경 등)이 일어났다면 이를 복구 해 줘야 한다. 이를 위해 데이터를 저장하는 부분의 로직에서는 적절하게 트렌젝션 처리를 해 줘야 하며, 처리를 하면서 지속적으로 상태를 변경하는 로직을 짜는 것 보다는 리퀘스트 단위 내에서 다 처리하고 한 번에 상태 변경을 시도하는 것이 좋다. 예를 들어 어떤 데이터를 파일로 저장을 하는데 조금씩 파일에 저장하는 로직 보다는 리퀘스트 처리 과정에서 파일을 만들어 한 번에 외부 저장소에 저장하는 편이 낫다. 그렇지 않다면 동일한 결과를 만드는 리퀘스트가 다시 실행되었을 때 이전의 실패한 처리에 영향을 받지 않도록 로직을 짜야 하는데, 실패로 변경된 외부 상태를 초기화하는 로직이 필요하다.

예기치 못한 처리로 인해서 중단된 경우를 위해 상태 변경의 영향을 최소화하기 위한 코드를 짜는 것이 중요하다. 해당 리퀘스트 처리 내에서의 상태 변경 이상의 반영구적인 상태 변경을 초래하는 코드의 경우 코드를 짜는데 있어 주의를 요구한다.

일부러 예외를 던져서 처리를 중단시키는 방법을 사용할 경우, 예외 처리는 던진 예외에 대한 처리만을 담당하도록 한다. 따라서 해당 예외 이외의 예기치 못한 부분에서 발생한 로직의 처리는 하지 못한다. 그래서 항상 반영구적인 상태 변경에 주의해서 코드를 작성하는 생각을 할 수 있어야 한다.

### 처리 후 실행해야 하는 예외와 처리 후 종료해야 하는 예외

예외 처리를 한 후, 로직을 멈추고 싶은 경우가 있을 것이다. `catch`로 예외를 잡아서 예외 처리를 한 후, 잡은 예외를 다시 던져서 처리를 종료시키는 방법이 있다. 하지만, 처리를 멈추기 위해 잡은 후 처리한 후 다시 던진 예외가 다른 계층에서 잡혀서 프로세스가 종료되지 않을 수도 있다. php에서는 프로세스를 강제적으로 종료시키는 `exit`를 생각할 수 있는데, 프레임워크의 처리 또는 전역 예외 처리기에 정의된 로직을 실행하지 않고 처리를 강제 종료 시키는 키워드로 사용하지 않는 것을 권장하는 안티패턴이다.

예외 처리는 기본적으로 처리의 중지를 염두하여 만들어져야 한다. 예외가 발생했을 때 어떤 처리를 한 후, 다시 예외를 던져서 충분히 준비되지 못한 로직의 실행을 막기 위함이다. 특별한 맥락에서 예외 처리 후 예외를 다시 던지지 않고 계속 처리를 진행할 수 있는데 예외를 포착한 이후, 그 다음 로직의 진행을 해도 문제가 없다는 판단하에 처리되어야 한다. 따라서 기본적으로 던진 예외는 중단을 전제로 처리될 수 있도록 만들어, 어떤 작은 단위의 코드를 작성할 때 예외 처리를 발생 시켜 해당 처리의 이후 과정을 진행하지 않아도 된다는 개념을 가져도 문제가 없도록 해야 하며, 이를 위해서 예외는 처리는 던져진 예외에 대한 처리만 수행하며, 예외가 던져진 맥락에서의 비즈니스 로직의 처리에 영향을 주지 않는 방식으로 짜여져야 한다.

### 예외 처리를 꼭 해야 하는가?

#### 예외를 다루는 방법

예외는 처리되지 않으면 최종적으로는 프로세스를 정지시킨다. 프로세스를 정지하는 것은 처리되고 있던 상태를 날려버리거나 처리의 되어야 할 데이터의 일부에 결함이 생기는 것이기 때문에 정지되지 않도록 만들 필요가 있다. 하지만, 프로그램을 작성하다 보면, 예외 처리를 해야하지만 미처 예외 처리를 하지 못하는 경우도 있고, 어떤 라이브러리의 기능을 사용했는데 충분히 사양서를 읽지 않아 특정 조건에서 예외가 던져지는 줄 몰랐을 경우도, 예외를 처리 해야 했지만 하지 못한 실수가 발생할 수 있다. 이런 경우 처리되지 않은 예외라면 최종적으로는 프로세스의 처리를 멈추고 예외를 개발자에게 보고하여 왜 예외가 발생했고 예외가 발생하지 말았어야 했는데 예외가 발생해서 처리 로직을 바꿔야 할지, 예외를 처리해야 했는데 처리를 누락해서 처리 로직을 추가 해 줘야 할지를 판단해서 예외가 발생하지 않도록 만드는 것이 올바른 방법이다.

#### 에러를 사용할 때

기본적으로 에러는 발생되지 않도록 코드를 만들어야 한다. 정수 연산에서 정수의 범위가 초과한 케이스, 0으로 나눈 케이스, 타입힌트와 값의 타입이 불일치하는 경우 에러로 처리 되는데 이런 케이스는 발생하지 않도록 프로그래밍을 해 줘야 한다. 사전에 로직을 잘 구성하여 정수의 연산의 범위가 범위를 초과하지 않도록 코드를 만들어야 하며, 0으로 나눠지지 않도록 로직을 구성해야 하며, 전달되는 값이 타입힌트의 지정한 타입이어야 한다. 이런 에러는 예외 처리의 대상이 되기 보다는 프로세스의 실행을 멈추는 것이 마땅하며, 프로그래머는 에러가 발생하지 않게 코드를 짜 줘야 한다. 예를 들어 분기 처리를 할 때 특정 분기에 대해서는 코드가 실행되지 않는 케이스가 존재할 수 있다. 이럴 때는 예외를 던지기 보다는 에러를 던져서 처리를 멈추고, 프로그래머는 보고된 에러가 발생하지 않는 로직을 만들어 줘야 한다.

#### 예외를 만드는 이유

어떤 로직이 동작할 때 각종 전제 조건을 요구하는 경우가 많다. 완성된 프로그램과 달리 라이브러리나 프레임워크 또는 특정한 기능을 따로 재사용할 수 있도록 분리한 모듈을 사용할 때 프로그래머는 실행에 필요한 전제조건을 충족하지 못할 수 있다. 이를 사용하는 프로그래머의 로직은 미리 모든 전제 조건을 구비하지 않고 기능을 실행하는 경우가 많다. 어떤 부분이 부족하기 때문에 실행이 되지 않는지 알려주어 실행에 필요한 전제 조건을 프로그래머가 채워 넣기를 기대하기 때문에 또는 로직이 실행되기 전에 미리 충분한 전제조건 마련할 수 없는 경우에 대한 별도의 처리를 할 수 있도록 예외를 만든다.

#### 에러와 예외의 용도

에러는 발생되지 않도록 코드를 짜는 것을 요구하는 반면, 예외는 발생되지 않도록 코드를 짜거나 필요한 경우 캐치하여 처리할 것을 기대하는 경우 사용하도록 한다. 물론 에러도 예외처럼 잡아서 처리할 수 있다. 예외를 잡아서 처리하는 것은 일반적인 반면, 에러를 잡아서 처리하는 것은 특별한 케이스에만 사용하며, 지극히 드문 일이다. 재사용할 수 있는 어떤 기능을 만들 때 예외를 잡아서 처리할 것도 염두에 둔다면 예외로, 그렇지 않고 반드시 발생하지 않아야 하는 의도라면 에러를 사용하도록 하자.

#### 예외를 잡아서 처리하는 것을 피하자.

Error는 에러가 발생할 상황이 일어나지 않도록 해야 하는 것인데 반해, 예외는 일어나지 않아야 하는 상황 뿐만 아니라 일어날 수도 있는 상황에서 사용한다. 별도의 처리가 없는 예외는 프로세스를 종료시키므로 반드시 처리를 하여 프로세스가 정지되지 않도록 해 줘야 한다. 예외는 어떤 로직의 처리에 문제가 있어 예외가 발생하고, 해당 문제가 해결되지 않은 불완전한 로직을 해소할 수 있는 특별한 해결책이 담긴 로직으로 기존의 메인 로직과는 다른 별도의 로직을 구성해서 전개한다. 또 다른 해결책은 에러처럼 예외가 일어나지 않도록 미리 로직을 구비하는 것이다.

예외 처리는 스텍 트레이스를 생성해야 하기 때문에 다른 코드들의 처리에 비해 무겁다. 또한 골든 케이스가 아닌 처리되지 않는 특별한 케이스에 대한 처리를 고려해야 하기 때문에 예외 처리는 까다롭다. 로직이 잘 전개되는 것을 생각하는 것만 생각해도 생각해야 할 플로우와 만들어야 할 코드가 많은데 특정 부분의 문제로 로직이 잘 전개되지 않을 경우의 처리 플로우와 코드를 함께 작성해야 하므로 까다롭다. 그래서 가능한 예외 처리를 하기 보다는 예외가 발생하지 않도록 코드를 짜는 것이 좋다. 예외가 발생했을 때 예외를 잡아서 처리하는 로직을 생각하기 보다는 왜 예외가 발생했고, 예외가 발생된 원인을 파악하고 미리 전제 조건을 잘 설정할 수 있는지를 먼저 생각해 보아야 한다. 미리 전제 조건을 설정할 수 없는 특별한 경우에만 예외 처리를 하도록 하자.

#### 굳이 에러나 예외를 만들어야 할까?

커스텀 예외나 커스텀 에러를 만드는 것은 여러 보일러 플레이트를 요구한다. 또한 별도의 에러처리를 만드는 것은 많은 시간을 요구한다. 많은 사람들이 사용할 공통의 모듈을 설계하고 다른 사람이 재사용할 수 있는 코드를 만들 때는 커스텀 예외나 에러를 만들어 어떻게 에러가 발생하지 않도록 예외는 발생하지 않거나 별도의 처리를 요구하도록 기대하는 의도로 구비하도록 한다. 하지만 코드를 사용하는 사람들이 의도한 대로 사용할 수 있을 때는 당장 커스텀 에러나 예외를 만들지 않고 나중으로 미루는 방식을 채택할 수도 있는데, 코드의 사용 방법이 정해져 있고, 특정 방법으로 사용해서는 안 된다는 것을 쉽게 알 수 있고, 소수의 개발자들의 프로젝트라서 사용법을 서로 묻고 답하기 쉬운 경우, 개발에 참여하는 사람들이 어떤 오류가 발생했을 때, 내부 코드를 읽고 파악하는 수고에 거부감을 느끼지 않는 단계일 때, 코드가 계속 변화하는 과도기적 단계라서 커스텀 에러나 예외를 정의하는 것이 적절한지 의문이 들 수 있는 경우 커스텀 에러나 예외를 만들지 않는 방식을 통해서 최소한의 기능을 구체적인 예외를 정의하는 것을 생략해서 좀 더 빠르게 만들 수 있다. 이 때는 커스텀 에러나 예외를 생략하므로 `assert`를 적극적으로 활용하여 코드를 어떻게 사용하면 좋을지 알려주는 방법을 쓰는 것이 좋다.

#### 실행을 중단하기

어떤 처리를 함에 있어서 해당 처리를 중단시킨다는 것은 상당히 중요한 일이다. 처리를 중단하여 애플리케이션의 상태를 변경하는 일을 막기 위해서 상태 변경을 한다. 그럼 어떻게 중단해야 할 것인가를 생각해 봐야 하는데, `exit`를 사용해서 중단하는 방법을 생각해 볼 수 있다. CGI 방법에서 php의 하나의 리퀘스트를 담당하는 프로세스를 `exit`를 사용해서 강제적으로 종료를 하게 되면 어떤 로직의 처리를 중단하고 그 뒤에 아무런 처리를 하지 않는 상태가 된다. 어떤 문제가 발생했을 때 로그를 남겨야 될 수도 있고, 어떤 처리가 중단 되었을 때 프레임워크에서 후속적으로 처리 해 줘야 하는 일이 발생할 수도 있다. 이런 모든 가능성을 차단하고 `exit`로 실행을 중단하는 것은 실행을 중단해도 아무런 문제가 없을 것이라는 판단이 있어야 가능하다.

혼자서 생으로 php를 사용하는 경우에는 후속처리로 아무것도 하지 않아도 된다는 판단을 할 수 있기 때문에 사용할 수 있다고 본다. 하지만, 다수의 사람에 의한 프로젝트 관리가 이뤄지거나 프레임워크 위에서 개발이 이뤄지고 있다면 어떤 후속 처리가 이뤄질지 알 수 없다. 이 상태에서 `exit`를 사용해서 강제로 종료한다는 것은 무모한 행동이라고 볼 수 있다. 혼자 생 php를 개발한다고 해도 훗날 예외에 대한 후속 처리를 정의할 수도 있는데 `exit`를 쓴 코드로 인해서 훗날 정의한 후속 처리를 해야 하는 기능이 실행되지 않을 수도 있으므로 좋은 선택이 아니다.

일반적으로 프레임워크는 예외가 발생했을 때의 프레임워크에서 처리해야 할 일들을 수행하도록 해 놓는다. 따라서 예외를 던지면, 프레임워크에서 던져진 예외를 포착하여 프레임워크의 종료에 필요한 로직을 수행 한 후 종료를 할 수 있게 처리를 하는 것이 일반적이므로 예외 처리를 활용하도록 하자.

#### 최상위 예외로 처리 중단하기

모든 php의 예외는 `Exception` 클래스를 상속 받는다고 하였다. 던져진 예외는 `catch` 문에 의해서 잡히는데, 이 때 항상 모든 예외를 잡지 않으며 지정한 예외 또는 지정한 종류의 예외만을 받을 수 있다. 커스텀 예외나 특정한 종류의 예외 객체를 던지는 것은 `catch` 문에 포착되어 무언가를 처리하기 위함이다. 특정 종류의 예외 감지기인 `catch` 문에 포착이 되어 지정한 예외 타입에 대한 준비해 둔 처리가 있다면 처리를 해 달라는 의도로 메시지를 던지는 것이다. 만약 `catch` 문에 모든 예외를 받을 수 있는 `Exception` 클래스를 타입으로 지정한다고 하자. 그럼 해당 `catch` 문에서 다시 받은 예외를 던지지 않는 한 예외가 처리된 것으로 해당 `catch` 구문 내의 코드가 실행된다. 최종적인 에러의 처리가 일어나는 부분이 아니라면 해당 로직에서 프로세스의 최종 에러 처리 로직에 에러를 전달하지 못하는 문제가 생긴다.

`catch`문에 전체 에러를 받는 `Exception` 클래스를 사용하는 것이 좋지 않은 이유는 `catch`문 내부의 어떤 코드에서 던져진 예외 객체가 포착이 되어 최종적인 에러 처리가 일어나는 곳으로 전달되지 못하게 되기 때문이다. 로직의 중단을 위해서 던져진 예외와 포착을 염두에 두고 던져진 예외를 구분해야 하는데, 로직의 중단을 위해 던져진 예외가 포착이 되어 프레임워크 등에 정의된 최종 에러 처리 구문으로 가지 않는다는 것은 처리의 중단이 의도치 않게 이뤄지는 것이다. 애플리케이션의 처리 상태에 대한 추측을 하기 어려워지는 문제를 갖고 있다. 이런 문제를 해결하기 위해서 `catch` 문에는 모든 예외를 받는 `Exception`을 사용하기 보다는 좀 더 제한된 종류의 예외를 포착하는 것이 필요하다. 이렇게 `catch`문에 `Exception`을 사용하지 않고 좀 더 좁혀진 예외를 포착하도록 정의하는 것으로 인하여 어느 부분에서든 `Exception`을 처리의 중단의 용도로 사용하는 것이 가능해진다. 또는 `catch` 문이 `Exception` 클래스의 객체를 받으면 처리 후 다시 던지는 방법을 사용하면 된다. 그런데 `catch` 문에 `Exception` 클래스를 정의한 것이 모든 예외를 포착하겠다는 것이므로 `Exception` 클래스의 객체인지 확인을 하고 던져야 하는 처리를 해 줘야 한다. 일반적으로는 세분화된 예외를 포착하는 방식을 사용하기 때문에 이를 사용하도록 하자.

예외는 예외가 발생한 코드를 실행하는 코드를 거슬러 올라가서 어느 지점의 코드를 실행했을 때 에러가 발생한지를 거슬러 올라갔을 때의 실행 지점 모두를 스텍으로 기록한다. 보통 예외에 대한 로그라는 것은 거슬러 올라갔을 때 기록한 실행 지점에 대한 기록을 보여주는 것이다. `Exception` 객체를 던지는 것을 통해서 최종 에러 처리가 일어나는 부분까지 도달하게 하여 최종 에러 처리가 이뤄지는 곳에서 예외를 기록하던지 보고하던지 통지하던지 한다.

#### 변수에 어떤 상태를 담아서 후속 처리하기

이 방법은 예외 처리를 사용하지 않고 처리가 실패했을 때의 값을 변수에 담거나 함수의 반환값으로 리턴을 해서 변수나 반환 값이 특정 상태인 경우 이 값을 처리하는 로직에 전달해서 처리하는 방법이다. 예외 처리가 `catch`로 예외를 잡아서 해당 상태일 때의 처리 로직을 수행했다면, 특정 값이 변수에 담기거나 반환이 되었을 때 해당 처리 로직에 맡기는 방식이다. 이 과정은 처리된 결과 데이터를 전달하는 과정에서 메인 로직의 흐름과 동떨어진 예외적인 상황을 처리하는 코드를 만들게 될 수 있단는 것이 흠이며, 반환값으로 `null`이나 `false` 등을 사용하게 된다면 이게 별도로 처리해야 할 에러 상태인지 애매할 수 있다는 문제가 있을 수 있다. 이를 해결하기 위해서 [Enum을 통해서 에러 객체를 반환하는 방식](https://peakd.com/hive-168588/@crell/much-ado-about-null)으로 만들 수 있는데, 예외처리를 해도 커스텀 예외를 만드는 것도 귀찮은 일이므로 상황에 따라 적절한 방법을 선택하도록 하자.

### 런타임 예외와 로직 예외

php의 예외는 기본적으로 RuntimeException과 LogicException으로 나뉜다. 이는 php 언어에 내장된 예외 분류 체계로

```
Exception
  |-- RuntimeException
  |-- LogicException
```

#### [RuntimeException](https://www.php.net/manual/en/class.runtimeexception.php)
> Exception thrown if an error which can only be found on runtime occurs.

런타임 예외는 코드의 실행 중, 일반적으로 던져지는 예외로 별도의 예외 처리로 이 예외를 잡아서 처리하거나, 이 예외가 발생하지 않도록 사전 조건을 만족하도록 로직을 구성하는 등 상황에 따라 적절한 처리를 할 때 사용하면 되는 에러이다. 일반적으로 php에서 예외 처리를 요구하는 예외의 경우 RuntimeException 클래스를 상속해서 예외를 만든다.

#### [LogicException](https://www.php.net/manual/en/class.logicexception.php)
> Exception that represents error in the program logic. This kind of exception should lead directly to a fix in your code.

로직 에러는 이런 예외가 발생하지 않도록 코드를 짜야 하는 것을 의미한다. 이는 위에서 설명한 Error의 처리와 비슷하게 이런 예외가 발생하지 않도록 사전에 미리 예외가 발생하지 않도록 코드를 만들어 주어야 한다. PHP에서 Error 클래스는 일반적으로 php의 내부 에러 (php 엔진에서 발생하는 에러)를 처리하는데 사용되며, 일반 사용자의 경우, 발생하면 안 되는 에러의 경우 LogicException 클래스를 사용하여 나타낸다.

### 스텍 트레이스

에러나 예외가 발생하면, 어떤 실행의 흐름에서 문제가 생겼는지 알려주는 스텍트레이스란 개념이 존재한다. 에러를 던져서 잡지 않은 부분까지의 실행의 흐름을 기술하기 위해서, 해당 코드를 실행하기 까지의 함수 (메소드, 기명 함수, 익명 함수)의 순서를 모두 나열하는 것을 통해서 어떤 문제가 발생했는지 알려주는 것이다.

스텍트레이스를 만들고 예외를 로깅하는 모든 과정은 상당한 비용을 초래한다. 이는 작은 규모의 프로젝트에서는 특별한 문제가 되지 않지만, 큰 규모의 프로젝트에서는 한 번 에러가 터진 곳에 수 많은 리퀘스트가 서버로 들어 올 때 에러가 발생하면 많은 에러가 동시에 발생하게 되고 에러는 리소스를 많이 사용하기 때문에 대규모의 시스템 리소스를 잡아먹고, 결국 시스템이 설정한 메모리 한계를 초과하게 되어 서버가 터지는 등의 문제가 발생한다.

php의 경우에는 하나의 리퀘스트는 처리할 수 있는 메모리량이 정해져 있고, 해당 메모리를 초과하면, 다른 리퀘스트에 피해를 주지 않기 위해서 프로세스를 강제 종료하고 메모리를 날린다. 그리고 php가 소모하는 메모리량은 기본적으로 리퀘스트당 128MB 정도로 상당히 높고, 하나의 서버에서 많은 동시 처리를 감당하지 않기 때문에 메모리 문제로 인해 리퀘스트가 다운되는 경우는 있어도 서버가 다운될 경우는 극히 드물다.

php에서 스텍 트레이스가 갖는 메모리 소모량은 큰 문제가 되지 않을 수 있지만, CPU 리소스도 많이 소비하기 때문에 대량의 에러가 발생하면 CPU의 처리 작업으로 인해 리퀘스트 큐가 처리되지 못하고 쌓여 처리가 지연될 수 있다는 문제가 있을 수 있다. 보통 서버의 스케일은 평상시 운용한 결과를 보고서 결정하는데, 갑작스런 예외는 예상 이외의 리소스를 소모할 수 있기 때문에 처리 지연으로 인한 문제가 발생할 수 있다.

이런 문제를 해결하기 위해서, 처리 비용을 소모하는 스텍트레이스를 만드는 방식이 아닌, 변수에 에러 객체를 담아서 후속 처리하는 로직을 만들 수도 있고 함수형 프로그래밍에서 either을 사용하는 것과 비슷한 방식으로 enum과 에러 객체를 조합하여 에러를 처리하는 로직을 만들 수도 있다. 하지만 이는 php에서 일반적인 방식의 처리 방향은 아니다.

### 예외 처리는 때로는 비즈니스 로직의 플로우를 동반한다.

단순히 코드를 작성하는 보일러 플레이트, 예외를 그룹핑하는 문제 뿐만 아니라, 예외 사항이 일어났을 때, 어떻게 처리해야 하는 것이 좋은지 생각해야 하는데, 일반적으로 로깅과 통지를 하는 코드를 만드는 것이 좋지만, 때때로 비즈니스상에서 별도의 처리 플로우를 만들어야 하는 경우도 있다. 일반적으로 비즈니스 로직 구성할 때는 골든 패스만을 생각하기 때문에 예외를 만들어야 하는 경우에는 골든 패스 이외의 또 다른 예외 처리에 따른 비즈니스 로직을 구성해야 하고 이럴 경우, 개발자 단독으로 결정하는 것이 아닌, 운용이나 기획하는 사람들과 재차 논의와 소통을 해야 한다. 이러한 비즈니스 로직을 생각해야 한다는 문제, 보일러 플레이트의 문제 등으로 인해서 예외는 특별한 상황이 아닌 한 발생하지 않도록 하도록 코드를 작성하는 것이 좋으며, 경우에 따라 예외가 필요하다면, 어떤 처리를 해야 할지 잘 생각 해 봐야 한다.

## References
- https://www.php.net/manual/en/language.exceptions.php
