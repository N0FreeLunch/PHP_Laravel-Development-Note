## 예외처리
- 모든 로직을 만들 때 일어날 수 있는 모든 경우의 수를 파악하고 그에 따른 처리를 할 수 있도록 만들면 어떠한 에러도 발생하지 않을 것이다. 어떤 로직이나 코드에 관해서는 모든 경우의 수를 파악할 수 없고 그로 인해서 미리 구비해 둔 로직으로는 처리할 수 없는 경우가 생긴다.
- 대부분의 프로그램은 미리 준비한 로직으로 처리를 할 수 없는 경우가 발생했을 때 예외 또는 에러를 발생시키며 해당 처리과정을 중단 시킨다. 이 때 프로그래머는 로그를 남기고 로그가 남겨졌다면, 에러나 예외 케이스에 대한 처리를 추가하여 해당 케이스에 대한 에러나 예외가 더 이상 발생하지 않도록 처리할 수 있다.

### 커스텀 예외
- 어떤 로직을 처리할 때 이러한 경우의 값이 전달되는 경우, 해당 로직에서는 충분한 처리 방안이나 로직이 갖춰져 있지 않기 때문에 더 이상 로직을 해당 맥락에서 처리하지 않고, 별도의 로직으로 전달하여 별개의 처리를 하는 방식을 사용할 때 커스텀 예외를 발생시킨다.
- 어떤 처리를 함에 있어서 로직을 처리하는 목적이나 맥락과는 다른 처리를 해야 할 때, 사용자 정의 예외를 발생 시켜서 별도의 로직에서 처리를 할 수 있다. 적절하게 예외를 사용함으로써 로직의 목적과 맥락에 맞지 않는 처리를 별도 뽑아내어 처리를 할 수 있으므로, 도메인 중심적인 로직을 나타내는데 불필요한 처리 과정을 함께 기술하지 않는 것으로 굉장히 깔끔한 로직을 만들 수 있다.

### 제공되는 커스텀 예외
- 프로그래밍 언어나 라이브러리에서 어떤 처리를 하는데 어떤 케이스가 발생했을 때, 언어나 라이브러리 내부에서 이러한 문제를 처리하지 않고 사용자에게 직접 예외를 처리하도록하기 위해서 일부러 커스텀 예외를 만들어 둔다.
- 물론 처리를 하는데 문제가 발생하면, 예외를 발생시키지 않고, 객체의 인터페이스나 센티널(`null` `false` 반환과 같은 구분값) 반환값을 사용할 수도 있을 것이다. 예외를 발생 시키면 일단 처리가 멈추기 때문에 사용자는 문제가 발생한 케이스에 대해 반드시 예외에 대한 처리를 해야하지만, 예외가 발생하지 않고 결과를 객체의 인터페이스 또는 함수의 반환값으로 주는 경우에는 이들 값에 대한 별도의 처리를 하지 않으면 처리가 멈추지 않기 때문에 문제가 발생했지만 문제가 발생하지 않았을 때의 로직을 그대로 실행할 가능성이 생길 수 있다. 물론 이런 경우 원하는 결과 값을 얻을 수 없기 때문에 대부분 실행 처리 과정에서 뭔가 예외가 발생하여 그 원인을 추적하겠지만 때때로 로직의 실행이 완료되어 문제가 발생했을 때 바로 알아채지 못하고 한참 뒤에 운용자 또는 서비스 사용자의 보고를 통해서 알게 되는 경우가 생길 수 있다. 이러한 문제를 방지하기 위해서 문제가 발생했을 때 일부러 커스텀 예외를 정의하여 반환해 실행을 멈추도록 한다.
- 프로그래밍 언어의 디폴트로 내장된 예외 객체 라이브러리에서 정의한 예외 객체를 발생시키면 이 예외 객체는 예외가 발생하는 코드를 감싼 try-catch 문을 통해서 해당 예외를 포착할 수 있다. 물론 try-catch 문을 사용하지 않으면 예외가 발생했으므로 프로그래밍 언어에 의해 예외가 포착이 되어 멈추거나, 라이브러리에 의해 예외가 포착되어 멈추게 되고, 예외가 발생했을 때 별도의 처리를 해 줘야 한다면 try-catch로 예외를 잡아서 처리를 해 주면 된다.

### 예외의 구현
- 예외를 사용할 때는 인터페이스로 php언어에서 제공하는 [`Throwable`](https://www.php.net/manual/en/class.throwable.php) 인터페이스를 사용하고, 클래스로 php 언어에서 제공하는 [`Exception`](https://www.php.net/manual/en/class.exception.php) 클래스를 사용한다.
- 예외는 프로그래밍 언어에 기본적으로 내장된 예외 객체를 상속하여 만들어지며, `Throwable` 인터페이스로 직접 예외 객체를 구현하여 만들 수 없다. `Throwable`이란 `throw`라는 문법을 통해서 던질 수 있다는 의미를 갖고 있으며, 모든 php의 예외 클래스는 php 언어의 기본 `Exception` 클래스를 상속 받아 만들어지고 php 기본 `Exception`은 `Throwable` 인터페이스를 구현하고 있기 때문에 모든 예외 클래스는 자동으로 `Throwable` 인터페이스에 부합한다. 따라서 모든 예외 객체는 `throw` 문법을 통해서 던질 수 있다.

### 예외의 캐치
- 예외는 예외를 던진 부분을 실행하는 코드에서 실행된다. A라는 코드가 B를 실행하고, B라는 코드가 C를 실행하고, C라는 코드에서 예외를 던지게 되면, C의 예외 발생한 부분을 감싸는 `catch` 문이 있다면 `catch`문에서 예외를 잡고, C를 감싸는 `catch` 문이 없다면, B라는 코드를 감싸는 `catch` 문이 있는지 확인하고 있다면 예외를 잡고, 없다면 A라는 코드를 감싸는 `catch`문이 있는지 확인을 하고 있다면 예외를 잡고, 없다면 php의 전역 예외 처리기에 예외를 던지고 예외를 처리하지 못하면, php 프로세스는 종료가 된다.
- 예외는 예외를 실행하는 코드를 둘러싼 부분에서 코드를 처리한다. A, B, C를 둘러싼 어디서 코드를 처리한다는 것이다. 하지만 발생한 에외를 처리하는 곳이 A, B, C 중의 한 곳을 선택한다고 처리 로직의 맥락과 흐름에 맞는가를 생각해 봐야 한다. 아키텍처적으로 C에서 발생한 예외를 B에서 처리하도록 하면 좋은 구조를 특별히 만들지 않는한, 예외를 처리할 부분으로 적당한 곳을 선정하기 어려운 문제가 있다.
- 로직을 실행하는 구조나 계층에 따라 동일한 예외에 대한 처리를 다르게 처리해야 하는 경우가 있다.
```
try {
    try {
        throw new CustomException();
    } catch(CustomException $e) {
        // B : $e에 대한 예외 처리 로직
        throw $e;
    }
} catch(CustomException $e) {
    // A : $e에 대한 예외 처리 로직
}
```
- 위 로직에서 B에서 예외를 잡아서 처리를 하고 다시 이를 B에서 처리할 수 있도록 예외를 다시 던지는 경우를 생각해 볼 수 있다. 계층형 아키텍처를 사용할 경우, 각각의 계층에서 동일한 예외라도 처리를 달리해야 하는 경우가 있을 수 있다. 이런 경우, 다시 예외를 반환하는 방식으로 코드를 짤 수도 있다.

#### throwable 인터페이스로 케치
```php
try {
} catch(Throwable $e) {
}
```
- 모든 예외는 php의 `Throwable` 인터페이스의 구현인 내장 `Exception` 객체를 통해서 상속을 받아 만들어지기 때문에 `Throwable` 인터페이스는 모든 예외를 케치할 수 있다.
- php에는 예외(`Exception`) 뿐만 아니라 에러(`Error`)이 존재한다. 예외와 에러는 모두 `Throwable` 인터페이스의 구현체이다. 예외 뿐만 아니라 에러를 잡고 싶다면 `Throwable`을 사용하면 된다.
- 여러 인터페이스 유형을 상속 받는 관계를 생각해 보자. `Throwable` 인터페이스는 모든 예외 객체가 갖고 있는 값이지만, 어떤 예외 객체는 다른 유형을 함께 구현했다고 하자. 그럼 해당 인터페이스만 구현된 예외 객체의 그룹을 선택적으로 catch 할 수 있다. php는 다중상속을 지원하지 않지만, 인터페이스를 통해서 상위-하위 관계가 아닌 여러 타입을 가질 수 있다. 상위-하위 관계는 아니지만 특정 유형의 예외를 그룹화 하고 싶을 때 인터페이스를 이용한 예외를 만들어 유형별로 케치를 할 수 있다.
```php
try {
} catch(CustomAddtionalMethodExceptionInterface $e) {
}
```
- 하지만 예외 처리는 `Throwable&CustomAddtionalMethodExceptionInterface`과 같은 교차 유형을 지원하지는 않는데, 이런 기능 도입에 미흡한 것을 보면 인터페이스를 통해서 예외를 케치하는 것을 자주 사용하는 것 같지는 않아 보인다.
- 하지만 인터페이스를 활용해 그룹화 하는 것 보다 보통은 `|` 파이프 기호로 `catch`할 대상들을 나열하는 방식, 여러 타입의 예외를 받을 수 있는 구문을 자주 사용한다.
```php
try {
} catch(Exception1 | Exception2 | Exception3 $e) {
}
```
- 위의 방식으로 여러 타입의 대상을 하나의 케치문에서 받아서 해당 `catch` 문에서 공통된 처리를 할 수 있다.

#### 예외 객체로 캐치
```php
try {
} catch(Exception $e) {
}
```
- `Throwable` 인터페이스를 사용하지 않더라도 php의 디폴트 내장 `Exception` 객체를 사용하여 모든 객체를 잡을 수 있다.
- `Exception $e`에서 `Exception` 부분은 케치하는 대상의 타입을 지정하는 부분이다. 타입힌트와 마찬가지로 자신의 하위 타입을 모두 받을 수 있는 특징을 갖는다.
- 하위 타입은 상위 타입의 인터페이스를 포함한다. 하위 타입에서는 상위 타입이 가지지 못한 인터페이스를 추가할 수 있다. 컴파일 언어의 경우, `Exception`으로 하위 타입의 예외 객체를 받으면 추가된 인터페이스에 접근 불가능한 특성이 있으나, php와 같은 동적 언어는 `Exception` 타입으로 캐치를 할 때 하위 타입에 접근할 수 있다.
- `catch` 구문에서 상위 타입을 지정하게 되면, 하위 타입은 모두 받게 되고 하나의 try-catch 문에서 catch를 여러번 사용했을 때 먼저 실행 된 `catch` 문에서 예외를 포착했다면, 다음으로 실행된 `catch` 문에서 동일한 타입의 예외를 캐치할 수 없다.
```php
try {
} catch(Exception1 $e) {
} catch(Exception2 $e) {
} catch(Exception3 $e) {
} 
```
- 위의 코드에서 `catch` 문은 단 한 곳에서만 실행이 된다. `Exception1`에서 예외를 잡았다면 다음 catch 문에서 잡을 수 없고, `Exception2`에서 예외를 잡았다면 다음 `catch` 문에서 잡을 수 없다.

#### 커스텀 예외 캐치
```php
class CustomException extends Exception
{
    public function __toString() {
        return "Custom Exception";
    }
}

class CustomException2 extends Exception
{
    public function __toString() {
        return "Custom Exception2";
    }
}
```
- 위의 코드는 아래의 예제에서 사용할 커스텀 예외 클래스를 정의한 것이다.
```php
try {
    throw new CustomException();
    echo "try completed\n";
} catch(Exception $e) {
    echo "all Exception catch\n";
} catch(CustomException $e) {
    echo "$e catch\n";
} finally {
    echo "finally is always run\n";
}
```
- 위 코드는 상위 타입 `Exception`에서 하위 타입 `CustomException`을 받기 때문에 `catch(Exception $e) { echo "all Exception catch\n"; }` 부분이 실행되며, `catch(CustomException $e) { echo "custom Exception catch\n"; }` 부분이 예외를 케치 할 수 있는 부분임에도 불구하고 앞선 `catch` 문이 먼저 예외를 케치하여 실행되지 않는다.
```php
catch(CustomException $e) {
    echo "$e catched\n";
} catch(Exception $e) {
    echo "all Exception catched\n";
}
```
- 위와 같이 하면 `CustomException`가 먼저 실행되고 나머지 에러에 대해 포착하는 `Exception`가 실행되는 순서가 되므로 나머지 모든 에러를 잡아서 처리하고 싶을 때 그에 앞서 특정한 에러를 먼저 잡아 낼 수 있다. 곧, `catch`를 작성하는 순서는 더 작은 범위 부터 큰 범위 순의 에러를 포착하는 방향으로 만들어야 큰 범위의 `catch`에서 포착되어 작은 범위의 `catch`에서 포착할 수 없는 일이 발생하지 않는다.
```php
try {
    throw new CustomException2();
    echo "try completed\n";
} catch(CustomException $e) {
    echo "$e catched\n";
} catch(CustomException2 $e) {
    echo "$e $e catched\n";
} finally {
    echo "finally is always run\n";
}
```
- `throw new CustomException2();`로 예외를 던진 케이스를 보면, `catch(CustomException $e) { echo "$e catched\n"; }`에서는 타입 불일치로 예외를 잡지 않고, `catch(CustomException2 $e) { echo "$e catched\n"; }`에서는 예외를 잡는다.

### 처리의 중단과 상태 복구
- 어떤 처리를 함에 있어서 예외가 발생하면 catch로 잡아서 처리하지 않는 한 에러가 발생하고 프로세스는 종료된다. 하나의 프로세스에서 여러 스레드로 리퀘스트를 처리하는 php 이외의 다른 여러 프로그래밍 언어의 프레임워크들은 예외를 하나의 리퀘스트틑 처리 단위로 자동으로 잡아서 에러 로그를 남기고 해당 리퀘스트 처리를 종료 시킨다. 이는 하나의 리퀘스트가 독립된 처리 단위이며 다른 리퀘스트에 영향을 주지 않기 때문에 채택되는 방식이다.
- 처리를 중단하게 되면, 에러가 나서 처리가 중단된 이전 부분까지의 로직의 진행 과정에서 상태 변경(데이터베이스의 값의 변경 등)이 일어났다면 이를 복구 해 줘야 한다. 이를 위해 데이터를 저장하는 부분의 로직에서는 적절하게 트렌젝션 처리를 해 줘야 하며, 처리를 하면서 지속적으로 상태를 변경하는 로직을 짜는 것 보다는 리퀘스트 단위 내에서 다 처리하고 한 번에 상태 변경을 시도하는 것이 좋다. 예를 들어 어떤 데이터를 파일로 저장을 하는데 조금씩 파일에 저장하는 로직 보다는 리퀘스트 처리 과정에서 파일을 만들어 한 번에 외부 저장소에 저장하는 편이 낫다. 그렇지 않다면 동일한 결과를 만드는 리퀘스트가 다시 실행되었을 때 이전의 실패한 처리에 영향을 받지 않도록 로직을 짜야 하는데, 실패로 변경된 외부 상태를 초기화하는 로직이 필요하다.
- 예기치 못한 처리로 인해서 중단된 경우를 위해 상태 변경의 영향을 최소화하기 위한 코드를 짜는 것이 중요하다. 해당 리퀘스트 처리 내에서의 상태 변경 이상의 반영구적인 상태 변경을 초래하는 코드의 경우 코드를 짜는데 있어 주의를 요구한다.
- 일부러 예외를 던져서 처리를 중단시키는 방법을 사용할 경우, 예외 처리는 던진 예외에 대한 처리만을 담당하도록 한다. 따라서 해당 예외 이외의 예기치 못한 부분에서 발생한 로직의 처리는 하지 못한다. 그래서 항상 반영구적인 상태 변경에 주의해서 코드를 작성하는 생각을 할 수 있어야 한다.

### 처리 후 실행해야 하는 예외와 처리 후 종료해야 하는 예외
- 예외 처리를 한 후, 로직을 멈추고 싶은 경우가 있을 것이다. `catch`로 예외를 잡아서 예외 처리를 한 후, 잡은 예외를 다시 던져서 처리를 종료시키는 방법이 있다. 하지만, 처리를 멈추기 위해 잡은 후 처리한 후 다시 던진 예외가 다른 계층에서 잡혀서 프로세스가 종료되지 않을 수도 있다. php에서는 프로세스를 강제적으로 종료시키는 `exit`를 생각할 수 있는데, 프레임워크의 처리 또는 전역 예외 처리기에 정의된 로직을 실행하지 않고 처리를 강제 종료 시키는 키워드로 사용하지 않는 것을 권장하는 안티패턴이다.
- 예외 처리는 기본적으로 처리의 중지를 염두하여 만들어져야 한다. 예외가 발생했을 때 어떤 처리를 한 후, 다시 예외를 던져서 충분히 준비되지 못한 로직의 실행을 막기 위함이다. 특별한 맥락에서 예외 처리 후 예외를 다시 던지지 않고 계속 처리를 진행할 수 있는데 예외를 포착한 이후, 그 다음 로직의 진행을 해도 문제가 없다는 판단하에 처리되어야 한다. 따라서 기본적으로 던진 예외는 중단을 전제로 처리될 수 있도록 만들어, 어떤 작은 단위의 코드를 작성할 때 예외 처리를 발생 시켜 해당 처리의 이후 과정을 진행하지 않아도 된다는 개념을 가져도 문제가 없도록 해야 하며, 이를 위해서 예외는 처리는 던져진 예외에 대한 처리만 수행하며, 예외가 던져진 맥락에서의 비즈니스 로직의 처리에 영향을 주지 않는 방식으로 짜여져야 한다.

### 예외 처리를 꼭 해야 하는가?

#### 실행을 중단하기
- 어떤 처리를 함에 있어서 해당 처리를 중단시킨다는 것은 상당히 중요한 일이다. 처리를 중단하여 애플리케이션의 상태를 변경하는 일을 막기 위해서 상태 변경을 한다. 그럼 어떻게 중단해야 할 것인가를 생각해 봐야 하는데, `exit`를 사용해서 중단하는 방법을 생각해 볼 수 있다. CGI 방법에서 php의 하나의 리퀘스트를 담당하는 프로세스를 `exit`를 사용해서 강제적으로 종료를 하게 되면 어떤 로직의 처리를 중단하고 그 뒤에 아무런 처리를 하지 않는 상태가 된다. 어떤 문제가 발생했을 때 로그를 남겨야 될 수도 있고, 어떤 처리가 중단 되었을 때 프레임워크에서 후속적으로 처리 해 줘야 하는 일이 발생할 수도 있다. 이런 모든 가능성을 차단하고 `exit`로 실행을 중단하는 것은 실행을 중단해도 아무런 문제가 없을 것이라는 판단이 있어야 가능하다.
- 혼자서 생으로 php를 사용하는 경우에는 후속처리로 아무것도 하지 않아도 된다는 판단을 할 수 있기 때문에 사용할 수 있다고 본다. 하지만, 다수의 사람에 의한 프로젝트 관리가 이뤄지거나 프레임워크 위에서 개발이 이뤄지고 있다면 어떤 후속 처리가 이뤄질지 알 수 없다. 이 상태에서 `exit`를 사용해서 강제로 종료한다는 것은 무모한 행동이라고 볼 수 있다. 혼자 생 php를 개발한다고 해도 훗날 예외에 대한 후속 처리를 정의할 수도 있는데 `exit`를 쓴 코드로 인해서 훗날 정의한 후속 처리를 해야 하는 기능이 실행되지 않을 수도 있으므로 좋은 선택이 아니다.
- 일반적으로 프레임워크는 예외가 발생했을 때의 프레임워크에서 처리해야 할 일들을 수행하도록 해 놓는다. 따라서 예외를 던지면, 프레임워크에서 던져진 예외를 포착하여 프레임워크의 종료에 필요한 로직을 수행 한 후 종료를 할 수 있게 처리를 하는 것이 일반적이므로 예외 처리를 활용하도록 하자.

#### 최상위 예외로 처리 중단하기
- 모든 php의 예외는 `Exception` 클래스를 상속 받는다고 하였다. 던져진 예외는 `catch` 문에 의해서 잡히는데, 이 때 항상 모든 예외를 잡지 않으며 지정한 예외 또는 지정한 종류의 예외만을 받을 수 있다. 커스텀 예외나 특정한 종류의 예외 객체를 던지는 것은 `catch` 문에 포착되어 무언가를 처리하기 위함이다. 특정 종류의 예외 감지기인 `catch` 문에 포착이 되어 지정한 예외 타입에 대한 준비해 둔 처리가 있다면 처리를 해 달라는 의도로 메시지를 던지는 것이다. 만약 `catch` 문에 모든 예외를 받을 수 있는 `Exception` 클래스를 타입으로 지정한다고 하자. 그럼 해당 `catch` 문에서 다시 받은 예외를 던지지 않는 한 예외가 처리된 것으로 해당 `catch` 구문 다음의 코드가 실행이 될 것이다. 최종적인 에러의 처리가 일어나는 부분이 아니라면 해당 로직에서 프로세스의 최종 에러 처리 로직에 에러를 전달하지 않게 되는 문제가 생긴다.
- `catch`문에 전체 에러를 받는 `Exception` 클래스를 사용하는 것이 좋지 않은 이유는 `catch`문 내부의 어떤 코드에서 던져진 예외 객체가 포착이 되어 최종적인 에러 처리가 일어나는 곳으로 전달되지 못하게 되기 때문이다. 로직의 중단을 위해서 던져진 예외와 포착을 염두에 두고 던져진 예외를 구분해야 하는데, 로직의 중단을 위해 던져진 예외가 포착이 되어 프레임워크 등에 정의된 최종 에러 처리 구문으로 가지 않는다는 것은 처리의 중단이 의도치 않게 이뤄지는 것이다. 애플리케이션의 처리 상태에 대한 추측을 하기 어려워지는 문제를 갖고 있다. 이런 문제를 해결하기 위해서 `catch` 문에는 모든 예외를 받는 `Exception`을 사용하기 보다는 좀 더 제한된 종류의 예외를 포착하는 것이 필요하다. 이렇게 `catch`문에 `Exception`을 사용하지 않고 좀 더 좁혀진 예외를 포착하도록 정의하는 것으로 인하여 어느 부분에서든 `Exception`을 처리의 중단의 용도로 사용하는 것이 가능해진다. 또는 `catch` 문이 `Exception` 클래스의 객체를 받으면 처리 후 다시 던지는 방법을 사용하면 된다. 그런데 `catch` 문에 `Exception` 클래스를 정의한 것이 모든 예외를 포착하겠다는 것이므로 `Exception` 클래스의 객체인지 확인을 하고 던져야 하는 처리를 해 줘야 한다. 일반적으로는 세분화된 예외를 포착하는 방식을 사용하기 때문에 이를 사용하도록 하자.
- 예외는 예외가 발생한 코드를 실행하는 코드를 거슬러 올라가서 어느 지점의 코드를 실행했을 때 에러가 발생한지를 거슬러 올라갔을 때의 실행 지점 모두를 스텍으로 기록한다. 보통 예외에 대한 로그라는 것은 거슬러 올라갔을 때 기록한 실행 지점에 대한 기록을 보여주는 것이다. `Exception` 객체를 던지는 것을 통해서 가능한 최종 에러 처리가 일어나는 부분으로 던져서 최종 에러 처리가 일어나는 부분에서 예외를 기록하던지 보고하던지 통지하던지 한다.

#### 변수에 어떤 상태를 담아서 후속 처리하기
- 이 방법은 예외 처리를 사용하지 않고 처리가 실패했을 때의 값을 변수에 담거나 함수의 반환값으로 리턴을 해서 변수나 반환 값이 특정 상태인 경우 이 값을 처리하는 로직에 전달해서 처리하는 방법이다. 예외 처리가 `catch`로 예외를 잡아서 해당 상태일 때의 처리 로직을 수행했다면, 특정 값이 변수에 담기거나 반환이 되었을 때 해당 처리 로직에 맡기는 방식이다. 이 과정은 처리된 결과 데이터를 전달하는 과정에서 로직의 흐름과 동떨어진 코드를 만들게 될 수 있단는 것이 흠이긴하다. 하지만 예외처리를 해도 커스텀 예외를 만드는 것도 귀찮은 일이므로 상황에 따라 적절한 방법을 선택하도록 하자.

## Reference
- https://www.php.net/manual/en/language.exceptions.php
