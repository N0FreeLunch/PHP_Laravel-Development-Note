## 정적 언어에서 null의 의미

정적언어에서 `null`이란 참조의 대상이 없을 때 이를 표현하기 위한 값이다. `null`은 기본 타입의 변수에는 할당할 수 없고, 참조 타입의 변수에만 할당할 수 있는데 이는 `null`이 참조할 대상이 없음을 나타낼 때에만 사용한다는 의미를 갖고 있다. 자바를 예로 들면, 기본 타입인 int, double, boolean이 있으며 이들을 객체로 다룰 수 있는 참조 타입인 Integer, Double, Boolean 등이 존재한다. 객체로 기본 타입을 다루게 되면 값을 다룰 수 있는 다양한 메소드들을 사용할 수 있다는 편리함을 제공한다.

참조 타입의 값은 참조할 대상에 접근하기 위해 메모리의 특정 주소를 가리키는 값을 가진다. 그런데 지정한 포인터(주소)에서 가져올 수 있는 적절한 대상이 존재하지 않는 경우 `null` 값을 반환한다.

`null`은 지정한 포인터 위치에 참조하는 대상이 없는 경우를 나타내기 때문에, 어떤 객체의 프로퍼티에 접근할 때 참조할 대상이 없는 null인 경우 프로퍼티가 존재하지 않아서 자바와 같은 언어에서는 null pointer exception라는 예외를 발생시킨다. 물론 nullsafe 연산자를 통해서 참조할 대상이 없을 경우를 확인하고 더 이상 값에 접근을 하지 않고 null 값을 반환하도록 할 수 있다.

객체는 메모리에서 생성되었다가 사라졌다가 수명을 가진 대상이다. 객체 뿐만 아니라 참조하는 대상의 상당수는 메모리에서 생성과 소멸을 한다. 이 때문에 존재하지 않는 대상을 참조하는 경우가 발생한다. 참조할 대상이 없을 때를 나타내기 위해 null 이란 값을 사용한다.

## php에서의 null

php에서는 null이 포인터를 참조하는 방식이 아닌, 할당되지 않은 값을 나타내기 위해 사용하는 하나의 타입이자 값이다.

php와 같이 동적 언어에서 값은 어떠한 유형의 값이라도 가능하다. 변수에 타입 제한이 있을 경우 제한된 타입의 값만 담을 수 있도록 형식적인 제약을 거는 것 뿐으로, 정적 언어에서와 같이 메모리 공간의 할당 문제로 형변환이 불가능한 이유가 아닌 프로그래머의 실수를 줄이고 변수 사용의 의도를 명확히 하기 위해 타입 개념이 도입되었다.

php와 같은 동적 언어에서는 `?string`, `?int`, `?array` 등 `null`이란 타입과 함께 다양한 타입을 변수에 할당 가능한 유형으로 정의할 수 있다.

이 글에서는 참조 대상이 없다는 null이 아닌 하나의 타입으로서 null을 써야 하는 이유에 대한 글이다.

## sentinel value

변수의 값을 할당할 수 있는 집합에서 특정한 처리를 위해 사용되는 특별한 값을 `sentinel value`라고 부른다. 일반적으로 비할당 또는 초기값으로 센티널 값을 사용한다.

sentinel은 보초, 감시자란 의미를 가지고 있다. 이는 sentinel value 해당하는 값은 특별한 처리를 해 줘야 하는 값이므로 변수를 처리할 때는 센티널 값인지 주의 깊게 확인하라는 의미를 가진다. 곧 감시 되어야 하는 값이란 의미이다.

센티널 값은 어떤 코드에서 동작하느냐에 따라 서로 다른 의미를 지닌다. 0과 양수만을 다루는 코드에서는 음수(보통은 -1)는 센티널 값으로 사용할 수 있으며, 자연수만 다루는 코드에서는 0은 센티널 값이 되며, `null` 또는 `false`를 병용하는 타입의 변수에서는 이들 값이 센티널 값이 될 수 있다. php8.2에서는 `false`를 하나의 타입으로 쓸 수 있고, php8.3에서는 `true`를 하나의 타입으로 사용할 수 있게 되었는데 센티널 값으로 쓰기 위한 `false`를 위한 것으로 보인다.

정적 언어에서 센티널 값은 해당 타입이 가지는 값 중에서 가장 사용되지 않는 값을 사용하는데, 배열의 경우에는 인덱스가 음수가 될 수 없으므로 -1을 인덱스의 센티널 값으로 지정할 수 있고, int 타입의 경우에는 int의 최대값인 PHP_INT_MAX(32비트 컴퓨터의 경우 2147483647)이란 값을 센티널 값으로 사용한다. 물론 이는 변수를 어떤 용도로 사용하느냐에 따라 센티널 값을 다르게 정의할 수 있다. 센티널 값에 해당하는 값을 상수로 정의를 하고 변수의 값이 상수로 정의한 센티널값에 해당하는지 확인하고 할당과 비할당 등을 확인할 수 있다.

또한 도메인의 제약에 따라 센티널 값이 달라질 수도 있는데, 엘리베이터에 탑승할 수 있는 최대 무게를 800kg라고 하면 800을 초과할 때는 엘리베이터를 움직이지 않게 하기 위해 801kg등을 센티널 값으로 만들 수도 있을 것이다. 하지만 센티널 값을 너무 임의로 지정하면 코드를 이해하는 시간이 더 걸릴 수 있으므로 보편적으로 사용되는 값을 센티널 값으로 사용하는 것을 권장한다.

### 단일 타입에서 센티널 값

int, float 집합에서 0은 단순 수 0인 값 뿐만 아니라 값의 비할당을 나타내는 특별한 값으로 쓰일 수 있는 센티널 값에 해당한다.

문자열 집합에서 `""`은 단순 빈 문자열일 뿐만 아니라 비할당을 나타내는 특별한 값으로 쓰일 수 있는 센티널 값에 해당한다.

배열에서 `[]`는 은 단순 빈 배열일 뿐만 아니라, 비할당을 나타내는 특별한 값으로 쓰일 수 있는 센티널 값에 해당한다.

### 빈값이 아닌 센티널 값

기본적으로 빈 값을 센티널 값으로 사용한다. 그러나 경우에 따라 빈 값을 센티널 값으로 할당할 수 없는 경우가 존재한다. 정적 언어는 형변환이 되지 않는 언어이기 때문에 다른 타입을 값을 센티널 값으로 사용할 수 없으나, 동적 언어는 자유로운 형변환이 가능하기 때문에 다른 타입의 값을 센티널 값으로 사용할 수 있다. 하나의 타입이 하나의 값을 가지는 `null`, `true`, `false`를 센티널 값의 후보로 쓰일 수 있으며, 기본적으로는 복합 타입의 경우 `null`을 센티널 값으로 세팅을 한다.

### 동적 언어에서 빈 값과 null을 센티널 값으로 사용하는 이유

빈 값이나 `null`이 아닌, 같은 타입 안에서의 특수한 값을 센티널 값으로 사용하는 것은 어떤 값을 센티널 값으로 해야 할지에 대한 의견이 나뉠 수 있고, 혹여라도 로직에서 센티널 값이 잘못 할당되지 않도록 로직을 잘 짜줘야 한다는 문제점이 있다. 이런 경우 센티널 값인지를 표기하기 위해 `const VALID_MAX_PRICE = PHP_INT_MAX;`와 같은 상수로 변수(`$price`)의 센티널 값을 세팅하는 등의 코드가 필요하다.

null 타입을 사용할 수 있는 것은 모든 값이 다 할당 가능성이 있는 값이어서 사용되는 타입의 어떤 값도 센티널 값으로 사용하기 모호한 경우 다른 타입으로 센티널 값을 지정할 수 있다는 장점이 있을 뿐만 아니라, 각 타입에서 사용되는 값과 사용되지 않는 값으로 무엇을 결정할지에 대한 어려움을 빈 값 또는 null 두 양상으로 줄여 생각할 수 있기 때문에 좀 더 센티널 값을 판단하기 쉽게 해 주는 장점이 있다.

## 동일 타입의 값의 문제

접근하려는 값이 동일 타입에서의 센티널 값인 경우 이 값이 실제 처리할 대상인지 그렇지 않은 구분 값인지 알 수 없다는 단점이 있다. 이 때는 해당 값이 센티널 값일 때 처리 되어야 하는지, 그렇지 않은지를 생각하는 것으로 어느 정도 판단을 내릴 수 있다. 예를 들어 수량을 나타내는 변수에서 0인 경우는 처리할 대상이 없다는 것이며, 가격을 나타내는 변수에서 0인 경우는 처리할 대상이 있다는 의미를 가진다. 수량은 0이면 구매로 이어질 수 없도록 로직을 처리하며, 가격이 0인 경우에는 어떤 이벤트에 따라서 공짜로 제품을 제공할 수도 있는 것이다. 따라서 수량은 빈 값으로 비할당을 표기해도 문제가 없지만, 가격은 빈 값이 유효한 값이므로 비할당으로 표기할 수 없다. 따라서 가격의 경우 비할당으로 `null` 타입을 사용한다.

멤버 변수의 할당과 비할당을 구분하는 것은 해당 멤버 변수를 이용하여 연산을 진행할 것인지 진행하지 않을 것인지 결정하기 위한 판단의 기준이 된다. 이 때문에 초기값의 설정이 중요한데 초기값이 `null` 인지 빈 값을 할당했는지로 구분을 할 수 있다.

만약 초기값을 정하지 않고 바로 값을 할당한 경우라면 해당 값의 센티널 값이 `null`인지 빈 값인지 알기 어려운 문제가 발생할 수 있다. php에서는 클래스 단위의 멤버 변수가 아니라면 명시적으로 타입을 지정하는데 어려움이 존재한다. 만약 어떤 값을 할당할 때 타입을 정하고 싶다면, `(fn(): Type => $var)()` 또는 `assert(is_type($var))` 같은 코드를 이용하여, 변수에 저장되는 타입의 값이 어떤 유형인지 IDE에 명시적으로 알려주는 방법도 사용할 수 있다. 익명함수를 이용한 코딩 스타일은 통상적으로 권장되는 방식이 아니므로 `assert(is_type($var))`와 같은 방식의 코딩 스타일을 추천한다. 이런 타입을 IDE에 알려주는 코딩 스타일은 보일러 플레이트를 만들기 때문에 변수에서 사용되는 코드의 타입의 범위가 어느 정도인지 추측하기 쉽도록 하나의 타입 또는 하나의 타입과 null을 사용하도록 한다.

### 변수의 타입 범위 추론하기

php에서 지역 변수 (함수 안에 정의되는 변수)는 타입 제한을 가지지 않는다. 따라서 해당 변수가 어떤 타입의 값을 갖는지 알기 어려운 문제가 있을 수 있다. 이 때 함수를 사용하여 해당 함수가 무엇에 관한 처리를 담당하는지 설명하는 것을 통해서 어떤 맥락 하에서 사용되는 변수라는 것을 통해 개발자가 생각해야 하는 범위를 줄일 수 있으므로 함수 내에서 사용되는 변수의 타입 범위를 더욱 잘 추측할 수 있게 해 준다.

여러번 중복하는 로직이 없는 경우에는 굳이 함수를 사용하지 말자는 의견이 있을 수 있다. 이는 바로 알 수 있는 로직을 함수를 사용해서 함수가 정의된 맥락으로 이동해서 코드를 읽어야 하므로 복잡해진다는 이유이다. 하지만 php에서 함수는 변수의 스코프를 분리할 수 있는 강력한 기능을 제공한다. 한 번 쓰고 마는 변수들을 함수의 종료와 함께 날려 버릴 수 있다. 함수를 잘 이용한다면 하나의 스코프에 더 이상 필요하지 않은 변수가 계속 남아 있는 것을 `unset`을 사용하지 않고서도 만들 수 있다. 또한 함수의 기능을 파악하는 것이 어려운 이유는 함수의 이름을 잘 정의하지 못해서 생긴 문제일 수 있다. 함수의 인풋과 아웃풋 함수의 이름 만큼의 기능만이 부여된 함수는 함수가 어떤 용도의 값인지 추측하기 쉽게 해 준다.

### null 보다 빈 값을 사용하는 이유

모든 값을 `null`과 병행하는 것은 로직의 분기 처리를 늘릴 수 있기 때문에 추천하지는 않는다.

예를 들어 `null`을 병용하지 않는 객체는 반드시 존재하기 때문에 `->`만 써도 괜찮은데 `null`을 병용한 객체는 `?->`을 사용하는 경우가 많다. 이 경우에도 객체가 반드시 전달되는 경우가 있으므로 `->`만 써도 충분한데, `?->`을 남용하는 경우가 생긴다. `?->`는 객체가 존재하지 않을 가능성을 고려한 것인데 `obj1?->obj2?->obj3` 이렇게 계속 객체에 접근할 경우, 어디서 `null`이 반환되었는지 알기 어려운 경우가 생길 수 있다. 이런 `?->`는 편하지만, 값이 어디서 `null`이 되었는지 알기 어렵게 하는 단점이 있다. 값의 타입을 늘리는 것은 이런 모호성과 잘못된 코딩 스타일의 코드를 늘릴 가능성을 높인다.

## null 할당의 장단점

### null 할당의 단점

일반적으로 값이 할당되지 않은 경우라면 값의 할당을 위한 로직을 실행하거나 에러를 발생시켜 값이 할당되지 않았을 경우를 배제하는 로직을 추가 해 줘야 한다. 코드의 분기문이 늘어나게 된다.

### `null`할당의 장점

빈 값과 달리 `null`을 비할당의 상태로 사용하면, 타입 불일치로 연산 과정에서 에러가 발생하기 때문에 비할당의 값을 확인하지 않고 사용했다는 것을 쉽게 알 수 있게 해 준다.

대부분의 언어에서 `null`인지 쉽게 파악할 수 있는 문법적인 설탕이 존재한다. php8 버전 이상에서는 `type1 | type2 | type3`으로 여러 개의 타입을 받을 수 있는 유니온 타입힌트가 존재한다. 이 때마다 어떤 타입과 `null` 타입을 같이 받을 수 있다는 `null | type`을 써 주는 것은 조금 귀찮다. `null | type`을 의미하는 `?type`라는 간단한 표현식. `is_object($var) && property_exists($var, 'property') ? $var->$property : null`을 `$var?->property`으로 간단히 표현하는 방법, `if(is_null($var)) $var = defaultValue`을 `$var ?? defaultValue`으로 간단히 표기하는 방법등을 제공한다.

할당과 비할당을 구분하기 위해서 null을 사용하는 것은 문법적인 구문까지 제공될 정도로 일반적으로 사용되는 값이다. 할당 비할당을 위해서 다른 특별한 타입을 사용할 필요가 없이 null으로 통일하여 어떤 타입에 추가적으로 null을 허용하고 있다면 할당과 비할당을 고려하라는 의미라는 것을 미리 파악하고 그에 맞게 사용할 수 있다.

## null에 대한 불편함을 호소

### null을 신경쓰지 않고 사용하고 싶다는 의견

할당의 유무를 판단하는데 있어서 null이 유용한 대상인 것은 맞지만, 할당이 이뤄지고 나서는 타입의 null 허용을 맘편히 잊고 사용하고 싶을 것이다. 변수가 null 값을 가지는지 체크하는 코드를 코드 중간 중간에 두기 보다는, null의 가능성을 미연의 차단하는 편이 좋다. 이를 위해 null을 사용하지 않는 변수는 null 타입을 제외하도록 한다.

로직을 처리하기 전에 할당된 값만 사용하고 비할당된 값은 사용하지 않도록 로직을 짜며, null을 의도하지 않은 로직에는 타입힌트로 null이 들어왔을 때 에러를 발생 시켜 null이 전달되지 않도록 제한을 하도록 하자. null을 비할당의 의미로 고정하기 위해 처리할 값이 없는 용도로 만들어야 하고 이외의 특별한 상태를 뜻하는 용어가 되지 않도록 null 타입을 주의 깊게 사용하도록 하자.

### 함수의 인자에 null을 전달하고 싶지 않다는 의견

함수의 인자에 null을 허용하는 코딩 스타일이 좋은 스타일이 아니라는 의견도 있다. null을 허용하는 대부분의 파라메터는 받은 null 값을 다른 유형의 디폴트 값으로 캐스팅을 하거나 내부적으로는 변환해서 사용하기 때문에, 명확히 null이란 대상을 처리하는 함수가 아니라면 암묵적인 변환을 만들어내는 nullable 파라메터를 만들지 않는 것이 올바르다는 주장이다.

null은 처리할 값이 존재하지 않는다는 의미를 나타내며, 함수는 특정 값을 어떤 방식으로 처리한다는 의미를 가지고 있다. 인자로 전달된 값을 사용해서 어떤 형태로든지 값을 처리하기 위해 사용하는데, 비할당을 나타내는 null이 들어왔을 때는 처리할 대상이 없기 때문에 함수에 전달하는 로직 자체가 잘못되었다는 생각을 할 수도 있다. 함수 내부에서 null의 변수를 사용할 경우에는 null의 인자를 전달받는 코딩 스타일이 아니라, null을 인자의 전달 받지 않았을 때 디폴트 값으로 할당하는 스타일을 사용할 수 있다.

```php
$withNullableArgument = function (string $arg1, ?string $arg2) {
    echo $arg1;
    echo PHP_EOL;
    echo $arg2 ?? '--';
}

$withoutNullableArgument = function (string $arg1, string $arg2 = null) {
    echo $arg1;
    echo PHP_EOL;
    echo $arg2 ?? '--';
}
```

`$withNullableArgument`의 두 번째 인자는 null 값을 받을 수 있지만, `$withoutNullableArgument`는 null 값을 받을 수 없도록 만들어 두었다. 두 번째 인자는 null을 인자로 받지 않는 대신에 디폴트 값으로 null을 할당한다. 따라서 null을 전달하지는 않지만, 함수 내부에서 null 상태의 변수를 사용할 수 있도록 한다.

```php
$var = null;
$withNullableArgument('Hello', $var);
if(!is_null($var)) $withNullableArgument('Hello');
```

함수에 null을 전달하지 않기 위해서 null인지 확인하는 분기 처리가 늘어났다는 단점이 생기게 되었다. 함수란 함수의 인자로 전달된 값을 통해서 함수의 동작이 어떻게 일어날 것인지 대략적인 추측을 할 수 있어야 한다. null이라는 불필요한 상태 전달을 줄였으므로 함수의 상태 변화 추측을 좀 더 명확하게 할 수 있다는 의견을 가질 수도 있다.

php9에서 php의 내장 함수는 null을 인자로 받지 못하도록 하는 [RFC](https://wiki.php.net/rfc/deprecate_null_to_scalar_internal_arg)가 통과 되었다. 이는 비록 php의 내장함수에 한하는 결정이지만, null이 인자로 들어왔을 때의 암묵적인 형변환이나 별도의 특수 처리를 추가적으로 고려하지 않고 함수를 명확하게 사용하는 이점을 제공한다.

일부 코딩 스텐다드에서는 함수의 파라메터에 null을 전달하는 경우에는 파라메터 이름의 접미어로 orNull을 붇여서 null을 파라메터로 허용할 경우 특별한 상태이므로 파라메터명에 null이 들어갈 수 있으니 해당 부분을 주의 깊게 코딩하라는 의미를 담고자 하기도 한다.

## 데이터베이스의 null

### 데이터베이스 null의 특징

- 어떤 컬럼에 유니크 제약조건이 있을 때 null 값을 가지는 여러 레코드가 존재할 수 있다.
- null 값이 있는 컬럼을 join을 할 때 A 컬럼의 null과 B 컬럼의 null은 서로 연결이 되지 않는다.
- 포함하는 조건의 쿼리를 작성할 때 null을 포함하는 별도의 조건을 추가해 줘야 한다.

### 비할당 값의 쿼리 조건 문제

특정 값이 아니다라는 조건을 검색할 때 null은 아니다의 대상이 되지 못한다. 카드 결제, 계좌 이체, 미등록을 enum 타입으로 만든다고 하자. 미등록을 null, 카드 결제를 'credit', 계좌 이체를 'account'이란 문자열로 만들 수 있을 것이다.

카드 결제가 아닌 대상을 모두 얻고 싶은 경우, `where payment_type != 'credit'`이란 코드를 만들 것이다. 이 때 미등록이 null으로 되어 있으므로 조건이 아닌 대상에 포함되지 않고 계좌 이체 대상만을 얻을 수 있다. null을 사용했다면 `where payment_type != 'credit' or payment_type is null`과 같은 코드를 만들어 줘야 하는 것이다.

생각해 보면 미등록이란 것은 미할당이 아니라, 어떤 특정한 상태를 뜻하기 때문에 비교가 가능하도록 빈 문자열 또는 'unregistered'등의 값으로 만들어 두는 것이 옳았다. 데이터베이스 컬럼의 디폴트 값을 null으로 두었을 때 이 값이 특별한 상태를 의미하는 경우, null을 포함하는 결과를 얻기 위해서 추가적인 조건 작성이 필요하다. 특별한 상태를 의미하는 경우 null이 아니라 빈 값 또는 컬럼이 갖는 타입의 센티널 값을 사용해야 별도의 조건문 추가가 없는 간결한 코드가 된다.

하지만, 프로그래밍 언어에서 빈 값이 유효한 값이어서 미할당의 값으로 null을 사용하고 싶은 경우가 있을 것이다. 데이터베이스에서 이 값을 그대로 사용하려고 한다면 컬럼 값 null이 갖는 배타적 조건 문제로 인해서 등록되지 않은 상태를 구분하기 위해서 'is_registered'와 같은 별도의 컬럼을 만드는 편이 좋다.

null이란 값을 미할당으로 사용할 때는 배타적 관계에서도 포함되지 않는 값이란 개념까지 고려하는 편이 좋다. 미할당은 상태란 개념이 일절 포함되지 않는 대상인 것이다. 그런데 미할당으로 빈 값을 사용했을 때는 배타적 관계에서 미할당도 대상 값으로 포함되기 때문에 주의가 필요하다. 예를 들어 구매 수량이 0인 경우는 존재할 수 없으므로 미할당으로 사용되는데, 특정 수량 이하인 경우, 쿼리가 `where amount <= 10`의 경우 미할당도 0이므로 카운트 되어 버린다. 0은 카운트가 되지 않도록 `where amount >=0 and amount <= 10` 등의 추가 조건 작성이 필요하다.

null을 사용할 때와 빈 값을 사용할 때 비할당의 포함 비포함을 위해서 쿼리 작성이 조금씩 달라지는 문제가 있다. null인 경우는 포함하기 위해 조건을 추가해 줘야 하고, 빈 값인 경우는 배제하기 위해 조건을 추가해 주어야 한다. 비할당의 개념을 포함할지 포함하지 않을지를 생각할 때는 배제하고 생각하는 편이 기본적이다. 따라서 디비의 경우 비할당을 빈 값 보다는 null을 사용하는 편이 좋지만, 같은 타입에서 어떤 기준 값이 비할당이라는 것은 꽤나 직관적이라서 실수를 쉽게 감지할 수 있어서 빈 값도 비할당으로 괜찮다고 본다.

하지만 특정한 빈 값이 아닌 특정 센티널 값이 비할당인 경우 데이터베이스에서는 어떤 값이 비할당인지 알기 어려운 문제가 있고 (default값을 비할당으로 볼 수 있을 것이다.), 빈 값은 비할당 값을 배제할 조건을 추가해야 하고, null은 포함해야 하는 조건을 추가해야 하는 등의 일관적이지 않은 문제가 있기 때문에 별도의 할당 비할당을 구분하는 컬럼을 만들어 함께 파악하는 스타일의 스키마를 만드는 것이 적절해 보인다. 그러면 할당 비할당 컬럼과 값 컬럼을 함께 사용하는 것을 통해서 센티널 값, 빈 값, null 등의 비할당을 동일한 방식으로 다룰 수 있다.

### 릴레이션 참조의 문제

users 테이블과 이를 참조하는 테이블의 user_id가 있다고 하자. users 테이블의 id는 유니크이고 id 값은 null이 되면 안 된다. 이는 프라이머리 키의 제약 사항이다. 이 키를 참조하는 외래키 user_id는 기본적으로 users 테이블에 존재하는 아이디를 참조한다. 레퍼런스 관계인데 존재하지 않는 아이디를 참조하는 경우, 데이터베이스는 에러 메시지를 발생시킨다. 이 때, 외래키가 null을 허용하는 경우, 참조하지 않는 값으로 null 값을 세팅할 수 있다. 참조 관계의 경우 기본 타입의 빈 값이나 센티널 값은 지정할 수 없는 반면, null은 지정할 수 있다. 따라서 id와 같은 컬럼의 경우 비할당의 값으로 null을 사용하도록 한다.

## References

- https://peakd.com/hive-168588/@crell/much-ado-about-null
- https://en.wikipedia.org/wiki/Sentinel_value
- https://wiki.php.net/rfc/null-false-standalone-typesx
- https://externals.io/message/116752
