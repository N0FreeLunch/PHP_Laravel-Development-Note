# 제네릭

## 자료구조
- 프로그래밍을 배울 때 자료구조라는 데이터를 다루는 방법을 배운다. 이 자료구조는 데이터를 저장하는 방식에 대한 것이고, 데이터를 저장하는 방식에 따라 데이터를 저장하는 과정과 데이터 더미에서 특정한 데이터를 뽑아 내고자 할 때의 효율이 달라지기 때문에 적절한 데이터 구조를 사용해서 프로그래밍을 해야 한다고 가르친다.

## php에서 자료구조
- php는 연관 배열이라는 자료 구조를 사용한다. 연관배열은 키-벨류 쌍의 데이터를 저장하는 방식이다.
- php에서 키를 지정하지 않고 배열에 데이터를 저장을 해도 0,1,2,3...의 인덱스가 생기는데 php에서 배열은 연관배열이므로 자동으로 키를 생성하기 때문이다.
- php에는 연관 배열이외에도 다른 자료구조의 개념이 존재하며 [SPL](https://www.php.net/manual/en/book.spl.php)이라는 php 언어에 내장되어 있는 자료구조를 다룰 수 있는 기능을 제공한다. 하지만 SPL 라이브러리를 사용한 사례는 잘 찾아보기 어려운데, php에서 제공하는 연관 배열으로도 다양한 처리를 할 수 있는 편리함을 제공하기 때문에 불편한 SPL 라이브러리를 사용할 필요성을 느끼지 못하는 경우가 많기 때문이다.

### spl 표준 라이브러리
> “SPL data structures are horribly designed.” — Anthony Ferrara [<sup>링크</sup>](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd)
- SPL 라이브러리는 최적화된 설계를 하지 않아서 느리다는 평이 있다. 하지만 php를 사용하는 대부분이 성능 보다는 비즈니스 로직에서 발생하는 요구사항을 처리하기 위해서 만드는 경우가 대부분이라 성능적인 비판이 있음에도 사용되는데 큰 문제가 없다.
- 연관 배열은 워낙 다양한 방식으로 다뤄야하다보니 특정한 방식으로 데이터를 다뤄야 할 필요성이 있다면 SPL 라이브러리로 데이터를 저장하여 데이터 사용 방식에 제약을 두는 편이 좋을 때 사용할 수 있다.

## 제네릭
- 프로그래밍 언어에서 제네릭은 타입에 의존적이지 않는 기능을 제공하는 것이다.
- 어떤 타입을 사용하고자 할 때 지정한 타입의 내부에서 사용할 타입을 함께 지정할 수 있는 문법을 '제네릭 문법'이라고 한다. 어떤 타입을 사용할 때 내부에서 사용할 타입을 다양하게 지정해서 사용할 수 있는 기능으로 내부에서 사용할 타입을 다양하게 지정할 수 있지만 지정할 때는 한 타입만 지정해야 한다.
- 자료구조에서 특히 제네릭을 많이 사용하는데 한 유형의 자료구조가 저장하는 값을 특정 타입에 구애받지 않고 저장할 수 있도록 하기 위함이다. 자료구조의 타입을 지정하고 자료 구조 내부에 저장할 값인 내부 타입을 지정하는 것을 통해서 자료구조에서 저장할 값을 사용할 때의 타입을 정하고 사용할 수 있다.
- 예를 들어 어떤 자료구조를 사용하는데, A라는 타입의 데이터만 저장할 수 있다면, B라는 타입일 때 사용할 수 있는 자료구조를 또 만들어야 하고, C라는 타입일 때 사용할 수 있는 자료구조를 또 만들어야 한다. 하지만, 제네릭 개념을 적용한 자료구조라면 어떠한 타입이든 저장할 수 있는 특성을 갖고 있기 때문에 저장할 데이터의 타입에 관계 없이 사용할 수 있는 유연성을 제공한다.

## 예제 코드
```php
class Lifo
{
    private array $array = [];

    public function push($value)
    {
        $this->array[] = $value;
    }

    public function pop()
    {
        return array_pop($this->array);
    }
}

$lifo = (new Lifo);
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');
var_dump($lifo->pop());
var_dump($lifo->pop());
var_dump($lifo->pop());
```
- 위의 코드는 데이터를 넣은 순서대로 데이터가 뽑히는 Last In First Out 자료구조를 php로 간단히 만든 코드이다.
- `push('a')` `push('b')` `push('c')`의 순서대로 데이터를 넣었고, 마지막에 넣은 값 부터 차례로 값이 뽑힌다.

### 타입힌트 생각해 보기
- 문자열의 값을 넣는다고 생각해 보자. 그럼 `public function push(string $value)`와 `public function pop(): string`이란 타입힌트를 줄 수 있다.
- 정수를 넣는다고 생각해 보자. 그럼 `public function push(int $value)`와 `public function pop(): int`이란 타입힌트를 줄 수 있다.
- 임의의 타입을 넣는다고 생각해 보자. 그럼 `public function push(mixed $value)`와 `public function pop(): mixed`이란 타입힌트를 줄 수 있다. 하지만 이 경우에는 데이터를 꺼냈을 때 어떤 타입인지 타입힌트에 의해 특정되지 않는다.
- 위 클래스의 내부 구조를 모르고 인터페이스만 안다고 하자. `push`와 `pop` 메소드가 있다는 것만 알고 있다. php에서는 클래스 내부에 타입힌트를 주어야 하는데, 외부에서 저장할 데이터의 타입을 결정할 방법이 없다.
- 만약 php가 제네릭을 지원한다면 `Lifo` 클래스를 사용할 때 클래스 내부에서 데이터를 저장할 때 외부에서 전달된 타입으로 제약을 걸 수 있을 것이다. `new Lifo<타입>` 이렇게 제네릭 문법을 사용해서 타입을 전달하면, `public function push(T $value)`와 `public function pop(): T`으로 `T` 자리에 클래스에서 `<타입>`으로 지정한 값의 타입 들어가 타입 안정적인 코드를 작성할 수 있다. `<string>`을 넣으면 `push(string $value)`와 `pop(): srting`이 되고, `<number>`을 넣으면 `push(number $value)`와 `pop(): number`가 된다.

### 컴파일 언어에서의 제네릭
- 컴파일 언어에서 어떤 자료 구조를 정했다면 저장할 데이터의 형식을 정해야 한다. 어떤 타입을 사용할 때 그 내부의 타입을 지정하는 것이다. 이 때 저장할 데이터가 가진 타입을 지정할 수도 있고 인터페이스를 지정할 수도 있다. 여러 타입을 지정하고 싶은 경우에는 공통의 인터페이스 또는 상위-하위 관계의 클래스 또는 여러 클래스의 공통의 상위 클래스를 타입으로 지정해야 한다. 전혀 관계 없는 두 타입을 자료구조의 데이터 타입으로 지정할 수 없으며 이는 어떤 자료 유형의 데이터 저장소에서 데이터를 꺼내 쓸 때 인터페이스가 달라지면 런타임의 동작에서 치명적인 에러가 발생할 수 있기 때문에 동일한 접근방식을 갖도록 제한을 하기 위해서이다.
- 컴파일 언어는 타입을 통해서 제한된 방식의 코딩 스타일을 제공하고 컴파일을 통해서 기계어나 기계어에 가까운 레벨의 중간언어(JAVA의 Bytecode, C#의 CLI : Common Intermediate Language)로 번역을 한다. 기계어나 중간언어는 컴파일 타임에 모든 타입 안정성을 체크하기 때문에 런타임의 동작에서 타입을 체크하지 않아도 타입으로 인한 에러가 발생하지 않는다. 이런 런타임에서 에러를 방지하기 위해 실행 도중에 타입을 체크하지 않으므로 컴파일 언어는 인터프리터 언어 보다 속도가 빠르다.
- 자료구조의 경우 데이터를 저장하고 꺼내쓰는 작업을 하는데 데이터를 꺼냈을 때 어떤 타입인지 알아야 어떤 접근을 할지 알 수 있다. 컴파일 언어는 런타임에 타입 체크를 하지 않기 때문에 데이터를 꺼냈을 때 어떤 타입인지 체크하는 동작을 하지 않고 꺼내 쓴다. 따라서 값을 사용할 때의 접근 방식을 컴파일 타임에 지정해 두어야 한다. 자료 구조의 사용과 동시에 자료 구조 안에 들어갈 타입을 지정하는데 이것이 컴파일 언어에서 제네릭이라고 부르는 문법이다.

### php에서의 제네릭
- php와 같은 동적 언어는 어떤 자료구조에 데이터를 넣을 때 타입 제약이 없다. 타입 제약이 없는 대신 하나의 자료 구조에 여러 타입의 데이터를 넣을 수 있다. 서로 상이한 타입의 값을 넣었다면 각각의 값이 갖는 접근 방식아 다름으로 인해서 런타임에서 코드가 동작할 때 동일한 타입을 사용하면 사용할 수 없는 접근 또는 정의되지 않은 접근을 할 때 에러가 발생한다. 하지만 php의 접근 에러는 프로그래밍 언어에서 통제할 수 있는 것으로 컴파일 언어에서 접근이 원천적으로 차단되어 있는 것과는 다르다.
- 프로그래밍 언어의 관점에서 php는 이미 제네릭의 정의가 말하는 것 처럼 자료 구조에 다양한 타입의 값을 저장할 수 있는 특징을 갖고 있다. 많은 컴파일 언어가 자료구조를 사용할 때 공통의 접근방식을 갖는 제한된 타입을 지정해야 하는 반면, php와 같은 동적 언어는 런타임에 발생하는 에러를 다룰 수 있기 때문에 타입을 지정하지 않더라도 자료구조에 데이터를 저장할 수 있다.

### 제네릭 문법이 없는 PHP
- php는 제네릭의 특성은 갖고 있지만, 제니릭 문법은 지원하지 않는다. 제네릭 문법은 어떤 타입을 사용할 때 그 내부의 타입을 함께 지정하는 것이다.
- 프로그래밍 언어에 타입에 대한 제약 사항이 없다면, 코드를 짤 때 실수할 가능성이 높아진다. php는 이러한 문제를 해결하기 위해서 타입힌트라는 기능을 도입했다. php에서 타입힌트는 클래스의 멤버 변수 및 함수/메소드의 인자와 반환값에 지정할 수 있다.
- 타입힌트를 지정할 수 있는 array와 같은 자료 구조를 사용할 경우 자료 구조 안에 넣을 값의 타입을 지정하여 자료 구조 안의 값을 제한하는 문법을 php에서도 지원하면 컴파일 언어와 같이 자료구조의 값을 넣거나 가져올 때 타입제한을 통해 타입 안정적인 코드를 짜고자 하는 것이 php에서의 제네릭이다.
- 예를 들어 `$array<int>`라는 코드를 썼을 때, `$array[n]`의 값은 `int` 타입이어야 하고, `$array<string>`라는 코드를 썼을 때, `$array[n]`의 값은 `string` 타입이어야 하는 제약을 거는 것이다.
- php에서는 지정한 타입의 내부에서 사용하는 타입을 지정할 수 없기 때문에 array 타입 내부에 저장할 타입을 타입힌트를 통해서 제한하지 못한다. 이 때문에 어떤 타입의 내부에서 사용할 타입을 지정할 수 없는 상황이 오면 타입힌트를 통한 타입제한을 하지 못하므로 불안한 느낌이 들 때가 있다.
- php에서는 타입힌트로 사용하고자 하는 타입의 내부 타입을 설정하는 제네릭 문법이 없기 때문에 타입힌트 위치에서의 내부 타입을 고정하는 방식이 아닌, 어떤 타입의 내부에서 사용하는 타입을 사용할 때 타입을 확인하는 방식을 사용해야한다.
- 예를 들어 배열의 경우 배열의 데이터를 꺼내 사용하고자 할 때 해당 값의 타입을 확인하는 방식이다. 데이터를 사용할 때 꺼내쓰는 데이터의 타입을 일일이 확인하는 코드를 추가해도 되지만 배열과 같은 iterator에는 콜백함수를 사용할 수 있다. php는 함수에 타입힌트를 지정할 수 있으므로 콜백함수에 타입힌트를 추가하는 것으로 값을 자료구조에 저장하거나 꺼내 쓸 때 타입을 체크할 수 있다.

### 제네릭이 없는 것이 단점일까?
- 제네릭은 무언가를 사용할 때 내부에서 사용할 타입을 지정해서 다양한 타입에 대해서 동작하는 어떠한 기능이 필요할 때 사용된다. 만약 다양한 타입에 대한 처리 기능이 있다면 해당 처리 기능을 거친 이후에 어떤 타입인지 알아야 처리후의 값을 사용할 수 있기 때문에 반드시 타입이 요구된다. 처리 후 얻어진 값의 타입을 알 수 있기 때문에, 만약 오브젝트가 얻어졌다면 오브젝트의 멤버를 IDE의 정적분석 툴을 통해서 자동완성으로 얻을 수 있고 존재하지 않는 멤버 등의 잘못된 접근 문법을 사용했을 때 코드를 직접 실행을 하지 않고서도 문법적인 잘못이 무엇인지 알려 준다.
- 그런데 php는 이미 어떠한 타입의 값이든 전달될 수 있고 전달된 값을 그대로 꺼내 쓸 수 있다. 제네릭을 굳이 쓰지 않아도 제네릭과 같은 기능을 이미 갖고 있는 것이다. 하지만 외부에서 타입을 지정하여 내부의 사용되는 타입에 제한을 걸 수 없기 때문에 엄격한 타입제한을 할 수 없다는 단점이 있다. 또한 처리 후의 값이 어떤 타입인지 코드의 실행 전에는 알 수 없는 경우도 많기 때문에 IDE의 정적 분석으로 해당 값의 타입이 어떤지 추론되지 않는 문제가 생길 수 있다.
- 하지만 처리후의 값을 꺼내서 사용할 때 타입힌트를 사용하는 코드 스타일을 통해서 어떤 타입이 쓰이는지 지정해 주면 제네릭이 없어도 타입 안정적인 코드를 만들 수 있다. 타입힌트를 통해 IDE의 정적 분석 도구가 타입을 추론을 통해 사용하고자 하는 값의 타입을 자동으로 추론해 준다.
- 제네릭은 외부에서 내부에서 사용할 타입을 지정하는 것이다. 그러면 처리 이후의 타입이 처리 이전에 지정된 타입으로 결정이 되는 특성이다. php의 경우에는 제네릭을 사용할 수 없지만 처리이후의 타입이 원하는 타입인지 확인하는 방식으로 제네릭을 대신할 수 있다. 어차피 외부에서 지정하는 타입이긴 마찬가지이며 미리 타입을 지정하느냐, 아니면 나중에 타입을 지정하느냐의 차이일 뿐이다.
- 하지만 제네릭으로 타입 제한을 걸면 꺼내 쓸 때마다 타입을 확인할 필요가 없으며 이미 타입이 결정되어 있다. 따라서 IDE의 정적 추론에 의해 자동완성을 편하게 이용할 수 있는 반면, 꺼내 쓸때마다 타입을 확인하는 코드를 작성해 주어야 하는 단점이 있다. 이런 단점은 함수형 스타일의 코드를 적극 사용하여 함수의 타입힌트를 걸어주는 것으로 어느 정도 극복이 가능하다.

### foreach문이 권장되지 않는 이유
- php에서 foreach문을 사용할 때는 리스트에 든 각각의 값에 대해 타입 검증을 하지 않고 사용하는 경우가 많다. `is_타입` 또는 `instanceof`로 타입 검증을 할 수 있지만, 이러한 것으로 검증을 했을 때, IDE에 의한 자동완성이 되지 않는 경우가 있을 수 있으며 조건문으로 확인을 한다는 것이 문법적으로 맘에 드는 방법은 아니다. 그래서 코딩의 스타일을 `foreach`를 쓰는 것 보다는 콜백함수를 가능한 사용하는 방식으로 하여 타입힌트로 값을 검증하는 것이 좀 더 괜찮은 코딩 스타일이다.
- php의 배열의 경우 `foreach`를 `array_walk`를 사용하여 콜백함수를 사용할 수 있는 방식을 사용할 수 있고, 배열이 아닌 다른 `iterator`의 경우 라라벨의 컬렉션 패키지를 사용해서 콜백 형태로 만들어서 사용하는 것을 추천한다.
```php
class Item
{
    public function getRandomValue(): int
    {
        return rand();
    }
}

$itemObj = new Item();
for($i=0; $i<10; $i++) {
    $numberList[$i] = $itemObj;
}

foreach($numberList as $item) {
    echo $item->getRandomValue(), PHP_EOL;
}

echo PHP_EOL."------------".PHP_EOL;

array_walk($numberList, function (Item $item): void {
    echo $item->getRandomValue(), PHP_EOL;
});
```
- 위의 코드에서 `foreach` 문을 사용하지 않고 `array_walk`로 콜백 함수를 사용한 코드를 사용하였다. 콜백함수를 사용하게 되면 각각의 원소에 대해 타입힌트를 적용할 수 있고 타입힌트로 인해 다른 타입이 들어오는 경우에는 에러를 내며, IDE는 타입힌트를 통해서 오브젝트 내부에 프로퍼티가 있는지 대한 추론을 할 수 있어서 코드를 편하게 짜는데 도움을 준다.
- php는 배열에 하나의 유형 뿐만 아닌 다양한 유형을 갖고 있기 때문에 배열에서 데이터를 뽑아 쓸때마다 불안한 느낌을 준다. 반복 가능한 유형에 콜백함수를 사용하는 표현으로 타입힌트를 걸어주면 타입을 한 번 짚고 넘어갈 수 있기 때문에 코드에 안정감을 주게 된다.

### 제네릭 도입이 어려운 이유
- php 파서의 모던화에 공헌했던 니키타의 의견 https://www.reddit.com/r/PHP/comments/j65968/comment/g83skiz/?utm_source=share&utm_medium=web2x&context=3
- 위의 의견을 보면 php에 제네릭을 도입하는 것이 쉬운 것이 아님을 알 수 있다. 제네릭을 사용한 php 파서에서 유형 추론의 복잡성 문제, php 파서의 대량의 리펙토링 문제, 런타임 시스템 리소스 증가의 문제 등의 문제로 쉽사리 도입되지 못하고 있다.
- 만약 제네릭을 도입하게 되더라도 더 이상 php라고 할 수 없을 정도의 변경사항이 발생할 수도 있다는 읙견이 있다. 또한 php는 오픈소스로서 php의 코어에 자발적으로 공헌하는 개발자들에 의해 유지된다. 언어의 스펙을 변경할 수 있는 풀 타임 개발자를 상당한 비용을 지불해서 고용하기 어렵기 때문에 대규모의 리펙토링은 현실적으로 어려움이 있다. 최근 php 파운데이션의 설립으로 php 코어에 기여할 수 있는 풀타임의 개발자들을 고용하는 것으로 보이지만 php 언어를 제네릭을 허용하는 방향으로 바꿀 것인지는 여러 문제들을 해쳐나가야 하기에 관망을 할 필요는 있다.

### 런타임 타임 확인
- php에서 제네릭이 도입되기 어렵게 된 원인 중 하나는 런타임 타입 검사 기능 때문이다. 타임스크립트나 파이썬의 경우 타입을 작성할 때 런타임에서 동작하는 타입을 제거하고, 런타임 이전의 정적 검사 타입 또는 트렌스파일 등의 타입 검사 과정을 통해서 타입을 확인하는 작업을 하는 것이다.
- php는 클래스의 멤버 변수, 함수의 파라메터와 반환값의 타입을 확인하는 타입힌트를 제공한다. 이 타입힌트가 런타임에서의 타입을 확인하는 기능을 하고 있다. 제네릭이 있는 다른 언어는 이러한 런타임 타입 체킹 기능을 사용하지 않고, 컴파일 타임, TS의 경우 트렌스파일 타임을 통해서, 파이썬의 경우 제네릭을 도입하기 위해서 런타임의 타입 검사 기능을 제거하였다.
- 물론 타입이 아닌 값의 유형을 완전히 바꾸는 방식의 코딩을 지원하며, 타입 힌트가 아닌 값의 타입을 코드로 강제적으로 변경하는 부분에 대해서는 타임 검사를 하지만, 타입힌트와 같이 타입으로 표기된 부분에서의 타입 검사는 하지 않아서 런타임 타입 검사 비용에 대한 문제를 해결하였다.

### 런타임 타입 확인을 하지 않음으로 생기는 문제
- 런타임에서 타입을 확인하지 않는 것은 어떠한 값이든 전달 가능하다는 문제가 있다. 따라서 런타임에서 잘못된 값이 들어가지 않도록 수 많은 데이터 전달 과정에서 엄격하게 타입이 정확한지 확인하는 작업이 필요하다. 이를 위해서 정적 검사 툴은 어느 부분에서 타입을 제대로 평가할 수 없는지를 확인하여 타입 추론이 잘 되지 않거나 타임 추론에 모순이 발생한 부분이 생기면 프로그래머에게 알려 준다. 프로그래머는 잘못된 타입이 들어가지 않게 하기 위해서 모든 부분에 있어서 엄격하게 타입을 작성하며, 잘못된 데이터가 들어가지 않도록 데이터 전달의 흐름에 주의를 기울이며 잘못된 인터페이스나 타입의 값이 외부에서 전달될 수 있는 부분은 벨리데이션을 작성한다.
- 하자만 런타임에서 타입을 확인하지 않기 때문에, 런타임에 잘못된 값이 전달되지 않게 하기 위해 지나치게 엄격하게 타입을 지정해야 하는 문제가 생긴다. 개발 초기 단계 부터 엄격하게 타입의 정적 추론이 가능하도록 짜 놓은 프로젝트인 경우 런타임의 타입 검사를 배제해도 잘못된 타입이 들어가는 경우를 막을 수 있지만, 정적 추론 없이 오랫동안 작성되어 온 애플리케이션이라면 정적 추론을 위해 모든 데이터 전달 플로우에 타입을 넣는 것이 현실적으로 어려운 문제에 직면할 수 있다.
- 또한 php와 같은 멀티 타입을 사용할 수 있는 언어의 경우, 외부 라이브러리나 외부에서 전달된 값을 사용할 때 지정된 타입 이외의 다른 어떤 타입의 값이 전달되어 사용되는지 확신을 할 수 없는 경우가 있다. 타입 안정적인 코드를 작성하려면 모든 예외 사항에 대한 어떤 타입의 처리를 할지에 대한 명세를 만들어야 하는데, 이런 것이 불가능한 경우가 있기 때문에 런타임의 타입 검사를 통해서 기대하지 못한 타입의 전달으로 처리될 수 없는 경우 에러를 발생 시켜 예측하지 못한 상황에 대해 어떻게 처리할지를 정의하지 않았으므로 처리를 하지 않도록 만드는 것이 좋다.
- 런타임의 타입 검사의 장점은 모든 데이터 전달 플로우의 타입이 명확하게 정의되고 벨리데이션도 완벽하게 갖춰지지 않는 상태에서 내가 작성한 부분의 타입 안정성을 확보할 수 있다는 장점을 갖고 있다.
- 제네릭 도입을 위해서 런타임 타임 검사를 제거하자는 의견이 제기되고 있지만, 수 많은 타입추론 불가능한 php의 코드에서 런타임 이전에 타임을 검사할 수 있는 시스템으로 변경하는 것은 현실적으로 불가능에 가깝다.
