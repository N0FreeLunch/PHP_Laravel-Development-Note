# php에서의 제네릭 이해하기

여러 프로그래밍 언어 가운데서 php는 속도, 함수형 프로그래밍, 정적 분석 등에서 약한 면모를 가진 언어이다. 이런 약점을 극복하고 좋은 퀄리티의 제품을 만들기 위해서는 php를 잘 다루는 방식을 알아야 한다. 인터프리터 언어인 자바스크립트, 루비, 파이썬과도 조금 다르고, 여타 컴파일 언어와도 좀 다른 php는 잘 다루면 아주 실용적이고 생산적인 언어이지만, 잘 다루지 못한다면 다른 언어들이 갖는 보편적인 특성과는 다른 특성들로 인해 혼란스럽고 이상한 언어로 보일 것이다.

php에는 다른 언어에서 흔히 볼 수 있는 제네릭이라는 문법이 없다. 써드 파티로 별도의 정적 분석 툴을 도입해서 docblock의 [`@template`](https://phpstan.org/blog/generics-by-examples)으로 제네릭을 사용할 수 있지만, 많은 양의 레거시 코드가 존재하면 정적분석 툴을 도입한다고 했을 때 코드의 수정이 만만치 않고 기존의 코딩 스타일을 정적 분석에 맞는 코딩 스타일로 바꿔야 하기 때문에 불편함이 생기므로 쉬이 도입하지 못하는 경우도 많다.

php에는 제네릭 문법이 없어서 아쉽지만 제네릭이 없더라도 제품을 개발하는데 있어 큰 지장을 주지는 않는다. 본 글은 php에서 제네릭이 없더라도 크게 불편하지 않았던 이유, 제네릭이 없더라도 이를 극복하고 php를 잘 활용할 수 있는 방법에 대해 서술한다.

## 연관배열의 문제

php는 연관 배열이라는 자료 구조를 사용한다. 연관배열은 키-벨류 쌍의 데이터를 저장하는 방식이다. php에서 키를 지정하지 않고 배열에 데이터를 저장을 해도 0,1,2,3...의 인덱스가 생기는데 php에서 배열은 반드시 키를 가져야 하는 연관배열이므로 키를 지정하지 않은 경우 자동으로 0 이상의 정수 키를 생성하기 때문이다.

다양한 종류의 자료 구조를 사용하는 다른 언어들과 달리 php는 데이터 구조로 주로 연관 배열을 사용하는데, 연관 배열은 다양한 자료구조를 연관 배열 하나로 대신할 수 있다는 장점을 가지고 있다. 여러 자료 구조에 대한 이해 없이도 간단히 사용할 수 있어서 쉽게 사용할 수 있다는 장점이 있지만, 연관배열은 너무 다양한 구조를 가질 수 있기 때문에 배열을 다루기 위해서는 배열 안에 어떤 데이터가 전달 되는지 알아야 한다는 문제점이 있다.

```php
[
    'a' => 1,
    'b' => 'B',
    'c' => [
        'q' => [ 'r' => 's' ],
        't' => [ 'u' => false ],
    ],
    'd' => new class { public int $x = 'y'; }
    100 => 'z'
]
```

위와 같은 배열을 다루어야 할 때 이 배열을 어떻게 처리해야 할지 배열의 원소를 일관된 방법으로 다룰 수 있는 방법이 없거나 생각하기 어렵다.

그에 반해서 배열의 모든 원소가 동일한 타입이라면 배열을 순회하면서 원소를 일관된 방식으로 다룰 수 있기 때문에 코딩하기에 좋다.

```php
$arr = [
    'a' => 1,
    'b' => 2,
    'c' => 100,
    'd' => 200,
];

foreach($arr as $k => $e) {
    if ($e >= 100) {
        echo "Key $k's value is 100 or more.";
    }
};

```

배열의 키는 문자열이라는 것만 알면, 배열 내부의 값이 어떤지에 관계 없이, 배열의 값은 정수이므로 if문을 통해서 수치 비교를 수행할 수 있고, echo를 통해서 문자열을 출력 할 수 있다.

## 제네릭 이해하기

### 제네릭이란?

프로그래밍 언어에서 제네릭은 특정 타입에 의존적이지 않는 기능을 제공하는 것이다.

### 타입 의존적이란?

제네릭을 사용하는 기능은 제네릭으로 지정한 값을 다루는 방식에 제한이 있을 수 있다. 예를 들어 변수 `$a`에 할당된 값이 int 또는 string 타입을 갖는다고 하자. 그럼 이 코드를 동작 시키기 위한 범용적인 코드를 만들기 위해서는 `strtoupper($a)`와 같은 문자열을 대상으로 하는 함수와 연결하면 안 된다. 왜냐하면, `$a`가 정수인 경우 에러가 발생하여 `$a`가 가질 수 있는 타입 모두에 대해 동작하지 않기 때문이다. 그에 반해 `intval($a)`는 정수와 문자열 모두에 사용될 수 있으므로 변수 `$a`에 연결해도 좋은 코드이다. 이렇게 전달하려는 값의 타입 중에서 일부 타입에 대해서만 처리된다면 특정 타입에 의존적인 것이고 전달되려는 값의 타입 모두를 처리할 수 있는 것이 타입에 의존하지 않는다는 의미이다.

- `strtoupper` 함수의 시그니처 : `strtoupper(string $string): string`
- `intval` 함수의 시그니처 : `intval(mixed $value, int $base = 10): int`

어떤 함수 fn에 대해서 fn의 파라메터는 여러 타입의 인자를 사용할 수 있을 때 특정 타입에 대한 의존성이 줄어든다. fn에 문자열 s를 전달했을 때 정수 i를 전달했을 때 fn(s), fn(t) 각각에 대해 함수가 동작할 때 fn이 문자열 s에 대해서만 성립하는 것과 달리, 좀 더 다양한 타입에 대해서 성립하기 때문에 타입 의존성이 줄어든다.

제네릭(generic)은 포괄적인이라는 뜻을 가진 용어로, 특정 타입 뿐만 아닌 다양한 타입에 대해서 성립하는 기능을 의미한다. 이후의 설명을 통해서 더 구체적으로 이해해 보자.

### 타입스크립트의 제네릭

php 개발자라면 자바스크립트에 대한 지식이 어느 정도 있을 것이다. 타입스크립트는 자바스크립트에 타입을 추가한 것으로 간단한 타입스크립트의 예를 통해 제네릭을 쉽게 이해할 수 있다.

타입스크립트는 자바스크립트의 배열의 원소의 타입을 지정할 수 있는 제네릭을 제공한다. `Array<T>`에서 T 부분에 타입을 넣는 것을 통해서 배열의 원소 타입을 제한 할 수 있다.

T 부분에 원하는 타입을 지정하는 것을 통해서 `Array<int>`, `Array<string>`, ... 등과 같이 여러 타입에 대해서 성립하는 기능을 만들 수 있다.

#### 타입 스크립트 코드의 예

```ts
const elements: Array<number> = [1, 2, 3, 4, 5];
```

타입 Array 옆에 `<number>`를 붙여주는 것을 통해서 배열 안의 모든 원소는 `number`으로 타입이 정해져서 배열 안에 다른 타입을 넣을 경우, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다.

```ts
const elements: Array<string> = ['a', 'b', 'c', 'd', 'e'];
```

마찬가지로 `<string>`을 붙여주는 것을 통해서 배열 안의 모든 원소는 `string`으로 타입이 정해져서 배열 안에 다른 타입을 넣을 경우, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다.

#### 제네릭과 유니온

```ts
const elements: Array<T> = [e1, e2, e3, e4, e5];
```

위 코드에서 타입 T에 대해서 `e1`, `e2`, `e3`, `e4`, `e5`를 사용하게 되면, 각각의 원소는 `<T>`에 지정한 타입이 되어야 한다. 배열을 사용할 때 원하는 타입을 지정할 수 있기 때문에 `<T>`로 타입을 지정해 사용하는 것은 특정 타입에 의존적이지 않은 기능을 제공한다.

```ts
const elements: Array<number | string> = [1, 'a', 3, 'b', 5];
```

`<T>` 부분에 `<number | string>`으로 유니온 타입을 지정하면 배열 안의 원소는 `number` 타입과 `string` 타입을 두 종류의 값을 넣을 수 있기 때문에, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하지 않는다. 단, 각각의 원소를 꺼내 쓸 때 원소가 수인 경우와 문자열인 경우를 분기해서 처리해 줘야 한다.

#### 제네릭의 유용성

```ts
const elements: Array<string> = ['a', 'b', 'c', 'd', 'e'];

console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
```

`.toUpperCase()` 메소드는 문자열인 대상에서만 사용할 수 있는 메소드이다. 만약 `numbers.pop()`으로 꺼낸 값이 문자열이 아니라면, 꺼낸 값에 `.toUpperCase()`을 사용한 코드는 IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다. 배열에서 더 이상 꺼낼 데이터가 없을 때 `undefined`를 반환하므로 `.toUpperCase()`에 연결하기 위해서 빈 문자열이 되도록 `?? ''` 코드를 추가해 주었다.

만약 `elements.pop()`으로 꺼낸 값이 문자열 뿐만 아닌 수 타입인 경우 `.toUpperCase()` 메소드가 존재하지 않기 때문에 사용할 수 없다. 제네릭을 사용해서 배열의 원소 타입을 문자열로 제한했기 때문에, `.toUpperCase()`을 붙이는 코드를 사용할 수 있다.

### 제네릭 문법

함수나 클래드 등을 사용하는 문법에서 특정 타입에 관계 없이 동작할 수는 있지만, 사용하기에 앞서 사용할 타입을 구체적으로 지정해 주어야 하는 것을 '제네릭 문법'이라고 한다. 타입 스크립트의 예를 들면 배열(`Array<T>`)은 타입에 의존적이지 않지만, `<>` 부분에 `<string>`이나 `<number>` 등의 타입을 지정하는 것을 통해서 지정한 타입으로 기능을 사용하는 것이 제네릭 문법이다.

자료구조에서 특히 제네릭을 많이 사용하는데, 특정 자료구조가 값을 저장할 때 타입에 구애받지 않고 값을 저장할 수 있도록 하기 위함이다. 예를 들어 어떤 자료구조를 사용하는데, A라는 타입의 데이터만 저장할 수 있다면, B라는 타입일 때 사용할 수 있는 자료구조를 또 만들어야 하고, C라는 타입일 때 사용할 수 있는 자료구조를 또 만들어야 한다. 하지만, 제네릭 개념을 적용한 자료구조라면 어떠한 타입이든 저장할 수 있는 특성을 갖고 있기 때문에 저장할 데이터의 타입에 관계없이 사용할 수 있는 유연성을 제공한다.

## php로 제네릭 이해하기

데이터를 넣은 순서대로 데이터가 뽑히는 Last In First Out 자료구조를 php로 간단히 만들어 보자.

```php
class Lifo
{
    private array $array = [];

    public function push($value)
    {
        $this->array[] = $value;
    }

    public function pop()
    {
        return array_pop($this->array);
    }
}

$lifo = (new Lifo);
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');
var_dump($lifo->pop());
var_dump($lifo->pop());
var_dump($lifo->pop());
```

`push('a')` `push('b')` `push('c')`의 순서대로 데이터를 넣었고, 마지막에 넣은 값 부터 차례로 값이 뽑힌다.

### 타입힌트 생각해 보기

문자열의 값을 넣는다고 생각해 보자. 그럼 `public function push(string $value)`와 `public function pop(): string`이란 타입힌트를 줄 수 있다.

정수를 넣는다고 생각해 보자. 그럼 `public function push(int $value)`와 `public function pop(): int`이란 타입힌트를 줄 수 있다.

임의의 타입을 넣는다고 생각해 보자. 그럼 `public function push(mixed $value)`와 `public function pop(): mixed`이란 타입힌트를 줄 수 있다. 하지만 이 경우에는 데이터를 꺼냈을 때 어떤 타입인지 타입힌트에 의해 특정되지 않는다.

위 클래스의 내부 구조를 모르고 클래스의 인터페이스만 안다고 하자. `push`와 `pop` 메소드가 있다는 것만 알고 있다. 클래스 내부에 타입힌트를 주고 싶은데, php는 제네릭 문법이 없기 때문에 외부에서 저장할 데이터의 타입을 결정할 방법이 없다.

만약 php가 제네릭을 지원한다면 `Lifo` 클래스를 사용할 때 클래스 내부에서 데이터를 저장할 때 외부에서 전달된 타입으로 제약을 걸 수 있을 것이다. `new Lifo<Type>` 이렇게 제네릭 문법을 사용해서 타입을 전달하면, `public function push(Type $value)`와 `public function pop(): Type`으로 `Type` 자리에 클래스에서 `<Type>`으로 지정한 값의 타입 들어가 타입 안정적인 코드를 작성할 수 있다.

제네릭이 있다면 `<string>`을 넣으면 `push(string $value)`와 `pop(): srting`이 되고, `<number>`을 넣으면 `push(number $value)`와 `pop(): number`가 된다.

### 각각의 타입에 대한 코드 작성해 보기

#### 정수를 저장하는 lifo

```php
class Lifo
{
    private array $array = [];

    public function push(int $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): ?int
    {
        return array_pop($this->array);
    }
}
```

#### 문자열을 저장하는 lifo

```php
class Lifo
{
    private array $array = [];

    public function push(string $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): ?string
    {
        return array_pop($this->array);
    }
}
```

#### 타입 파라메터가 존재한다면?

제네릭은 다른 말로 타입 파라메터라고 부른다. 타입을 파라메터 처럼 지정하고 기능을 사용할 때 타입을 지정하는 것으로 타입 파라메터에 타입을 전달하기 때문이다.

php에는 제네릭이 존재하지 않지만 다음과 같은 코드를 상상해 볼 수 있다.

```php
class Lifo<T>
{
    private array<T> $array = [];

    public function push(T $value)
    {
        $this->array[] = $value;
    }

    public function pop(): ?T
    {
        return array_pop($this->array);
    }
}

$lifoString = new Lifo<string>;
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');

$lifoInt = new Lifo<int>;
$lifo->push(1);
$lifo->push(2);
$lifo->push(3);
```

타입 힌트 위치에 T라는 타입 파라메터를 사용하고 클래스를 객체로 인스턴스화 할 때 타입 파라메터에 전달할 타입을 `<string>`이나 `<int>`로 지정하면, T의 위치에 `string`이나 `int`의 타입 제약이 걸린다.

#### 타입스크립트로 이해하기

제네릭을 지원하는 타입스크립트로 php 코드를 타입스크립트로 바꿔 이해해 보자.

```php
class Lifo<T> {
    private array: T[] = [];

    public push(value: T): void {
        this.array.push(value);
    }

    public pop(): T | undefined {
        return this.array.pop();
    }
}

const lifo = new Lifo<string>();
lifo.push('a');
lifo.push('b');
lifo.push('c');

console.log(lifo.pop()); // 'c'
console.log(lifo.pop()); // 'b'
console.log(lifo.pop()); // 'a'
console.log(lifo.pop()); // undefined
```

Lifo라는 클래스에 제네릭 문법으로 `<string>` 타입을 지정하는 것을 통해서 `lifo.push()`으로 값을 넣을 때, `lifo.pop()`으로 값을 꺼낼 때 문자열만을 (꺼낼 값이 없을 때는 `undefinded`) 반환하도록 한다.

`Lifo<string>`, `Lifo<number>`으로 제네릭 문법에 어떤 타입을 지정하느냐에 따라 `Lifo` 클래스 내부의 T로 되어 있는 부분의 타입이 달라진다. T는 어떤 타입을 받을지를 정하는 매개변수의 역할로 타입을 받는 타입 파라메터의 역할을 한다.

## 컴파일 언어의 제네릭과 php의 제네릭

### 컴파일 언어에서의 제네릭

컴파일 언어에서 어떤 자료 구조를 정했다면 저장할 데이터의 타입을 정해야 한다. 자료구조는 다양한 타입에 대해서 동작하기 위해 제네릭을 사용한다. 이 때 저장할 데이터가 가진 타입을 지정한다. 여러 타입을 지정하고 싶은 경우에는 유니온 타입 또는 공통의 인터페이스 또는 상위-하위 관계의 클래스 또는 여러 클래스의 공통의 상위 클래스를 타입으로 지정해야 한다.

이 때 제네릭으로 지정하지 않은 다른 타입의 값을 사용할 수는 없는데, 이는 어떤 자료 유형의 데이터 저장소에서 데이터를 꺼내 쓸 때 타입 또는 인터페이스가 달라지면 런타임의 동작에서 잘못된 타입을 참조하거나 전달하는 치명적인 에러가 발생할 수 있기 때문에 지정한 타입에 대한 맞물리는 (int를 반환하면 int를 다루는 코드에 연결하고 string을 사용하면 string을 다루는 코드에 연결하는) 코드를 사용하도록 제한을 하기 위해서이다.

컴파일 언어는 타입을 통해서 제한된 방식의 코딩 스타일을 제공하고 컴파일을 통해서 기계어나 기계어에 가까운 레벨의 중간언어(JAVA의 Bytecode, C#의 CLI : Common Intermediate Language)로 번역을 한다. 기계어나 중간언어는 컴파일 타임에 모든 타입 안정성을 체크하기 때문에 런타임의 동작에서 타입을 체크하지 않아도 타입으로 인한 에러가 발생하지 않는다. 하지만 런타임 타입 체크가 잘 이뤄지지 않으면 런타임에 치명적인 에러를 발생시킨다.

자료구조의 케이스를 생각해 보자. 저장하고 꺼내쓰는 작업을 하는데 데이터를 꺼냈을 때 어떤 타입인지 알아야 어떤 접근을 할지 알 수 있다. 컴파일 언어는 런타임에 타입 체크를 하지 않기 때문에 데이터를 꺼냈을 때 어떤 타입인지 체크하는 동작을 하지 않고 꺼내 쓴다. 이 때 메모리에 저장된 값과 전달하려는 런타임의 코드 실행에서 타입 불일치가 일어나면 치명적인 에러가 발생할 수 있다.

php의 경우 타입 불일치가 일어나면 언어 자체의 에러를 예외 처럼 던져 스텍 트레이스를 생성하는 것에 반해 기계어나 중간 언어로 번역된 코드를 실행하는 컴파일 언어는 의도적으로 타입을 체크하지 않는 한 타입 불일치가 런타임에 일어나면 이를 처리할 수 없고 프로그램은 크레시가 발생할 것이다. 그래서 이런 일이 발생하지 않도록 컴파일 타임에 강력하고 엄격한 정적 검사를 수행한다.

그래서 컴파일 언어는 이용할 타입을 컴파일 타임에 지정해 두어야 한다. 자료 구조의 사용과 동시에 자료 구조 안에 들어갈 타입을 지정해서 자료 구조에 데이터를 넣고 꺼낼 때 명확한 타입을 정하여 연결되는 코드의 동작을 런타임 코드 실행 이전에 보증하기 위한 것이 컴파일 언어에서 제네릭이라고 부르는 문법이다.

### 제네릭이 없어서 발생하는 문제

php와 같은 동적 언어는 어떤 자료구조에 데이터를 넣을 때 타입 제약이 없다. 타입 제약이 없는 대신 하나의 함수나 객체를 사용할 때 여러 타입의 데이터를 전달하고 처리하게 코드를 작성할 수 있다. 컴파일 언어에서 제네릭을 사용하면 지정하지 않은 타입의 값의 전달 및 출력이 컴파일러의 정적 타입 검사에 의해 원천적으로 차단되어 있는 것과 달리 어떠한 타입의 값도 전달할 수 있기 인터프리터 언어에서는 제네릭을 타입 제약을 걸기 위해 사용한다.

서로 상이한 타입의 값에 대해서 각각의 값을 처리하는 방법이나 맞물려 처리되는 코드가 달라지기 때문에 에러가 발생하므로 런타임에서 사용한 기능에서 나온 값의 타입을 체크하고 각 타입에 적합한 분기 처리를 해 줘야 한다.

만약 타입을 지정하지 않으면, 어떤 타입의 값이 전달될지 알 수 없다. 지정된 타입힌트가 없다면 php는 기본적으로 mixed로 처리를 하며, string, int, float, bool, null, SomeClass1Obj, SomeClass2Obj, SomeClass3Obj ... 등 다양한 값이 전달될 수 있는 가능성을 고려하고 이들 모두에 대해서 분기 처리를 해야 하는데, 이는 불가능하다.

따라서 런타임에 어떤 타입의 값이 전달되는지 알아야 하고, 실제 런타임에서 전달되는 타입에 대해서만 고려하여 코드를 작성해 주어야 한다. 그리고 타입 힌트를 통해서 런타임에서 주어지는 값은 이러한 것이니 이 타입힌트에 대해서 처리해 주세요라는 의미로 타입힌트를 작성한다.

그런데 타입 힌트로 mixed 타입이나 유니온 타입으로 너무 많은 타입을 지정하게 되면, 처리해야 할 분기처리의 양이 늘어나게 된다. 제네릭 문법을 사용하면, 클래스나 함수를 정의할 때는 여러 타입에 대한 처리를 지원하지만, 사용할 때는 특정 타입을 지정하고, 이후에는 지정된 타입에 대해서만 처리하면 되는 장점이 있지만, php는 제네릭이 없기 때문에 동일한 기능의 코드인데, (string 타입에 대해 처리하는 Lifo, int 타입에 대해 처리하는 Lifo를 따로 만들 듯) 각각의 타입에 대해 성립하는 코드를 따로 만들어 주어야 하는 경우도 있다.

### 유니온 타입에 대한 일반적인 코딩 스타일

위에서 소개한 예제의 Lifo 클래스에서 내부에 타입힌트를 `string`으로 정의했는지 `int`로 정의했는지에 따라서 배열 안의 데이터로 전달할 수 있는 대상은 문자열이 되기도 하며, 정수가 되기도 한다. 문자열만을 저장하는 Lifo를 쓰고 싶다면 문자열 타입힌트를 갖는 클래스를 만들어야 하고, 정수만을 저장하는 Lifo를 쓰고 싶다면 정수 타입힌트를 갖는 클래스를 만들어야 한다. 하나의 타입으로 제한되어 있기 때문에 `push` 메소드로 타입을 전달할 때, `pop` 메소드로 값을 꺼낼 때 하나의 타입에 대해서만 (꺼낼 대상이 없는 경우는 null을 추가로) 생각하면 된다.

하지만 여러 클래스를 만드는 것은 효율적이지 못하다. 제네릭을 사용할 수 있다면 Lifo 클래스를 하나만 만들어 인스턴스화를 할 때 `new Lifo<string>` `new Lifo<int>` 등으로 타입을 지정해 주면 되지만 php는 제네릭을 사용할 수 없기 때문에, 유니온 타입이나 모든 타입을 허용하는 mixed 타입 힌트를 사용한다. 하지만 이렇게 되면 `push` 메소드로 타입을 전달할 때, `pop` 메소드로 값을 꺼낼 때 각각의 원소의 타입은 `int` 단일, `string` 단일이 아니라, `int|string`이므로 꺼낸 값을 처리할 때 `int`에 대해서도 `string`에 대해서도 성립하도록 코드를 만들어 주어야 한다. 제네릭으로 단일 타입을 사용할 때는 처리하지 않아도 되는 코드에 유니온을 쓰면서 타입에 따른 분기 처리 로직의 작성이 필요하게 된다.

타입힌트를 사용하면 지정한 타입이 아니면 에러를 발생 시키는 것을 통해서 잘못된 타입의 값이 전달 되었을 때 발생하는 타입 에러를 통해서 타입이 잘못된 이유를 찾고 이를 개선하여 코드를 정확하게 작성하고, 이후에는 타입힌트로 제한한 범위에 한정하여 코드를 정해진 타입 범위 내에서 IDE의 도움을 받아 안정적으로 구현할 수 있다.

때때로, 실제 전달되지도 않는 여러 타입에 대한 로직 처리를 할 필요는 없기 때문에 타입힌트로 지정한 타입 모두에 대한 처리가 아닌 일부 타입에 대해서만 처리 로직을 만드는 경우가 생긴다. 인터프리터 언어의 경우 런타임에서 타입을 확인하기 때문에 타입이 `int | string`이더라도 전달되는 값이 `int`뿐이라면 `int`에 대해서만 처리하고, `string`뿐이라면 `string`에 관한 처리를 하면 된다.

타입 시스템이 강한 언어의 경우 유니온 타입이 전달되면 모든 타입 케이스에 대한 분기 로직을 작성해 주어야 한다. `int | string`가 전달되었다면 반드시 `int`에 대한 처리와 `string`에 대한 처리 모두를 해 주어야 한다. php에서도 강력한 정적 분석 툴을 사용하는 경우 타입 안정성을 위해 유니온 타입이 갖는 모든 타입에 대한 처리를 작성해 주어야 한다. (그렇지 않으면 정적 분석 툴을 통과하지 못한다.)

타입힌트가 `?int`으로 되어 있다면 연결되는 로직은 `int`와 `null` 모두에 대한 처리 로직을 만들어야 하며, `null`이 실제로 사용하지 않는 값이라면 `?int`가 아닌 `int`만 사용하여 타입힌트에서 제거하는 것이 해당 코드를 사용할 때 불필요한 처리를 추가로 작성한다.

일반적으로는 인터프리터 언어가 유니온 타입에 대해 전달되는 값이 유니온 타입으로 지정한 타입 중에서 특정한 타입만 전달되는 것을 전제한다고 하더라도 해당 일부 타입에 대해서 코드를 짜는 것이 아닌 유니온 타입이 갖는 전체 타입에 대한 처리 로직을 추가하는 것이 일반적인 코딩 스타일이다.

### 유니온 타입과 `assert`로 제네릭 대체하기

php에서는 타입힌트로 사용하고자 하는 타입의 내부 타입을 설정하는 제네릭 문법이 없기 때문에, 기본적으로는 유니온 타입, 공통의 인터페이스, 공통의 상위 클래스 등 여러 타입에 대해서 성립하는 로직을 만들되, 값을 전달할 때 또는 값을 꺼내 쓸 때 유니온 타입 중에서 일부 타입에 대해서만 로직이 동작한다는 전제를 두고 코드를 작성하는 방법이 있다.

#### 사전 조건을 통한 조건 부여

예를 들어 php에서 배열의 경우 배열 내부의 원소 타입을 지정할 수 없기 때문에 기본적으로는 mixed로 처리될 것이다. 그러나 배열에서 원소를 추가할 때 타입을 확인하고 꺼내 사용하고자 할 때 타입을 확인하는 것을 통해서 유니온 타입을 사용하더라도 유니온 타입에서 일부 타입에 대해서만 동작한다는 전제를 설정하는 코드를 만들어 이후에는 유니온 타입 전체 타입에 대한 처리 로직이 아닌 일부 타입에 대해서만 동작하는 코드를 작성하는 코딩 스타일을 사용할 수 있다.

```php
declare(strict_types = 1);

$list = rand(0, 1) ? range(0, 30) : range('a', 'z');

assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true));

$result = array_map(fn($v) => $v+1, $list);

var_dump($result);
```

위 코드에서 `$list`는 0에서 30까지의 정수 또는 a부터 z까지의 문자열인 원소를 가지는 모두 정수 원소를 가지거나 모두 문자열 원소를 가지는 코드이다.

`array_map(fn($v) => $v+1, $list)` 부분의 코드는 문자열일 때는 동작하지 않고, 수(`int`)인 경우에만 동작한다. `$list`의 원소는 명시적인 타입힌트는 없지만 암묵적으로는 int 또는 string이다.

`assert`를 통해서 만약 배열의 모든 원소가 정수가 아니면 에러로 종료하도록 만들어져 있다. 이는 해당 라인 다음 줄 부터의 코드는 정수가 아니라면 실행될 수 없다는 전제 조건을 설정한 것이다.

이 전제조건으로 인해서, 배열의 원소가 int 또는 string 타입을 갖지만 `assert`와 같은 전제 조건을 설정할 수 있는 코드를 통해서 개발자는 이 코드의 배열은 내부 원소가 int 타입이니까 int 타입에 대해서만 처리하자고 생각할 수 있다.

위의 코드는 phpstan, psalm과 같은 강력한 정적 분석 도구에 의해서는 문자열 원소에 대한 처리를 하지 않았다는 에러 메시지가 발생하는데, `array_reduce` 등으로 사전조건을 지정하는 경우, 배열의 모든 원소를 확인하는 약간 복잡한 코드가 들어간 `assert`문의 타입 제한은 정적 분석 도구가 분석하지 못하기 때문에 `$list`의 원소가 `int`만이 전달된다는 사전 조건을 지정하더라도 여전히 `int`와 `string` 모두에 대한 처리를 해야 한다고 지적한다는 문제점이 있으며 개발자에게 타입 조건을 알려줄 뿐이다.

### 유니온 타입의 문제

제네릭을 사용할 때는 타입 매개변수 T에 대해 `new Lifo<string>`, `new Lifo<int>`와 같이 타입을 지정하면, `$lifo->push($value)`로 데이터를 넣을 때 `$value`의 타입이 <Type>에서 지정한 타입으로 고정되고, `$el = $lifo->pop()`으로 데이터를 뽑을 때 `$el`의 타입이 제네릭에서 지정한 타입 또는 `null`이 된다.

그런데 `Lifo`의 타입 매개 변수가 T가 아닌 mixed 타입으로 고정되어 있다면, `Lifo`는 타입의 제한 없이 어느 값이든 사용할 수 있다. 하지만 `$lifo->push($value)`으로 값을 전달할 때 어떠한 타입도 가능하고, `$el = $lifo->pop()`으로 꺼내 쓸 때도 어떠한 타입도 가능하기 때문에 `$el`을 처리하기 위해서 모든 타입에 대해서 동작하는 코드를 작성해야 한다. 이는 무리이므로 처리 후의 타입을 최소한으로 제한을 해야 한다.

php에 제네릭이 없는 대신 mixed 또는 유니온 타입을 쓰되, 값을 전달하거나 얻을 때 `assert`와 같은 도구를 통해 타입의 전제 조건을 설정하는 것을 통해 제네릭 없이도 타입 안정적인 코드를 만들 수 있다.

하지만 제네릭으로 타입 제한을 걸면 꺼내 쓸 때마다 타입을 확인할 필요가 없으며 기능을 생성하는 타이밍에(`new Lifo<string>`, `new Lifo<int>`) 제네릭으로 타입이 결정되어 있다. 따라서 IDE의 정적 추론을 편하게 이용할 수 있는 반면, 타입을 확인하는 방법은 꺼내 쓸때마다 타입을 확인하는 코드를 작성해 주어야 하는 단점이 있다. 다음 내용을 통해서 구체적으로 이해해 보자.

### Type narrowing

여러 타입을 갖는 변수에서 일부의 타입만을 사용하는 경우 `assert`를 통해서 타입의 범위를 좁힐 수 있다. 이 기능은 다양한 정적 분석 툴에서 [type narrowing](https://phpstan.org/writing-php-code/narrowing-types)이라는 기능으로 지원되는 기능으로, phpstorm 등과 같은 IDE를 사용하면, 여러 타입의 합으로 구성된 타입을 단일 또는 소수의 타입에 대해서 동작하는 것을 전제한다고 IDE에 알려 준다.

IDE는 유니온 타입이 가진 모든 타입에 대한 처리를 하지 않으면 타입 미스매칭으로 지적한다. 또는 공통 인터페이스, 상위 클래스 등의 타입의 변수를 처리할 때 특정 서브 인터페이스 또는 서브 클래스에 대한 처리를 할 때도 타입 미스매칭으로 지적한다. 타입 좁히기를 사용하면 전달 될 수 있는 여러 타입 중에서 특정 타입에 대해서 성립한다는 전제를 `assert`를 통해서 IDE에 알려주어 원래 타입으로 지정된 것은 여러 타입을 통과시키지만 실제 이 로직에서 사용할 것은 이 타입이기 때문에 이 타입에 대해서만 다음 로직의 처리가 맞는지 확인해 달라는 의미로 사용할 수 있다.

#### 코드를 통해 이해하기

```php
declare(strict_types = 1);

class TypeNarrowing
{
    public int|string $numeric;
}

function addOne(int $value): int {
    return $value + 1;
}

$list = [100, '100'];

$obj = (new TypeNarrowing);
$obj->numeric = $list[rand(0,1)];

assert(is_int($obj->numeric));

$result = addOne($obj->numeric);
var_dump($result);
```

`TypeNarrowing`의 멤버 변수 `$numeric`는 int 또는 string 타입을 가진다. `$obj->numeric` 코드에서 위의 코드만 보고서는 `100`이 할당될지, `'100'`이 할당될지 알 수 없다. `addOne` 함수는 `int` 타입만을 받는데 문자열 타입이 전달되면 에러가 발생한다. 이 때문에 IDE에 의한 정적 분석 또는 정적 분석 툴에 의해 `addOne($obj->numeric)`부분에 `int` 뿐만 아닌 `string`을 전달할 수 있는데 `addOne`은 `int` 타입만을 받기 때문에 정적 분석에 따른 에러가 발생한다.

php에서 IDE에 의한 정적 분석 또는 정적 분석 툴에 의한 타입 체크를 하고 있다면, `$obj->numeric`에는 여러 타입을 가질 수 있더라도 특정 코드 부터는 특정 타입만을 사용한다고 `assert`로 정적 분석 도구에 사용할 타입을 알려주는 것을 통해서 정적 분석 도구에 의해 에러가 발생하는 부분을 방지할 수 있다. 이는 타입스크립트의 Type narrowing 키워드인 `as`와 비슷한 역할을 한다.

앞서 배열의 원소를 모두 확인하는 `assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true))`와 같은 코드는 정적 분석 도구가 배열의 내부 원소 타입을 제한했다고 판별하기 어려울 정도의 복잡성을 지녔지만, 단순히 `is_int($var)`, `is_string($var)`, `|| is_null($var)` 등과 같은 코드를 사용하면 정적 분석 도구에서 [Type narrowing 키워드로 지정된 방식](https://phpstan.org/writing-php-code/narrowing-types#type-checking-functions)이므로 IDE와 정적 분석 도구들은 이를 기반으로 타입의 범위를 좁힐 수 있도록 지원한다. (타입 미스매칭에 의한 에러를 방지한다.)

위의 코드에서 `assert(is_int($obj->numeric))` 부분의 주석을 해제하면 `$obj->numeric`의 타입은 `int|string`이지만 `assert`로 타입 좁히기를 하면 `int`로 인식되기 때문에 정적 분석에 의한 지적을 피할 수 있다.

### 정적 분석과 assert

php에 제네릭이 없어 유니온 타입이나 mixed를 사용하는 경우, 값을 전달하거나 뽑아 쓸 때 유니온 타입이나 mixed 타입에 대한 처리를 할 수 있는 모든 코드를 작성하는 것은 적절하지 않다. 그렇다고 해서 유니온 타입이나 mixed 타입으로 전달받은 결과 값이 가질 수 있는 타입 중에서 일부 타입에 대해서만 성립하는 코드를 짜게 되면 정적 분석에 의한 지적이 생긴다. 이 때 `assert`로 사용할 타입을 좁혀서 정적 분석에 의한 지적을 막을 수 있다.

```php
declare(strict_types = 1);

class Lifo
{
    // @phpstan-ignore-next-line
    private array $array = [];

    public function push(mixed $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): mixed
    {
        return array_pop($this->array);
    }
}

$stringList = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($stringList));

$lifoString = (new Lifo);
array_walk($stringList, function ($v) use ($lifoString) {
    assert(is_string($v));
    $lifoString->push($v);
});

for($i=0; $i < count($stringList) ; $i++) {
    $output = $lifoString->pop();
    assert(is_string($output));
    echo $output;
}

$numberList = json_decode(json_encode(range(1, 10)) ?: '[]');

assert(is_array($numberList));

$lifoInteger = (new Lifo);
array_walk($numberList, function ($v) use ($lifoString) {
    assert(is_int($v));
    $lifoString->push($v);
});

for($i=0; $i < count($numberList) ; $i++) {
    $output = $lifoString->pop();
    assert(is_int($output));
    echo $output;
}
```

`json_decode(json_encode(range('a', 'i')) ?: '[]')`, `json_decode(json_encode(range(1, 10)) ?: '[]')`의 코드를 사용한 이유는 결과 값의 타입을 정적 분석 도구가 알 수 없게 하기 위해서이다.

`assert(is_array($stringList))`, `assert(is_array($numberList))`는 알 수 없는 타입의 값의 타입이 배열이라는 전제를 설정하여 정적 분석 도구로 하여금 `array_walk`에 의한 순회를 가능하게 한다.

배열 내부의 원소의 타입을 알 수는 없지만, `->push($v)` 전의 `assert(is_int($v))`, `assert(is_string($v))`를 통해서 사용하려는 타입과 다른 타입의 배열의 원소는 전달되지 않는다는 전제 조건을 설정한다.

위의 코드에서 `echo $output;`의 코드를 사용할 때 값은 문자열로 형변환 되어 출력 된다. 값에 따라 문자열로 변환 될 수 있는 것이 있고 없는 것이 존재한다. phpstan의 정적 분석기로 위 코드를 실행해 보면 `$lifoString->pop();`의 반환 타입이 mixed가 되어 있기 때문에 문자열로 변환 할 수 없는 값이 나올 수 있어 타입 에러가 발생한다. 그러나 `assert(is_int($output))`, `assert(is_string($output))`으로 `echo`로 출력할 수 있는 타입의 전제 조건을 설정하는 것을 통해서 IDE에 사용하는 타입을 알려주면 정적 추론에 의한 지적을 사라지게 할 수 있다.

이렇게 제네릭이 없어도 `assert`를 통한 타입을 좁히기를 통해서 제네릭 없이도 정적 분석을 만족하는 코드를 만들 수 있다.

### 배열 원소에 대한 정적 분석의 한계

```php
$list = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($list));

foreach($list as $item) {
    assert(is_string($item));
}

foreach($list as $item) {
    echo $item; // Parameter #1 (mixed) of echo cannot be converted to string.
}
```

심지어 위의 코드와 같이 배열 안의 모든 원소가 문자열임을 순회를 통해 모든 원소의 타입을 `assert(is_string($item))`으로 확인을 하더라도, 다음 순회 코드에서 IDE의 정적 분석이나 phpstan과 같은 정적 분석 도구는 배열 내의 타입이 무엇인지 확인하지 못한다. 따라서 순회 코드를 작성할 때마다 `assert`를 통한 타입 좁히기 코드를 반복적으로 적어야 하는 문제점이 있다.

### foreach vs array_walk

php의 배열은 정적 분석 툴을 사용하지 않는 한, 내부 원소의 타입을 알 수 없다. `assert`로 원소의 타입을 IDE나 정적 분석 도구에 알려 주기 위해서는 배열의 값을 하나씩 꺼냈을 때 가능하다. `assert` 구문 안에 `is_타입` 또는 `instanceof`으로 IDE의 정적 분석에 의한 자동완성을 사용할 수 있다.

`foreach` 또는 `for`를 사용할 때는, 루프를 반복할 때마다 배열에서 값을 하나씩 꺼내쓰는 코드를 작성할 것이다. 이 때, 순회하는 원소의 타입을 알 수 없으며 php 배열은 원소의 타입을 지정하지 못하기 때문에 정적 분석은 `mixed`로 대상을 판단할 것이다. 뽑은 값을 변수에 할당해 `assert`를 사용해서 타입을 좁혀 처리 대상이 되는 타입만을 정해준다. 그럼 IDE는 해당 타입으로 코드의 타입을 추론한다.

`array_walk`도 배열을 순회하는 기능이지만, 함수를 하나 받아서 함수의 파라메터로 배열의 원소를 하나씩 전달 받아서 순회처리하는 기능이다. 그런데 배열의 원소 타입을 알 수 없어 `mixed`로 추론되는데, 순회 함수의 파라메터에 어떤 타입 힌트 T를 설정하면 정적 분석은 `mixed`로 추론되는데 특정 타입 T로 연결되는 코드를 만들었다면서 타입이 연결되지 않는다는 지적을 한다. 따라서 순회 함수의 파라메터에는 타입힌트를 쓰지 않거나 `mixed`로 정하고, 순회 함수 내부에서 파라메터 변수를 `assert`로 타입을 좁혀 처리 대상이 되는 타입만 지정하는 방법을 사용하여 정적 분석의 지적을 피하도록 한다.

```php
$list = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($list));

foreach($list as $el) {
    // assert(is_string($item));
    echo $item;
}

array_walk($list, function (string $el) {
    echo $item;
});

array_walk($list, function (mixed $el) {
    // assert(is_string($el));
    echo $item;
});
```

foreach 문에서 `$el`의 타입을 알 수 없기 때문에 `echo $item`으로 출력할 수 있는 문자열로의 변환이 가능한지 알 수 없다. 그래서 `assert`를 통해서 원소 각각의 타입이 문자열인지 확인해야 한다.

`$list` 배열 내의 각각의 원소는 `mixed`으로 추론이 되는데, `array_walk` 함수의 순회함수의 파라메터의 타입힌트는 `string`이다. 바닐라 php에서는 이런 코딩 스타일도 실행에 문제가 없지만, 정적 분석 툴을 이용하고 있다면 타입 미스매칭으로 지적이 된다. 따라서 순회 함수의 파라메터 타입은 배열의 원소 타입으로 추론되는 것과 동일하게 해 주고, 각각의 원소를 사용할 때 `assert`로 실제 사용할 타입을 IDE에 알려 주도록 하자.

```php
class Item
{
    protected int $cached;

    public function __construct()
    {
        $this->cached = rand();
    }
	
    public function getCachedValue(): int
    {
        return $this->cached;
    }
}

class SubItem extends Item
{
    public function getCachedValueToString(): string
    {
        return strval($this->cached);
    }
}

$numberList = [];

for($i=0; $i<10; $i++) {
    $numberList[$i] = new SubItem;
}

foreach($numberList as $item) {
    echo $item->getCachedValue(), PHP_EOL;
}

echo PHP_EOL."------------".PHP_EOL;

array_walk($numberList, function (Item $item): void {
    echo $item->getCachedValue(), PHP_EOL;
});

array_walk($numberList, function (Item $item): void {
    echo $item->getCachedValueToString(), PHP_EOL;;
});
```

위의 코드에서 `foreach` 문을 사용하지 않고 `array_walk`로 콜백 함수를 사용한 코드를 사용하였다. 콜백함수를 사용하게 되면 각각의 원소에 대해 타입힌트를 적용할 수 있고 타입힌트로 인해 다른 타입이 들어오는 경우에는 에러를 내며, IDE는 타입힌트를 통해서 오브젝트 내부에 프로퍼티가 있는지 추론을 할 수 있어서 코드를 편하게 짜는데 도움을 준다.

php는 배열에 하나의 유형 뿐만 아닌 다양한 유형을 갖고 있기 때문에 배열에서 데이터를 뽑아 쓸때마다 불안한 느낌을 준다. 반복 가능한 유형에 콜백함수를 사용하는 표현으로 타입힌트를 걸어주면 타입을 한 번 짚고 넘어갈 수 있기 때문에 코드에 안정감을 주게 된다.

## phpdoc 제네릭

phpdoc을 사용하여 `/* @var array<int, Type> */` 또는 `/* @template Type */` 템플릿을 사용하면 php에서 제네릭을 사용할 수 있다.

```php
/**
 * @template T
 */
class Lifo
{
    /**
     * @var array<int, T>
     */
    private array $array = [];

    /**
     * @param T $value
     */
    public function push(mixed $value): void
    {
        $this->array[] = $value;
    }

    /**
     * @return T|null
     */
    public function pop(): mixed
    {
        return array_pop($this->array);
    }
}

/** @var Lifo<int> $lifo */
$lifo = new Lifo();
$lifo->push(1);
$lifo->push(2);

$sum = ($lifo->pop() ?? 0) + ($lifo->pop() ?? 0);
```

docblock generic은 언어의 네이티브 문법이 아니고 제 3자의 정적 분석 도구에 의존하며, 런타임의 타입 확인을 하지 않는다. 네이티브 문법이 아니기 때문에 언어의 내장 툴에 비해 작성해야 하는 보일러 플레이트의 양이 많으며, 언어의 동작에 영향을 주지 않기 위해서 런타임 체크가 없다. 또한 docblock으로 타입을 맞출 때, docblock 자체는 IDE에 의한 구문 지적이 없기 때문에 docblock을 타이핑 할 때 실수하기 쉽고 무엇이 잘못되었는지 파악하기 어려운 문제가 있다.

또한 정적 분석 도구들은 타사 라이브러리이므로 프로젝트에 phpstan을 사용하는데, 라이브러리는 psalm을 사용하고 있다면, 라이브러리의 코드를 사용할 때 타입 추론이 안 되는 호환성 문제가 발생할 수 있다.

## 유니온 타입의 문제

php의 각종 라이브러리가 유니온 타입으로 타입이 만들어져 있고, 제네릭을 사용하지 않기 때문에 라이브러리의 기능이 유니온 타입 또는 클래스 타입이라면 유니온 타입 중의 몇 가지 타입, 하위 타입 중의 무언가를 사용하는데 모든 코드에 대해, 정적 분석을 사용하면 라이브러리의 타입 힌트로 제공되는 모든 타입에 대한 처리를 만들어야 한다.

예를 들어 라라벨의 Eloquent를 사용했을 때 `SomeModel::someQuery()->first()`라는 코드를 사용했을 때, [`Model|object|BuildsQueries|null`](https://api.laravel.com/docs/10.x/Illuminate/Database/Eloquent/Builder.html#method_first)가 타입힌트로 되어 있다. 라라벨 11 부터는 phpstan으로 정적 분석이 되도록 [TValue|null](https://api.laravel.com/docs/11.x/Illuminate/Database/Eloquent/Builder.html#method_first)을 지원하지만, 라라벨 10 이전이라면, Model|object|BuildsQueries|null 정적 분석 툴을 사용하면 모든 타입에 대한 분기처리를 해야 한다. 하지만 일반적인 상황에서 실제 first가 반환하는 값은 SomeModel 클레스의 인스턴스 또는 null을 두 가지 타입 뿐이다.

정적 분석 도구는 `assert`를 통해서 타입 좁히기 기능을 제공하기 때문에 `assert`로 유니온 또는 상위 타입에 실제 사용되는 일부 또는 하위 타입을 구체적으로 알려주는 것을 통해서 모든 타입에 대한 분기처리가 아니라, 실제 사용하는 타입에 대한 처리만 하는 코드를 작성하도록 도울 수 있다.

```php
$someData = SomeModel::someQuery()->first();
assert(is_null($someData) || $someData instanceof SomeModel);
```

SomeModel은 Model 인스턴스를 상속하여 정의한 모델으로 Model의 하위 타입이다. 따라서 타입 좁히기를 통해서 변수에 할당된 값이 SomeModel 타입 또는 null으로 정적 분석 툴과 IDE에 알려 준다. 그러면 `assert` 이후 라인 부터는 `$someData` 변수를 사용할 때 null과 SomeModel 두 가지 타입에 대한 처리만 하면 된다.

Eloquent 모델 내에서 메소드를 오버라이딩 하는 방법도 존재한다. 마찬가지로 부모 클래스의 메소드의 반환 값이 Model|object|BuildsQueries|null 타입을 가지고 있으므로 타입 좁히기를 해 주어야 한다.

```php
public function first(array|string $columns = ['*']): ?SomeModel
{
    $first = parent::first($columns);
    assert(is_null($first) || $first instanceof SomeModel);
    return $first;
}
```

위 방법은 first가 존재하는 클래스에 정의해 주어야 하기 때문에 first가 정의된 [BuilderClass](https://timacdonald.me/dedicated-eloquent-model-query-builders/)를 상속받는 클래스에 적어 주어야 한다.

## Type narrowing의 문제

타입스크립트는 타입에 의한 안정성을 최대한 확보하기 위해서 전달된 변수를 사용할 때 변수가 가진 모든 타입에 대한 처리를 요구한다. as를 사용해서 타입좁히기를 하면 모든 타입 중에서 일부 타입만 전달되는 것을 가정하고 코드를 전개하기 때문에 런타임에 좁힌 타입과 다른 타입이 전달될 경우 연결된 코드의 타입 추론이 잘못되어 런타임에 잘못된 동작을 하게 될 가능성이 존재한다.

다음 리액트 코드에서 `event.target`는 여러 태그 요소 중 하나를 자바스크립트의 인스턴스로 만든 것이다. 전달되는 태그는 여러 태그 중 어느 태그가 전달되는 것이고, 태그들 각각이 서로 다른 타입을 갖기 때문에 여러 타입 중 어느 하나를 알려 줘야 다음 코드를 작성할 수 있어서 as를 사용하여 타입 좁히기를 통해서 타입을 알려 주었다.

```ts
const handleClick = (event: React.MouseEvent) => {
  const target = event.target as HTMLButtonElement;
  console.log(target.value);
};
```

타입스크립트에서는 위의 코드 대신에, 제네릭을 통해서 다음과 같이 `.target`의 타입을 구체적으로 지정하는 방식을 추천한다. `React.MouseEvent<HTMLButtonElement>`으로 전달되는 이벤트의 타입을 정확하게 지정하는 것으로 `event.target`의 타입을 정확하게 도출해 낼 수 있도록 한다.

```ts
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
  const target = event.target;
  console.log(target.value);
};
```

하지만 onClick 이벤트 핸들러는 런타임에서 호출되어 이벤트를 전달하므로 타입스크립트로 정한 타입과 실제 이벤트로 생성되어 이벤트 함수로 전달되는 인자의 타입 불일치가 있을 수 있으므로 개발 시 반드시 런타임에서 이상 동작이 없는지 확인을 해야 한다. 자바스크립트가 동작할 때 덕타이핑 미스매칭이 발생하지 않으면 잘못된 부분을 알지 못할 수도 있기 때문에 다음과 같이 잘못된 부분을 좀 더 명확히 체크하는 쪽이 좋다.

```ts
const handleClick = (event: React.MouseEvent) => {
  const target = event.target;
  if (target instanceof HTMLButtonElement) {
    console.log(target.innerText);
  } else {
    console.warn('type mismatching');
  }
};
```

### 런타임으로 동작 확인의 중요성

러스트의 등장, 모바일 애플리케이션 개발으로 인한 스위프트, 코틀린 등의 등장과 프론트앤드에 타입스크립트 보급이 활발하게 이뤄지면서 타입 안전한 코드 작성을 용이하게 하고 있다. 그리고 이들 언어에 의해 타입의 장점이 알려지며 점점 더 타입 안전한 코드를 작성하고자 하는 수요가 늘어나고 있다.

일반적인 웹 개발은 비즈니스 로직이 중요한 부분을 담당한다. 사용자의 입력값에 대한 적절한 벨리데이션, 입력값과 저장된 값을 비교하여 적절한 논리적인 제약사항을 표현하는 것들은 동일한 타입 안에서의 값의 차이가 중요한 분야가 많다. 동일한 타입 내에서의 값의 변화를 새로운 타입을 만들어 추상화를 하는 것은 때때로 유용하지만 경우에 따라 어렵거나 불가능하며 쉽게 비즈니스 로직의 제약사항을 표현할 수 있음에도 타입 안정성을 지나치게 추구하다가 이해하기 어려운 코드를 만들 수 있다.

또한 각종 외부에서 입력된 값을 프로그래밍 언어에 매핑하는 과정, 디비와 같은 외부 데이터를 프로그래밍 언어에 매핑하는 과정은 반드시 런타임 확인이 필요한 부분이다. 일반적인 비즈니스 로직을 처리할 때 런타임 확인은 빼 놓을 수 없는 상당히 중요한 분야이며 각종 비즈니스 로직의 처리가 필수적인 웹 프로그래밍에서 런타임 확인이 빠질 수는 없다.

### php에서 타입 좁히기가 괜찮은 방법인 이유

`assert`를 통한 타입 체크 기능은 타입 좁히기를 사용하기 때문에 타입 시스템을 통한 안정성을 획득하는 측면에서 제네릭에 비할 수 없으며 불완전하다. 하지만, 대부분의 언어가 컴파일이 되면서 제네릭 타입이 삭제되어 런타임 타입 확인이 불가능한 것에 반해 (C#은 제네릭의 타입 삭제가 이뤄지지 않는 좋은 언어이다.) php는 런타임에 거의 대부분의 타입을 확인할 수 있고, 빌드라는 시간이 걸리는 과정 없이 빠르게 실행하여 전달되는 타입의 적절성을 체크할 수 있기 때문에 제네릭이 없더라도 타입 안정적인 코드를 잘 작성할 수 있다.

php에서 실제 프로덕션 환경에서 타입으로 인한 문제가 자주 발생하는 코드를 작성한다면, 컴파일 언어를 사용해도 비슷한 문제를 만드는 코드를 작성할 가능성이 높다. php는 가능한 정적 분석에 의해 구문 분석이 가능한 방향의 코딩을 하는 스킬이 필요하고, 컴파일 언어는 컴파일러에 의해 잘못된 코드의 확인이 가능한 방향의 코딩을 하는 스킬이 필요하다.

## PHP에 왜 제네릭이 없는가?

php 파서의 모던화에 공헌했던 [니키타의 의견](https://www.reddit.com/r/PHP/comments/j65968/comment/g83skiz/?utm_source=share&utm_medium=web2x&context=3)을 보면 php에 제네릭을 도입하는 것이 쉬운 것이 아님을 알 수 있다. 제네릭을 사용한 php 파서에서 유형 추론의 복잡성 문제, php 파서의 대량의 리펙토링 문제, 런타임 성능 저하의 문제 등의 문제로 쉽사리 도입되지 못하고 있다.

만약 제네릭을 도입하게 되더라도 더 이상 php라고 할 수 없을 정도의 변경사항이 발생할 수도 있다는 의견이 있다. php는 레거시 코드에 대한 최대한의 호환성을 유지하면서 업데이트가 되는 전략을 가지고 있으므로 제네릭 도입으로 기존의 코드를 너무 많이 수정해야 한다면, php의 호환성의 이점이 사라질 것이다.

또한 php는 오픈소스로서 php의 코어에 자발적으로 공헌하는 개발자들에 의해 유지된다. 언어의 스펙을 변경할 수 있는 풀 타임 개발자를 상당한 비용을 지불해서 고용하기 어렵기 때문에 대규모의 리펙토링은 현실적으로 어려움이 있다. 최근 php 파운데이션의 설립으로 php 코어에 기여할 수 있는 풀타임의 개발자들을 고용하는 것으로 대량의 리펙토링 문제는 어느정도 해결 될 것으로 보인다.

하지만 php 파서가 하나의 파일만을 확인하는 인터프리터 언어의 특징상 도입이 쉽지 않은 것이 php의 제네릭이므로 개발 리소스 뿐만 아닌 이론적인 어려움이 있다고 한다.

php의 제네릭 연구는 php 파운데이션의 [다음 기사](https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections/#fluid-arrays)를 참고하자.

### 런타임 타임 확인을 고집하기

타입스크립트, 파이썬, 자바 등 많은 언어에서 제네릭을 지원하기 위해 컴파일 후 제네릭의 타입이 삭제되는 방식을 도입하여 런타임 타입을 확인할 수 없는 경우가 있다. 하지만 php는 가능한 런타임 타입 확인을 할 수 있는 언어로 남고자 하기 때문에 파이썬이나 타입스크립트와 같이 런타임에 타입이 삭제하는 방향의 변화를 거부한다. 런타임 타입 삭제 기능이 필요하다면 php 언어의 네이티브 기능이 아닌 docblock을 사용한 정적 분석이 타입 체크 기능을 잘 지원하기 때문에 phpdoc을 이용하도록 권장한다.

### 런타임 타입 체크 기능이 여전히 필요한 이유

php는 타입힌트를 통해서 런타임 타입 검사를 한다. 타입힌트는 정적 분석 도구나 IDE에 타입 검사를 할 수 있게 해 준다는 장점도 있지만, 런타임 타입 검사를 하기 때문에 무시해도 될 정도이긴 하지만 약간의 성능 저하를 유발한다. 이 때문에 일부 사람들은 php에서 제네릭을 도입하기 위해서 미래에는 타입힌트의 런타임 타입 확인 기능을 삭제하고, 타입스크립트와 같이 실제 코드가 실행되기 전에 타입 체크를 하는 언어로 바꾸자는 주장을 하기도 한다. 하지만 런타임 타입 체크를 하지 않는 것이 마냥 좋은 것은 아니다.

런타임에서 타입을 확인하지 않는 것은 어떠한 값이든 전달 가능하다는 문제가 있다. 그래서 런타임에서 타입과 미스 매칭되는 값이 잘못 들어가지 않도록 외부의 값이 프로그래밍 언어로 매핑될 때 잘못된 타입으로 전달되지 않도록 정확한 타입으로 매핑 되는지 확인하는 작업이 필요하다. 타입스크립트의 경우 Zod, Ajv, Yup, Joi, Valibot 등의 라이브러리를 통해서 잘못된 타입이 매핑되지 않도록 방지한다. 자바나 C#의 경우 ORM의 정의와 실제 디비의 스키마가 불일치하는 임피던스 미스매칭 현상이 발생하지 않도록 주의해야 한다.

또 다른 런타임 타입 확인이 없을 때의 문제는 런타임에 잘못된 값이 전달되지 않게 하기 위해 지나치게 엄격하게 타입을 지정해야 하는 문제가 생긴다. php에서는 정적 추론 도구를 사용하지 않은 개발로 많은 프로젝트가 만들어 졌는데, 개발 초기 단계 부터 엄격하게 타입의 정적 추론이 가능하도록 짜 놓은 프로젝트인 경우 리퀘스트로 데이터가 전달되는 부분이나 데이터베이스의 값을 프로그래밍 언어의 값으로 매핑하는 부분만 런타임 확인을 해 주면, 그 이후로는 런타임의 타입 검사를 배제해도 잘못된 타입이 들어가는 경우를 막을 수 있지만, 정적 추론 없이 오랫동안 작성되어 온 php 프로젝트라면 정적 추론을 위해 모든 데이터 전달 플로우에 타입을 넣어야 하는데 이는 현실적으로 어려운 문제에 직면할 수 있다.

또 다른 문제는 외부 라이브러리나 외부에서 전달된 값을 사용할 때 지정된 타입 이외의 다른 어떤 타입의 값이 전달되어 사용되는지 확신 할 수 없는 경우가 있다. 타입 안정적인 코드를 작성하려면 모든 예외 사항에 대한 어떤 타입의 처리를 할지에 대한 명세를 만들어야 한다는 것이다. 이런 것이 불가능한 경우가 있기 때문에 런타임의 타입 검사를 통해서 기대하지 못한 타입의 전달으로 처리될 수 없는 경우 에러를 발생 시켜 예측하지 못한 상황에 대해 다음 부터는 어떻게 처리 할지 추가적인 처리를 점진적으로 만들어 나가는 방식으로 대응하도록 한다.

런타임의 타입 검사의 장점은 모든 데이터 전달 플로우의 타입이 명확하게 정의되고 벨리데이션도 완벽하게 갖춰지지 않는 상태에서 작성한 코드의 동작을 런타임으로 타입 미스매칭이 발생한 부분을 개선하는 것으로 작성한 코드의 타입 안정성을 확보할 수 있다는 장점을 갖고 있다.

제네릭 도입을 위해서 런타임 타임 검사를 제거하자는 의견이 제기되고 있지만, 수 많은 타입추론 불가능한 php의 코드에서 런타임 이전에 타입을 검사할 수 있는 시스템으로 변경하는 것은 현실적으로 불가능에 가깝기 때문에 런타임 타입 체크 기능을 유지하면서 php는 발전하고 있다.

## 마지막으로

php는 네이티브 제네릭이 없다. 하지만 docblock 제네릭을 사용하거나 유니온 타입을 사용하고 `assert`로 타입을 좁히는 방식과 컴파일 없이 빠르게 런타임 동작을 확인하는 것으로 제네릭이 없는 한계를 극복하면서 로직을 작성할 수 있다.

엄격한 타입 시스템이 아니기 때문에 런타임에 전달되는 타입을 확인해야 하는 단점이 있기도 하지만, 엄밀한 타입 정의를 생략하고 런타임 확인을 통해서 전달된 타입을 확인하는 것으로 간단히 로직을 작성할 수 있다는 장점이 있다.

php만으로 비즈니스 로직을 구성하고, 서비스를 제공하는데 문제는 없다. 하지만, 최근 많은 언어들이 좋은 타입 시스템을 도입하고 있기 때문에 좋은 타입 시스템을 배울 수 있는 다른 언어도 함께 배울 수 있는 환경이 있다면 좋을 것 같다.
