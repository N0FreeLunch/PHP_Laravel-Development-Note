# 제네릭

여러 프로그래밍 언어 가운데서 php는 동시성 처리, 함수형 프로그래밍, 정적 분석 등에서 약한 면모를 가진 언어이다. 이런 약점을 극복하고 좋은 퀄리티의 제품을 만들기 위해서는 php를 잘 다루는 방식을 알아야 한다. 자바스크립트와도 조금 다르고, 루비와도 조금 다르고, 여타 컴파일 언어와도 좀 다른 php를 잘 다루면 괜찮은 언어이지만, 잘 다루지 못한다면 다른 언어들이 갖는 보편적인 특성과는 다른 특성들로 인해 혼란스럽고 이상한 언어로 보일 것이다.

php에는 다른 언어에서 흔히 볼 수 있는 제네릭이라는 문법이 없다. 써드 파티로 별도의 정적 분석 툴을 도입해서 제네릭을 사용할 수 있지만, 많은 양의 레거시 코드가 존재하면 정적분석 툴을 도입한다고 했을 때 코드의 수정이 만만치 않고 기존의 코딩 스타일을 정적 분석에 맞는 코딩 스타일로 바꿔야 하기 때문에 불편함이 생기므로 쉬이 도입하지 못하는 경우도 많다.

php에는 제네릭 문법이 없는데, 없어서 아쉽지만 제네릭이 없더라도 코딩에 크게 불편함을 주지는 않는다. 본 글은 php에서 제네릭이 없더라도 크게 불편하지 않았던 이유, 제네릭이 없더라도 이를 극복하고 php를 잘 활용할 수 있는 방법에 대해 서술한다.

## 자료구조

프로그래밍을 배울 때 자료구조라는 데이터를 다루는 방법을 배운다. 이 자료구조는 데이터를 저장하는 방식에 대한 것이고, 데이터를 저장하는 방식에 따라 데이터를 저장하는 과정과 데이터 더미에서 특정한 데이터를 뽑아 내고자 할 때의 효율이 달라지기 때문에 적절한 데이터 구조를 사용해서 프로그래밍을 해야 한다고 가르친다.

### php에서 자료구조

#### 연관 배열

php는 연관 배열이라는 자료 구조를 사용한다. 연관배열은 키-벨류 쌍의 데이터를 저장하는 방식이다. php에서 키를 지정하지 않고 배열에 데이터를 저장을 해도 0,1,2,3...의 인덱스가 생기는데 php에서 배열은 반드시 키를 가져야 하는 연관배열이므로 키를 지정하지 않은 경우 자동으로 0 이상의 정수 키를 생성하기 때문이다.

다양한 종류의 자료 구조를 사용하는 다른 언어들과 달리 php는 데이터 구조로 주로 연관 배열을 사용하는데, 연관 배열은 다양한 자료구조를 연관 배열 하나로 대신할 수 있다는 장점을 가지고 있다. 문제는 php의 연관배열은 너무 다양한 구조를 가질 수 있기 때문에 배열을 대상으로 하는 알고리즘에 배열을 전달 되었을 때 구체적으로 어떤 결과를 만들어낼지 알기 어렵다는 문제가 있다.

```php
[
    'a' => 1,
    'b' => 'B',
    'c' => [
        'q' => [ 'r' => 's' ],
        't' => [ 'u' => false ],
    ],
    'd' => new class { public int $x = 'y'; }
    100 => 'z'
]
```

위와 같은 배열이 어떤 알고리즘으로 전달되었을 때 이 배열이 어떻게 변환되어 반환될지 예측하기 어려울 수 있다.

#### SPL 라이브러리

php에는 연관 배열이외에도 자료구조를 구현한 클래스 개념이 존재하며 [SPL](https://www.php.net/manual/en/book.spl.php)이라는 자료구조를 다룰 수 있는 기능을 제공한다. 하지만 SPL 라이브러리를 사용한 사례는 잘 찾아보기 어려운데, php에서 제공하는 연관 배열으로도 다양한 처리를 할 수 있는 편리함을 제공하기 때문에 불편한 SPL 라이브러리를 사용할 필요성을 느끼지 못하는 경우가 많기 때문이다. 하지만, 연관 배열이 다양한 구조를 갖는 것과 달리 SPL의 자료구조를 활용하면 어떤 데이터 처리 방식을 사용해야 하는지를 알려주기 때문에 상황에 따라 유용하게 사용하 수 있다.

> “SPL data structures are horribly designed.” — Anthony Ferrara [<sup>링크</sup>](https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd)

SPL 라이브러리는 최적화된 설계를 하지 않아서 느리다는 평이 있다. 하지만 php를 사용하는 대부분이 성능 보다는 비즈니스 로직에서 발생하는 요구사항을 처리하기 위해서 사용하므로 성능적인 비판이 있음에도 대부분의 상황에서 사용하는데 문제가 없다고 생각한다.

연관 배열은 워낙 다양한 방식으로 다룰 수 있고 다양한 구조를 갖고 있다보니 특정한 방식으로 데이터를 다뤄야 할 필요성이 있다면 데이터를 다루는 방식에 제약을 두는 편이 좋을 수 있다. 이 때, SPL 라이브러리로 데이터를 다루면 적절하게 쓰일 수 있다.

## 제네릭 이해하기

### 제네릭이란?

프로그래밍 언어에서 제네릭은 특정 타입에 의존적이지 않는 기능을 제공하는 것이다.

타입에 의존적이지 않은 기능이 무엇인지 알아 보자. 제네릭을 사용하는 기능은 제네릭으로 지정한 값을 다루는 방식에 제한이 있을 수 있다. 예를 들어 변수 `$a`에 할당된 값이 int 또는 string 타입을 갖는다고 하자. 그럼 이 코드를 동작 시키기 위한 범용적인 코드를 만들기 위해서는 `strtoupper($a)`와 같은 문자열을 대상으로 하는 함수와 연결하면 안 된다. 왜냐하면, `$a`가 정수인 경우 에러가 발생하여 주어진 타입 모두에 대해 성립될 수 없기 때문이다. 그에 반해 `intval($a)`는 정수와 문자열 모두에 사용될 수 있으므로 변수에 연결해도 좋은 코드이다. 이렇게 전달하려는 값의 타입 중에서 일부 타입에 대해서만 처리된다면 특정 타입에 의존적인 것이고 전달되려는 값의 타입 모두를 처리할 수 있는 것이 타입에 의존하지 않는다는 의미이다.

#### 타입스크립트의 제네릭

php 개발자라면 자바스크립트에 대한 지식이 어느 정도 있을 것이다. 타입스크립트는 자바스크립트에 타입을 추가한 것으로 간단한 타입스크립트의 예를 통해 제네릭을 쉽게 이해할 수 있을 것이다.

타입스크립트는 자바스크립트의 배열의 원소의 타입을 지정할 수 있는 제네릭을 제공한다. `Array<T>`에서 T 부분에 타입을 넣는 것을 통해서 배열의 원소 타입을 제한 할 수 있다.

```ts
const elements: Array<number> = [1, 2, 3, 4, 5];
```

타입 Array 옆에 `<number>`를 붙여주는 것을 통해서 배열 안의 모든 원소는 `number`으로 타입이 정해져서 배열 안에 다른 타입을 넣을 경우, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다.

```ts
const elements: Array<string> = ['a', 'b', 'c', 'd', 'e'];
```

마찬가지로 `<string>`을 붙여주는 것을 통해서 배열 안의 모든 원소는 `string`으로 타입이 정해져서 배열 안에 다른 타입을 넣을 경우, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다.

#### 제네릭과 유니온

```ts
const elements: Array<T> = [e1, e2, e3, e4, e5];
```

위 코드에서 타입 T에 대해서 `e1`, `e2`, `e3`, `e4`, `e5`를 사용하게 되면, 각각의 원소는 `<T>`에 지정한 타입이 되어야 한다. 배열을 사용할 때 원하는 타입을 지정할 수 있기 때문에 `<T>`로 타입을 지정해 사용하는 것은 특정 타입에 의존적이지 않은 기능을 제공한다.

```ts
const elements: Array<number | string> = [1, 'a', 3, 'b', 5];
```

`<T>` 부분에 `<number | string>`으로 유니온 타입을 지정하면 배열 안의 원소는 `number` 타입과 `string` 타입을 두 종류의 값을 넣을 수 있기 때문에, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하지 않는다. 단, 각각의 원소를 꺼내 쓸 때 원소가 수인 경우와 문자열인 경우를 분기해서 처리해 줘야 한다.

#### 제네릭의 유용성

```ts
const elements: Array<string> = ['a', 'b', 'c', 'd', 'e'];

console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
```

`.toUpperCase()` 메소드는 문자열인 대상에서만 사용할 수 있는 메소드이다. 만약 `numbers.pop()`으로 꺼낸 값이 문자열이 아니라면, 꺼낸 값에 `.toUpperCase()`을 사용한 코드는 IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다. 배열에서 더 이상 꺼낼 데이터가 없을 때 `undefined`를 반환하므로 `.toUpperCase()`에 연결하기 위해서 빈 문자열이 되도록 `?? ''` 코드를 추가해 주었다.

만약 `elements.pop()`으로 꺼낸 값이 문자열 뿐만 아닌 수 타입인 경우 `.toUpperCase()` 메소드가 존재하지 않기 때문에 사용할 수 없다. 제네릭을 사용해서 배열의 원소 타입을 문자열로 제한했기 때문에, `.toUpperCase()`을 붙이는 코드를 사용할 수 있다.

### 제네릭 문법

타입에 의존적이지 않고 동작하는 어떤 기능에 대해, 특정 타입에 대해서 기능을 사용할 수 있도록 하는 문법을 '제네릭 문법'이라고 한다. 타입 스크립트의 예를 들면 배열(`Array<T>`)은 타입에 의존적이지 않지만, `<>` 부분에 `<string>`이나 `<number>` 등의 타입을 지정하는 것을 통해서 지정한 타입으로 기능을 사용하도록 한다.

자료구조에서 특히 제네릭을 많이 사용하는데, 특정 자료구조가 값을 저장할 때 타입에 구애받지 않고 값을 저장할 수 있도록 하기 위함이다. 예를 들어 어떤 자료구조를 사용하는데, A라는 타입의 데이터만 저장할 수 있다면, B라는 타입일 때 사용할 수 있는 자료구조를 또 만들어야 하고, C라는 타입일 때 사용할 수 있는 자료구조를 또 만들어야 한다. 하지만, 제네릭 개념을 적용한 자료구조라면 어떠한 타입이든 저장할 수 있는 특성을 갖고 있기 때문에 저장할 데이터의 타입에 관계없이 사용할 수 있는 유연성을 제공한다.

## php로 제네릭 이해하기

데이터를 넣은 순서대로 데이터가 뽑히는 Last In First Out 자료구조를 php로 간단히 만들어 보자.

```php
class Lifo
{
    private array $array = [];

    public function push($value)
    {
        $this->array[] = $value;
    }

    public function pop()
    {
        return array_pop($this->array);
    }
}

$lifo = (new Lifo);
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');
var_dump($lifo->pop());
var_dump($lifo->pop());
var_dump($lifo->pop());
```

`push('a')` `push('b')` `push('c')`의 순서대로 데이터를 넣었고, 마지막에 넣은 값 부터 차례로 값이 뽑힌다.

### 타입힌트 생각해 보기

문자열의 값을 넣는다고 생각해 보자. 그럼 `public function push(string $value)`와 `public function pop(): string`이란 타입힌트를 줄 수 있다.

정수를 넣는다고 생각해 보자. 그럼 `public function push(int $value)`와 `public function pop(): int`이란 타입힌트를 줄 수 있다.

임의의 타입을 넣는다고 생각해 보자. 그럼 `public function push(mixed $value)`와 `public function pop(): mixed`이란 타입힌트를 줄 수 있다. 하지만 이 경우에는 데이터를 꺼냈을 때 어떤 타입인지 타입힌트에 의해 특정되지 않는다.

위 클래스의 내부 구조를 모르고 인터페이스만 안다고 하자. `push`와 `pop` 메소드가 있다는 것만 알고 있다. php에서는 클래스 내부에 타입힌트를 주어야 하는데, 외부에서 저장할 데이터의 타입을 결정할 방법이 없다.

만약 php가 제네릭을 지원한다면 `Lifo` 클래스를 사용할 때 클래스 내부에서 데이터를 저장할 때 외부에서 전달된 타입으로 제약을 걸 수 있을 것이다. `new Lifo<타입>` 이렇게 제네릭 문법을 사용해서 타입을 전달하면, `public function push(T $value)`와 `public function pop(): T`으로 `T` 자리에 클래스에서 `<타입>`으로 지정한 값의 타입 들어가 타입 안정적인 코드를 작성할 수 있다. `<string>`을 넣으면 `push(string $value)`와 `pop(): srting`이 되고, `<number>`을 넣으면 `push(number $value)`와 `pop(): number`가 된다.

### 각각의 타입에 대한 코드 작성해 보기

```php
class Lifo
{
    private array $array = [];

    public function push(int $value)
    {
        $this->array[] = $value;
    }

    public function pop(): int
    {
        return array_pop($this->array);
    }
}
```

```php
class Lifo
{
    private array $array = [];

    public function push(string $value)
    {
        $this->array[] = $value;
    }

    public function pop(): string
    {
        return array_pop($this->array);
    }
}
```

#### 타입 파라메터가 존재한다면?

제네릭은 다른 말로 타입 파라메터라고 부른다. 타입을 파라메터 처럼 지정하고 기능을 사용할 때 타입을 지정하는 것으로 타입 파라메터에 타입을 전달하기 때문이다.

php에는 제네릭이 존재하지 않지만 다음과 같은 코드를 상상해 볼 수 있다.

```php
class Lifo<T>
{
    private array<T> $array = [];

    public function push(T $value)
    {
        $this->array[] = $value;
    }

    public function pop(): T
    {
        return array_pop($this->array);
    }
}

$lifoString = new Lifo<string>;
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');

$lifoInt = new Lifo<int>;
$lifo->push(1);
$lifo->push(2);
$lifo->push(3);
```

타입 힌트 위치에 T라는 타입 파라메터를 사용하고 클래스를 객체로 인스턴스화 할 때 타입 파라메터에 전달할 타입을 `<string>`이나 `<int>`로 지정하는 방식으로 사용할 수 있다. 그럼 T의 위치에 `string`이나 `int`가 나온다.

#### 타입스크립트로 이해하기

제네릭을 지원하는 타입스크립트로 php 코드를 타입스크립트로 바꿔 이해해 보자.

```php
class Lifo<T> {
    private array: T[] = [];

    public push(value: T): void {
        this.array.push(value);
    }

    public pop(): T | undefined {
        return this.array.pop();
    }
}

const lifo = new Lifo<string>();
lifo.push('a');
lifo.push('b');
lifo.push('c');

console.log(lifo.pop()); // 'c'
console.log(lifo.pop()); // 'b'
console.log(lifo.pop()); // 'a'
```

Lifo라는 클래스에 제네릭 문법으로 `<string>` 타입을 지정하는 것을 통해서 `lifo.push()`으로 값을 넣을 때, `lifo.pop()`으로 값을 꺼낼 때 문자열만을 (꺼낼 값이 없을 때는 `undefinded`) 반환하도록 한다.

`Lifo<string>`, `Lifo<number>`으로 제네릭 문법에 어떤 타입을 지정하느냐에 따라 `Lifo` 클래스 내부의 T로 되어 있는 부분의 타입이 달라진다. T는 어떤 타입을 받을지를 정하는 파라메터의 역할로 타입을 받는 타입 파라메터의 역할을 한다.

### 컴파일 언어에서의 제네릭

컴파일 언어에서 어떤 자료 구조를 정했다면 저장할 데이터의 타입을 정해야 한다. 자료구조는 다양한 타입에 대해서 동작하기 위해 제네릭을 사용한다. 이 때 저장할 데이터가 가진 타입을 지정할 수도 있고 인터페이스를 지정할 수도 있다. 여러 타입을 지정하고 싶은 경우에는 공통의 인터페이스 또는 상위-하위 관계의 클래스 또는 여러 클래스의 공통의 상위 클래스를 타입으로 지정해야 한다. 이 때 제네릭으로 지정하지 않은 다른 타입의 값을 사용할 수는 없는데, 이는 어떤 자료 유형의 데이터 저장소에서 데이터를 꺼내 쓸 때 타입 또는 인터페이스가 달라지면 런타임의 동작에서 잘못된 타입을 참조하거나 전달하는 치명적인 에러가 발생할 수 있기 때문에 지정한 타입에 대한 맞물리는 코드를 사용하도록 제한을 하기 위해서이다.

컴파일 언어는 타입을 통해서 제한된 방식의 코딩 스타일을 제공하고 컴파일을 통해서 기계어나 기계어에 가까운 레벨의 중간언어(JAVA의 Bytecode, C#의 CLI : Common Intermediate Language)로 번역을 한다. 기계어나 중간언어는 컴파일 타임에 모든 타입 안정성을 체크하기 때문에 런타임의 동작에서 타입을 체크하지 않아도 타입으로 인한 에러가 발생하지 않는다.

컴파일 언어처럼 런타임에서 타입이 사라지면 좀 더 빠른 속도를 기대 할 수 있기 때문에 php 진영의 일부 급진주의자들은 빠른 속도를 위해서 타입힌트를 통한 런타임 타입 검사를 없애고 언어 자체에 내장된 정적 분석으로 대체해야 한다는 주장을 하기도 한다.

자료구조의 경우 데이터를 저장하고 꺼내쓰는 작업을 하는데 데이터를 꺼냈을 때 어떤 타입인지 알아야 어떤 접근을 할지 알 수 있다. 컴파일 언어는 런타임에 타입 체크를 하지 않기 때문에 데이터를 꺼냈을 때 어떤 타입인지 체크하는 동작을 하지 않고 꺼내 쓴다. 이 때 메모리에 저장된 값과 전달하려는 런타임의 간의 타입 불일치가 일어나면 치명적인 에러가 발생할 수 있다. php의 경우 타입 불일치가 일어나면 언어 자체의 에러를 예외 처럼 던져 스텍 트레이스를 생성하는 것에 반해 기계어나 중간 언어로 번역된 코드를 실행하는 컴파일 언어는 이를 처리할 수 없다. 그래서 이런 일이 발생하지 않도록 컴파일 타임에 강력하고 엄격한 정적 검사를 수행한다.

따라서 컴파일 언어는 이용할 타입을 컴파일 타임에 지정해 두어야 한다. 자료 구조의 사용과 동시에 자료 구조 안에 들어갈 타입을 지정하는데 이것이 컴파일 언어에서 제네릭이라고 부르는 문법이다.

### php에서의 제네릭

php와 같은 동적 언어는 어떤 자료구조에 데이터를 넣을 때 타입 제약이 없다. 타입 제약이 없는 대신 하나의 함수나 객체를 사용할 때 여러 타입의 데이터를 전달하고 처리하게 코드를 작성할 수 있다. 컴파일 언어에서 제네릭을 사용하면 지정하지 않은 타입의 값의 전달 및 출력이 컴파일러의 정적 타입 검사에 의해 원천적으로 차단되어 있는 것과 달리 php는 제네릭이 없는 대신 어떠한 타입의 값도 전달할 수 있다. 다만 서로 상이한 타입의 값을 넣었다면 각각의 값을 처리하는 방법이나 맞물려 처리되는 코드가 달라지기 때문에 런타임에서 사용한 기능에서 나온 값의 타입을 체크하고 각 타입에 적합한 처리를 해 줘야 한다.

### 유니온 타입으로 제네릭 대체하기

앞서 소개한 예제의 Lifo 클래스에서 내부에 타입힌트를 `string`으로 정의했는지 `int`로 정의했는지에 따라서 배열 안의 데이터로 전달할 수 있는 대상은 문자열이 되기도 하며, 정수가 되기도 한다. 문자열만을 저장하는 Lifo를 쓰고 싶다면 문자열 타입힌트를 갖는 클래스를 만들어야 하고, 정수만을 저장하는 Lifo를 쓰고 싶다면 정수 타입힌트를 갖는 클래스를 만들어야 한다. 하나의 타입으로 제한되어 있기 때문에 `push` 메소드로 타입을 전달할 때, `pop` 메소드로 값을 꺼낼 때 하나의 타입에 대해서만 (꺼낼 대상이 없는 경우는 null을 추가로) 생각하면 된다.

하지만 여러 클래스를 만드는 것은 효율적이지 못하다. 제네릭을 사용할 수 있다면 Lifo 클래스를 하나만 만들어 인스턴스화를 할 때 `new Lifo<string>` `new Lifo<int>` 등으로 타입을 지정해 주면 되지만 php는 지정을 할 수 없다. 이를 위해서 유니온 타입이나 모든 타입을 허용하는 mixed 타입 힌트를 사용할 수 있는데, 이렇게 되면 `push` 메소드로 타입을 전달할 때, `pop` 메소드로 값을 꺼낼 때 타입의 제한이 없다는 문제점이 있다.

타입힌트를 사용하는 것은 지정한 타입이 아니면 에러를 발생 시키는 것을 통해서 잘못된 타입의 값이 전달 되었을 때 발생하는 타입 에러를 통해서 타입이 잘못된 이유를 찾고 이를 개선하여 코드를 정확하게 작성하게 하기 위한 것과 타입힌트를 쓰면 어떤 타입의 값일지 알 수 있기 때문에 타입힌트로 지정한 타입에 대해서만 코드를 작성하면 된다는 장점이 있다. 

하지만, 실제 전달되지도 않는 여러 타입에 대한 로직 처리를 할 필요는 없기 때문에 타입힌트로 지정한 타입 모두에 대한 처리가 아닌 일부 타입에 대해서만 처리 로직을 만드는 경우가 생긴다. 인터프리터 언어의 경우 런타임에서 타입을 확인하기 때문에 타입이 `int | string`이더라도 전달되는 값이 `int`뿐이라면 `int`에 대해서만 처리하고, `string`뿐이라면 `string`에 관한 처리를 하면 된다. 하지만 정적 타입의 언어인 경우 유니온 타입이 전달되면 모든 타입 케이스에 대한 분기 로직을 작성해 주어야 한다. `int | string`가 전달되었다면 반드시 `int`에 대한 처리와 `string`에 대한 처리 모두를 해 주어야 한다. php에서도 강력한 정적 분석 툴을 사용하는 경우 유니온 타입이 갖는 모든 타입에 대한 처리를 작성해 주어야 한다.

또한 타입힌트가 `?int`으로 되어 있다면 연결되는 로직은 `int`와 `null` 모두에 대한 처리 로직을 만들어야 하며, `null`이 실제로 사용하지 않는 값이라면 `?int`가 아닌 `int`만 사용하여 타입힌트에서 제거하는 것이 해당 코드를 사용할 때 불필요한 처리를 추가로 작성하는 것을 방지한다.

이런 측면에서 보았을 때, 인터프리터 언어가 유니온 타입에 대해 전달되는 값이 유니온 타입의 일부 타입만 전달되는 것을 전제한다고 하더라도 일부 타입에 대해서 코드를 짜는 것이 아닌 유니온 타입이 갖는 전체 타입에 대한 처리 로직을 추가하는 것이 일반적인 코딩 스타일임을 알 수 있다.

php에서는 타입힌트로 사용하고자 하는 타입의 내부 타입을 설정하는 제네릭 문법이 없기 때문에, 기본적으로는 여러 타입에 대해서 성립하는 로직을 만들되, 값을 전달할 때 또는 값을 꺼내 쓸 때 유니온 타입 중에서 일부 타입에 대해서만 로직이 동작한다는 전제를 두고 코드를 작성하는 방법이 있다.

예를 들어 php에서 배열의 경우 배열 내부의 원소 타입을 지정할 수 없기 때문에 기본적으로는 mixed로 처리될 것이다. 그러나 배열에서 원소를 추가할 때 타입을 확인하고 꺼내 사용하고자 할 때 타입을 확인하는 것을 통해서 유니온 타입을 사용하더라도 유니온 타입에서 일부 타입에 대해서만 동작한다는 전제를 설정하는 코드를 만들어 이후에는 유니온 타입 전체 타입에 대한 처리 로직이 아닌 일부 타입에 대해서만 동작하는 코드를 작성하는 코딩 스타일을 사용할 수 있다.

### 제네릭이 없는 것이 단점일까?

제네릭은 무언가를 사용할 때 내부에서 사용할 타입을 지정해서 다양한 타입에 대해서 동작하는 어떠한 기능이 필요할 때 사용된다. 만약 다양한 타입에 대한 처리 기능이 있다면 해당 처리 기능을 거친 이후에 어떤 타입인지 알아야 처리후의 값을 사용할 수 있기 때문에 반드시 타입이 요구된다. 처리 후 얻어진 값의 타입을 알 수 있기 때문에, 만약 오브젝트가 얻어졌다면 오브젝트의 멤버를 IDE의 정적분석 툴을 통해서 자동완성으로 얻을 수 있고 존재하지 않는 멤버 등의 잘못된 접근 문법을 사용했을 때 코드를 직접 실행을 하지 않고서도 문법적인 잘못이 무엇인지 알려 준다.

그런데 php는 이미 어떠한 타입의 값이든 전달될 수 있고 전달된 값을 그대로 꺼내 쓸 수 있다. 제네릭을 굳이 쓰지 않아도 제네릭과 같은 기능을 이미 갖고 있는 것이다. 하지만 외부에서 타입을 지정하여 내부의 사용되는 타입에 제한을 걸 수 없기 때문에 엄격한 타입제한을 할 수 없다는 단점이 있다. 또한 처리 후의 값이 어떤 타입인지 코드의 실행 전에는 알 수 없는 경우도 많기 때문에 IDE의 정적 분석으로 해당 값의 타입이 어떤지 추론되지 않는 문제가 생길 수 있다.

하지만 처리후의 값을 꺼내서 사용할 때 타입힌트를 사용하는 코드 스타일을 통해서 어떤 타입이 쓰이는지 지정해 주면 제네릭이 없어도 타입 안정적인 코드를 만들 수 있다. 타입힌트를 통해 IDE의 정적 분석 도구가 타입을 추론을 통해 사용하고자 하는 값의 타입을 자동으로 추론해 준다.

제네릭은 외부에서 내부에서 사용할 타입을 지정하는 것이다. 그러면 처리 이후의 타입이 처리 이전에 지정된 타입으로 결정이 되는 특성이다. php의 경우에는 제네릭을 사용할 수 없지만 처리이후의 타입이 원하는 타입인지 확인하는 방식으로 제네릭을 대신할 수 있다. 어차피 외부에서 지정하는 타입이긴 마찬가지이며 미리 타입을 지정하느냐, 아니면 나중에 타입을 지정하느냐의 차이일 뿐이다.

하지만 제네릭으로 타입 제한을 걸면 꺼내 쓸 때마다 타입을 확인할 필요가 없으며 이미 타입이 결정되어 있다. 따라서 IDE의 정적 추론에 의해 자동완성을 편하게 이용할 수 있는 반면, 꺼내 쓸때마다 타입을 확인하는 코드를 작성해 주어야 하는 단점이 있다.

### Type narrowing

여러 타입을 갖는 변수에서 일부의 타입만을 사용하는 경우 `assert`를 통해서 타입의 범위를 좁힐 수 있다.

```php
declare(strict_types = 1);

class TypeNarrowing
{
    public int|string $numeric;
}

function addOne(int $value): int {
    return $value + 1;
}

$list = [100, '100'];

$obj = (new TypeNarrowing);
$obj->numeric = $list[rand(0,1)];

// assert(is_int($obj->numeric));

$result = addOne($obj->numeric);
var_dump($result);
```

`TypeNarrowing`의 멤버 변수 `$numeric`는 int 또는 string 타입을 가진다. `$obj->numeric` 코드에서 위의 코드만 보고서는 `100`이 할당될지, `'100'`이 할당될지 알 수 없다. `addOne` 함수는 `int` 타입만을 받는데 문자열 타입이 전달되면 에러가 발생한다. 이 때문에 IDE에 의한 정적 분석 또는 정적 분석 툴에 의해 `addOne($obj->numeric)`부분에 `int` 뿐만 아닌 `string`을 전달할 수 있는데 `addOne`은 `int` 타입만을 받기 때문에 정적 분석의 에러가 발생한다.

php에서 IDE에 의한 정적 분석 또는 정적 분석 툴에 의한 타입 체크를 하고 있다면, `$obj->numeric`에는 여러 타입을 가질 수 있더라도 현재의 코드 맥락에서는 특정 타입만을 사용한다고 `assert`로 정적 분석 도구에 사용할 타입을 알려주는 것을 통해서 정적 분석 도구에 의해 에러가 발생하는 부분을 방지할 수 있다. 이는 타입스크립트의 Type narrowing 키워드인 `as`와 비슷한 역할을 한다.

위의 코드에서 `assert(is_int($obj->numeric))` 부분의 주석을 해제하면 `$obj->numeric`의 타입은 `int|string`이지만 `int`로 인식되기 때문에 정적 분석에 의한 에러가 나지 않게 만들 수 있다.

### 정적 분석과 assert

```php
declare(strict_types = 1);

class Lifo
{
    // @phpstan-ignore-next-line
    private array $array = [];

    public function push(mixed $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): mixed
    {
        return array_pop($this->array);
    }
}

$stringData = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];

$lifoString = (new Lifo);
array_walk($stringData, function (string $v) use ($lifoString) {
    $lifoString->push($v);
});

for($i=0; $i < count($stringData) ; $i++) {
    $output = $lifoString->pop();
    // assert(is_string($output));
    echo $output;
}

$numberData = [1,2,3,4,5,6,7,8,9,10];

$lifoInteger = (new Lifo);
array_walk($numberData, function (int $v) use ($lifoString) {
    $lifoString->push($v);
});

for($i=0; $i < count($stringData) ; $i++) {
    $output = $lifoString->pop();
    // assert(is_int($output));
    echo $output;
}
```

위의 코드에서 `echo $output;`의 코드를 사용할 때 값은 문자열로 형변환 되어 출력 된다. 값에 따라 문자열로 변환 될 수 있는 것이 있고 없는 것이 존재한다. phpstan의 정적 분석기로 위 코드를 실행해 보면 `$lifoString->pop();`의 반환 타입이 Mixed가 되어 있기 때문에 문자열로 변환 할 수 없는 값이 나올 수 있어 타입 에러가 발생한다. 그러나 `// assert(is_int($output));`의 주석을 풀어 assert로 반환 타입이 항상 특정한 타입이란 것을 알려 주면 타입 에러가 더 이상 발생하지 않는다.

### foreach문이 권장되지 않는 이유
- php에서 foreach문을 사용할 때는 리스트에 든 각각의 값에 대해 타입 검증을 하지 않고 사용하는 경우가 많다. `is_타입` 또는 `instanceof`로 타입 검증을 할 수 있지만, 이러한 것으로 검증을 했을 때, IDE에 의한 자동완성이 되지 않는 경우가 있을 수 있으며 조건문으로 확인을 한다는 것이 문법적으로 맘에 드는 방법은 아니다. 그래서 코딩의 스타일을 `foreach`를 쓰는 것 보다는 콜백함수를 가능한 사용하는 방식으로 하여 타입힌트로 값을 검증하는 것이 좀 더 괜찮은 코딩 스타일이다.
- php의 배열의 경우 `foreach`를 `array_walk`를 사용하여 콜백함수를 사용할 수 있는 방식을 사용할 수 있고, 배열이 아닌 다른 `iterator`의 경우 라라벨의 컬렉션 패키지를 사용해서 콜백 형태로 만들어서 사용하는 것을 추천한다.
```php
class Item
{
    public function getRandomValue(): int
    {
        return rand();
    }
}

$itemObj = new Item();
for($i=0; $i<10; $i++) {
    $numberList[$i] = $itemObj;
}

foreach($numberList as $item) {
    echo $item->getRandomValue(), PHP_EOL;
}

echo PHP_EOL."------------".PHP_EOL;

array_walk($numberList, function (Item $item): void {
    echo $item->getRandomValue(), PHP_EOL;
});
```
- 위의 코드에서 `foreach` 문을 사용하지 않고 `array_walk`로 콜백 함수를 사용한 코드를 사용하였다. 콜백함수를 사용하게 되면 각각의 원소에 대해 타입힌트를 적용할 수 있고 타입힌트로 인해 다른 타입이 들어오는 경우에는 에러를 내며, IDE는 타입힌트를 통해서 오브젝트 내부에 프로퍼티가 있는지 대한 추론을 할 수 있어서 코드를 편하게 짜는데 도움을 준다.
- php는 배열에 하나의 유형 뿐만 아닌 다양한 유형을 갖고 있기 때문에 배열에서 데이터를 뽑아 쓸때마다 불안한 느낌을 준다. 반복 가능한 유형에 콜백함수를 사용하는 표현으로 타입힌트를 걸어주면 타입을 한 번 짚고 넘어갈 수 있기 때문에 코드에 안정감을 주게 된다.

### 제네릭 도입이 어려운 이유
- php 파서의 모던화에 공헌했던 니키타의 의견 https://www.reddit.com/r/PHP/comments/j65968/comment/g83skiz/?utm_source=share&utm_medium=web2x&context=3
- 위의 의견을 보면 php에 제네릭을 도입하는 것이 쉬운 것이 아님을 알 수 있다. 제네릭을 사용한 php 파서에서 유형 추론의 복잡성 문제, php 파서의 대량의 리펙토링 문제, 런타임 시스템 리소스 증가의 문제 등의 문제로 쉽사리 도입되지 못하고 있다.
- 만약 제네릭을 도입하게 되더라도 더 이상 php라고 할 수 없을 정도의 변경사항이 발생할 수도 있다는 읙견이 있다. 또한 php는 오픈소스로서 php의 코어에 자발적으로 공헌하는 개발자들에 의해 유지된다. 언어의 스펙을 변경할 수 있는 풀 타임 개발자를 상당한 비용을 지불해서 고용하기 어렵기 때문에 대규모의 리펙토링은 현실적으로 어려움이 있다. 최근 php 파운데이션의 설립으로 php 코어에 기여할 수 있는 풀타임의 개발자들을 고용하는 것으로 보이지만 php 언어를 제네릭을 허용하는 방향으로 바꿀 것인지는 여러 문제들을 해쳐나가야 하기에 관망을 할 필요는 있다.

### 런타임 타임 확인
- php에서 제네릭이 도입되기 어렵게 된 원인 중 하나는 런타임 타입 검사 기능 때문이다. 타임스크립트나 파이썬의 경우 타입을 작성할 때 런타임에서 동작하는 타입을 제거하고, 런타임 이전의 정적 검사 타입 또는 트렌스파일 등의 타입 검사 과정을 통해서 타입을 확인하는 작업을 하는 것이다.
- php는 클래스의 멤버 변수, 함수의 파라메터와 반환값의 타입을 확인하는 타입힌트를 제공한다. 이 타입힌트가 런타임에서의 타입을 확인하는 기능을 하고 있다. 제네릭이 있는 다른 언어는 이러한 런타임 타입 체킹 기능을 사용하지 않고, 컴파일 타임, TS의 경우 트렌스파일 타임을 통해서, 파이썬의 경우 제네릭을 도입하기 위해서 런타임의 타입 검사 기능을 제거하였다.
- 물론 타입이 아닌 값의 유형을 완전히 바꾸는 방식의 코딩을 지원하며, 타입 힌트가 아닌 값의 타입을 코드로 강제적으로 변경하는 부분에 대해서는 타임 검사를 하지만, 타입힌트와 같이 타입으로 표기된 부분에서의 타입 검사는 하지 않아서 런타임 타입 검사 비용에 대한 문제를 해결하였다.

### 런타임 타입 확인을 하지 않음으로 생기는 문제
- 런타임에서 타입을 확인하지 않는 것은 어떠한 값이든 전달 가능하다는 문제가 있다. 따라서 런타임에서 잘못된 값이 들어가지 않도록 수 많은 데이터 전달 과정에서 엄격하게 타입이 정확한지 확인하는 작업이 필요하다. 이를 위해서 정적 검사 툴은 어느 부분에서 타입을 제대로 평가할 수 없는지를 확인하여 타입 추론이 잘 되지 않거나 타임 추론에 모순이 발생한 부분이 생기면 프로그래머에게 알려 준다. 프로그래머는 잘못된 타입이 들어가지 않게 하기 위해서 모든 부분에 있어서 엄격하게 타입을 작성하며, 잘못된 데이터가 들어가지 않도록 데이터 전달의 흐름에 주의를 기울이며 잘못된 인터페이스나 타입의 값이 외부에서 전달될 수 있는 부분은 벨리데이션을 작성한다.
- 하자만 런타임에서 타입을 확인하지 않기 때문에, 런타임에 잘못된 값이 전달되지 않게 하기 위해 지나치게 엄격하게 타입을 지정해야 하는 문제가 생긴다. 개발 초기 단계 부터 엄격하게 타입의 정적 추론이 가능하도록 짜 놓은 프로젝트인 경우 런타임의 타입 검사를 배제해도 잘못된 타입이 들어가는 경우를 막을 수 있지만, 정적 추론 없이 오랫동안 작성되어 온 애플리케이션이라면 정적 추론을 위해 모든 데이터 전달 플로우에 타입을 넣는 것이 현실적으로 어려운 문제에 직면할 수 있다.
- 또한 php와 같은 멀티 타입을 사용할 수 있는 언어의 경우, 외부 라이브러리나 외부에서 전달된 값을 사용할 때 지정된 타입 이외의 다른 어떤 타입의 값이 전달되어 사용되는지 확신을 할 수 없는 경우가 있다. 타입 안정적인 코드를 작성하려면 모든 예외 사항에 대한 어떤 타입의 처리를 할지에 대한 명세를 만들어야 하는데, 이런 것이 불가능한 경우가 있기 때문에 런타임의 타입 검사를 통해서 기대하지 못한 타입의 전달으로 처리될 수 없는 경우 에러를 발생 시켜 예측하지 못한 상황에 대해 어떻게 처리할지를 정의하지 않았으므로 처리를 하지 않도록 만드는 것이 좋다.
- 런타임의 타입 검사의 장점은 모든 데이터 전달 플로우의 타입이 명확하게 정의되고 벨리데이션도 완벽하게 갖춰지지 않는 상태에서 내가 작성한 부분의 타입 안정성을 확보할 수 있다는 장점을 갖고 있다.
- 제네릭 도입을 위해서 런타임 타임 검사를 제거하자는 의견이 제기되고 있지만, 수 많은 타입추론 불가능한 php의 코드에서 런타임 이전에 타임을 검사할 수 있는 시스템으로 변경하는 것은 현실적으로 불가능에 가깝다.
- php의 스트릭트 모드와 같이 파일 상단의 어떤 식별자를 통해서 런타임의 검사를 생략할 것인지 사용할 것인지를 사용자가 직접 지정하는 방식을 생각해 볼 수도 있을 것 같다. 런타임 타입 확인을 하지 않는 것의 이점이 충분하지 않기 때문에 제네릭 같은 문법의 도입을 위해 필요하다고 할 수 있겠지만, 런타임 타입 확인을 하는 코드도 제네릭이 도입 되어야 할 것 같아서 전략적인 논의가 필요해 보인다.
