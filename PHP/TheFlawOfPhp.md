## 함수형 프로그래밍에 좋지 않은 PHP

### 함수형 프로그래밍이 불편하다.
- PHP 함수형 프로그래밍을 지원한다. 고차함수를 만들 수 있고, 클로저를 사용할 수 있고, 1급 객체와 함수를 지원하며, 참조 투명한 객체 또는 함수를 만들 수 있다.
- 하지만 함수형 언어를 사용하는데 편리한 문법을 제공하지는 않는다. 따라서 함수형 표현을 사용한 고차원의 프로그래밍을 하는데 편하지 않고 일부러 함수형 언어를 사용하기 보다는 그냥 일반 문법을 사용하는 것이 더 깔끔한 코드를 만드는 경우도 많다.
- 이에 대한 이유로는 php 언어가 초보자에 좀 더 친화적인 언어가 되고자 하며 제대로 익히기에는 습득이 어려운 함수형 기능들이 언어를 사용하는 것은 높은 난이도를 요구할 수 있기 때문에 배제한 것이라고 본다. 멀티 패러다임 다른 언어들을 보아도 함수형 프로그래밍을 적극 활용해서 프로그래밍을 하는 곳도 있지만 사용하지 않고도 얼마든지 프로그래밍에 문제가 없다는 것을 보여주며 지나친 함수형 프로그래밍은 오히려 초보자들의 접근을 어렵게 한다.
- OOP에 대한 제대로된 이해만으로도 초보 엔지니어들의 습득과 제대로된 이해를 바탕으로 한 기술 적용이 어려운 상황에서 함수형 프로그래밍 또한 제대로 사용하는 것을 기대하기 어렵다. 높은 습득난이도와 많은 학습량으로 인해서 함수형 프로그래밍을 적극 사용한 코드는 사용하는 사람들의 부족한 실력으로 인해 사용을 안하느니만 못한 경우가 많이 발생할 수 있다. 프로그래밍 방식을 일관성있게 통합시키기 위해서 일부러 함수형 프로그래밍에 대한 지원을 프로그래밍이 가능한 최소한으로 지원하고 있다는 생각이 들지만 적극 지원하지 않기에 아쉬움이 큰 언어

### 불변성에 대한 지원이 약하다.
- 상수의 지원은 CONST 키워드로 사용한다. CONST 키워드는 PHP 파일 단위에서의 전역공간 또는 PHP의 글로벌 상수 또는 클래스 내의 멤버로 선언하는 방법이 있다. 함수 스코프 내에서는 CONST 키워드를 사용할 수 없다는 단점이 있다.
- 함수 스코프 내에서 사용할 수 있는 변수는 상수로 선언 될 수 없기 때문에 변경의 위험성을 가지고 있다. 변수의 값이 일정한지 일정하지 않은지 코드 맥락에서 확인하는 것은 코드를 인지하는데 필요한 시간을 더 걸리게 하고 이는 생산성의 저하로 이어진다. 편하게 사용하기 위해 만들어진 PHP는 함수 스코프 내에서도 상수 선언을 자유롭게 할 수 있는 편이 좋지 않을까라는 생각이 든다.
- 자바스크립트에서 const는 변수의 재할당이 빈번하게 일어날 수 있는데 클로저 스코프 등에도 상위 스코프에서 설정한 변수가 그대로 전달되는 점 때문이다. 이에 반해 php는 클로저 등의 문맥으로 상위 스코프의 변수를 전달하기 위해서는 use라는 키워드를 써 줘야 한다.(함수 내부로 외부 스코프의 변수를 전달할 때 `function () use {}` ) 프로그래밍에서 자바스크립트만큼의 문맥간의 변수 공유가 일어나지 않기 때문에 덜 치명적이라는 점이 있지만 const의 사용이 제한된다는 것은 매우 아쉬운 부분이다.
- 자바의 경우 변수에 `final` 키워드를 할당하게 되면 선언된 클래스의 객체에서조차 재할당 불가능한 값이 된다. 하지만 php는 선언된 클래스의 객체에서의 재할당을 할 수 있고, 상속된 객체에서의 재할당만 막는 제한적인 문법을 가지고 있다. 같은 클래스의 객체에서의 재할당 불가로 `final` 키워드를 사용하지 않으므로 로컬 스코프에서 `final` 키워드를 사용하게 추가할 일도 없다.

### 함수형 표현을 사용하는데 보일러 플레이트가 많다.
- 자바스크립트 처럼 `() => 'return value'` 간단한 표기가 없다. php8에서는 `fn() => 'return value'`방식을 지원하지만 다른 언어의 간단한 표기 보다 좀 더 많은 보일러 플레이트를 요구한다. 
- `fn` 함수는 `{}`의 블록 스코프를 갖지 않기 때문에 내부에 여러줄에 걸친 복잡한 코드를 쓰는 것이 아닌 바로 반환할 수 있는 간단한 식을 쓸 때 사용해야한다. 따라서 여러줄에 걸친 코드를 사용하는 경우 여전히 `function` 키워드의 함수를 사용할 수 밖에 없다. php에서는 `function` 함수의 기능을 `fn` 함수가 충분히 대체할 수 없으며 아주 제한된 경우에 한정해서 쓸 수 있는 문법이기 때문에 간단한 함수를 많이 선언하는 함수형 프로그래밍에 불편한다.

### 멀티코어를 활용할 수 없는 구조
- PHP는 보통 웹서버로 사용한다. 그런데 흔시 사용되는 CGI 방식의 웹 서버에서는 멀티코어의 사용을 권장하지 않는다.
- 함수형 프로그래밍은 불변성의 모듈을 쌓아가면서 프로그래밍을 한다. 이를 통해 복수의 스레드를 사용해도 레이스 컨디션이 발생하지 않기 때문에 코루틴 또는 스레드를 사용하는 프로그래밍에서 함수형 프로그래밍은 이점을 제공한다. 하지만 php는 멀티코어를 활용하지 못하므로 불변성 모듈을 쌓아서 프로그래밍을 하는 수고에 비해 얻는 비교적 적을 수 밖에 없다. 특별한 이점이 없는 상황에서 보일러 플레이트가 많고 불변성을 쌓는 방식의 고민을 하면서 시간을 들이는 함수형 프로그래밍을 하는 것으로 얻는 효과는 크지 않다. 그저 적재 적소에 함수형 기법을 사용해서 코드를 좀 더 잘 나누고 추상화 하는 부분에 도움을 주는 정도면 충분하다.
- swoole을 사용하면 코루틴과 채널을 활용한 병렬 프로그래밍을 지원한다. 하지만 swoole을 통한 병렬 프로그래밍은 함수형 표현을 상용한 병렬 연산을 활용하는 것과는 다른 고루틴과 비슷한 방식이며 채널을 통해서 메모리를 공유하는 방식이다.

### 비동기를 제대로 활용할 수 없는 구조
- PHP8에서 fiber라고 비동기 문법을 지원한다. 하지만 fiber는 사용자를 위한 문법이 아니라, 라이브러리 제작자를 위한 문법으로 고안되었다. php에서 비동기 문법을 사용하기 위해서는 reactPHP 또는 php AMP 라이브러리를 설치하여 사용하도록 권장되고 있다.
- 비동기를 활용하기 위해서는 이들 라이브러리가 제공하는 방식으로 I/O 관련 기능을 사용해야 하는데, 프레임워크를 사용하고 있다면 프레임워크의 I/O 기능이 이들 비동기 라이브러리를 지원하지 않기 때문에 코드를 섞어 쓰게 되고 이상한 코드를 만들어 내게 된다. 코드의 일관성을 위해서 프레임워크를 사용할 때는 이들 비동기 라이브러리를 사용하지 않는 편이 훨씬 낫다.

## 일관성이 없음
- 일관성이 없다는 것은 사용하는데 있어서 비슷한 구조를 가지고 있지 않기 때문에 기억해서 사용하기 어렵다는 것이고, 기억해서 사용하기 어렵다는 것은 하나 하나 사용할 때 마다 찾아 봐야 한다는 의미이다. 이는 결국 생산성의 저하로 이어지게 된다.
- 좋은 서비스를 만들기 위해서는 언어 수준에서 예측할 수 있는 코드를 짜는 것이 중요하다. 하지만, 언어의 비일관성은 로직을 파악하는데 좀 더 많은 시간이 필요한 코드를 만들어 낸다. 따라서 해석 및 태스트에 소모되는 비용이 더 많이 요구되는 문제가 있다.
- 예를 들어 php의 내장함수들은 저마다 사양이 제각각이다. 함수 하나하나를 살펴보면 나름 그렇게 만들어진 이유가 있지만, 인자의 종류에 따른 순서라든지 함수명이라든지 조금씩 개선은 되고 있지만 여전히 불편한 점이 많다.
- 언어를 사용하면 할 수록 언어의 기능을 찾지 않고도 잘 만들 수 있어야 하는데, php의 경우에는 같은 시간을 숙달하더라도 더 많이 검색을 통해서 기능을 찾아서 사용해야 하는 문제점이 있다. 생산성의 향상을 위해서 사용하는 언어가 도리어 생산성의 향상에 크게 공을 들이지 않고 있고, 이것이 타 언어에 대비 경쟁력이 높지 않은 언어가 되는 이유가 된다고 본다.

### 배열 함수의 비일관성

#### 배열 함수의 인자의 순서의 비일관성 
- callable과 array의 인자 순서가 배열 함수마다 다르다. http://phpsadness.com/sad/6
- haystack과 needle의 인자 순서가 배열 함수마다 다르다. http://phpsadness.com/sad/9

#### 배열 함수의 비일관성을 해결하기 위한 방법
- 부족한 일관성에 대한 해결 방법 : 일관성 있게 만든 매핑된 라이브러리를 사용한다. 이를 위해서는 지속적으로 메인테인스가 이뤄지는 인기 있는 라이브러리로 사용하는 것이 중요하다. 배열 함수를 사용하지 말고 라라벨 컬렉션을 제공하는 라이브러리를 사용하는 방법 등을 사용하자. 
- 라라벨 컬렉션만 분리한 라이브러리 : https://github.com/tighten/collect

### 문자열 함수의 비일관성

#### 문자열 함수 명칭의 비일관성
- 언더바 \_를 사용한 명칭과 \_를 사용하지 않은 명칭이 혼합되어 있다. http://phpsadness.com/sad/4

#### 문자열 함수의 비일관성을 해결하기 위한 방법
- 라라벨의 경우에는 문자열을 지원하는 helper 함수 `str::함수명` 기능을 사용한다.

## 표준 라이브러리에서 제공해야 할 기능을 서드파티로 떠 넘김
- 일반적으로 다른 언어는 언어와 함께 표준 라이브러리의 기능을 제공한다.
- 하지만 PHP의 경우 어느정도 기본적인 기능을 언어 차원에서 제공하지만 사용자 편의를 위한 기능을 서드파티 라이브러리에 떠맡긴다.
- 표준 내장 객체가 잘 만들어져 있어서 외부 라이브러리에 의존하는 긴능을 줄이는 것이 좋은데 내장 기능을 사용하자니 편하게 사용하기 어려운 문제점이 있고, 쉽고 편리한 기능을 제공하는 라이브러리를 쓰자니 신뢰성이 떨어지는 서드파티 라이브러리를 꼭 사용해야 하는 문제가 생긴다.
- 그리고 내장 기능은 OOP 방식으로 캡슐화 되어서 기능을 제공하고 있지 않고 요즘 추세와 맞지 않는 상대적으로 저수준(C언어 보다는 나은)의 개념으로 만들어져 있기 때문에 가독성이 떨어진다. 
- 기능을 알기 위해서는 설명을 해석하기 쉽지 않은 PHP 내장 기능을 이해해야 한다. (심지어 이걸 제대로 이해하고 쓰고 있는 사람이 어느정도 될지도 모를 정도) 쉽게 쉽게 어떤 기능을 활용할 수 있는지 잘 캡슐화된 대상을 표준 라이브러리에서 제공할 필요가 있다고 본다. 매커니즘에 대한 대략적인 이해만으로도 명확하게 어떤 기능을 하는지 알고 사용할 수 있도록 해야 할 것.
- 표준 라이브러리를 만들어서 미래에도 계속적으로 유효한 라이브러리를 만들어 써드파티가 아닌 표준 라이브러리의 사용을 권장하는 방식으로 코딩의 표준을 잡을 필요가 있어 보인다.
- PHP 사용자별로 라이브러리 사용자 별로 프레임워크 사용자 별로 파편화된 지식을 습득하게 되면서 일관성을 맞추기 위해서 내장 함수에 의존하게 된다. 이로 인해 OOP를 제대로 활용하지 못하는 문제가 발생한다.
- 클래스화 되어 있는 array function 기능을 통한 체이닝 지원, 기본적인 기능을 모두 포함하고 있는 curl 간편한 curl 기능, async await 등등의 기능 등등을 표준 라이브러리 차원에서 제공해야 한다. 물론 curl 기능을 레핑한 Guzzle, async await 기능을 레핑한 ReactPHP, PHP AMP 등의 공신력있는 라이브러리, array function 기능을 대신 사용가능한 라라벨 collection 등이 있지만 언제 폐기 될지 모르는 다양한 라이브러리들이 존재한다는 것이 문제. 이래서 라라벨과 같은 프로젝트가 인기를 끌 수 밖에 없는 것으로 

### 자바스크립트와의 비교
- 자바스크립트의 경우, 자바스크립트 해석 엔진과 함께 표준 내장 객체를 제공한다. 
- 자바스크립트의 표준 내장 객체는 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects 에서 확인 가능하다.
- 또한 노드 JS와 브라우저는 각각 내장 라이브러리를 제공한다. 노드 JS의 내장 라이브러리 또한 기능이 너무 많고 쉽게 사용하기 쉽지 않다. 하지만 브라우저의 내장 라이브러리는 사용하기 쉽고 이해하기 쉽도록 만들어져 있다는 것이 느껴진다.

## 타입 비교가 이상함
```
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");
```
의 결과는

#### php 7 버전에서는
```
bool(true)
bool(true)
bool(true)
bool(true)
```
#### php 8 버전에서는
```
bool(false)
bool(true)
bool(true)
bool(true)
```

### 문제
- 단순히 `==` 연산자를 통한 비교를 하는 것이 문제가 아니다.
- 이 타입 추론의 방식이 디폴트로 되어 있기 때문에 in_array 와 같은 다양한 내장 함수에서 위의 비교를 암묵적으로 사용하고 있음
```
in_array("1", ["01"]);
in_array("10", ["1e1"]);
in_array(100, ["1e2"]);
```
의 결과값도
```
bool(true)
bool(true)
bool(true)
```
이 된다.
- php의 `==`이 위와 같은 처리를 한다는 것을 알고 있어도 `in_array`라는 함수를 쓸 때 위와 같이 판별한다는 것을 일반적으로 위와 같은 상황이 일어난다고 미리 알고 쓰지 않는 경우가 많다. php의 다양한 내장함수들이 이 암묵적 비교를 사용하고 있고, 이 내장함수를 쓰는 다양한 함수들, 라이브러리들이 위와 같은 문제를 가지고 있다. 따라서 예측하지 못한 버그가 발생하게 된다. 어떤 기능을 사용할 때 내부적으로 암묵적 비교를 사용하고 있겠지를 항상 가정해야 하는 문제점이 있다.
- 내부적으로 어떻게 처리할 줄 알고 이런 부분들을 모두 가정하고 써야 하는지, php를 쓰면 참담한 심정을 가지게 된다.
- 예를 들어 라라벨 벨리데이션에서 `"in:01,02,03"` 벨리데이션을 사용했을 때 `"1", "2", "3"`도 통과하게 된다. 사용자는 당연히 문자열이 일치할 때 벨레데이션을 통과하겠지하고 사용하는데 내부적으로는 `==` 연산 `in_array` 방식을 사용하고 있기 때문에 개발자의 예측과 달라지는 문제가 발생하게 된다.

## 스칼라 오브젝트의 미지원
- 자바스크립트, 자바 언어를 사용하면 `"문자열".함수()` 방식의 표현을 사용할 수 있다. 어떤 타입에 대해서 해당 타입에 대해 사용할 수 있는 기능들을 `.`을 붙여주게 되면 IDE는 리스트를 보여준다. 하지만 php의 객체가 아닌 타입은 오브젝트의 속성에 접근하는 `->` 키워드로 접근하는 기능을 제공하지 않는다.
- php에서는 콜러블이라고 함수를 사용하여 값을 바꾸어 나가는데 콜러블의 대표적인 것이 php의 내장함수들이다. 다른 언어들은 `값.함수()`로 접근하는 것들을 php는 문자열이면 'str_어쩌구' 함수, 배열이면 'array_어쩌구', '어쩌구_array' 함수를 사용하는 등 함수를 사용해서 만들어야 한다.
- IDE를 사용하면 `값.`을 입력하는 순간 함수 리스트가 나와서 무엇을 사용하면 되는지 쉽게 알 수 있는 반면, php는 이런 지원을 하지 않기 때문에 내장 함수를 검색해서 사용해야 한다. 물론 자주 쓰는 내장함수는 기억하는 경우도 많이 있겠지만, 오랜기간 php를 써 봐도 잘 기억이 나지 않는 걸 보면, 언어가 편하고 좋다라고 하기 어려운 면이 있다.

## Reference
- http://phpsadness.com/
- https://www.php.net/manual/en/language.operators.comparison.php
