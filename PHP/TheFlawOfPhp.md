## 느리다

### 프로세스 단위로 리퀘스트를 처리

기본적으로 php는 리퀘스트를 받고 리스폰스를 하는 과정을 하나의 프로세스로 처리한다. 리퀘스트가 전달되면 프로세스를 실행하고 리퀘스트의 처리가 끝나면 프로세스를 종료된다. 다른 언어는 하나의 프로세스에서 수 많은 리퀘스트 라이프사이클을 처리할 수 있도록 만들어져 있다. 

php가 아닌 다른 언어들은 웹 리퀘스트를 처리하기 위해서는 이 처리를 담당하는 라이브러리나 프레임워크에 의존할 수 밖에 없는데 php는 언어가 제공하는 기본적인 기능으로도 http 리퀘스트를 처리할 수 있는 기능을 제공한다.

프레임워크를 사용하는 경우에는 프레임워크가 제공하는 많은 기능을 사용하기 위해서 로딩되는 최소한의 시간 + 리퀘스트를 처리하는 로직으로 구성이 된다. php가 아닌 다른 언어들은 한 번 프레임워크를 서버에서 실행하면 프레임워크가 제공하는 기능들이 메모리에 이미 다 추가가 되는 상태이며 리퀘스트가 들어 올 때마다 메모리에서 필요한 것을 꺼내어 쓰면 된다. 하지만 php는 리퀘스트가 들어올 때 마다 프레임워크를 실행하고 프레임워크가 제공하는 기능을 메모리에 올리고 리퀘스트를 처리하기 위한 파일의 코드를 읽어서 메모리에 올린 후에 리퀘스트에 대한 처리를 하는 과정을 매번 반복한다. 따라서 다른 언어에 비해서 속도가 느릴 수 밖에 없는 단점이 있다.

물론 swoole과 같은 것을 사용하면 php도 다른 언어처럼 하나의 프로세스를 실행하고, 이를 종료하지 않고 메모리에 프레임워크나 라이브러리의 코드를 올리고 리퀘스트를 처리할 때마다 메모리에서 필요한 기능을 가져다 쓰는 방식으로 사용할 수 있다. 하지만 swoole은 아직 충분히 안정성 있고 규모있는 프로덕션에서 사용할 수 있는지에 대한 사례가 아직 적은 도입하기에는 모호한 기술이며 미래에 어떻게 될지 알 수 없는 기술이기도 하다. 라라벨에는 옥테인이라는 swoole을 사용하는 기술이 있다. 이를 사용하면 잘 알려진 프레임워크를 사용하면서도 초기 로딩을 반복하지 않기 때문에 좋은 효율을 뽑아 낼 수 있다.

php는 프로세스 단위로 리퀘스트를 처리하기 때문에 리퀘스트의 처리가 끝나면 프로세스가 종료되어 런타임에서 생긴 모든 php 코드에 관한 메모리를 날려버린다. 따라서 하나의 리퀘스트와 다른 리퀘스트 사이에는 메모리를 공유하는 부분이 없고 서로 독립적인 실행이 가능하게 만든다는 장점이 있다. 또한 프로세스가 종료되면서 디비와의 연결도 끊어지고 프로세스가 실행되면서 다시 디비와의 연결이 때문에, 프로그래밍의 문제로 디비의 연결이 끊어지지 않아 발생하는 이슈도 피할 수 있는 장점이 있다. 이런 장점 때문에 php는 느리지만 다른 언어 보다 메모리나 디비 연결 문제에 대한 걱정을 덜 하면서도 안전하게 사용할 수 있다는 장점이 있고 대규모 서비스가 아닌 경우에는 좋은 선택지가 될 수 있다.

### CPU의 효율을 충분히 끌어내지 못한다.

php는 프로세스 단위로 리퀘스트를 처리하며 웹 프로그래밍은 데이터베이스와 파일 스토리지 등 서버와 서버간의 통신에 시간이 들게 된다. 리퀘스트를 처리해서 리스폰스를 만들어 클라이언트에게 주기까지 여러번의 통신을 하게 되고 통신을 대기하는 시간동안 CPU는 유휴상태에 들어간다.

노드 JS 기반의 웹 라이브러리나 프레임워크의 경우에는 이벤트 기반으로 리퀘스트를 처리하기 때문에 IO 대기 시간동안 다른 리퀘스트를 처리할 수 있다는 장점이 있으며, 고 언어는 고루틴 기반으로 리퀘스트를 처리하기 때문에 IO 대기로 인해 CPU가 유휴상태로 전환되기 전에 다른 코루틴에 할당된 리퀘스트를 CPU에 할당하는 방식으로 CPU가 노는 것을 최대한 줄일 수 있다. 또한 스프링의 경우에도 스레드 기반으로 리퀘스트를 처리하기 때문에 자바라는 컴파일 언어의 이점을 배제하고서 생각하더라도 php의 프로세스 기반 보다 훨씬 더 빠른 컨텍스트 스위칭을 할 수 있어서 좀 더 CPU를 활용할 수 있다.

PHP는 프로세스 방식이라서 서버의 CPU의 스레드 갯수에 비해서 동시에 처리할 수 있는 리퀘스트를 많이 할당할 수 없으며 많아야 CPU 스레드의 2배 정도로를 할당할 수 있다. 또한 프로세스 단위의 컨텍스트 스위칭 비용이 코루틴이나 스레드에 비해 비싸기(=리소스를 많이 사용) 때문에 CPU를 많이 사용하면서도 느릴 수 밖에 없다는 단점이 있다.

php의 swoole의 경우에는 코루틴 기반의 리퀘스트 처리 방식을 지원하지만, 프로덕션에서 사용해도 좋을 만한 적당한 웹 프레임워크가 없다는 문제점이 있다. 또한 라라벨 옥테인은 프레임워크의 필요한 기능을 로딩하는 초기 로딩인 부트스트레핑을 반복하지 않는다는 장점은 있지만, 아직까지 코루틴 기반의 리퀘스트 처리 방식은 지원하지 않으며 적극적인 개발이 이뤄지지도 않고 있다는 단점이 있다.

## 함수형 프로그래밍에 좋지 않은 PHP

### 함수형 프로그래밍이 불편하다.

PHP 함수형 프로그래밍을 지원한다. 고차함수를 만들 수 있고, 클로저를 사용할 수 있고, 1급 객체와 함수를 지원하며, 참조 투명한 객체 또는 함수를 만들 수 있다. 하지만 함수형 언어를 사용하는데 편리한 문법을 제공하지는 않는다. 언어 내장의 배열 컬렉션이라든가, 파라메터로 함수를 받을 때의 함수의 시그니처 표기를 지원하지 않는 등의 문제가 있다. 오히려 함수형 표현을 사용한 고차원의 프로그래밍 보다 그냥 일반 문법을 사용하는 것이 더 깔끔한 코드를 만드는 경우도 많다.

함수형 프로그래밍을 적극 도입하지 않는 이유로는 php 언어가 초보자에 좀 더 친화적인 언어가 되고자 하며 제대로 익히기에는 습득이 어려운 함수형 기능들이 언어를 사용하는 것은 높은 난이도를 요구할 수 있기 때문에 배제한 것이라고 본다. 멀티 패러다임 다른 언어들을 보아도 함수형 프로그래밍을 적극 활용해서 프로그래밍을 하는 곳도 있지만 사용하지 않고도 얼마든지 프로그래밍에 문제가 없다는 것을 보여주며 지나친 함수형 프로그래밍은 때때로 오히려 초보자들의 접근을 어렵게 한다.

OOP에 대한 제대로된 이해만으로도 초보 엔지니어들의 습득과 제대로된 이해를 바탕으로 한 기술 적용이 어려운 상황에서 함수형 프로그래밍 또한 제대로 사용하는 것을 기대하기 어렵다. 높은 습득 난이도와 많은 학습량으로 인해서 함수형 프로그래밍을 적극 사용한 코드는 사용하는 사람들의 부족한 실력으로 인해 사용을 안하느니만 못한 경우가 많이 발생할 수 있다. 

하지만 현대 프로그래밍은 무조건 함수형 프로그래밍을 사용하자는 것이 아니라, 함수형 프로그래밍 기법을 통해서 코드를 간략히 할 수 있는 부분은 간략히 하고, 코드를 좀 더 명확하고 깔끔하게 표현할 수 있는 기법을 적절히 사용하자는 것인데, 초보자들을 위해 경력이 있는 대부분의 언어 사용자가 알고 있는 지식을 활용할 수 없게 만드는 것이 좋은지 생각을 해 봐야한다.

프로그래밍 방식을 일관성있게 통합시키기 위해서 일부러 함수형 프로그래밍에 대한 지원을 프로그래밍이 가능한 최소한으로 지원하고 있다는 생각이 들지만 적극 지원하지 않기에 아쉬움이 큰 언어이다.

### 불변성에 대한 지원이 약하다.

상수의 지원은 `const` 키워드로 사용한다. `const` 키워드는 PHP 파일 단위에서의 전역공간 또는 PHP의 글로벌 상수 또는 클래스 내의 멤버로 선언하는 방법이 있다. 함수 스코프 내에서는 `const` 키워드를 사용할 수 없다는 단점이 있다. 또한 재할당 불가능한 변수를 선언하는 키워드로 `readonly`를 제공한다.

함수 스코프 내에서 사용할 수 있는 변수는 상수로 선언 될 수 없기 때문에 변경의 위험성을 가지고 있다. 변수의 값이 일정한지 일정하지 않은지 코드 맥락에서 확인하는 것은 코드를 인지하는데 필요한 시간을 더 걸리게 하고 이는 프로그래밍의 실수를 유발한다. 함수 스코프 내에서도 상수 선언을 자유롭게 할 수 있는 편이 좋을 것 같지만 php 파서의 스팩을 결정하는 사람들은 클래스 단위의 const, readonly를 사용하면 되며, 함수 스코프에서 지원을 하게 되면 언어의 복잡성이 늘어난다는 이유로 이를 피한다. 이러한 제한 때문에 한 스코프의 코드를 길지 않게 코딩하는 습관이 요구된다. 하지만 이렇게 작은 단위의 함수를 쓰는 프로그래머를 자주 만날 수 있을까?

자바스크립트의 변수는 재할당이 빈번하게 일어날 수 있는데 클로저 스코프 등에도 상위 스코프에서 설정한 변수가 그대로 전달되는 점 때문이다. 상위 스코프에서 선언된 변수를 하위 스코프에서 미처 파악하지 못하고 사용하게 되면서 변수의 덮어쓰기가 일어난다. 이러한 문제를 방지하기 위해 JS에서는 다른 동적 언어에서 잘 도입하지 않았던 변수의 재할당 방지 키워드인 `const`가 도입되었다. 이에 반해 php는 클로저 등의 문맥으로 상위 스코프의 변수를 전달하기 위해서는 `use`라는 키워드를 써 줘야 한다. (함수 내부로 외부 스코프의 변수를 전달할 때 `function () use { $transmit_outer_scope_variable }`으로 함수 내에서 사용할 외부 스코프의 변수를 지정한다.) php는 자바스크립트와 달리 함수 외부의 변수를 함수 내부에서 쓰기 위해서는 use를 사용해야 하므로 문맥간의 변수 공유가 일어나지 않기 때문에 자바스크립트 보다는 덜 치명적이라는 점이 있지만 `const`나 `readonly`의 사용이 클래스의 멤버 변수로만 제한된다는 것은 매우 아쉬운 부분이다.

자바의 경우 변수에 `final` 키워드를 할당하게 되면 선언된 클래스의 객체에서조차 재할당 불가능한 값이 된다. 하지만 php는 선언된 클래스의 객체에서의 재할당을 할 수 있고, 상속된 객체에서의 재할당만 막는 제한적인 문법을 가지고 있다. 같은 클래스의 객체에서의 재할당 불가로 `final` 키워드를 사용하지 않으므로 로컬 스코프에서 `final` 키워드를 추가할 일도 없다.

### 함수형 표현을 사용하는데 보일러 플레이트가 많다.

자바스크립트 처럼 `() => 'return value'` 간단한 표기가 없다. php8에서는 `fn() => 'return value';`방식을 지원하지만 다른 언어의 간단한 표기 보다 좀 더 많은 보일러 플레이트를 요구한다. 

`fn` 함수는 `{}`의 블록을 갖지 않기 때문에 내부에 여러 줄에 걸친 복잡한 코드를 쓰는 것이 아닌 바로 반환할 수 있는 간단한 식을 쓸 때 사용해야한다. 따라서 여러 줄에 걸친 코드를 사용하는 경우 여전히 `function` 키워드의 함수를 사용할 수 밖에 없다. php에서는 `function` 함수의 기능을 `fn` 함수가 충분히 대체할 수 없으며 아주 제한된 경우에 한정해서 쓸 수 있는 문법이기 때문에 간단한 함수를 많이 선언하는 함수형 프로그래밍에 불편한다.

### 멀티 코어를 활용할 수 없는 구조
PHP는 보통 웹서버로 사용한다. 그런데 흔히 사용되는 CGI 방식의 웹 서버에서는 멀티코어의 사용을 권장하지 않는다.

함수형 프로그래밍은 불변성의 모듈을 쌓아가면서 프로그래밍을 한다. 이를 통해 복수의 스레드를 사용해도 레이스 컨디션이 발생하지 않기 때문에 코루틴 또는 스레드를 사용하는 프로그래밍에서 함수형 프로그래밍은 이점을 제공한다. 하지만 php는 멀티코어를 활용하지 못하므로 불변성 모듈을 쌓아서 프로그래밍을 하는 수고에 비해 얻는 비교적 적을 수 밖에 없다. 특별한 이점이 없는 상황에서 보일러 플레이트가 많고 불변성을 쌓는 방식의 고민을 하면서 시간을 들이는 함수형 프로그래밍을 하는 것으로 얻는 효과는 크지 않다. 그저 적재 적소에 함수형 기법을 사용해서 코드를 좀 더 잘 나누고 추상화 하는 부분에 도움을 주는 정도면 충분하다.

swoole을 사용하면 코루틴과 채널을 활용한 병렬 프로그래밍을 지원한다. 하지만 swoole을 통한 병렬 프로그래밍은 함수형 표현을 상용한 병렬 연산을 활용하는 것과는 다른 고루틴과 비슷한 방식이며 채널을 통해서 메모리를 공유하는 방식이며, 보편화 되어 있는 php 기술은 아니다. 이를 사용하기 위해서는 특별한 환경과 특별한 프레임워크 사용해야 하는데 php 세계에서 인기있는 환경이나 프레임워크는 아니다. 오히려 이런 기술을 사용해야 하는 프로젝트라면 이런 쪽으로 좀 더 보편화된 고언어를 사용하는 것을 추천한다.

### 비동기를 제대로 활용할 수 없는 구조

PHP8에서 fiber라고 비동기 문법을 지원한다. 하지만 fiber는 사용자를 위한 문법이 아니라, 라이브러리 제작자를 위한 문법으로 고안되었다. php에서 비동기 문법을 사용하기 위해서는 reactPHP 또는 php AMP 라이브러리를 설치하여 사용하도록 권장되고 있다.

비동기를 활용하기 위해서는 이들 라이브러리가 제공하는 방식으로 I/O 관련 기능을 사용해야 하는데, 프레임워크를 사용하고 있다면 프레임워크의 I/O 기능이 이들 비동기 라이브러리를 지원하지 않기 때문에 코드를 섞어 쓰게 되고 이상한 코드를 만들어 내게 된다. 코드의 일관성을 위해서 프레임워크를 사용할 때는 이들 비동기 라이브러리를 사용하지 않는 편이 훨씬 낫다.

## 일관성이 없음

일관성이 없다는 것은 사용하는데 있어서 비슷한 구조를 가지고 있지 않기 때문에 기억해서 사용하기 어렵다는 것이고, 기억해서 사용하기 어렵다는 것은 하나 하나 사용할 때 마다 찾아 봐야 한다는 의미이다. 이는 결국 생산성의 저하로 이어지게 된다.

좋은 서비스를 만들기 위해서는 언어 수준에서 예측할 수 있는 코드를 짜는 것이 중요하다. 하지만, 언어의 비일관성은 로직을 파악하는데 좀 더 많은 시간이 필요한 코드를 만들어 낸다. 따라서 해석 및 태스트에 소모되는 비용이 더 많이 요구되는 문제가 있다.

예를 들어 php의 내장함수들은 저마다 사양이 제각각이다. 함수 하나하나를 살펴보면 나름 그렇게 만들어진 이유가 있지만, 인자의 종류에 따른 순서라든지 함수명이라든지 조금씩 개선은 되고 있지만 여전히 불편한 점이 많다.

언어를 사용하면 할 수록 언어의 기능을 찾지 않고도 잘 만들 수 있어야 하는데, php의 경우에는 같은 시간을 숙달하더라도 더 많이 검색을 통해서 기능을 찾아서 사용해야 하는 문제점이 있다. 생산성의 향상을 위해서 사용하는 언어가 도리어 생산성의 향상에 크게 공을 들이지 않고 있고, 이것이 타 언어에 대비 경쟁력이 높지 않은 언어가 되는 이유가 된다고 본다.

### 배열 함수의 비일관성

#### 배열 함수의 인자의 순서의 비일관성

callable과 array의 인자 순서가 배열 함수마다 다르다. http://phpsadness.com/sad/6 기본적으로는 array를 첫 번째로 callback을 마지막으로 하는데, array_map의 경우에는 여러 배열을 받기 위해 array를 가변 인자로 받는다. php에서 가변 인자는 맨 마지막 인자로 정의 되어야 하므로 순서가 뒤 바뀐 것으로 php의 가변 인자 사양에 대해 무지하다면 아주 이상한 정의로 보일 것이다.

haystack과 needle의 인자 순서가 배열 함수마다 다르다. http://phpsadness.com/sad/9 배열에서 무언가를 찾을 때는 needle이 먼저, 배열을 그 다음 인자로 받으며, 문자열인 경우에는 문자열을 먼저, needle을 그 다음 인자로 받는다.

#### 함수의 인자 순서의 비일관성을 해결하기 위한 방법

이런 인자의 순서에 따른 혼란을 막기 위해 php의 내장 함수를 사용할 때 명명된 인자를 사용하는 습관을 갖자.

#### 배열 함수의 비일관성을 해결하기 위한 방법

일관성 있게 만든 매핑된 라이브러리를 사용한다. 이를 위해서는 지속적으로 메인테인스가 이뤄지는 인기 있는 라이브러리로 사용하는 것이 중요하다. 배열 함수를 사용하지 말고 라라벨 컬렉션을 제공하는 라이브러리를 사용하는 방법 등을 사용하자. [라라벨 컬렉션만 분리한 라이브러리](https://github.com/tighten/collect) [추천하는 함수형 php 라이브러리](https://github.com/lstrojny/functional-php)

### 문자열 함수의 비일관성

#### 문자열 함수 명칭의 비일관성

언더바 \_를 사용한 명칭과 \_를 사용하지 않은 명칭이 혼합되어 있다. http://phpsadness.com/sad/4

#### 문자열 함수의 비일관성을 해결하기 위한 방법

라라벨의 경우에는 문자열을 지원하는 helper 함수 `str::함수명` 기능을 사용한다.

## 표준 라이브러리에서 제공해야 할 기능을 서드파티로 떠 넘김

일반적으로 다른 언어는 언어와 함께 표준 라이브러리의 기능을 제공한다. 하지만 PHP의 경우 어느정도 기본적인 기능을 언어 차원에서 제공하지만 사용자 편의를 위한 기능을 서드파티 라이브러리에 떠맡긴다.

표준 내장 객체가 잘 만들어져 있어서 외부 라이브러리에 의존하는 기능을 줄이는 것이 좋은데 내장 기능을 사용하자니 편하게 사용하기 어려운 문제점이 있고, 쉽고 편리한 기능을 제공하는 라이브러리를 쓰자니 신뢰성이 떨어지는 서드파티 라이브러리를 꼭 사용해야 하는 문제가 생긴다.

내장 기능은 OOP 방식으로 캡슐화 되어서 기능을 제공하기 보다는 요즘 추세와 맞지 않는 상대적으로 저수준(C언어 보다는 나은)의 개념으로 만들어져 있기 때문에 가독성이 떨어진다.

기능을 알기 위해서는 설명을 해석하기 쉽지 않은 PHP 내장 기능을 이해해야 한다. (심지어 이걸 제대로 이해하고 쓰고 있는 사람이 어느 정도 될지도 모를 정도) 쉽게 쉽게 어떤 기능을 활용할 수 있는지 잘 캡슐화된 대상을 표준 라이브러리에서 제공할 필요가 있다고 본다. 매커니즘에 대한 대략적인 이해만으로도 명확하게 어떤 기능을 하는지 알고 사용할 수 있도록 해야 하는데 그렇지 못하다.

표준 라이브러리를 만들어서 미래에도 계속적으로 유효한 라이브러리를 만들어 써드파티가 아닌 표준 라이브러리의 사용을 권장하는 방식으로 코딩의 표준을 잡을 필요가 있어 보인다.

PHP 사용자별로 라이브러리 사용자 별로 프레임워크 사용자 별로 파편화된 지식을 습득하게 되면서 일관성을 맞추기 위해서 내장 함수에 의존하게 된다. 이로 인해 OOP를 제대로 활용하지 못하는 문제가 발생한다.

클래스화 되어 있는 array function 기능을 통한 체이닝 지원, 기본적인 기능을 모두 포함하고 있는 curl 간편한 curl 기능, async await 등등의 기능 등등을 표준 라이브러리 차원에서 제공해야 한다. 물론 curl 기능을 레핑한 Guzzle, async await 기능을 레핑한 ReactPHP, PHP AMP 등의 공신력있는 라이브러리, array function 기능을 대신 사용가능한 라라벨 collection 등이 있지만 언제 폐기 될지 모르는 다양한 라이브러리들이 존재한다는 것이 문제. 이래서 라라벨이나 심포니와 같은 프로젝트가 인기를 끌 수 밖에 없는 상황이다.

### 자바스크립트와의 비교

자바스크립트의 경우, 자바스크립트 해석 엔진과 함께 표준 내장 객체를 제공한다. 자바스크립트의 표준 내장 객체는 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects 에서 확인 가능하다.

또한 노드 JS와 브라우저는 각각 내장 라이브러리를 제공한다. 노드 JS의 내장 라이브러리 또한 기능이 너무 많고 쉽게 사용하기 쉽지 않다. 하지만 브라우저의 내장 라이브러리는 사용하기 쉽고 이해하기 쉽도록 만들어져 있다는 것이 느껴진다.

## 타입 비교가 이상함

#### php 7 버전에서는
```php
var_dump(0 == "a"); // bool(true)
var_dump("1" == "01"); // bool(true)
var_dump("10" == "1e1"); // bool(true)
var_dump(100 == "1e2"); // bool(true)
```

#### php 8 버전에서는
```php
var_dump(0 == "a"); // bool(false)
var_dump("1" == "01"); // bool(true)
var_dump("10" == "1e1"); // bool(true)
var_dump(100 == "1e2"); // bool(true)
```

### 문제

단순히 `==` 연산자를 통한 비교를 하는 것이 문제가 아니다. 이 타입 추론의 방식이 디폴트로 되어 있기 때문에 in_array 와 같은 다양한 내장 함수에서 위의 비교를 암묵적으로 사용하고 있다.

```php
in_array("1", ["01"]); // bool(true)
in_array("10", ["1e1"]); // bool(true)
in_array(100, ["1e2"]); // bool(true)
```

php의 `==`이 위와 같은 처리를 한다는 것을 알고 있어도 `in_array`라는 함수를 쓸 때 위와 같이 판별한다는 것을 일반적으로 위와 같은 상황이 일어난다고 미리 알고 쓰지 않는 경우가 많다.

또한 php의 다양한 내장함수들이 이 암묵적 비교를 사용하고 있고, 이 내장함수를 쓰는 다양한 함수들, 라이브러리들이 위와 같은 문제를 가지고 있다. 따라서 예측하지 못한 버그가 발생하게 된다. 어떤 기능을 사용할 때 내부적으로 암묵적 비교를 사용하고 있겠지를 항상 가정해야 하는 문제점이 있다. 내부적으로 어떻게 처리할 줄 알고 이런 부분들을 모두 가정하고 써야 하는지, php를 쓰면 참담한 심정을 가지게 된다.

예를 들어 라라벨 벨리데이션에서 `"in:01,02,03"` 벨리데이션을 사용했을 때 `"1", "2", "3"`도 통과하게 된다. 사용자는 당연히 문자열이 일치할 때 벨레데이션을 통과하겠지하고 사용하는데 내부적으로는 `==` 연산 `in_array` 방식을 사용하고 있기 때문에 개발자의 예측과 달라지는 문제가 발생하게 된다.

다행히도 `in_array`를 단독으로 사용하는 경우 세번째 인자로 `true` 값을 전달하면 `==`가 아닌 `===`으로 확인하는 방식으로 사용되어 엄격한 비교가 가능하지만, php 개발자는 `in_array`를 스트릭트 모드로 사용하지 않은 수 많은 코드에 의존하고 있다는 것이 문제이다.

## 스칼라 오브젝트의 미지원

자바스크립트, 자바 언어를 사용하면 `"문자열".함수()` 방식의 표현을 사용할 수 있다. 어떤 타입에 대해서 해당 타입에 대해 사용할 수 있는 기능들을 `.`을 붙여주게 되면 IDE는 리스트를 보여준다. 문자열이나 수 등의 기본 타입에서 사용할 수 있는 함수의 속성을 접근할 수 있게 해 주는 기능을 스칼라 오브젝트라고 말한다. 스칼라라는 것은 프로그래밍 언어에서의 오브젝트가 아닌 값을 나타내는 타입을 의미한다. 이를 오브젝트 처럼 접근해서 쓴다는 것이 스칼라 오브젝트이다. 하지만 많은 언어에서 이러한 접근방식을 지원하는 것과 달리 php에서는 객체가 아닌 타입은 오브젝트의 속성에 접근하는 `->` 키워드로 접근하는 기능을 제공하지 않는다.

php에서는 호출할 수 있는 종류의 대상을 콜러블이라고 하는데 콜러블의 대표적인 것이 php의 내장함수들이다. 다른 언어들은 '값.함수()'로 접근하는 것들을 php는 문자열이면 'str_어쩌구' 함수, 배열이면 'array_어쩌구', '어쩌구_array' 함수를 사용하는 등 함수를 사용해서 만들어야 한다.

문제는, IDE를 사용하면 '값.'을 입력하는 순간 함수 리스트가 나와서 무엇을 사용하면 되는지 쉽게 알 수 있는 반면, php는 이런 지원을 하지 않기 때문에 내장 함수를 검색해서 사용해야 한다. 또한 '값.'을 사용하는 순간, 함수의 인자에서 값이 어디에 들어가는지 알 필요가 없다. 나머지 인자들의 위치만 기억하면 되므로 공식 문서를 찾지 않아도 사용하기 쉽다. 물론 자주 쓰는 내장함수는 기억하는 경우도 많이 있겠지만, 오랜기간 php를 써 봐도 잘 기억이 나지 않는 걸 보면, 언어가 편하고 좋다라고 하기 어려운 면이 있다.

물론 스칼라 오브젝트를 지원한다고 하더라도 동적 타입의 언어의 경우, 값이 어떤 타입인지 모르기 때문에 IDE의 자동 추론이 잘 되지 않는 문제가 있고, php도 그런 부분에 있어서 마찬가지라고 넘어갈 수 있겠다.

스칼라 오브젝트에 관한 설명은 다음 링크를 참조하자 : https://dev.to/mattsparks/i-want-scalar-objects-in-php-2o6b

## 제네릭 미지원

php에서 제네릭 추가는 해결하기 어려운 문제로, 해결하지 못할 것이라는 전망이 우세하다. php에서 제네릭을 기대하지 않는 편이 좋다는 것이다.

제네릭을 활용하면 어떤 함수나 클래스가 어떤 타입에 대해서 성립하는지 알 수 있는 정보를 제공할 수 있다. 하지만 제네릭이 없기 어떤 기능을 사용했을 때 얻는 값의 유형에 대한 정보를 얻을 수 없고 이 때문에 런타임 타입검사를 통해서 유형 정보를 확인할 수 밖에 없다.

제네릭 대신에 유니온 타입을 사용하고, `assert(is_type($value))`와 같은 코드를 통해서 사용하는 타입 정보를 정적 분석 도구에 알려주는 방식의 코딩을 통해서 제네릭이 없이도 어느 정도는 타입 안정적인 코딩을 할 수 있다.

강타입 언어 보다 적은 제약의 빠른 생산성을 위해 동적 언어를 사용하는데 런타임의 타입 체크를 위해서 로직을 추가적인 로직을 작성해 줘야 한다면 동적 언어를 쓰는 이점이 있을까?를 생각해 봐야 한다.

## Reference
- http://phpsadness.com/
- https://www.php.net/manual/en/language.operators.comparison.php
