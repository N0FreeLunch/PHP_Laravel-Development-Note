# 유니온 타입

## 동적 타이핑 언어

컴파일 언어는 컴파일 단계에서 타입과 구문으로 발생하는 버그를 차단하고, 런타임에서는 가능한 이러한 검사를 하지 않는 것으로 빠른 동작을 수행하는 의도로 만들어진다. 컴파일 언어는 컴파일을 통해서 저수준의 언어가 된다. 컴퓨터는 0과 1의 코드로 구성 되는데, 수 많은 0과 1이 하나라도 잘못되면 치명적인 버그로 이어질 수 있다. 컴파일 언어가 엄격한 타입 검사를 하지 않으면 런타임에서의 각종 검사가 없기 때문에 타입이 잘못되어 0과 1의 값이 바뀌게 되고 이 때문에 치명적인 버그로 이어질 수 있기 때문이다.

이에 반해 동적 언어는 변수에 어떤 값이라도 넣을 수 있도록 만들어져 있는데, 타입 정보를 변수가 갖고 있기 때문에 다음에 이어질 코드 간의 타입을 확인하여 타입이 불일치하면 에러를 발생시키고 인터프리터 엔진을 종료하면 된다. 동적 타이핑 언어는 변수에 모든 값을 넣을 수 있기 때문에 모든 타입을 갖고 있다. 그래서 변수에 넣을 수 있는 값을 제한하거나, 변수에 넣어진 값이 제한되었다고 가정하고 사용하는 방법을 쓰는데 이 때 변수가 가질 수 있는 여러 타입에 대한 정보를 유니온 타입으로 기술한다.

## 오버로딩

오버로딩은 같은 이름의 함수에 다양한 시그니처를 사용할 수 있게 하기 위해서 매개변수의 타입이나 반환 타입을 다르게 세팅한 것을 여럿 만드는 것이다. 그럼 동일한 함수명이라도 전달되는 파라메터 타입에 따라서 각각의 타입에 맞는 처리를 할 수 있는 기능을 제공한다.

동적 타이핑 언어인 php에는 오버로딩이라는 개념이 없다. (적어도 현존하는 메이저 동적 타입 언어 php, ruby, js, python 등) 타입힌트가 도입되기 전의 php의 함수 매개변수에는 다양한 타입의 값이 전달될 수 있었고 이 때문에 타입을 이용해서 동일한 이름의 서로 다른 함수를 호출할 수 있는 오버로딩 개념이 적용될 수 없었다. 이후 타입힌트가 도입이 되었을 때도 언어를 크게 바꾼 것 없이 하나의 함수에서 여러 타입을 사용할 수 있는 유니온 타입을 사용할 수 있게 바뀐 것 뿐이다.

오버로딩이 없기 때문에 하나의 함수 명칭으로 다양한 타입에 대한 처리를 하기 위해서는 유니온 타입을 사용해서 하나의 함수에서 매개변수에 전달된 타입에 따라 분기 처리를 하는 방식으로 오버로딩과 비슷한 사양의 클래스를 만들 수 있다.

## 시그니처

파라메터가 유니온 타입을 받는다고 하자. 첫 번째 파라메터가 3가지 타입을 받고, 두 번째 인자가 3가지 타입을 받으면 총 9가지의 타입을 할당할 수 있다. 그러나 대부분의 경우 이렇게 해석되는 것은 아니며, 첫 번째 인자의 타입을 A1, A2, A3 두 번째 인자의 타입을 B1, B2, B3, 반환 타입을 R1, R2라고 할 때, 모든 경우의 수를 다 처리하지 않고 일부 파라메터에 대한 처리만 한다.

예를 들어 다음 타입에 대한 처리를 한다고 하자. '첫 번째 인자 -> 두 번째 인자 -> 반환'의 관계에서 A1 -> B1 -> R1, A2 -> B2 -> R1, A3 -> B3 -> R2의 타입 처리 방식을 갖는다고 하자. 실제로는 3개의 패턴만이 존재하는데, 유니온 타입을 사용해야 하기 때문에 마치 함수의 파라메터가 3x3으로 9가지 경우를 다 처리하는 기능처럼 보이는 것이다.

함수는 시그니처를 통해서 해당 함수의 기능을 추측할 수 있도록 만드는 것이 중요한데, 유니온 타입으로 처리하게 되면 함수를 만들 때 의도하지 않았던 패턴의 시그니처도 생각하게 만드는 등의 문제가 생긴다. 오버로딩의 방식을 사용하게 되면, 함수의 시그니처 패턴이 어떤 것인지 좀 더 명확하게 될 수 있다.

php애는 오버로딩이 없다. 하지만 무턱대고 유니온타입을 사용하면 시그니처의 경우의 수가 늘어나기 때문에 어떤 시그니처를 사용하고 말아야하는지 모호한 경우가 생길 수 있다. 오버로딩이 불가능한 php에서는 함수의 이름을 달리해서 처리하는 방법을 생각하는 편이 좋다.

### 예제로 이해하기

#### 2가지의 시그니처를 유니온 타입으로 표기한 예

```php
function color(int|string $redOrHex, int $green = null, int $blue = null) {}

$indianRedFromRgb = color(205, 92, 92);
$indianRedFromHex = color('#CD5C5C');
```

위의 코드는 `color(205, 92, 92)`으로도 사용할 수 있고, `color('#CD5C5C')`으로도 사용할 수 있다. 의미론상 `color('#CD', 92, 92)`등과 같은 코드는 어색하다는 것을 알 수 있다. (hex 코드의 색은 보통 RGB의 각 색별로 나눠 표기하지 않기 때문) 유니온 타입을 사용할 때, 대부분의 경우 어떤 시그니처 조합을 사용해야 하는지 말아야 하는지 알 수 있기 때문에 유니온 타입을 사용하는 방법을 써도 괜찮지만, `color('#CD', 92, 92)`와 같은 코드도 되지 않을까라고 생각해서 동작을 시도해 보는 경우가 있을 수 있다. 유니온 타입의 시그니처는 보통 일반 상식에 따라 해석되지만 가끔 혼동을 줄 수도 있다는 단점이 존재한다.

#### 유니온 타입을 사용하지 않고 함수를 나누는 예

```php
function colorRgb(int $red, int $green, int $blue) {}
```

```php
function colorHex(string $hex) {}
```

위와 같이 함수를 2가지로 구분하면 깔끔하다. 색상을 세팅하고 나면 내부에서는 동일한 색상을 다루는 대상으로 변환해서 처리를 할 텐데, colorRgb을 사용했다면 colorHex를 사용하지 않도록 해 주어야 한다. 그리고 colorRgb에 어떤 변화가 있을 때는 colorHex의 코드도 수정해야 하는 경우가 생긴다. 함께 다뤄야 할 대상을 분리해 놓은 느낌을 주는 것이 맘에 들지 않을 수도 있다. 이 때는 readonly를 사용해서 값이 두 번 세팅이 되면 런타임 에러를 주는 방식으로 사용해 볼 수 있을 것이다.

## 제네릭이 없는 언어

### 제네릭이란?
어떤 시그니처에 대해 내부에서 사용하는 특정 값이 특정 타입에 의존적이지 않고 여러 타입을 사용할 수 있도록 할 때 제네릭을 사용한다. 제네릭을 사용해서 정의된 시그니처를 사용할 때 타입 매개변수에 특정 타입을 지정해 주면, 해당 시그니처의 내부 코드의 타입 파라메터는 지정된 타입을 사용하게 된다.

### 제네릭이 없는 문제

php는 제네릭이 없기 때문에 여러 타입을 사용할 때 유니온 타입을 사용한다. 유니온 타입의 단점은, 사용 초기에 정한 타입에 의해 연관된 타입을 결정할 수 없는 문제가 존재한다. 다음 예제를 보자.

```php
$padEmptyRight = function (int|string $input, int $length): int|string {
	return match(true) {
		is_string($input) => mb_str_pad($input, $length),
		is_int($input) => intval(mb_str_pad(strval($input), $length, '0')),
	};
};

var_dump($padEmptyRight(123, 6)*100); // int(12300000)
var_dump($padEmptyRight('hello', 6).'world'); // string(11) "hello world"

var_dump($padEmptyRight(123, 6).'world'); // string(11) "123000world"
var_dump($padEmptyRight('hello', 6)*100); // Fatal error: Uncaught TypeError: Unsupported operand types: string * int
```

`$padEmptyRight`라는 함수를 사용했을 때, `$padEmptyRight('hello', 6)`는 `"hello world"`가 된다. 문자열에 `*100`을 하게 되므로 에러가 발생한다. `$padEmptyRight` 함수의 시그니처를 통해서 문자열이면 빈 문자열인 스페이스를, 정수인 경우에는 빈 수인 0을 지정한 길이를 채우기 위해서 왼쪽에 추가할 것이다. 함수의 시그니처를 통해서, 문자열이면 문자열이 반환되고, 정수면 정수가 반환되는 사양의 코드라는 것을 알 수 있다.

하지만 정적 분석 도구는 `$padEmptyRight(123, 6)*100`와 `$padEmptyRight('hello', 6)*100` 코드에 대해, 반환 타입이 `int|string`이면 분기 처리를 통해서 어떤 타입을 사용할 것인지 정하지 않은 상태에서 함부로 문자열에 100을 곱할 수 없다고 알려 준다.

제네릭을 썼다면, 함수의 파라메터는 `OperatorType $input`가 되고, 반환 타입은 `: OperatorType`가 되어 인풋과 동일한 타입의 반환값이라는 것을 알 수 있지만, php는 제네릭이 없는 언어이기 때문에 유니온 타입을 사용할 수 밖에 없고 인풋 타입에 대한 아웃풋 타입을 화정할 수 없기에 정적 분석 도구는 각각의 타입에 대한 타입을 명확히 정한 후에야 타입을 사용할 수 있게 한다.

```php
$paded123 = $padEmptyRight(123, 5);
if (is_int($paded123)) var_dump($paded123 * 100);
```

```php
assert(is_int($paded123));
var_dump($paded123 * 100);
```

### 런타임 타입 확인

php는 모든 타입을 런타임에 확인할 수 있는 언어이므로, 유니온 타입을 사용했을 때 어떤 타입으로 좁혀지는지 (type narrowing) 알려주는 것을 통해서 어떤 타입인지 알 수 있다. 하지만, 이는 런타임에서 어떤 타입이 전달되었는지 확인해야 하므로 정적 분석이 아닌 `assert`에 의한 코드의 실행을 통해서 실제 타입이 정확한지 알 수 있다는 단점이 존재한다.

강력한 타입 추론 기능을 가진 언어의 경우, 코드를 실행하는 타임이 아닌 컴파일 타임에서 타입을 체크하기 때문에 제네릭을 통해서 사용할 타입이 지정되면 연관된 다른 부분의 타입이 결정되는 제네릭을 활용해서 코드 간의 타입 결정을 추론할 수 있고, 엄격한 타입 드리븐의 코드 구성이 가능하다.

하지만 php의 경우, 제네릭이 없기 때문에 `assert`를 통해서 타입 좁히기(type narrowing)를 해야 하고, 이는 런타임에 타입을 확인하기 때문에 반드시 실행을 해서 확인을 해야 하며, 직접 실행을 하지 않아도 타입의 안정성을 보장하는 이점을 누리기 어렵다는 단점이 존재한다.

하지만 대부분의 비즈니스 로직을 작성할 때, 타입 주도 설계는 지나친 추상화를 요구하기 때문에 보편적으로 쓰이는 방식은 아니며, 각종 외부 시스템 의존적인 부분 및 값의 특정한 패턴 검사는 타입으로 확인할 수 있는 영역이 아니기 때문에 적당한 타입 추론과 더불어 코드 실행을 통해서 런타임에 문제가 있는지 없는지 확인을 해야 한다. 강력한 타입 시스템은 시스템의 타입 안정성을 보장할 수 있지만, 로직의 무결성을 보장하지는 못하므로 결국 런타임의 실행을 통한 확인이 필요하다.

### 엄격한 타입 시스템을 가진 언어와 비교

어차피 실행을 통해서 로직을 확인해야 한다면, `assert`를 통한 타입 확인을 런타임에 수행하는 것은 다른 언어에 비해 개발 시간적 여건상의 불리한 점은 아니다.

하지만, 모든 동작 확인 및 테스트를 수행할 수는 없고 일부 케이스에 대해서는 누락이 발생할 수 밖에 없는데, 이 때 강력한 타입시스템은 대부분의 엣지 케이스를 특별히 검사하지 않아도 문제 없이 동작하는 코드가 될 가능성이 높다는 장점을 가진다.

### 제네릭의 문제와 유니온 타입의 충분함

제네릭은 시그니처 내부에서 해당 타입 매개변수를 활용해서 어떤 처리를 하는데 쉽게 파악하기 어려운 문제를 야기한다. 외부의 상태에 의존적인 코드를 작성한다고 하자. 외부의 데이터를 어떤 데이터 스트럭쳐에 매핑시키기 위해서 제네릭으로 지정한 타입을 사용할 것이다. 이런 로직을 둘러싼 시그니처의 제네릭은 외부의 시그니처만 보고서는 내부에서 사용하려는 타입이 무엇인지 알 수 없기 때문에 코드를 모두 읽어야 하는 코드를 만들 수 있다.

이런 문제 때문에 제네릭을 사용할 때는 제네릭의 명칭 부여, 내부 상태에 의존하지 않는 함수형 프로그래밍 기법, 작은 단위의 로직의 설계, 인풋에 대한 예측 가능한 아웃풋의 관계 등을 활용해서 제네릭이 어떤 용도로 사용되는지 시그니처만을 통해서 알 수 있도록 코드를 작성하는 것이 중요하다.

어차피 로직을 간결하고 의도가 잘 드러나도록 코드를 작성해야 한다면, 로직이 간결하기 때문에 어떤 인풋 타입에 대해서 어떤 타입이 반환되는지 제네릭 없이 유니온 타입으로도 타입이 어떻게 결정될지 알 수 있기 때문에 올바른 코딩 프렉티스와 코드 설계 방법론을 적용한다면 제네릭이 없어도 충분히 안정적인 코드를 작성할 수 있다.

작은 단위의 로직의 반환 값의 타입을 `assert`를 통해서 타입을 확인하고 다음 값으로 로직을 전달하는 것을 통해서 타입 안정적인 코드를 사용할 수 있는 것이다.

## References
- https://wiki.php.net/rfc/deprecate_functions_with_overloaded_signatures
