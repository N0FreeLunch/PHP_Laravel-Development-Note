# 유니온 타입

## 동적 타이핑 언어

## 오버로딩

오버로딩은 같은 이름의 함수에 다양한 시그니처를 사용할 수 있게 하기 위해서 매개변수의 타입이나 반환 타입을 다르게 세팅한 것을 여럿 만드는 것이다. 그럼 동일한 함수명이라도 전달되는 파라메터 타입에 따라서 각각의 타입에 맞는 처리를 할 수 있는 기능을 제공한다.

동적 타이핑 언어인 php에는 오버로딩이라는 개념이 없다. 타입힌트가 도입되기 전의 php의 함수 매개변수에는 다양한 타입의 값이 전달될 수 있었고 이 때문에 타입을 이용해서 동일한 이름의 서로 다른 함수를 호출할 수 있는 오버로딩 개념이 적용될 수 없었다. 이후 타입힌트가 도입이 되었을 때도 언어를 크게 바꾼 것 없이 하나의 함수에서 여러 타입을 사용할 수 있는 유니온 타입을 사용할 수 있게 바뀐 것 뿐이다.

오버로딩이 없기 때문에 하나의 함수 명칭으로 다양한 타입에 대한 처리를 하기 위해서는 유니온 타입을 사용해서 하나의 함수에서 매개변수에 전달된 타입에 따라 분기 처리를 하는 방식으로 오버로딩과 비슷한 사양의 클래스를 만들 수 있다.

## 시그니처

파라메터가 유니온 타입을 받는다고 하자. 첫 번째 파라메터가 3가지 타입을 받고, 두 번째 인자가 3가지 타입을 받으면 총 9가지의 타입을 할당할 수 있다. 그러나 대부분의 경우 이렇게 해석되는 것은 아니며, 첫 번째 인자의 타입을 A1, A2, A3 두 번째 인자의 타입을 B1, B2, B3, 반환 타입을 R1, R2라고 할 때, 모든 경우의 수를 다 처리하지 않고 일부 파라메터에 대한 처리만 한다.

예를 들어 다음 타입에 대한 처리를 한다고 하자. '첫 번째 인자 -> 두 번째 인자 -> 반환'의 관계에서 A1 -> B1 -> R1, A2 -> B2 -> R1, A3 -> B3 -> R2의 타입 처리 방식을 갖는다고 하자. 실제로는 3개의 패턴만이 존재하는데, 유니온 타입을 사용해야 하기 때문에 마치 함수의 파라메터가 3x3으로 9가지 경우를 다 처리하는 기능처럼 보이는 것이다.

함수는 시그니처를 통해서 해당 함수의 기능을 추측할 수 있도록 만드는 것이 중요한데, 유니온 타입으로 처리하게 되면 함수를 만들 때 의도하지 않았던 패턴의 시그니처도 생각하게 만드는 등의 문제가 생긴다. 오버로딩의 방식을 사용하게 되면, 함수의 시그니처 패턴이 어떤 것인지 좀 더 명확하게 될 수 있다.

php애는 오버로딩이 없다. 하지만 무턱대고 유니온타입을 사용하면 시그니처의 경우의 수가 늘어나기 때문에 어떤 시그니처를 사용하고 말아야하는지 모호한 경우가 생길 수 있다. 오버로딩이 불가능한 php에서는 함수의 이름을 달리해서 처리하는 방법을 생각하는 편이 좋다.

### 예제로 이해하기

#### 2가지의 시그니처를 유니온 타입으로 표기한 예

```php
function color(int|string $redOrHex, int $green = null, int $blue = null) {}

$indianRedFromRgb = color(205, 92, 92);
$indianRedFromHex = color('#CD5C5C');
```

위의 코드는 `color(205, 92, 92)`으로도 사용할 수 있고, `color('#CD5C5C')`으로도 사용할 수 있다. 의미론상 `color('#CD', 92, 92)`등과 같은 코드는 어색하다는 것을 알 수 있다. (hex 코드의 색은 보통 RGB의 각 색별로 나눠 표기하지 않기 때문) 유니온 타입을 사용할 때, 대부분의 경우 어떤 시그니처 조합을 사용해야 하는지 말아야 하는지 알 수 있기 때문에 유니온 타입을 사용하는 방법을 써도 괜찮지만, `color('#CD', 92, 92)`와 같은 코드도 되지 않을까라고 생각해서 동작을 시도해 보는 경우가 있을 수 있다. 유니온 타입의 시그니처는 보통 일반 상식에 따라 해석되지만 가끔 혼동을 줄 수도 있다는 단점이 존재한다.

#### 유니온 타입을 사용하지 않고 함수를 나누는 예

```php
function colorRgb(int $red, int $green, int $blue) {}
```

```php
function colorHex(string $hex) {}
```

위와 같이 함수를 2가지로 구분하면 깔끔하다. 색상을 세팅하고 나면 내부에서는 동일한 색상을 다루는 대상으로 변환해서 처리를 할 텐데, colorRgb을 사용했다면 colorHex를 사용하지 않도록 해 주어야 한다. 그리고 colorRgb에 어떤 변화가 있을 때는 colorHex의 코드도 수정해야 하는 경우가 생긴다. 함께 다뤄야 할 대상을 분리해 놓은 느낌을 주는 것이 맘에 들지 않을 수도 있다. 이 때는 readonly를 사용해서 값이 두 번 세팅이 되면 런타임 에러를 주는 방식으로 사용해 볼 수 있을 것이다.

## 제네릭이 없는 언어

## References
- https://wiki.php.net/rfc/deprecate_functions_with_overloaded_signatures
