# 타인 안정성

## 선언 타입 없음

php의 큰 문제 중 하나는 지역 변수에 선언 타입이 없다는 점이다. 선언 타입이 없다는 것은, 코드의 논리 전개에 따라 한 번 선언된 변수의 타입이 값의 변화에 따라 계속 변화한다는 것이다.

여타 정적 언어가 변수의 선언부의 타입만을 확인하면 어떤 타입을 사용하는지 알 수 있는 것과 달리 php는 사용하려는 변수의 타입을 확인하기 위해서는 선언된 부분뿐만 아니라 코드의 전개까지 확인해야 한다는 불편함이 있다.

## 변수 사용의 전제조건

기본적으로 변수에 값을 할당할 때는 하나의 타입 또는 null을 포함한 하나의 타입을 사용해야 한다. 만약 변수가 여러 타입을 가질 수 있다면, 각각의 타입에 맞는 분기 처리 로직이 필수적이고 로직이 복잡해진다.

하나의 변수가 선언시 여러 타입을 사용한다면 어느 정도의 타입까지 분기처리 로직을 해 줘야 하는지 불분명할 수 있으며, 특정 타입의 분기를 처리하지 않는 등의 실수를 할 수 있다. 따라서 변수의 타입은 가능한 최소한으로 하고, 타입이 다른 대상을 사용할 때는 새로운 변수를 추가하여 사용하는 등의 코드를 만들도록 하자.

## 코드의 전개에 따라 변수의 타입을 확인하기

### 무효한 값으로 null을 사용할 때

무효한 값으로 null을 사용할 때는, 유효한 값이라면 null이 아닌 특정한 타입만을 가진다.

`if (is_int($var))`이라는 코드는 `$var` 변수가 null 또는 정수 타입의 값을 가지고 있고, 조건이 true인 경우는 변수가 할당되었을 때의 로직을, false인 경우에는 변수가 할당되지 않았을 때의 로직으로 `$var`가 null이란 의미를 담고 있다.

```php
if (is_int($var)) {
    // $var is valid.
}
```

### 무효한 값으로 빈 값을 사용할 때

무효한 값으로 null이 아닌 빈 값을 사용할 때는, 변수는 하나의 타입만을 가진다. 이 때 할당과 비할당의 여부는 빈 값인지 아닌지를 판별하는 것으로 확인할 수 있다.

php에서 빈 값은 직접 빈 값과의 비교를 통해 확인을 할 수 있다. `$var === 0`, `$var === []`, `$var === ''` 

`if ($var !== '')`이라는 코드는 변수가 하나의 타입을 갖고 있고, 조건이 true인 경우는 변수가 할당되었을 때의 로직을, false인 경우에는 변수가 할당되지 않았을 때의 로직으로 `$var`가 빈 값인 의미를 담고 있다.

```php
if ($var !== '') {
   // $var is vaild
}
```

#### 빈 값을 체크하면 무효한 빈 값인가?

변수가 null을 비할당으로 사용하고, null이 아닌 타입을 할당 값으로 사용할 때, 빈 값이 특수한 용도로 쓰이는 값이라 `if ($var !== 0)`과 같은 코드를 썼다고 하자. 이 조건문이 false인 경우는 비할당이 아니라 할당에 해당한다. 빈 값이 유효한 값이라 특수한 처리를 하는 경우 `if ($var === 0)`으로 긍정문을 사용하도록 하고, `if ($var !== 0)`와 같이 부정문으로 사용되고 else와 같은 로직이 없는 경우는 0을 비할당으로 보면 된다.

```php
if ($var === 0) {
    // 0 is specific value.
}
```

기본적으로 if문은 긍정문을 기준으로 코드를 짜는 것이 일반적이며, if문을 부정문으로 코드를 짜는 것은 특별한 이유가 있을 때이다. `if ($var !== 0)`와 같이 부정을 if 블록으로 실행하려는 코드는 특별한 이유가 있을 때이고 이는 변수의 빈 값이 비할당인 경우라는 것으로 생각할 수 있다.

```php
if ($var !== 0) {
    // $var is valid int value.
}
```

대부분 비할당의 경우 로직을 실행하지 않는다. if문에 빈 값을 체크하는 조건문이 있다면 빈 값에 대해 어떤 로직을 실행하는 것이므로 유효한 값으로 사용되는 것이고, if문이 빈 값이 아닌지 체크하는 조건문이 있다면 빈 값이 아닐 때 로직을 실행해야하는 것이므로 빈 값이 유효한 값이 아니라는 의미를 갖는다.

## 변수의 타입 변화

정적 언어의 경우 변수의 타입이 한 번 선언된 후에는 더 이상 타입을 변경할 수 없다. php의 지역변수는 변수가 선언될 때 타입을 정할 수 없고, 로직의 전개에 따라 동일한 이름의 변수라도 다른 타입의 값이 전달될 수 있다. 그렇다면 특정 부분에서 변수의 타입은 무엇일까? 변수 안에 든 값의 타입을 알기 위해서는 변수에 어떤 변경이 일어나는지 모두 확인을 해야 한다. 가능하면 선언할 때 의도한 타입과 다른 타입이 변수에 들어가는 것을 방지하는 것이 좋다. 기존 변수의 타입과 다른 타입 양상을 가지는 변수는 새로운 변수를 만들어 전개하는 것이 좋다.

## null의 암묵적 형변환

스트릭트 모드의 단점은 

```php
$var = null;

$addNull = 1+$var;

var_dump($addNull);

$xNull = 1*$var;

var_dump($xNull);
```

수 연산자와 null을 함께 연산을 하면 null은 0으로 자동 형 변환되어 계산된다.

## 스트릭트모드

php에서 스트릭트 모드는 함수의 인자와 반환 값에 대해 암묵적인 형 변환을 사용할 수 없도록 제약을 건다.

함수의 인자와 반환값에만 제한을 걸기 때문에 이외의 다른 자동 형 변환이 일어나는 쪽에서는 에러가 발생하지 않는다.

## 암묵적인 형변환

```php
$fn = function (string $a, string $b) {
    var_dump($a);
    var_dump($b);
};

$fn(1, 2);
```

문자열 타입힌트의 파라메터를 가진 함수에 수를 전달하였다. 함수 내부로 전달된 값을 확인해 보면 `'1'`, `'2'`으로 문자열 값이 출력된다.

수를 전달했는데 문자열로 받는 것을 알 수 있는데 특별히 형 변환하는 키워드를 사용하지 않았지만 다른 타입으로 값이 변환되는 기능이 암묵적인 형 변환이다.

```php
declare(strict_types=1);

$fn = function (string $a, string $b) {
    var_dump($a);
    var_dump($b);
};

$fn(1, 2);
```

php 파일의 선두에 `<php? declare(strict_types=1);`를 사용하는 것을 통해서 함수의 인자와 반환값의 타입이 변하지 않도록 만들 수 있다.

## 타입이 강한 언어에 대한 환상

타입이 강한 언어를 사용하면, 런타임에 발생할 수 있는 실수를 잡아 주기 때문에 안전하다는 환상을 가지는 경우가 많다. 하지만, 버그라는 것은 타입으로만 발생하는 것이 아니며, 논리적인 문제로도 발생할 수 있고, 사람이 명확하게 판단하기 어려운 복잡한 개념을 정의하려고 할 때 문제가 발생할 수도 있다.

컴파일 언어가 제네릭과 같은 일부 기능에 대해 런타임에 타입 정보가 사라지는 문제를 갖지만, php는 런타임에 모든 대상의 타입 정보를 확인할 수 있다. (물론 resource와 같은 일부 값에 대해서는 타입이 모호한 면이 있지만 명확한 타입이 정의되는 쪽으로 전환이 되고 있다.) 컴파일 언어는 컴파일과 IDE를 통해서 타입에 문제가 있는지를 확인하지만, php는 런타임에 타입정보를 확인할 수 있으므로 타입힌트나, assert를 통해서 타입을 확인하면서 코드를 만들면 된다. 그리고 많은 경우 IDE를 통해서 타입 정보를 확인할 수 있는 경우도 많다. IDE와 코딩 스타일을 잘 활용하는 것을 통해서 타입으로 인한 문제 발생을 상당히 줄일 수 있다.

php는 인터프리터 언어이므로 빠른 실행을 통해서 동작의 결과를 확인할 수 있다. 컴파일 언어는 컴파일도 하고 최종적으로는 동작도 확인해야 하는데, 컴파일 언어보다 덜 엄격한 타입 검사를 하지만, 동작 확인이 컴파일 언어보다 빠르다는 장점도 있다. 컴파일 언어는 컴파일 언어의 장단점이 있고, php는 php만의 장단점이 있다. php도 상당히 역사가 긴 언어이고 언어를 개선하기 위해 많은 시도가 있는 언어라 컴파일 언어보다 못하다기 보다는 인터프리터로서의 장단점이 있는 언어이다.

## References

- https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
