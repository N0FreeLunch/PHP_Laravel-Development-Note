# 타인 안정성

## 선언 타입 없음

php의 큰 문제 중 하나는 선언 타입이 없다는 점이다. 선언 타입이 없다는 것은, 코드의 논리 전개에 따라 한 번 선언된 변수의 타입이 값의 변화에 따라 계속 변화한다는 것이다.

여타 정적 언어가 변수의 선언부의 타입만을 확인하면 어떤 타입을 사용하는지 알 수 있는 것과 달리 php는 사용하려는 변수의 타입을 확인하기 위해서는 선언된 부분뿐만 아니라 코드의 전개까지 확인해야 한다는 불편함이 있다.

## 변수 사용의 전제조건

기본적으로 변수에 값을 할당할 때는 하나의 타입 또는 null을 포함한 하나의 타입을 사용해야 한다. 만약 변수가 여러 타입을 가질 수 있다면, 각각의 타입에 맞는 분기 처리 로직이 필수적이고 로직이 복잡해진다.

## 코드의 전개에 따라 변수의 타입을 확인하기

### 무효한 값으로 빈 값을 사용할 때

무효한 값으로 null이 아닌 빈 값을 사용할 때는, 변수는 하나의 타입만을 가진다. 이 때 할당과 비할당의 여부는 빈 값인지 아닌지를 판별하는 것으로 확인할 수 있다.

php에서 빈 값은 직접 빈 값과의 비교를 통해 확인을 할 수 있다. `$var === 0`, `$var === []`, `$var === ''` 

`if ($var !== '')`이라는 코드는 변수가 하나의 타입을 갖고 있고, 조건이 true인 경우는 변수가 할당되었을 때의 로직을, false인 경우에는 변수가 할당되지 않았을 때의 로직으로 `$var`가 빈 값인 의미를 담고 있다.

### 무효한 값으로 null을 사용할 때

무효한 값으로 null을 사용할 때는, 유효한 값이라면 null이 아닌 특정한 타입만을 가진다.

`if (is_int($var))`이라는 코드는 `$var` 변수가 null 또는 정수 타입의 값을 가지고 있고, 조건이 true인 경우는 변수가 할당되었을 때의 로직을, false인 경우에는 변수가 할당되지 않았을 때의 로직으로 `$var`가 null이란 의미를 담고 있다.

## null의 암묵적 형변환

스트릭트 모드의 단점은 

```php
$var = null;

$addNull = 1+$var;

var_dump($addNull);

$xNull = 1*$var;

var_dump($xNull);
```

수 연산자와 null을 함께 연산을 하면 null은 0으로 자동 형 변환되어 계산된다.

## 스트릭트모드

php에서 스트릭트 모드는 함수의 인자와 반환 값에 대해 암묵적인 형 변환을 사용할 수 없도록 제약을 건다.

함수의 인자와 반환값에만 제한을 걸기 때문에 이외의 다른 자동 형 변환이 일어나는 쪽에서는 에러가 발생하지 않는다.

## 암묵적인 형변환

```php
$fn = function (string $a, string $b) {
    var_dump($a);
    var_dump($b);
};

$fn(1, 2);
```

문자열 타입힌트의 파라메터를 가진 함수에 수를 전달하였다. 함수 내부로 전달된 값을 확인해 보면 `'1'`, `'2'`으로 문자열 값이 출력된다.

수를 전달했는데 문자열로 받는 것을 알 수 있는데 특별히 형 변환하는 키워드를 사용하지 않았지만 다른 타입으로 값이 변환되는 기능이 암묵적인 형 변환이다.

```php
declare(strict_types=1);

$fn = function (string $a, string $b) {
    var_dump($a);
    var_dump($b);
};

$fn(1, 2);
```

php 파일의 선두에 `<php? declare(strict_types=1);`를 사용하는 것을 통해서 함수의 인자와 반환값의 타입이 변하지 않도록 만들 수 있다.

## References
- https://www.php.net/manual/en/language.types.declarations.php#language.types.declarations.strict
