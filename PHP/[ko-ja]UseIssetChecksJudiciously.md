## isset을 사용하는 올바른 방법
## issetだらけのコードはやめてください。

### 도입
### はじめに
- 상당히 많은 php 코드에서 `isset`을 남용하고 있다고 생각한다. 어떤 경우에 `isset`을 사용하고, `isset`을 왜 함부로 사용하면 안 되는지 그 이유를 알아보도록 하자.
- 非常に多くのphpコードで、`isset`を乱用していると思います。どのケースで`isset`を使用すべきか、`isset`をなぜむやみに使用してはならないのか、その理由を理解しましょう。
- 적절하지 않게 `isset`을 사용한 코드를 볼 때 마다 불편한 느낌이 있었고 이 이유를 명확히 밝혀 `isset`을 남발하는 코드의 사용을 최소화하기 위한 목적으로 작성하였다.
- `isset`が不適切に使用されたコードを見るたびに好ましくない感じがありました。この理由を明確にして`isset`を乱発するコードを最小化するためにこの記事を作成しました。

### 좋은 코드란 무엇인가?
### 良いコードは何か？
- 좋은 코드란 해석의 다양성을 줄이는 것이다. 해석할 수 있는 경우의 가짓수를 줄이는 것은 코드를 빠르고 명확하게 이해할 수 있도록 한다.
- 良いコードとは、解釈の幅を狭めることです。解釈できる場合の数を減らすことで、コードを迅速かつ明確に理解できます。
- 예를 들어 php에서 `const CONSTANT_VALUE = '불변값'`으로 코드를 사용하면 이 값은 고정된 값이고 변경할 수 없는 값이란 것을 알 수 있다. 변수와 달리 상수는 고정된 값으로 이 값이 처음 선언된 부분에서의 값과 다르다는 것을 생각할 필요가 없으므로 상수의 변경 과정을 추척하지 않아도 된다. 상수를 사용한 것은 값이 변경될 가능성을 줄이는 것으로 해석의 다양성을 줄이는 일이다.
- 例えば、phpで`const CONSTANT_VALUE = '不変値'`とコードを使用すると、この値は固定されており、変更できないことが分かります。変数とは異なり、定数は最初に宣言された時点の値と異なる可能性がないため、定数の変更過程を追跡する必要はありません。定数を使用することは、値の変更可能性の判断を減らすことで、解釈の多様性を減らすことです。
- 빠르고 명확하게 이해할 수 있는 코드를 만들기 위해서는 프로그래밍 언어에서 지원하는 문법을 잘 이해하여 가능한 적은 양상을 가질 수 있도록 코드를 작성하는 것이 필요하다.
- 迅速かつ明確に理解できるコードを作成するためには、プログラミング言語でサポートされている文法をよく理解し、できるだけ少ない様相を持つようにコードを作成する必要があります。

### isset 문법의 특징
### isset関数
- php에서 `isset`은 대상의 값이 정의되지 않은 경우 또는 값이 `null`인 경우를 판별하는 함수이다.
- phpの`isset`関数は、対象の値が定義されているかまたは`null`なのかを判別する関数です。
- 값이 정의되지 않거나, `null`인 경우에 `isset(대상)`은 `true`를 반환하고 그렇지 않으면 `false`를 반환한다.
- 値が定義されていない場合や`null`の場合、`isset(対象)`は`true`を返します。それとも`false`を返します。

### 정의되지 않은 변수를 확인하는 기능
### 定義されていない変数を確認する機能
- php에서 값이 정의되었는지 정의되지 않았는지 확인하는 수단으로는 `isset`, `??`, `??=` 기능이 존재한다. php에서 많은 기능과 함수가 존재하지만 대상이 정의된 값인지 정의되지 않은 값인지 확인하는 문법은 이들 3가지로 제한적이다.
- phpで値が定義されているか未定義なのかを確認する手段は、`isset`、`??`、`??=`の機能があります。phpで多くの機能と関数が存在しますが、対象が定義された値なのか未定義なのかを確認する文法はこれら3つに制限されます。
- 따라서 이들 정의되지 않은 대상을 파악하는 기능은 단순히 `null` 확인하는 용도으로 쓰는 것 보다는 값의 정의 유무를 판별할 때 사용하는 것으로 하고, 값의 `null` 여부를 판단하는 것은 `is_null(대상)`이나 `대상 === null`의 문법을 사용하는 것이 좋다.
- そのため、これらの未定義なのかを確認する機能を、単に`null`を確認する用途で使うのではなく、値の定義・未定義を判別するために使うことにして、値が`null`なのかを判断する際には`is_null(対象)`や`対象===null`の文法を使うことをお勧めします。
- 이런 코딩 스타일을 갖게 되면, `isset`을 사용했을 때는 변수의 정의을 확인하는 용도로 바라보게 되고, `is_null`이나 `=== null`을 사용했을 때는 변수의 타입이 `null`인지 확인하는 용도로 바라보게 되어 정의되지 않은 값인지 `null` 값인지 명확하게 이해할 수 있는 로직을 짤 수 있다.
- このようなコーディングスタイルを持つと、`isset`を使用した場合は変数の定義を確認する用途として考えるようになり、`is_null`や`===null`を使用した場合は変数のタイプが`null`なのかを確認する用途として考えるようになり、未定義の値なのかを明確に分かるロジックを組むことができます。

#### `??`, `??=`에 대해 알아보기
#### `??`, `??=`に関して説明
`??` : [Null coalescing operator](https://www.php.net/manual/en/language.operators.comparison.php#language.operators.comparison.coalesce)
- `변수 = 대상 ?? 기본값`의 문법은 `변수 = (fn() => isset(대상) ? 대상 : 기본값)();`의 문법과 동일하다.
- `??` : `変数 = 対象 ?? デフォルト値`の文法は、`変数 = (fn()=>isset(対象) ? 対象 : デフォルト値)();`の文法と同じです。

`??=` : [Null coalescing assignment operator](https://www.php.net/manual/en/migration74.new-features.php#migration74.new-features.core.null-coalescing-assignment-operator)
- `대상 ??= 기본값`의 문법은 `if(!isset(대상)) { 대상 = 기본값; }`의 문법과 동일하다. [Null coalescing assignment operator](https://www.php.net/manual/en/migration74.new-features.php#migration74.new-features.core.null-coalescing-assignment-operator)으로 불린다.
- `??=` : `対象 ??= デフォルト値`の文法は、`if(!isset(対象)) { 対象 = デフォルト値; }`の文法と同じです。

`isset`, `??`, `??=`는 값의 존재를 확인할 수 있는 특별한 기능
- 변수가 정의되어 있는 경우 `isset`은 `null`인지 확인하므로 `is_null`을 대신 사용할 수 있지만, `??`, `??=`는 축약된 문법이므로 대체할 수 있는 표현이 없다. 따라서 반드시 정의되지 않은 대상인지 확인하는데만 쓰는 것을 강제하지는 않으며 필요에 따라 값이 `null`인 경우에도 사용하는 경우도 있다고 본다. 하지만 php에서 정의되지 않은 변수를 확인하는 수단이 `isset`, `??`, `??=`의 3개로 제한되어 있기 때문에 가능한 이들 문법은 변수의 값이 정의되어 있을 때 사용되는 문법과 구분되게 사용하는 것을 권장한다.
- 変数が定義されている場合、`isset`は`null`か確認するので`is_null`を代わりに使用できますが、`??`, `??=`は縮約文法なので代わりに使える表現がありません。したがって、必ずしも定義されていないかどうかを確認する用途だけに使うことを強制するのではなく、必要に応じて値が `null`の場合にも使用する場合もあると思います。しかし、phpで未定義の変数を確認する手段が、 `isset`, `??`, `??=`の3つに制限されているため、可能な限りこれらの文法は変数の値が定義されているときに使用される文法と区別されるように使用することをお勧めします。

### 정의된 변수와 정의되지 않은 변수의 구분의 중요성
### 変数の定義と未定義の区別の重要性
- 정의되지 않은 대상은 php에서 값 자체가 없는 것으로 대부분의 php 함수나 문법은 값의 존재를 상정하고 동작을 수행하기 때문에 `isset`, `??`, `??=` 이외의 코드에서 에러가 발생하는 경우가 대부분이다.
- 未定義の変数は、phpで値が設定されていないものであり、ほとんどのphp関数や文法は値の存在を前提として動作するため、`isset`, `??`, `??=`以外のコードでエラーが発生する場合がほとんどです。
- 변수를 정의하지 않았기 때문에 php 코드의 많은 부분에서 이를 사용하기 위해서는 `isset`으로 변수의 존재 유무를 확인하고 코드를 짜야 한다.
- phpコードの多くの箇所で未定義の変数を使用するには、`isset`を使用して変数の存在を確認し、コードを構築する必要があります。
- 어떤 로직을 만들 때 로직의 흐름을 전개하는 것과 상관없는 문법적인 요소들이 서로 섞이는 것은 좋지 않다. 로직을 전개하기 전에 로직의 흐름과 관계 없는 것을 미리 처리하고 로직의 흐름만을 기술하는 편이 좋다.
- ロジックを作成する際、ロジックの流れとは関係のない文法的な要素が混ざるのは好ましくありません。ロジックを展開する前に、ロジックの流れに関係ない部分を事前に処理し、ロジックの流れだけを記述する方が良いです。
- 변수를 미리 정하지 않고 코드를 짜게 되면 중간 중간 `isset`이 들어가게 되면서 깔끔하지 못한 코드를 만들게 된다. 따라서 `isset`과 같은 정의되지 않은 변수를 확인하는 코드를 사용할 때는 다음과 같은 순서로 코드가 나열되는 형태를 갖는 것이 좋다.
- 変数を事前に定義せずにコードを組むと、途中で`isset`が入って、きれいなコードが作られません。そのため、`isset`などの未定義の変数を確認するコードを使用する場合は、コードが以下のような順序で記述されることをお勧めします。

#### 코드 작성의 순서
1. 변수를 선언할 때 변수의 기본 값을 지정한다. 변수가 여러 조건에 따라 값이 달라진다면 메소드나 함수 등의 반환 값으로 변수 값을 받도록 하자.
2. 혹시 변수에 값이 정의되지 않은 경우 'isset', '??', '??=' 의 문법을 사용하여 변수 값이 정해지지 않은 부분이 없는지 확인하고 디폴트 값을 할당한다.
3. 로직을 전개하는데 필요한 변수들이 다 모인 이후, 로직의 흐름을 나타내는 코드를 작성하도록 하자.

#### コード作成の手順
1. 変数を宣言する際、変数のデフォルト値を指定する。 変数の値が複数の条件によって変わる場合は、メソッドや関数などの戻り値を使用して変数の値を受け取るようにする。
2. 変数が値で初期化されていない場合は、 `isset`、`??`、`??=` の構文を使用して、変数が未定義であるかどうかを確認し、未定義の場合はデフォルト値を割り当てる。
3. ロジックを展開するのに必要な変数がすべて集まった後、ロジックの流れを表すコードを作成する。


- 만약 어떤 흐름의 로직의 결과에 따라 새로운 변수를 사용해서 그 다음 로직에 사용해야 하는 경우 다음과 같은 방식을 사용할 수 있다.
- もし、ある流れのロジックの結果によって新しい変数が必要になり、その次のロジックで新しい変数を追加して使用しなければならない場合、次のような手法でコードを作成します。

#### 코드 작성의 순서
1. 
    1. 변수를 선언할 때 변수의 기본 값을 지정한다. 변수가 여러 조건에 따라 값이 달라진다면 메소드나 함수 등의 반환 값으로 변수 값을 받도록 하자.
    2. 혹시 변수에 값이 정의되지 않은 경우 'isset', '??', '??=' 의 문법을 사용하여 변수 값이 정해지지 않은 부분이 없는지 확인하고 디폴트 값을 할당한다.
    3. 로직을 전개하는데 필요한 변수들이 다 모인 이후, 로직의 흐름을 나타내는 코드를 작성하도록 하자.
2. 
    1. 1단계의 로직의 결과에 따라 새로운 변수가 사용되는 경우 중간에 변수를 추가한다. 가능한 이 부분에서 정의되지 않은 변수가 생기지 않도록 한다.
    2. 2단계의 로직을 전개하는데 필요한 변수를 추가한 이후, 2단계 로직의 흐름을 나타내는 코드를 작성하도록 하자.
3. 2단계에서 로직이 끝나지 않고 새로운 변수가 추가되는 경우 3은 2단계의 반복이다.
4. 3단계에서 로직이 끝나지 않고 새로운 변수가 추가되는 경우 4은 3단계의 반복이다.
5. ...

#### コード作成の手順
1. 
    1. 変数を宣言する際、変数のデフォルト値を指定する。 変数の値が複数の条件によって変わる場合は、メソッドや関数などの戻り値を使用して変数の値を受け取るようにする。
    2. 変数が値で初期化されていない場合は、 `isset`、`??`、`??=` の構文を使用して、変数が未定義であるかどうかを確認し、未定義の場合はデフォルト値を割り当てる。
    3. ロジックを展開するのに必要な変数がすべて集まった後、ロジックの流れを表すコードを作成する。
2. 
    1. 1段階のロジックの結果によって新しい変数が導入される場合、途中で変数を追加する。できるだけこのプロセスで未定義の変数が生じないようにする。
    2. 2段階のロジックを展開するために必要な変数を追加した後、2段階ロジックの流れを表すコードを作成する。
3. 2段階でロジックが終わらずに新しい変数が追加される場合、3は2段階の繰り返しす。
4. 3段階でロジックが終わらずに新しい変数が追加される場合、4は3段階の繰り返しす。
5. ...

### 데이터 전달 프로토콜에 대한 이해 결여
### データ伝達プロトコルに対する理解欠如
- 여기서 데이터 전달 프로토콜이라고 하는 것은 어떤 핵심 로직을 전개하기에 앞서 미리 필요한 변수를 정의하는 것을 의미한다. 어떤 핵심 로직을 전개하기 위해 필요한 변수를 미리 만들어 둔 변수의 집합을 프로토콜이라고 하고 이를 핵심 로직에 전달하는 것을 데이터 전달이라고 하자.
- ここでデータ伝達プロトコルとは、あるコアロジックを展開する前に、必要な変数を事前に定義することを意味します。ある核心ロジックを展開するために必要な変数をあらかじめ用意しておいた変数の集合をプロトコルにして、これを核心ロジックに伝達することをデータ伝達とします。
- `isset`으로 로직을 짜면 값의 존재와 비존재를 확인하기 편리하다며 `isset` 위주로 사용하는 경우가 많다. 메인테넌스 할 때 값이 전달되는 프로토콜에 대한 이해 없이 그냥 `isset`을 사용해서 값이 있을 땐 처리하고 값이 없을 때 처리하지 않으면 되기 때문에 별다른 고민없이 코드를 짤 수 있기 때문이다.
- `isset`でロジックを組むと、値の存在と非存在を確認しやすいとして`isset`を中心に使用する場合が多いです。メンテナンスする時、値の伝達プロトコルに対する理解をしなく`isset`を使用して値がある時に処理し、値がない時に処理しないことで、特に悩みなくコードを組むことができるから`isset`を使用します。
- 하지만 변수의 값을 체크하고 이후 사용하기 위해 값을 할당하기 위한 용도가 아닌, 필요한 값이 전달되지 않았기 때문에 에러가 나서 `isset`으로 로직을 실행을 피하기 위한 방식으로 코드를 짜게되면 코드의 실행 과정에서 값의 전달이 명확한 프로토콜에 의해 일어나는 것이 아닌 중구난방으로 사용되는 코드를 짜게 되어 잘 정의된 로직을 만들기 보다 그냥 돌아가는 로직을 만들 가능성이 높아진다.
- しかし、変数の値をチェックし、その後ロジックで使用するために値を割り当てるための用途ではなく、必要な値が伝わらないからエラーが発生し、`isset`でコードの実行を回避するためにコードを組むと、コードの実行過程で値の伝達が明確なプロトコルによって行われるのではなく、かってにコードが使用されることになり、よく定義されたロジックを構築するよりも、単に動作するコードを作成する可能性が高くなります。
- 그저 동작하는 코드를 만들면 코드에 복잡한 조건이 추가될 때마다 더욱 흐름과는 동떨어진 로직을 만들게 되고, 전체적인 이해없이 코드를 개선하는 경험이 쌓이다 보니 곰돌이 무릅을 고무 망치로 쳤을 때 반대쪽 발이나 손이 올라가는 짤에 좋아요를 누르게 될 가능성이 높다.
- 単に動作するコードを作成すると、コードに複雑な条件が追加されるたびに、より流れとはかけ離れたロジックを作り、全体的な理解なしにコードを改善する経験が積まれるため、熊の膝をゴムハンマーで叩いた時、反対側の足や手が上がるGIFに「いいね」を押す可能性が高いです。

### 정의되지 않은 변수 사용시 에러를 나게 처리해야 하는 이유
### 未定義の変数を使用する際にエラーを発生させる必要性
- 코드를 작성할 때 에러를 처리하는 한 가지 방법은 기대하지 않았던 동작이 일어날 때 에러를 발생시켜서 에러가 발생한 로직을 보완하는 방식이다.
- コードを作成する際、エラーを処理する方法の一つは、予期していなかった動作が発生した場合にエラーを発生させてエラーが発生したロジックを補完する方法です。
- 미리 필요한 변수의 값을 모두 모은 다음 이들로 로직을 짜게 되면 필요한 변수가 전달되지 않은 경우 에러가 발생하게 되고, 프로그래머는 에러를 확인하고 정의되지 않은 변수가 왜 사용되고 있는지 데이터의 전달 프로토콜의 형태를 고민하는 과정을 통해 코드의 흐름을 좀 더 이해할 수 있게 된다. 이를 통해 명확한 데이터 전달의 흐름을 이해할 수 있어서 잘 정의되고 정돈된 코드를 만들 수 있다.
- あらかじめ必要な変数の値をすべて集めてから、これらを使用してロジックを組むと、必要な変数が伝わらない場合にエラーが発生し、プログラマーはエラーを確認し、未定義の変数がなぜ使用されたのか、データの伝達プロトコルの形を考える過程を通じてコードの流れをより理解することができます。これにより、明確なデータ伝達の流れを理解し、整頓された、よく定義されたコードを作成することができます。
- 특정 조건에서 변수가 정의되지 않은 채 전달된 경우 어떤 조건에서 변수가 정의되지 않았는지에 대한 고민 없이 `isset`으로 정의되지 않은 변수가 전달 될 때 로직을 실행하지 않는 방식으로 처리하면 더 이상 에러가 발생하지 않기 때문에 데이터 전달 프로토콜에 대한 고민의 기회를 잃어버리므로 이런식의 해결을 추천하지 않는다.
- 特定の条件で変数が定義されないまま伝達される場合、どのような条件で変数が定義されていないかについての悩みなく、`isset`を使用して変数が定義されていない場合にはロジックを実行しない方法で処理すると、もはやエラーが発生しないため、データ伝達プロトコルに対する悩みの機会が失われますので、このような解決策はお勧めしません。

### 할당과 비할당의 구분
### 割り当てと非割り当ての区別
- 할당과 비할당을 구분하기 위해서 일부러 변수를 정의하지 않는 경우가 있을지도 모른다. 변수가 정의되지 않으면 할당되지 않은 값이고, 변수가 정의되면 사용하면 되는 값이 되기 때문이다. 하지만 이러한 할당, 비할당을 표현하는데 굳이 `isset`을 사용할 필요가 없으며 `isset`을 대체할 수 있는 php 표현은 상당히 많다.
- 割り当てと非割り当てを区別するためにわざわざ変数を定義しない場合があるかもしれません。変数が定義されなければ割り当てられていない値であり、変数が定義されれば使用してもよい値になるからです。 しかし、このような割り当て非割り当ての状態を表現するのにあえて `isset`を使用する必要はなく、代わりに使えるphp表現はかなり多いです。
- 많은 경우 로직의 전개 과정에서 여러 타입에 대한 처리 보다는 하나의 타입에 대한 처리를 하는 기능이 많다. 또한 변수가 갖는 타입이 많아질수록 변수를 사용할 때 로직의 분기가 많아진다. 그래서 변수는 가능한 적은 종류의 타입을 갖는 것을 추천한다.
- 多くの場合、ロジックの展開過程で複数のタイプに対する処理よりも、1つのタイプに対する処理を行う機能が多いです。また、変数が持つタイプが多くなるほど、変数を使用する際にロジックの分岐が増えます。そのため、変数はできるだけ少ない種類のタイプを持つことをお勧めします。
- 하나의 타입만을 사용하더라도 할당 비할당의 상태를 표현할 수 있는 경우가 있는데 디폴트 값으로 빈 값을 이용하는 방법이다. 보통 문자열의 경우에는 빈 문자열 `""`과 비지 않은 문자열으로, 수의 경우에는 `0`과 `0`이 아닌 수로, 배열은 빈 배열`[]`과 비지 않은 배열 `[1,2,3]`으로 하나의 타입에서 빈 값과 비지 않은 값을 구분하는 방식을 사용하고 디폴트 값으로 빈 값을 할당하는 방식을 사용한다. php의 `empty`란 내장함수는 동일한 타입에서 빈 값을 체크해 주는 함수이고 이를 이용하여 `isset`을 대체할 수 있다.
- 1つのタイプだけを使用しても、割り当て・非割り当ての状態を表現できる場合があります。デフォルト値として空の値を利用する方法です。通常、文字列の場合は空の文字列`""`と空でない文字列で、数の場合は`0`と`0`でない数で、配列は空の配列`[]`と空でない配列`[1,2,3]`で、1つのタイプで空の値と空でない値を区分する方式を使用し、デフォルト値で空を割り当てる方式です。phpの`empty`内部関数は同じタイプの値で空の値をチェックする関数であり、これで`isset`を代替できます。
- 물론 할당된 값이 빈 값에 해당하는 값이어서 빈 값의 여부만으로는 디폴트 값인지 할당된 값인지 구분하지 못할 경우가 있다. 이 경우는 타입을 추가해서 `null`과 함께 사용한다. 또한 오브젝트 같은 경우는 빈 값을 정의하기 까다롭기 때문에 비어 있는지를 나타내기 위해서 `null` 타입을 추가해서 함께 사용할 수 있다.
- もちろん、割り当てられた値が空の値なので、空の値であるかどうかだけではデフォルト値なのか、割り当てられた値なのか区別できない場合があります。この場合は、タイプを追加して`null`と一緒に使用します。また、オブジェクトの場合は空の値を定義するのが難しいため、空かどうかを示すために`null`タイプを追加して一緒に使用することができます。
- 예를 들어 구매수량이라는 것은 0은 구매하지 않은 것이고, 0이 아닌 수라면 구매한 것에 해당하므로 하나의 타입으로 할당의 상태를 구분할 수 있지만, 가격은 0 또한 가격이 될 수 있으므로 하나의 타입으로 할당 여부를 구분할 수 없는 특성을 가진다.
- 例えば、購入数量というのは、0なら購入していないもので、0でない数なら購入したものです。そのため、1つのタイプで割り当ての状態を区分することができます。しかし、価格は0であることもありますし、価格がない場合もあります。そのため、価格は1つのタイプで割り当てるかどうかを区分できない特性を持っています。
- 로직을 전개하기 위해 필요한 모든 변수를 미리 정의하고 난 이후에는 해당 값에 어떤 타입의 값이 들어가 있는지 확인할 수 있는 기능은 많다.
- ロジックを展開するために必要なすべての変数をあらかじめ定義した後は、その値にどのタイプの値が入っているかを確認できる機能は多いです。
- is_​array, is_​bool, is_​callable, is_​countable, is_​double, is_​float, is_​int, is_​integer, is_​iterable, is_​long, is_​null, is_​numeric, is_​object, is_​real, is_​resource, is_​scalar, is_​string
- 이들 키워드는 `null` 타입과 병용하여 값이 준비 되었는지 준비되지 않았는지 확인할 수 있게 해 주며, 중간중간 변수의 타입을 알 수 있게 해 주기 때문에 타입 안정적인 코드를 짜는데 도움을 주기도 한다.
- これらのキーワードは、`null`タイプと併用して値が用意されているか否かを確認できるし、途中で変数のタイプを知ることができるため、タイプ安定的なコードを組むのに役立ちます。
- 어떤 변수의 디폴트 값을 먼저 선언하고자 한다면 각 타입의 빈 값 또는 `null`타입을 사용한 코드를 만들도록 하자.
- ある変数のデフォルト値を先に宣言したい場合は、各タイプの空の値または`null`タイプを使用したコードを作成しましょう。

### 예제 코드
### 例のコード
```php
class Conversation
{
    private readonly string $sayMessage;
    private readonly string $receiverName;

    public function setSayMessage(string $message): self
    {
        $this->sayMessage = $message;
        return $this;
    }

    public function setReceiverName(string $name): self
    {
        $this->receiverName = $name;
        return $this;
    }

    public function getConversation(): string
    {
        $this->fillUndefinedMember();
        $objectPhrase = empty($this->receiverName) ? "" : " to {$this->receiverName}";
        return "Jimmy said{$objectPhrase}, {$this->sayMessage}";
    }

    private function fillUndefinedOptionalMember(): void
    {
        $this->receiverName ??= "";
    }
}

echo (new Conversation)->setSayMessage("Nice to Meet You")->getConversation();
echo PHP_EOL;
echo (new Conversation)->setReceiverName("David")->setSayMessage("Nice to Meet You")->getConversation();
```
- `setReceiverName` 메소드와 `setSayMessage` 메소드를 사용하여 `undefined`인 멤버에 값을 정의해 주었다.
- `setReceiverName` メソッドと `setSayMessage` メソッドを使用して `undefined`のメンバーに値を定義しました。
- `setReceiverName` 메소드를 사용하지 않은 경우, `fillUndefinedMember` 메소드에 의해 빈 문자열이 `$receiverName`에 할당된다. 따라서 `setReceiverName`는 옵션인 메소드이다.
- `setReceiverName` メソッドを使用しない場合 `fillUndefinedMember` メソッドによって空の文字列が `$receiverName`に割り当てられます。 したがって、`setReceiverName`はオプションのメソッドです。
- `setSayMessage` 메소드를 사용하지 않은 경우, `fillUndefinedOptionalMember`에 의해 디폴트 값이 할당되지 않으므로 `$sayMessage`멤버를 사용할 때 에러가 발생한다. 이는 일부러 에러를 발생 시킨 것으로 `setSayMessage`는 필수 메소드이다.
-  `setSayMessage` メソッドを使用していない場合, `fillUndefinedOptionalMember`によってデフォルト値が割り当てられないため `$sayMessage`メンバーを使用する際にエラーが発生すします。 これはわざとエラーを発生させたものであり、`setSayMessage`は必須メソッドです。
- `private string $receiverName = "";`으로 처음 멤버 변수를 선언할 때 디폴트 값을 할당해도 되지만, `readonly`를 사용하는 경우에는 변수를 한 번만 할당할 수 있으므로 `setter`로 값을 받는 경우에는 디폴트 값을 멤버 선언과 동시에 할당하지 않았다.
- `private string $receiverName = "";`で最初にメンバー変数を宣言する際にデフォルト値を割り当ててもよいですが、`readonly`を使用する場合は変数を一度だけ割り当てることができます。そのため、`setter`で値を受け取る場合はデフォルト値をメンバー宣言と同時に割り当てませんでした。
- 이름이 전달되지 않는 경우는 빈 문자열이므로 `empty($this->receiverName)`로 이름이 할당되었는지 되지 않았는지를 `empty` 함수로 확인하였다.
- 名前が伝わらない場合は空の文字列であるため、`empty($this->receiverName)`として、名前が割り当てられているかどうかを`empty`関数で確認しました。
- 위 과정은 `setter` 메소드를 통해 1에 해당하는 '변수의 기본 값 지정' -> `fillUndefinedOptionalMember` 메소드를 사용하여 2에 해당하는 '정의되지 않은 경우 디폴트 값 지정' -> `getConversation`의 리턴값에서 3에 해당하는 '로직을 전개하는데 필요한 변수들이 다 모인 이후, 로직의 흐름을 나타내는 코드를 실행'의 단계로 나눠져 있다.
- 上記のプロセスは、`setter` メソッドを介して1に該当する「変数のデフォルト値指定」 → `fillUndefinedOptionalMember`メソッドを使用して、2に該当する「定義されていない場合、デフォルト値指定」 → `getConversation`のリターン値から3に該当する「ロジックを展開するのに必要な変数がすべて集まった後、ロジックの流れを表すコードを実行」の段階に分かれています。

### isset의 모호성
### issetの曖昧さ
- `isset()`의 괄호 안에는 값에 대한 접근으로 발생하는 에러 유형은 무시된다. 예를 들어 `$ten = 10; var_dump($ten[1]);`와 같은 코드를 실행할 때 `$ten[1]`가 `isset` 함수의 인자가 아니라면 수에 `[키]`로 접근한 표현이기 때문에 에러가 나지만, `isset` 함수의 인자로 `$ten = 100; var_dump(isset($ten[1]));`과 같은 방식으로 사용하면 값의 접근에 대한 에러이므로 에러가 발생하지 않고 `false`를 반환하게 된다. 이런 `isset`의 특성 때문에 `isset` 내부에 이상한 표현의 값이 들어가더라도 에러가 발생하지 않고 `false`를 반환하는 경우가 생긴다.
- `isset()`の括弧内には、値へのアクセスによるエラーは無視されます。例えば、`$ten = 10; var_dump($ten[1]);`のようなコードを実行すると、`$ten[1]`が`isset`関数の引数でない場合、数に`[キー]`でアクセスした表現でエラーが発生ます。一方、`isset`関数の引数として`$ten = 100; var_dump(isset($ten[1]));`のように使用すると、値のアクセスに関するエラーではなく、単に`false`が返ります。このような`isset`の特性のため、`isset`内部に変な表現の値が入ってもエラーが発生せず、単に`false`を返すことがあります。
- 어느 정도 모호한지 생각 해 보자. 배열의 특정 원소에 `isset`을 사용하는 경우 `isset(변수[키])`와 같은 형태가 된다. 그런데 이 형태는 변수가 존재하지 않다는 것인지, 변수가 배열이 아니기 때문에 접근할 수 없는 표현인지, 변수는 존재하는데 변수의 키에 할당된 값이 존재하지 않다는 것인지 구분할 수 없는 모호한 표현으로 이들은 모두 `false`를 반환한다. `true`라면 값이 존재하는 것이므로 사용할 수 있는 표현이지만 `false`인 경우에는 무엇이 잘못되었는지 이 표현만으로는 알 수 없고 값을 일일이 디버깅 해야 알 수 있다. 또한 배열의 값이 `null`이기 때문에 `false`를 반환한 것일 수도 있다. 앞서 `isset`을 값의 존재를 확인하는 용도로만 사용하기로 했으므로 이 경우는 이제 배제하고 생각을 해도 `isset`은 인자로 받는 값의 표현식이 조금이라도 복잡해지면 무엇이 잘못되어서 `false`를 반환한 것인지 알기 어렵다는 문제점이 있다.
- どの程度曖昧なのか考えてみましょう。 配列の特定の要素に`isset`を使用する場合、`isset(変数[キー])`の形になります。しかし、この形態は変数が存在しないか、変数が配列ではないためアクセスできないか、変数は存在するのに変数のキーに割り当てられた値が存在しないか、いずれの場合も単に `false` を返すため、区別が難しい曖昧な表現です。`true`の場合は値が存在するため`変数[キー]`は使用できる対象になりますが、`false`の場合は何が誤っているのかがこの表現だけでは分かりません。具体的な問題が分かるまでデバッグが必要です。また、配列の値が`null`であるためにも`false`を返される可能性も考えられます。先ほど`isset`を値の存在を確認する用途で使用することにしたので、この場合は排除して考えても`isset`は引数として受け取る値の表現式が少しでも複雑になると、何が間違って`false`を返したのか分かりにくいという問題があります。
- `isset`은 이러한 모호성을 가지고 있기 때문에 이런 단점을 해결할 수 있는 대체할 수 있는 보다 명확한 표현이 있다면 대체할 수 있는 기능을 사용하는 것이 좋다.
- `isset`のこのような曖昧さから、これを解決できる代替できるより明確な表現があれば、代わりにその機能を使用することをお勧めします。

#### 배열에서 모호성 해결
#### 配列の曖昧さを解決
- 배열의 경우 `isset`을 대체할 수 있는 표현이 있는데 `array_key_exists`란 표현이다. 이 함수의 사용 방법은 `array_key_exists(string|int $key, array $array): bool`인데 배열과 키를 받아 키의 배열에서 키의 존재를 확인하는 함수이다.
- 配列の場合、`isset`に代わる表現として、`array_key_exists`という関数があります。この関数の使用方法は、`array_key_exists(string|int $key, array $array): bool`です。この関数は、配列とキーを受け取り、そのキーが配列内に存在するかどうかを確認するものです。
- 첫 번째 인자로 문자열이나 정수가 아닌 경우에는 에러가 발생하고, 두 번째 인자로 배열이 아닐 경우에 에러가 발생하기 때문에 에러 없이 이 함수가 실행되면 배열에 키가 존재하는지 배열에 키가 존재하지 않는지 이외의 가능성이 없으므로 무엇이 문제인지 명확하게 알 수 있다.
- 最初の引数が文字列や整数でない場合はエラーが発生し、2番目の引数が配列でない場合もエラーが発生するため、エラーなしでこの関数を実行すると、配列にキーが存在するのか配列にキーが存在しないのか以外の様相がないので、何が問題なのか明確に分かります。
- php에서 배열은 원소의 값이 정의되어 있지 않으면 키도 존재하지 않는 구성을 갖고 있다. 키가 없으면 값이 없는 것이고, 키가 있다면 값이 뭐라도 있는 것이다. 따라서 배열에서 값의 존재가 아닌 특정 키가 존재하는 않는 것만으로도 `undefined`인지 아닌지를 구분할 수 있다.
- phpでは、配列が元素の値が定義されていない場合、そのキーも存在しない構造です。キーがなければ値がないのことで、キーがあれば値が何でもあることです。したがって、配列において値の存在ではなく、特定のキーが存在しないだけでも、「undefined」かどうかを区別できます。
- 따라서 배열에서 특정 원소의 값의 존재를 확인할 때는 `isset`을 사용하기 보다는 `array_key_exists` 쪽을 사용하도록 하자.
- 従って、配列内の特定の要素の値の存在を確認する際には、`isset`ではなく、`array_key_exists`を使用することをお勧めします。

#### 다차원 배열의 경우
#### 多次元配列の場合
- `array_key_exists`는 배열 안의 한 차원의 원소에 대해서만 적용할 수 있다. 여러 차원의 배열인 경우, `array_key_exists(n차원키, 배열[1차원키][2차원키][3차원키]...[n-1차원키])`의 형식이 될 것이다. `isset([1차원키][2차원키][3차원키]...[n차원키])`와 달리 `array_key_exists`는 n차원의 키에 접근하기 전에 `n-1` 차원키에 접근하지 못하면 에러가 나는 반면, `isset`은 접근하지 못하거나 n차원의 배열 값이 존재하지 않거나 `null`이면 `false`이고 값이 존재하면 `true`가 된다. 배열에 접근할 수 있는지는 무시해도 좋고 최종적으로 값의 존재만 확인하면 될 때는 접근하는 과정에서의 에러를 어느정도 무시할 수 있는 `isset`을 사용할 수 있는 반면, 접근할 수 없는 경우를 명확히 확인하고자 한다면 `array_key_exists`를 사용하면 된다.
- `array_key_exists`は配列中の一次元の元素に対してのみ適用できます。 多次元の配列の場合、`array_key_exists(n次元キー, 配列[1次元キー][2次元キー][3次元キー]···[n-1次元鍵]）`の形式になります。 `isset([1次元キー][2次元キー][3次元キー]···[n次元キー])` と異なり、`array_key_exists`は`n`次元のキーにアクセスする前に`n-1`次元キーにアクセスできないとエラーが発生します。`isset`はアクセスできないか、またはn次元の配列値が存在しないか、`null`であれば`false`で、値が存在すると`true`となります。配列にアクセスできるかどうかは無視してもいいですし、最終的に値の存在だけ確認すればよい時は、アクセスする過程でのエラーをある程度無視できる`isset`を使用でできます。一方、アクセスできない場合を明確に確認したい場合は`array_key_exists`を使用します。
- 외부에서 전달되는 데이터에 의해 어떤 형식의 배열이 만들어질지 알 수 없는 상황인 경우에 특정 값의 존재만 확인하고자 한다면 접근 과정에서의 에러를 어느 정도 무시할 수 있는 `isset`을 사용해도 된다고 생각한다. 하지만, 애플리케이션에서 프로그래머의 정의에 의해 생성되는 배열의 경우에는 잘못된 접근임에도 에러를 발생시키지 않을 수 있는 `isset` 대신에 `array_key_exists`를 사용함으로 값의 접근 과정에서 무엇이 잘못되었는지 더 쉽게 알 수 있기 때문에 더 명확한 코드를 만들 수 있다. 만약 `array_key_exists`가 아닌 `isset`을 꼭 사용해야 한다면 형태를 예측하기 어려운 배열을 만드는 것으로 자신이 만든 코드가 만들어내는 결과물에 대한 통제력이 부족한 것으로 코드를 잘못 짜고 있는지 고민을 해 보는 편이 좋다.
- 外部から伝達されるデータによって、どのような形式の配列が生成されるか分からない場合、特定の値の存在だけを確認したい場合は、アクセス過程でのエラーをある程度無視できる`isset`を使ってもよいと思います。ただし、アプリケーションでプログラマの定義によって生成される配列の場合は、誤ったアクセスであってもエラーを発生させない`isset`の代わりに、`array_key_exists`を使用することで、値の接近過程で何が間違っているのか、より分かりやすいから、もっと明確なコードを作成することができます。もし、`array_key_exists`ではなく`isset`を必ず使わなければならない場合は、形態を予測しにくい配列を作ることで、自分が書いたコードが生成する結果に対するコントロールが不足している可能性が高いため、コードを間違って組んでいるか悩んでみたほうがいいです。
- 다차원 배열도 마찬가지로 `isset` 보다는 `array_key_exists`를 사용하는 것을 권장한다. 하지만 때때로 프로그래머의 통제를 벗어난 영역에서 생성되는 배열이라 값의 배열의 구조와 형태에 대한 확신을 가질 수 없는 비교적 예외적인 경우에는 `isset`을 사용할 수도 있다.
- 多次元配列においても、`isset`よりは`array_key_exists`を使用することをお勧めします。 ただし、時にはプログラマーの統制以外の領域で生成される配列であるため、値の配列の構造と形態に対する確信が持てない比較的例外的な場合には`isset`を使用することもできます。

### 결론
### 結論

#### isset
- `isset`을 `null`을 확인하는데 쓰는 것이 아니라, 가능한 정의되지 않은 값을 확인하는 것 위주로 쓰도록 하자.
- `isset`を`null`を確認するのに使うのではなく、できる限り変数が定義されていないかどうかを確認すること中心に使うようにしましょう。
- `isset`을 사용할 때는 정의되지 않은 값을 확인하고 로직을 실행하지 않는 방식으로 사용하는 것이 아니라, 정의되지 않은 변수에 빠짐 없이 값이 할당되도록 확인 및 기본값을 설정하는 용도로 사용하자.
- `isset`を使用する際は、定義されていない変数を確認してロジックを実行しない方式で使用するのではなく、定義されていない変数に値が漏れないように確認およびデフォルト値を設定する用途で使用しましょう。
- 이렇게 `isset`을 사용하는 스타일을 갖게 되면, `isset`을 사용한 코드를 읽을 때 `null` 확인으로 해석하는 경우의 수를 줄여서 코드를 좀 더 빠르고 명확하게 이해할 수 있는 코드를 만들 수 있다.
- このように`isset`を使うスタイルを採用すると、`isset`を使ったコードを読む時、`null`を確認で解釈する場合の数を減らしてより速く明確に理解できるコードを作ることができます。

#### 할당과 비할당
#### 割り当てと非割り当
- 할당과 비할당을 구분할 때는 정의/미정의로 구분하는 것 보다는 빈 값 또는 `null`등의 기본값을 사용하도록 하자.
- 割り当てと非割り当てを分ける際は、定義・未定義で区切るのではなく、空の値またはまたNull等デフォルト値を使いましょう。

#### 배열
#### 配列
- 검증할 대상이 배열과 같이 값에 접근하는 형태가 조금이라도 복잡해진다면, 무엇이 문제인지 명확히 알 수 있는 `array_key_exists`와 같은 기능을 `isset`대신에 사용하자.
- 検証対象が配列のように値にアクセスする形が少しでも複雑になったら、何が問題なのか明確に分かる`array_key_exists`のような機能を`isset`の代わりに使いましょう。
