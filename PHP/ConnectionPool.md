## php에서의 커넥션 풀
- php에는 기본적으로 커넥션 풀링(connection pooling)이 존재하지 않는다. 커넥션풀 대신 '퍼스시트 커넥션'이란 개념이 존재한다.
- 커넥션풀은 연결을 한 번 맺으면 연결을 끊지 않고 계속적으로 유지하는 것이며, 지속성 연결은 연결이 잠시 끊어졌다고 해도 동일 연결원이면 연결에 관한 과정을 완전히 종료하지 않고 다음 연결 때 연결 인스턴스를 사용하는 것이다.
- 하나의 PHP 프로세스를 통해서 디비 연결을 끊지 않는 방식은 커넥션풀이 될 수 있다. 하지만 CGI 방식을 통한 PHP 방식은 하나의 리퀘스트가 끝나면 무조건 디비와의 연결이 끊어질 수 밖에 없는 구조이다.
- 퍼시스트 커넥션은 끊어져도 끊어지기 전의 연결을 데이터베이스 측에서 완전히 종료 작업으로 전환하지 않고 다음 연결이 필요할 때 기존 연결 인스턴스를 계속 쓰겠다는 의미이다.

## 커넥션 풀의 작동 원리
- 커넥션 풀링은 데이터베이스 측에서 설정한다. 서버측에서는 디비에 연결을 끊는다는 프로토콜을 전송하지 않는 방식으로 커넥션을 유지하는 것이 커넥션 풀이다.

## php 에서 퍼시스트 커넥션
- 퍼시스트 커넥션은 PHP의 자식 프로세스가 SQL 서버에 연결할 때, 페이지를 처리할 때마다가 아니라 전체 수명 동안 한 번만 연결되기 때문에 커넥션풀과 유사한 개념을 가지고 있다.
- 하지만 퍼시스트 연결(persistent connection)이 커넥션 풀링과 다른 점은 MySQL 서버 구성으로 활성화되면 MySQL은 요청된 클라이언트(php 스크립트)가 작업을 완료하고 종료된 후 데이터베이스는 연결을 열린 상태로 유지하고 유휴 상태가 된다는 점이다.
- 두 번째 요청에 동일한 자격 증명 데이터(동일한 사용자 이름, 동일한 비밀번호, 동일한 연결 매개변수, 동일한 데이터베이스 이름, 동일한 IP에서 온 것일 수도 있음, IP가 확실하지 않음)가 제공되면 MySQL은 이전 연결을 유휴 상태에서 활성 상태로 풀링한다.
- 동일 자격 증명에 대한 유휴상태 활성화는 MySQL이 연결을 위한 초기 스타트 시간을 절약하고 총 연결 수를 줄이는 데 도움이 된다.
- PHP 스크립트가 종료되는 코드 끝에는 커넥션을 계속 연결한다거나 끊는 옵션이 없기 때문에 연결 풀링 옵션은 MySQL 서버 측에서 활성화 해 줘야 한다.
- mysql_pconnect()는 스크립트 실행이 끝날 때 연결 닫기 요청 신호를 보내지 않도록 설정하는 코드이고 이를 통해 CGI 프로세스가 종료되더라도 연결을 끊지 않을 수 있다.

### 연결 오버헤드
- 커넥션을 끊었다가 다시 연결하는데 드는 리소스를 연결 오버헤드라고 한다.
- 통신 횟수가 많아지면, 데이터베이스는 연결을 새로 맺는데 드는 비용을 줄여서 쿼리 로직을 실행하는데 자원을 더 소비할 수 있도록 하는 것이 좋다.

### 통신 횟수가 적을 경우 연결 오버헤드를 줄이는 것이 유의미하지 않은 이유
- 통신 횟수가 적다면 데이터베이스의 자원을 연결을 맺는데 사용해도 된다. 물론 연결을 새로 맺는데 드는 시간이 필요하기 때문에 쿼리의 반응은 조금 느릴 수 있지만, 하나의 PHP 프로세스의 라이프사이클이 종료되기 전까지 맺은 연결을 끝내지 않는 방식을 일반적으로 사용하기 때문에 하나의 PHP 프로세스의 라이프사이클에서 요청 되는 전체 쿼리에 비해 연결 오버헤드는 그렇게 크지 않으며 속도를 획기적으로 높여 주지 않는다.

### PHP에서 연결을 끊지 않을 때의 단점
- PHP 프로세스의 라이프사이클이 종료될 때 까지 연결을 물고 있기 때문에 PHP 프로세스가 하나의 연결을 맺어 놓고 다른 통신 또는 CPU 인텐스한 작업에 치중하게 될 경우 데이터베이스와의 연결이 놀고 있게 된다.
- 데이터베이스 입장에서는 연결을 하나 사용하지만 연결을 통해 들어 오는 쿼리가 없기 때문에 비효율적인 사용을 하게 된다. 대부분의 언어에서 데이터베이스 연결을 사용할 때, 연결을 맺게 할 수도 있고 끊게 할 수도 있는 것은 이런 점 때문에 사용자가 상황에 맞게 커넥션을 맺고 끊고 하라는 의미라고 보여진다. 언어 내부에서의 처리 시간이 길어지면 연결을 끊고 언어 내부에서의 처리 시간이 길지 않으면 연결을 유지하는 방식 하지만 언어 내부에서 처리가 길어지는 시간과 연결 오버헤드에 드는 시간을 개발자 입장에서 비교하기가 쉽지 않기 때문에 이런 처리의 의미가 있을지 의문이다.
- PHP 코드 자체에 문제가 생겨 프로세스가 오랫동안 종료되지 않는 경우 하나의 커넥션을 잡아 먹고 많은 리퀘스트에 의해 이런 프로세스가 여러개가 생길 경우 커넥션이 빠르게 소진되는 문제점이 생길 수 있다.

### 커넥션풀의 단점
- 연결을 끊지 않고 계속 유지하기 때문에 연결이 맺어져 있는 동안은 다른 프로세스가 맺어져 있는 연결을 사용할 수 없다.
- 데이터베이스에 락이 걸린 상태일 경우 후속 처리가 무기한 차단될 수 있다. 테이블의 락이 걸린 채로 프로세스가 종료되면 프로세스 종료 시 실행할 코드를 등록할 수 있는 register_shutdown_function함수를 사용해서 락을 해제하는 방법을 사용할 수 있다.
- 후속 처리가 무기한 차단 되는 경우에는 httpd 서버 또는 데이터베이스 서버를 다시 시작해야 할 수 있다.

### 트렌젝션 처리
- 트랜잭션을 사용할 때 트랜잭션 블록이 완료 되기 전에 스크립트 실행이 종료되는 경우 해당 연결을 사용하는 다음 스크립트로 트랜잭션 블록도 넘어간다.
- php 프로세스가 종료되기 전에 트렌젝션을 종료할 수 있도록 설정하는 것이 중요하다.
- 예기치 못한 에러에 의해서 트렌젝션이 종료될 경우도 있기 때문에 php 프로세스가 실행될 때 rollback을 처리하는 코드를 쓰는 방법을 생각해 볼 수 있다. 공식 문서에서 추천하는 방법은 php 프로세스가 종료될 때 실행하는 코드를 정의할 수 있는 register_shutdown_function 함수를 사용해서 rollback을 등록하는 방법을 사용하는 방법을 추천한다. (register_shutdown_function : https://www.php.net/manual/en/function.register-shutdown-function.php)


## MySql 이 아닌 다른 디비에서의 퍼시스트 커넥션
- php는 트렌젝션을 처리할 수 있는 RDBMS에서 퍼시스트 커넥션을 지원하는 디비로 mysql, postgresql, mssql을 지원한다.

### 퍼시스트 커넥션이 비효율적인 경우

### Nginx에서의 퍼시스트 커넥션

## Reference
- https://stackoverflow.com/questions/39753/connection-pooling-in-php
- 지속성 연결이란? https://www.php.net/manual/en/features.persistent-connections.php
- Nginx에서 지속성 연결 https://stackoverflow.com/questions/43280573/whether-the-connection-between-php-fpm-and-nginx-by-fast-cgi-are-persistent-kee
- https://mita2db.hateblo.jp/entry/2020/08/02/162024#f-e0b377ff
- https://www.oracle.com/technical-resources/articles/coggeshall-persist.html

