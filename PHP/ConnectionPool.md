## php에서의 커넥션 풀
- php에는 기본적으로 커넥션 풀링(connection pooling)이 존재하지 않는다. 커넥션풀 대신 '퍼스시트 커넥션'이란 개념이 존재한다.
- 커넥션풀은 연결을 한 번 맺으면 연결을 끊지 않고 계속적으로 유지하는 것이며, 지속성 연결은 연결이 잠시 끊어졌다고 해도 동일 연결원이면 연결에 관한 과정을 완전히 종료하지 않고 다음 연결 때 기존의 연결 인스턴스를 사용하는 것이다.
- 하나의 PHP 프로세스를 통해서 디비 연결을 끊지 않는 방식은 커넥션풀이 될 수 있다. 하지만 CGI 방식을 통한 PHP 방식은 하나의 리퀘스트가 끝나면 무조건 디비와의 연결이 끊어질 수 밖에 없는 구조이다. 따라서 프로세스 쪽에서는 연결을 끊지만 디비 쪽에서는 연결에 관련된 절차나 정보를 완전히 종료하지 않는 퍼시스트 커넥션을 사용한다.
- 퍼시스트 커넥션은 끊어져도 끊어지기 전의 연결을 데이터베이스 측에서 완전히 종료 작업으로 전환하지 않고 다음 연결이 필요할 때 기존 연결 인스턴스를 계속 쓰겠다는 의미이다.

## 데이터베이스 연결이란?
- 데이터베이스에 연결이 된다는 의미는 데이터베이스 쪽에서 연결에 대한 처리를 하는 인스턴스가 생성되고, 프로그래밍 언어의 로직에서도 연결에 대한 처리를 하는 인스턴스가 생성되어 둘 사이의 정보교환이 일어날 때를 의미한다.
- PHP에서 프로세스가 종료되면, 프로그래밍 언어에서의 데이터베이스 연결에 대한 처리를 하는 인스턴스가 사라지게 되고 데이터베이스는 프로그래밍 언어쪽의 연결이 사라진 것을 감지하고 자동적으로 연결에 대한 인스턴스를 해제하는 방법을 사용한다.

## 데이터 베이스의 커넥션 갯수 제한
- 데이터베이스는 일정한 양의 커넥션 수의 제한을 두고 있다. 제한된 커넥션 수를 초과한 연결 시도는 할 수 없다. 따라서 제한된 수의 연결이 초과하는 경우 다른 프로세스가 연결을 맺을 수 없다.
- 예를 들어 데이터베이스가 제공할 수 있는 연결을 100이라고 할 때 150의 연결 요청이 들어오게 되면 50의 연결이 이뤄지지 않으므로 처리되지 않는다. 지속성 연결을 사용하지 않는 경우 다른 10개의 PHP 프로세스가 종료되면 100의 연결에서 10의 연결을 사용할 수 있게 되고 대기중인 50개의 연결에서 10개가 사용 가능하도록 바뀐다. PHP에서 디비에 연결할 수 없을 때 일정 시간동안 연결하려고 타임아웃 기간을 잡고 있기 때문에 타임아웃이 생기기 전에는 여러 번 연결을 시도하고 있고 디비에서 커넥션을 할 수 있는 여유가 생기면 디비 쪽으로 연결을 시도하던 프로세스가 연결을 획득하게 된다.

## 커넥션 풀의 작동 원리
- 커넥션 풀링은 데이터베이스 측에서 설정한다. 서버측에서는 디비에 연결을 끊는다는 프로토콜을 전송하지 않는 방식으로 커넥션을 유지하는 것이 커넥션 풀이다.
- 물론 데이터베이스 연결을 사용하는 프로그래밍 언어 로직에서도 디비에 연결할 커넥션을 만드는 비용이 들기는 하지만 프로그래밍 언어 쪽의 속도 차이가 유의미한 경우는 정말 대량의 요청을 빠른 레이턴시로 처리해야 하는 분야가 아니면 차이가 유의미한 경우는 드물다.
- 또한 서버의 스케일링은 비교적 쉽지만, 디비의 스케일링은 상대적으로 어렵고 한계가 생길 수도 있다. 이를 위해 디비측의 자원 사용을 최소화하는 전략이 필요하기 때문에 디비쪽의 연결 인스턴스를 재사용하는 것은 유의미하지만, 프로그래밍 언어 쪽의 연결 인스턴스를 재사용하는 것은 유의미하지 않은 경우가 많다.

## php 에서 퍼시스트 커넥션
- 퍼시스트 커넥션은 PHP의 자식 프로세스가 SQL 서버에 연결할 때, 페이지를 처리할 때마다가 아니라 전체 수명 동안 한 번만 연결되기 때문에 커넥션풀과 유사한 개념을 가지고 있다.
- 하지만 퍼시스트 연결(persistent connection)이 커넥션 풀링과 다른 점은 예를들어 MySQL 디비의 경우 서버 구성으로 활성화되면 MySQL은 요청된 클라이언트(php 스크립트)가 작업을 완료하고 종료되지만, 데이터베이스는 연결을 열린 상태로 유지하고 유휴 상태가 된다는 점이다.
- 데이터베이스로 유입되는 두 번째 요청에 동일한 자격 증명 데이터(동일한 사용자 이름, 동일한 비밀번호, 동일한 연결 매개변수, 동일한 데이터베이스 이름, 동일한 DNS(IP 같은 것들)로 부터 온)가 제공되면 MySQL은 이전 연결에 관한 정보를 갖고 있는 내부 인스턴스를 활용해서 유휴 상태에서 활성 상태로 풀링한다.
- 동일 자격 증명에 대한 유휴 상태 활성화는 MySQL이 연결을 위한 초기 스타트 시간을 절약하고 총 연결 수를 줄이는 데 도움이 된다.
- PHP 스크립트가 종료되는 코드 끝에는 커넥션을 계속 연결한다거나 끊는 옵션이 없기 때문에 연결 풀링 옵션은 MySQL 서버 측에서 활성화 해 줘야 한다.
- `mysql_pconnect()`는 스크립트 실행이 끝날 때 연결 닫기 요청 신호를 보내지 않도록 설정하는 코드이고 이를 통해 CGI 프로세스가 종료되더라도 연결을 끊지 않을 수 있다.

### 연결 오버헤드
- 커넥션을 끊었다가 다시 연결하는데 드는 리소스를 연결 오버헤드라고 한다.
- 통신 횟수가 많아지면, 데이터베이스는 연결을 새로 맺는데 드는 비용인 오버헤드를 줄여서 쿼리 로직을 실행하는데 자원을 더 소비할 수 있도록 하는 것이 좋다.

### 통신 횟수가 적을 경우 연결 오버헤드를 줄이는 것이 유의미하지 않은 이유
- 통신 횟수가 적다면 데이터베이스의 자원을 프로그래밍 언어의 로직과 디비의 커넥션을 맺는데 사용해도 된다. 물론 연결을 새로 맺는데 드는 시간이 필요하기 때문에 쿼리의 반응은 조금 느릴 수 있다. 하지만 하나의 PHP 프로세스에서 디비의 연결은 PHP프로세스의 라이프사이클이 종료되기 전까지 디비와 맺은 연결을 끊지 않는 방식으로 사용되는 것이 일반적이다. 하나의 PHP 프로세스의 라이프사이클에서 디비 연결을 끊고 다시 연결하고 끊고 다시 연결하지 않고 초기 연결 이후 커넥션을 끊지 않고 사용하는 경우가 대부분이므로 요청 되는 전체 쿼리에 비해 연결 오버헤드는 그렇게 크지 않으므로 속도를 획기적으로 높여 주지 않는다.

### PHP에서 연결을 끊지 않을 때의 단점
- PHP 프로세스의 라이프사이클이 종료될 때 까지 연결을 물고 있기 때문에 PHP 프로세스가 하나의 연결을 맺어 놓고 다른 통신 또는 CPU 인텐스한 작업에 치중하게 될 경우 데이터베이스와의 연결이 놀고 있게 된다.
- 데이터베이스 입장에서는 연결을 하나 사용하지만 연결을 통해 들어 오는 쿼리가 없기 때문에 비효율적인 사용을 하게 된다. 대부분의 언어에서 데이터베이스 연결을 사용할 때, 연결을 맺게 할 수도 있고 끊게 할 수도 있는 것은 이런 점 때문에 사용자가 상황에 맞게 커넥션을 맺고 끊고 하라는 의미라고 보여진다. 언어 로직에서 처리 시간이 길어지면 연결을 끊고 언어 내부에서의 처리 시간이 길지 않으면 연결을 유지하는 방식으로 사용하면 시스템 리소스를 효과적으로 사용할 수 있다. 물론 언어 내부에서 처리가 길어지는 시간과 연결 오버헤드에 드는 시간을 개발자 입장에서 비교하기가 쉽지 않기 때문에 이런 처리의 의미가 있을지 의문이다.
- PHP 코드 자체에 문제가 생겨 프로세스가 오랫동안 종료되지 않는 경우 하나의 커넥션을 잡아 먹고 많은 리퀘스트에 의해 이런 프로세스가 여러 개가 생길 경우 커넥션이 빠르게 소진되는 문제점이 생길 수 있다.

### 커넥션풀의 단점
- 연결을 끊지 않고 계속 유지하기 때문에 동일한 자격증명이 아니라면 기존 커넥션을 이용할 수 없게 된다. 애플리케이션 서버를 스케일링 할 때 서로 다른 서버에서 디비의 커넥션을 서로 획득하려고 시도할 것인데 서버 각각은 동일한 자격증명이 아니기 때문에 기존에 남아 있던 커넥션을 이용하지 못하게 되는 경우가 생긴다. 지속성 연결의 경우 기존 커넥션을 해지하지 않기 때문에 결국 각각의 서버에 할당된 커넥션만을 사용하기 때문에 다른 연결되어 있는 다른 커넥션이 한가하더라도 이용할 수 없는 비효율적인 부분이 생길 수 있다.
- 데이터베이스에 락이 걸린 상태일 경우 후속 처리가 무기한 차단될 수 있다. 테이블의 락이 걸린 채로 프로세스가 종료되면 프로세스 종료 시 실행할 코드를 등록할 수 있는 `register_shutdown_function` 함수를 사용해서 락을 해제하는 방법을 사용할 수 있다. 하지만 이 방식의 단점은 PHP가 언어 차원에서 대응할 수 없는 원인에 의해 종료되는 경우 `register_shutdown_function`가 실행되지 않는 문제가 발생할 수 있다.
- 후속 처리가 무기한 차단 되는 경우에는 httpd 서버 또는 데이터베이스 서버를 다시 시작해야 할 수 있다.

### 트렌젝션 처리
- 트랜잭션을 사용할 때 트랜잭션 블록이 완료 되기 전에 스크립트 실행이 종료되는 경우 해당 연결을 사용하는 다음 스크립트로 트랜잭션 블록도 넘어간다.
- php 프로세스가 종료되기 전에 트렌젝션을 종료할 수 있도록 설정하는 것이 중요하다.
- 예기치 못한 에러에 의해서 트렌젝션이 종료될 경우도 있기 때문에 php 프로세스가 실행될 때 rollback을 처리하는 코드를 쓰는 방법을 생각해 볼 수 있다. 공식 문서에서 추천하는 방법은 php 프로세스가 종료될 때 실행하는 코드를 정의할 수 있는 register_shutdown_function 함수를 사용해서 rollback을 등록하는 방법을 사용하는 방법을 추천한다. (register_shutdown_function : https://www.php.net/manual/en/function.register-shutdown-function.php)

## MySql 이 아닌 다른 디비에서의 퍼시스트 커넥션
- php는 트렌젝션을 처리할 수 있는 RDBMS에서 퍼시스트 커넥션을 지원하는 디비 연결을 위한 함수로 `ibase_pconnect()`, `odbc_pconnect()`, `oci_pconnect()`, `pfsockopen()`, and `pg_pconnect()`을 지원한다. 이들 기능은 퍼시스트 커넥션이 아닌 함수들과 동일한 방법으로 사용할 수 있도록 만들어져 있으며 언제든 퍼시스트 커넥션이 아닌 함수로 교체할 수 있다.

### 퍼시스트 커넥션이 비효율적인 경우

### Nginx에서의 퍼시스트 커넥션

## Reference
- https://stackoverflow.com/questions/39753/connection-pooling-in-php
- 지속성 연결이란? https://www.php.net/manual/en/features.persistent-connections.php
- Nginx에서 지속성 연결 https://stackoverflow.com/questions/43280573/whether-the-connection-between-php-fpm-and-nginx-by-fast-cgi-are-persistent-kee
- https://mita2db.hateblo.jp/entry/2020/08/02/162024#f-e0b377ff
- https://www.oracle.com/technical-resources/articles/coggeshall-persist.html

