### '값에 접근한다'라는 개념
- `객체->멤버`의 방식으로 멤버의 값에 접근할 수 있다.
- `배열['키']`의 방식으로 키에 할당된 값에 접근을 할 수 있다.
- `$변수` 또는 `상수` 나 `클래스::상수`의 방식으로 변수 또는 상수에 부여된 값에 접근할 수 있다.
- php에서 '값'은 변수에만 할당되는 것이 아니다. 값이 할당될 수 있는 다양한 대상이 존재하며 이러한 값에 접근하는 방식으로 사용되는 모든 유형을 '값에 접근한다'라고 표현하자.

### `undefined`란?
- `undefined`는 정의되지 않은 값이다.
- php에서는 접근할 수 있는 값에 어떤 값이든 할당이 되어야 하는데, `undefined`는 php 언어에서 키워드로 제공되지 않으므로 직접 값으로 할당할 수 없다. `undefined`는 초기화 되지 않은 값을 나타낸다.
- 일반적으로 값에 접근할 수 있는 대상을 초기화 할 때는 변수에 `null` 또는 각 타입의 빈 값(`0`, `''`, `[]`)을 대입한다.

### `undefined`의 특징
- `undefined`는 프로그래밍 언어에서 직접 값으로 다룰 수 있는 대상이 아니다. 초기화란 값에 접근할 수 있는 대상에 프로그래밍 언어에서 다룰 수 있는 어떤 값을 직접 할당을 한 것에 해당한다. 따라서 다룰 수 있는 값이 아닌 `undefined`으로 초기화 할 수 없다.
- 자바스크립트에서는 값에 접근할 수 있는 대상이지만 초기화가 되지 않았을 때 기본적으로 `undefined`가 할당이 된다. php의 `undefined`는 자바스크립트 처럼 값이 아니며 값이 존재하지 않는 것을 뜻한다.
- php에서는 값을 다루는 대상을 값에 접근할 수 있는 대상에 할당을 한다. `$변수 = 값을_다루는_대상`이며 값을 다루는 대상의 상태를 null으로 하고, boolean으로 하고, string으로 하고, object로 하는 방식이다.
- 하지만 `undefined`는 값을 다루는 대상 자체가 없는 것으로 변수에 값 자체가 할당이 되지 않은 것을 의미한다.

### `isset`으로 `undefined`의 판별
- php에서 정의되지 않은 값에 접근할 때는 에러가 발생하고 프로그램의 실행이 멈춘다. 이는 값에 접근을 할 때 '값을_다루는_대상'이 할당되지 않았기 때문에 값에 접근을 해서 '값을_다루는_대상'를 사용해야 하는데 사용할 수 있는 대상이 아니기 때문에 처리할 수 없으므로 에러를 발생시키는 것이다.
- 따라서 값에 직접 접근하지 않고 접근할 대상을 지정하는 것으로 접근할 때 '값을_다루는_대상'이 할당이 되어 있는지 확인할 필요가 있고 이것을 가능하게 해 주는 함수가 `isset`이라는 함수이다. 다른 함수는 '값을_다루는_대상'에 먼저 접근을 하여 판단을 하기 때문에 '값을_다루는_대상'조차 정의되지 않은 `undefined`의 경우 접근을 할 수 없으므로 에러가 발생한다.
- `isset`은 값에 직접 접근하지 않고 접근하려는 대상에 '값을_다루는_대상'이 할당되어 있는지를 체크하고 할당되지 않은 경우 `false`를 반환한다. 만약 할당되어 있다면 `null`인지 확인하고 `null`이면 `false`를 반환한다.

### 값의 할당과 값의 비할당을 구분
- 기본적으로 `undefined`는 php 언어에서 직접 할당 가능한 값이 아니기 때문에 값에 접근할 때 `undefined`이면 어떠한 초기화도 이뤄지지 않은 값임을 구분할 수 있다. 따라서 값의 할당과 비할당을 값의 `undefined` 여부를 통해서 구분할 수 있다.

### `null`과 `undefined`
- `null`은 직접 할당할 수 있는 값인 것에 반해 `undefined`는 직접 할당할 수 있는 값이 아니다. 따라서 변수의 초기화가 이뤄졌을 때 아직 값의 결정이 이뤄지지 않은 경우에는 `null`을 임시로 할당하는 방식으로 사용할 수 있고, 변수의 초기화조차 이뤄지지 않았을 때는 값을 다루는 대상이 존재하지 않는 것으로 `undefined`가 되어 있다.
- 값이 `null`의 경우는 값에 접근할 때 접근할 대상이 초기화 되고 요구되는 값이 아직 결정되지 않았다는 의미를 가지기도 하지만, 값이 결정된 이후에도 값이 `null`인 경우가 있을 수 있다.
- 예를 들어 데이터베이스의 값이 `null`이 될 수 있다. 데이터베이스의 값을 php 언어에 가져올 때 `null`인 상태로 가져올 수 있기 때문에 값의 초기값 뿐만 아니라 결정된 값으로 `null`이 사용될 수 있다. 따라서 `null`의 값만으로 초기화 상태의 값인지 결정된 값으로 사용된 값인지 구분하는 용도로 사용하기에는 적합하지 않다고 생각할 수도 있다. 하지만 `null`이란 처리할 데이터가 없다는 것이므로 값이 결정되지 않아서 처리하지 않는 것이나 값이 결정되었으나 처리할 데이터가 없어 처리하지 않는 것이나 동일하게 다뤄지는 경우가 많다. 따라서 `null`을 결정된 값인지 아닌지의 구분으로 판단하기 보다는 처리할 값인지 처리하지 않을 값인지의 구분으로 바라보는 것이 좋다.
- 그런데 `isset` 함수는 `undefined`와 `null` 모두 false로 판별하기 때문에, 만약 `null`으로 초기화 되거나 값이 할당이 되었을 경우가 있으므로 값에 접근할 때 값의 할당과 비할당을 구분할 수 없다. 따라서 타입이 `nullable`인 변수의 할당여부를 확인하기 위해서는 `isset`이 false이면서 대상이 null이 아닌 경우를 판단할 수 있는 `isset(대상) && 대상 !== null` 또는 `isset(대상) && !is_null(대상)` 또는 `isset(대상) && is_타입(대상)`의 방식을 사용한다. `is_타입`의 경우 변수에 타입이 정해져 있을 경우 해당 타입에 해당하는 `is_int`, `is_string`, `is_object` 등의 타입 일치 함수를 사용한다. php에 `undefined`의 경우만 확인할 수 있는 함수가 있으면 더 좋아 보이지만 없기 때문에 위와 같은 방법으로 사용할 수 없기 때문에 `null`을 확인할 때는 `isset`을 쓰고, `undefined`를 확인할 때는 `isset`을 쓰는 스타일을 사용하여, `isset`이면 `undefined`를 체크하는 용도로 사용했구나라고 생각해도 무방하도록 코드를 짜는 편이 좋다. 타입이 `nullable`이 아닌 경우에는 `isset(대상)`으로 할당과 비할당을 구분할 수 있기 때문에 `isset(대상) && null이_아님을_체크`의 방식을 사용할 필요가 없다.

### 타입과 값
- php에서는 클래스나 객체의 멤버 또는 함수의 파라메터에 타입을 지정하여 다른 타입의 값을 할당할 수 없게 만들 수 있다.
- 또한 하나의 타입 뿐만 아니라 여러 타입을 변수에 설정할 수도 있다. 보통 결정된 값은 하나의 타입을 갖는 것에 반해, 값이 결정되기 전의 초기화 상태의 값을 지정하기 위해 `?int`, `?string`, `?object`등 `null` 타입을 허용하고 초기 값으로 `null` 값을 할당하는 경우가 있다.
- 하지만 활용되는 타입이 하나인데 초기화를 위해서 `null`을 할당하는 것이 좋지 않다. 왜냐하면, 변수에 타입을 하나 더 혀용하는 순간 타입에 따라 연산 방식을 다르게 해 줘야 하기 때문이다. 예를 들어 `int|string` 타입인 경우 수의 경우 덧셈을 `$a + $b`와 같이 코드를 쓸 것이고, 문자열의 경우에는 `$a.$b`와 같이 코드를 쓰게 될 것이므로 연산의 방식이 달라진다. `?int`의 경우도 마찬가지로 `int`인 경우에는 수학 연산이 가능한 것에 반해 `null`이면 에러가 발생하므로 `nullable` 타입으로 만들 경우 `null`을 항상 체크해 주어야 한다는 번거로움이 생긴다.
- 타입 선언의 장점은 다른 타입이 들어가는 경우를 방지해서 상정한 타입 이외의 값으로 로직이 돌아가지 않도록 하는 것에 있다. 하지만 값이 여러 타입을 가지고 있다면 각 타입에 따라 로직이 다르게 돌아가도록 분기를 고려해야 하기 때문에 가능한 하나의 타입으로 만드는 것이 좋다.
- `null`을 사용한 초기값을 지정하기 위해서는 `nullable` 타입이 되도록 만들어 주어야 한다. 하지만 `nullable` 타입을 만드는 것은 타입을 하나 더 늘리는 것으로 로직의 분기를 더 만들게 되므로 `null`으로 초기화를 하지 않는 편이 더 나을 경우가 많다.
- 따라서 값을 초기화하는 방식으로 할당을 하기 보다는 비할당을 하고 로직을 전개하기 위해 값이 할당이 되었는지 `isset`과 같은 함수로 필요한 값이 다 갖추어졌는지 확인하는 편이 좋다.

### 변수의 초기화
- 기본적으로 변수를 선언할 때는 초기 값을 할당을 하게 되어 있다. 변수를 선언할 때 초기값을 할당하지 않는다면, 변수를 선언하고 사용할 수 없기 때문에 보통 초기값을 할당하는 방식으로 사용한다.
- 변수를 적고 아무 값도 할당하지 않는다면, 해당 값에 접근을 해도 아무런 값이 없어 `undefined`이며, 변수명을 미리 적지 않고 변수를 접근하면 변수가 생성이 되면서 

### 오브젝트에서 `undefined`
- 오브젝트에서 멤버 변수는 초기화 되지 않는 경우가 있다. 멤버의 초기화를 위해 null을 초기값으로 설정을 하는 경우가 있는데 `undefined` 초기화를 하지 않고 멤버 변수를 로직에 사용하기 전에 `isset`을 사용해서 값이 할당이 되었는지를 모두 체크하고 로직을 전개하는 편이 좋다.
- 오브젝트를 만들 때 생성자에 멤버를 초기화할 때 필요한 값을 전달하는 방법을 사용할 수도 있지만, 생성자 주입 등의 기술을 사용하면 생성자를 전달하는 시점과 별도로 멤버를 초기화 시켜야 할 필요가 있다. 이럴 경우 일반적으로 setter 메소드를 사용해서 멤버의 값을 초기화하는 방법을 사용한다.
- 오브젝트의 어떤 메소드를 실행하기 위해서는 필수적으로 할당되어야 할 멤버의 값이 필요할 수 있다. 메소드의 로직을 실행하기에 앞서 필요한 멤버의 값이 모두 제대로 할당이 되었는지를 체크하는 메소드를 만들고 검증을 통과하지 못한 경우에는 에러를 발생시키는 방법을 사용한다.
- 요구되는 멤버의 할당 여부를 확인하는 메소드에 `isset` 함수를 사용하여 변수의 할당 여부를 체크하여 오브젝트의 할당 여부를 체크한다.

### null coalescing operator
- php에서 널 병합 연산자라고 불리는 null coalescing operator는 `??`으로 표기되는 연산자이다. 이 연산자는 다른 연산자 `?->`의 nullsafe operator (php8.0)가 `null` 만을 확인하는 것과 달리 값의 존재여부인 `undefined`의 확인도 한다.
- php에서 `undefined`를 확인하는 기능은 `isset` 함수와 `??` 연산자 뿐이다. 이는 애초에 php에서 `undefined`가 php에서 다룰 수 있는 value의 형태가 아니기 때문이다. '값을_다루는_대상'이 할당조차 되지 않은 상태가 `undefined`이므로 할당여부도 확인하는 기능과 할당된 값이 어떤 값인지 확인하는 다른 여러 기능들과는 다른점이 있는 것이다.

#### `??` null coalescing operator (php 7.0)
```php
// Fetches the value of $_GET['user'] and returns 'nobody'
// if it does not exist.
$username = $_GET['user'] ?? 'nobody';
// This is equivalent to:
$username = isset($_GET['user']) ? $_GET['user'] : 'nobody';

// Coalescing can be chained: this will return the first
// defined value out of $_GET['user'], $_POST['user'], and
// 'nobody'.
$username = $_GET['user'] ?? $_POST['user'] ?? 'nobody';
```
- 위의 예제로 확인가능한 것은 `??` 연산자가 `undefined`도 확인할 수 있다는 점이다.
- 이는 접근하려는 대상에 값이 할당되지 않았을 때, default 값으로 가질 값을 설정하여 추후 연산에서 계속적인 `undefied`의 확인 없이 연산 로직을 수행할 수 있도록 하는 장점이 있다.
- php7.4에서 도입된 null coalesce assignment Operator 로 불리는 `??=`도 동일하게 접근하려는 값이 할당 여부를 확인 한 후, 접근하려는 할당 영역에 값이 정의되지 않은 경우 `??=` 연산자를 기준으로 우변의 값을 할당한다.

### 어떻게 다룰 것인가?
- 정의되어 있지 않은 경우 로직의 전개를 조기 종료하는 방식을 사용할 수 있다. `if(isset($age) === false) return;`
- 정의되어 있지 않은 경우 로직의 전개에 필요한 초기값을 할당하는 방식으로 로직의 할당 여부에 관계 없이 동작시키는 방법이 있다. `$amount ??= 0`
- 할당되지 않은 값에 `undefined` 확인 없이 접근할 경우, 초기화가 필요하다는 에러가 발생하므로 값의 할당을 확인 후 사용해야 하는 값의 할당 체크가 이뤄지지 않은 경우를 코드 개발 타이밍에 알 수 있다.
