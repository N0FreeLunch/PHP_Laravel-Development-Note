# 예측 가능한 관계

코드를 작성할 때 예측 가능한 관계성을 가지는 추상화를 하는 것이 중요하다.

## 사전 상태와 사후 상태

어떤 추상화된 코드가 실행되기 위해서는 사전에 필요한 상태가 있을 것이다. 함수 파라메터가 전달 받은 값, 동일 객체내의 멤버에 세팅된 값을 참조하는 것등 데이터베이스에서 가져온 값 등이 사전 상태가 된다. 사전 상태로 인해 추상화된 코드들이 실행되어 변경되는 변화를 사후 상태라고 할 수 있다. 함수의 반환된 값, 객체의 내부 멤버 값의 변화, 데이터 베이스나 레디스에 값의 변경과 저장 등이 사후 상태가 된다.

## 추상화

### 개념 단위의 추상화

사전 상태가 어떻게 세팅이 되면, 사후 상태는 어떻게 변화할 것이라는 것을 알 수 있도록 코드를 추상화하는 것이 중요하다. 프로그래밍에서 반복되는 코드는 추상화하라는 말을 하지만, 단순히 반복되니까 코드를 추상화한다고만 생각하는 것은 좋지않다. 반복이 된다고 추상화를 하게 되면 사용하려는 공통 코드가 생기는 특수한 맥락이 반복되는 부분에서만 사용할 수 있는 코드가 되며, 추상화 된 대상을 조합하는 로직을 만들 수 없게 된다. 복잡한 로직을 만들기 위해서는 생각할 수 있는 개념 단위들을 서로 조합해서 로직을 만들 수 있는데 단순 반복되는 코드를 줄이기 위해 추상화 된 코드는 한 단위의 개념으로 생각하기 어렵기 때문에 조합을 하기 위해 사용할 수 있는 적절한 단위가 되기 어려울 가능성이 높다.

코드를 만들 때는 추상화를 할 수 있는 개념적인 단위가 생긴다. 로직을 단순히 여러 작은 단계로 쪼개는 것이 중요한 것이 아니라 개념적인 단위로 나눌 수 있도록 해야 하는데 시스템의 도메인과 시스템의 코드에서 중요한 포인트가 되는 개념을 추출해야 한다. 다른 사람들이 추상화 된 코드를 보았을 때 단순히 공통적인 기능을 모아 두었구나 반복되는 코드라서 분리르 했구나가 아니라, 이 부분을 이렇게 따로 떼어낸 것이 시스템을 구성하고 이해하는데 중요한 포인트가 될 수 있는 것이구나라는 것을 느끼고 알 수 있도록 코드를 만들어야 한다. 이러한 코드를 접하고 개선하고 수정하는 작업을 통해서 프로젝트에 참가하는 개발자들이 개념화된 코드 뭉치를 통해서 시스템을 이해하도록 하는 것이 중요하다.

프로젝트라는 것은 여러 사람들의 협업으로 시스템을 만들어 나가는 과정인데, 사양서가 없으면 무엇이 중요하고, 무엇 필수적이며, 무엇을 목적으로 하는지 알 수 없도록 코드를 만드는 것 보다, 개념적인 추상화들을 통해서 코드를 개선하고 추가하고 변경하는 모든 과정에서 코드만 보고서도 어떤 목표와 의도를 가지고 추가, 개선, 변경해야 하는지 느끼고 깨달을 수 있도록 추상화를 하는 것이 중요하다. 그래서 개인적으로는 기존에 개념화 되지 않는 것을 개념화하고 추상화하고 설명할 수 있는 능력, 중요한 것과 중요하지 않은 부분을 어떻게 강약을 줄지를 판단하는 능력이 굉장히 중요하다고 생각한다. 이는 특히 글을 잘 쓰는 사람에게서 얻을 수 있는 역량이라서 글쓰기를 잘 하는 사람이 코드도 잘 짤 수 있다고 생각한다.

### 사후 상태의 예측

순수 함수의 경우 어떤 파라메터에 대해 어떤 리턴 값을 가지는 것인지 알 수 있도록 추상화를 한다. 일반적인 코드는 순수함수만을 사용하기는 어렵기 때문에 사전 상태를 통해서 사후 상태의 변화를 알 수 있도록 추상화를 하는 것이 중요하다. 그래야 추상화된 코드를 가져다 썼을 때 무슨일이 일어날지 알 수 있다.

### 적절한 명칭의 중요성

추상화된 코드는 사전 상태를 일관된 방식으로 사후 상태로 변경한다. 만약 특수한 케이스에 대해 다른 변환 방식을 갖는 경우 일관성에 위배되기 때문에 이런 케이스가 발생하는 추상화를 갖는 경우에는 클래스명, 함수명, 메소드명을 이런 변환을 알아챌 수 있도록 적절하게 부여주는 것이 좋다.

### 일관된 관계성과 테스트

테스트를 할 수 있는 코드는 어떤 환경이 고정되어 있는 상황에서 인풋과 아웃풋의 관계를 추론할 수 있도록 코드를 만드는 것이다. 일관된 상관 관계를 가져서 인풋에 대한 아웃풋을 추측할 수 있도록 만드는 것이 테스트하기 쉬운 코드이다. 이런 일관된 관계성을 가지는 코드에 함수의 시그니처만으로는 알 수 없는 특수한 변환을 수행하는 경우, 이런 특별한 케이스에 대응하는 테스트 케이스를 계속적으로 추가해야 하고, 테스트 케이스는 늘어난다.

함수형 프로그래밍이 테스트하기 쉽다는 것은 각각의 함수가 나타내는 시그니처에 따라 인풋에 따른 아우풋의 관계가 일정하며, 시그니처로 나타낼 수 없는 특수한 변환을 하지 않기 때문이다. 물론 도메인 단위의 기능을 만들 때는 특수한 변환을 수행하지만 로직의 흐름을 구성하는 각각의 단편 함수들이 인풋에 대한 아웃풋의 관계가 일관된다.

## 곱의 법칙

경우의 수를 헤아리는 단원의 수학에서 곱의 법칙이란 개념이 존재한다. A, B, C 라는 세 지점이 있고, A에서 B까지 가는데 2갈래의 길이 있고, B에서 C까지 가는데 3갈래의 길이 있다고 하자. 그럼 A에서 C까지 가는데는 몇 가지 방식의 길로 갈 수 있는가? 6가지 길로 갈 수 있다. A에서 B로 가는 관계에서 2가지 양상이 있고, B에서 C로 가는 관계에서 3가지 양상이 있다. 각각의 단위를 따로 보면 A->B는 2갈래의 케이스를 검증하면 되고, B->C는 3갈래의 케이스를 검증하면 되는데, A->C로 가는 케이스를 검증하려고 하면 6갈래의 케이스를 검증해야 한다.

테스트를 할 때 검증해야 할 케이스가 굉장히 많을 수 있다. 이런 경우는 개념을 분리해서 경우의 수를 줄일 수 있을지를 생각해 봐야 한다. A->C로 가기 위한 방식을 확인하기 보다는 개념을 나누어 A->B, B->C 각각에 대한 검증을 하는 것을 통해서 많은 검증의 케이스를 줄일 수 있다. 개념 단위를 나눌 때는 곱의 법칙이 이뤄질 수 있는 부분을 기준점으로 나누는 측면도 생각하는 것이 중요하다.
