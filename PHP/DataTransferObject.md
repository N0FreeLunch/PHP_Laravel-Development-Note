## DTO란 무엇인가?
- DTO는 data transfer object의 약자이다.
- 프로그래밍이란 컴퓨터를 이용해서 데이터의 변화를 진행시켜 나가는 과정이라고 할 수 있다. 결과를 유도하거나 어떤 기능을 만들기 위해 데이터를 변화시키는 것이 DTO이다.
- 데이터를 변화시키는 방식은 일반적으로 어떤 변수에 데이터를 담아서 변화시키는 과정이 있으며, 함수형 프로그래밍과 같이 변수에 데이터를 담아 변화시키지 않는 방식의 프로그래밍 방식도 존재한다.
- 이때, 어떠한 저장 기능을 가진 대상의 구조를 일관성 있게 유지하면서 데이터의 변화를 유도하기 위한 방식으로 DTO를 사용한다.

## DTO의 특징
- getter/setter로 구성되어 있다. getter만 존재하는 DTO도 있으며, getter/setter가 존재하는 DTO도 있으며, getter/setter 없이 멤버로만 구성된 DTO도 있다.
- getter만 존재하는 DTO는 정해진 구조의 저장 대상에서 한 번 저장된 데이터를 계속 가져다 쓰기 위해서 사용한다. setter가 없고 객체를 생성할 때 생성자를 통해서 데이터를 할당하므로 한 번 생성된 객체의 데이터 변경을 방지한다. 이런 DTO를 Value Object라고 부르며 Vo라고 부른다.
- getter와 setter가 함께 존재하는 DTO는 DTO라는 일관된 구조와 값의 범위 내에서의 데이터 저장 객체의 값 변화를 유도하기 위해서 사용한다.
- getter와 setter 없이 멤버로 구성된 DTO는 php에서 타입힌트가 도입되면서 사용해 볼 수 있게 되었는데, 타입힌트를 통해서 개별 멤버의 값의 범위를 어느 정도 제한할 수 있게 되었다. 그래서 setter를 사용할 때 저장되는 값의 범위를 제한하는 등의 로직을 넣는 것을 대신해서 php의 타입 힌트를 통해서 범위의 제한이 가능하기 때문에 getter/setter 없이 public 멤버로만 구성된 DTO를 구성한다. 물론 getter/setter를 사용하면 타입힌트가 제공하는 범위 보다 훨씬 엄격한 값의 범위 제한을 할 수 있지만, setter/getter를 정의하는 것은 시간을 요구하기 때문에 시간 대비 적당한 제한을 할 수 있는 타입힌트를 사용하는 멤버 변수로만 이뤄진 DTO를 사용하는 것이 좋다.
- DTO는 객체의 멤버를 사용하여 만들기 때문에 IDE의 자동완성을 통해 멤버에 접근하기 쉬운 구조를 제공한다.
- DTO에는 값의 타입과 유효범위를 정하는 것 이외의 비즈니스 로직을 넣지 않는다. 이는 데이터의 전달의 역할만 담당하게 하기 위해서이다. 그리고 가능한 값의 유효성을 검증하는 것은 DTO에 데이터를 담기 전에 또는 DTO의 값을 전달 받은 후의 로직에서 처리하면 DTO 자체에서 처리하는 것을 지양한다.

## PHP에서 DTO를 사용해야 하는 이유
- 스칼라 데이터를 담은 단일 변수를 통한 데이터 전달은 스칼라 값 하나만으로 데이터가 전달되기 때문에 관심사를 한 번에 모을 수 없는 단점이 있다. 관심사 별로 묶은 여러 값들을 하나로 묶는 방법으로 일반적으로 php에서 많이 사용하는 방법으로 연관 배열을 사용한다.
- 연관 배열을 통한 데이터 전달은 관심사를 한번에 모을 수 있고 연관 배열이 너무 유연하기 때문에 사용하기는 쉽지만, 코드의 실행 플로우의 전후 데이터 구조가 정해져 있지 않다보니 데이터 구조의 변화가 있는지 확인을 해야하는 불편함이 생긴다. 또한 연관 배열 내부에는 타입을 지정할 수 없기 때문에 타입의 변화가 생겨 코드의 실행 과정에서 타입 불일치로 문제가 발생할 가능성이 있다.
- 연관 배열을 대신해서 데이터를 담는 용도의 객체를 만들어 쓰는데 이 방식이 DTO로 알려진 방식이다. 하지만 DTO를 사용하는 것은 객체를 만들어 써야하고 제대로 쓰기 위해서는 생성자, setter, getter를 만들어써야 하기 때문에 지나친 보일러 플레이트를 만들어 낸다는 단점이 있다. 이런 단점에도 DTO를 사용하는 것을 추천하는데 그 이유는 작성 시간이 조금 늘어나도 프로그래밍의 안정성이 좋기 때문이다. 시간 대비 안정성이 좋아서 DTO를 사용하는 것을 추천한다.
- 객체지향에서 다른 객체로 데이터를 전달 할 때는 오브젝트의 메소드를 사용해서 전달한다. php에서 오브젝트의 메소드의 매개변수는 타입힌트를 가질 수 있다. 타입힌트를 통해서 특정 구조의 데이터 형식을 전달 받을 수 있기 때문에 데이터를 전달하려는 오브젝트와 데이터를 전달 받는 오브젝트 간의 형식적인 일치를 통해서 서로 분리된 두 객체 간의 데이터 전달 프로토콜을 명확하게 할 수 있다.
- DTO는 별도로 분리된 클래스 파일로 각각 네임스페이스를 갖는다. 네임스페이스를 통해서 메소드의 타입힌트로 DTO를 사용할 수 있고, 클래스 타입힌트를 통해서 명확하게 멤버의 타입과 이름이 고정된 대상에 접근할 수 있으므로 IDE의 자동완성을 통해서 DTO의 멤버를 접근하는 코드를 쉽게 작성할 수 있다.
- 또한 getter/setter를 생략한 타입힌트 제한 정도만을 거는 멤버 변수로만 이뤄진 DTO를 사용하여 어느 정도 구조적으로 탄탄하고, 코딩의 실수를 줄이고, 생산성도 나쁘지 않은 정도의 시간 대비 퀄리티가 좋은 코드를 작성할 수 있기 때문에 DTO를 사용한다.

## getter/setter가 필요한가?
- getter와 setter는 객체 내부의 변수 통제용으로 사용하는 것이며, 멤버 변수를 객체 밖으로 노출시키지 않는 이유는 변수가 외부에서 컨트롤 되는 상황을 막기 위해서이다. 아주 단순한 객체라고 하더라도 추후 외부의 출력과 입력에 로직이 추가될 가능성이 있기 때문에 가능한한 getter와 setter를 사용해서 객체를 만들도록 한다.
- 하지만 DTO의 경우 특별한 비즈니스 로직을 담지 않는다. 데이터 전달을 위해 할당할 수 있는 값의 형태와 범위를 제한하는 용도로 멤버 변수는 비공개로 하고 getter와 setter를 사용할 수 있지만 엄격한 값의 제한이 필요하지 않으며, 예상 외의 변수가 없으며 컨트롤이 가능한 범위 내에 있으며 단순 타입 제한 정도의 역할로서 객체를 사용할 수도 있다.
- getter와 setter는 멤버 변수의 값을 직접적으로 가져오고 정의하는 속성을 가진 메소드이다. 직접적인 멤버 변수의 수정은 다른 메소드의 동작을 통한 멤버 값의 통제를 벗어나게 만드는 문제점이 있다. 객체의 상태(멤버 변수)는 객체의 엑션에 의해 통제가 되어야 한다는 것을 의미한다.

### nested(anonymous) class
- php에서 클래스는 보통 하나의 파일에 하나만을 작성하는 것이 코딩 스타일로 정해진 원칙이다. 물론 php의 코드는 하나의 파일에 여러 클래스를 정의하고 사용할 수 있지만, 하나의 클래스를 네임스페이스를 활용하여 다른 php 파일에서 사용할 수 있도록 하기 위해서 하나의 파일에 하나의 클래스를 작성하는 것을 권장한다.
- 그런데 하나의 파일 내부에서 사용하는 용도라면 원칙이 하나의 파일에 하나의 클래스만 정의하는 것이지만, 외부에서 사용하지 않는다면 하나의 파일에 여러 클래스를 정의해도 되지 않을까 생각해 볼 수 있다.
- 네임스페이스로 노출되는 클래스는 외부에서 클래스를 사용하고 클래스가 가진 동작을 발동시킨다. 어차피 네임스페이스로 노출되지 않는 클래스의 경우에는 클래스를 여러개 쓰는 것이 아닌 익명 클래스를 사용하는 방식을 생각해 볼 수 있다.
- 익명 클래스는 말 그대로 클래스의 이름이 없는 것으로 클래스 없이 객체를 만들 수 있는 기능이다.
```php
class User
{
    protected $money;
    public function __construct()
    {
        $money = new class {
            public $account = 100000;
            public $cash = 5000;
            public $stock = 50000;
        }
    }
}
```
- 이렇게 nested class를 만들어서 사용하게 되면, 이는 이 클래스 내부에서 통제되는 용도로 주로 사용한다. 주로 선언된 클래스 내에서 다뤄지기 때문에 외부 요인에 의해 저장된 값에 예외 사항이 생길일이 거의 없을 때 사용한다.
- 하지만 클래스의 이름이 없기 때문에 타입힌트로 사용할 수 없다는 단점이 있다. 객체 멤버가 가진 값을 IDE의 자동완성으로 확인하기 위해서는 객체를 직접 생성해서 바로 사용해야 하는데, 다른 대상에게 이 객체를 넘겨주는 경우 멤버에 대한 자동완성 기능을 소실하는 경우가 생긴다. 그나마 타입 제한을 위해서 익명 클래스로 만든 객체를 전달하기 위해서는 object 타입힌트를 사용하게 되는데 객체 멤버에 대한 정보를 상실하게 되기 때문에 IDE의 자동완성을 기대할 수 없다는 문제가 있다.
- 이런 단점 때문에 익명 클래스는 정의 후에 바로 사용할 수 있는 코드에 사용하며, 익명 클래스의 구조를 바로바로 확인이 가능한 범위에서만 사용하도록 한다. 이 데이터 구조를 바로바로 정의된 코드의 확인을 하기 어려운 곳에 까지 전달하기 위해서는 이름이 있는 클래스를 사용하여 클래스 이름을 통해서 타입힌트로 사용해야 IDE의 타입힌트에서도 자동 완성으로 구조에 접근할 수 있다. 별도의 파일에 네임스페이스로 공개되어 있는 DTO 클래스를 만들어 사용하면 타입힌트로 사용할 수 있고 어느 맥락의 코드에서도 객체 내부의 멤버가 무엇인지 IDE는 자동완성 해 준다는 장점을 얻는다.
- 익명 클래스의 문제점이 드러났으므로 하나의 파일에 여러 클래스를 사용하는 경우를 생각해 보자. 타입힌트를 사용하기 위해서는 사용할 타입의 클래스가 먼저 선언 되어 있어야 하므로 클래스의 작성 순서가 중요하며, 다른 파일의 객체에 전달될 때는 하나의 클래스 이외의 다른 클래스는 네임스페이스로 전달되지 않으므로 다양한 파일의 다양한 코드 맥락에서 사용하기 위한 데이터 전달자의 역할을 충분한 역할을 할 수 없다는 문제점이 있다.

```php
class User
{
    public $money;
    public function __construct()
    {
        $money = new class {
            public int $account = 100000;
            public int $cash = 5000;
            public int $stock = 50000;
        }
    }
}
```
- php 7.4 부터는 멤버에 타입을 선언할 수 있기 때문에 간단한 구조와 타입이 제한된 저장소로서의 역할을 한다.
- 위의 구조는 객체 내에서 단순하게 만들 수 있는 데이터 전달 객체의 구조를 갖고 있다. 하지만 이름이 없기 때문에 타입힌트로 사용할 수 없고, IDE의 자동완성 기능의 적용도 제한적이다. 따라서 객체와 객체간의 데이터 전달, 레이어와 레이어 간의 데이터 전달에 사용되는 DTO의 역할을 충분히 한다고 볼 수 없으므로 이런식으로 사용하지는 않는다.
- 흔히 getter와 setter를 정의하는 데이터 전달 객체는 객체와 객체 간의 데이터 전달을 필요로 할 때, DTO를 독립적으로 정의하여 사용하는 것을 목적으로 한다. 독립적인 객체이기 때문에 다양한 문맥에서 사용될 수 있다. 다양한 문맥에서 사용되는 만큼 의도하지 않은 방식의 데이터의 전달이 이뤄질 수 있고 객체간의 데이터 전달 서로 다른 문맥 간의 데이터 전달로 DTO가 사용될 수 있기 때문에 getter/setter/타입힌트 등으로 오용을 통제하는 것도 생각해 볼만한다.


## 객체지향의 DTO와 함수형 프로그래밍의 모나드
- 함수형 프로그래밍에서는 모나드라는 개념이 있다. 쉽게 말해서 자연수와 자연수의 덧셈 연산의 결과는 항상 자연수이다. 연산의 결과가 자연수이기 때문에 결과를 가지고 자연수 연산을 해도 자연수이다. 어떤 연산에 대해 특정 범위(여기서는 자연수)에 관해 닫혀있다는 것이 중요한 개념인데, 덧셈에 대한 연산은 자연수에 대해 닫혀있다라고 수학에서는 표현한다.
- 함수형 프로그래밍에서 모나드는 객체지향 프로그래밍에서 DTO와 비슷한 개념을 가지고 있다. 데이터의 구조를 연산(함수형 프로그래밍에서는 함수를 사용한 전후) 전후에도 연산할 수 있도록 프로그래밍 플로우의 진행 전후에도 일정하게 유지시킨다는 점에서 비슷한 개념을 가진다.
- 이렇게 연산 구조를 일정하게 유지하는 것은 동일 데이터 구조를 가지고 있기 때문에 무언가를 적용할 때도 재사용할 수 있으며, 프로그래밍의 진행 플로우에서도 일정한 구조내에서 값이 변하며 일정 틀 안에서의 값의 변경이라는 점을 알 수 있다는 것 때문에 변화의 흐름을 추측하고 해석하기 쉽다는 장점이 있다.
- 함수형 프로그래밍에서 모나드를 사용하면 연산 전후의 데이터의 구조가 일치하고 동일한 데이터 구조를 통해 계속 함수를 재사용해서 결과값을 만들어 나갈 수 있다. 마찬가지로 객체지향에서도 DTO의 사용을 통해서 여러 객체에 대한 재사용을 할 수 있는 또는 하나의 도메인에 대해서 동일한 데이터 구조의 변화를 통해 데이터 변화의 플로우를 만들어 나갈 수 있다.
- 물론 DTO보다는 모나딕한 구조를 가지는 것이 재사용성에서 훨씬 압도적이기는 하지만 모나딕한 구조를 정의하는 것이 쉬운 것이 아니기 때문에 대부분 특정 타입 변수의 리스트 형식의 구조로 퉁친다. 이에 반해 DTO는 특정 관심사에 대한 데이터를 주제별로 정의하기가 쉽다는 장점이 있다.


## PHP에서 DTO를 사용하는 방법
### 직접 DTO 객체를 만드는 방법
- 연관 배열을 DTO로 만들어 주는 매퍼 라이브러리 또는 툴 코드를 작성한다.

### 라이브러리를 통한 DTO 객체 만들기
- spatie에서 나온 신뢰할 수 있는 DTO 라이브러리 [data-transfer-object](https://github.com/spatie/data-transfer-object)을 사용해 볼 수 있다.
- DTO 라이브러리는 연관 배열을 DTO 객체로 만들어 주는 기능을 제공하기 때문에 적은 코드로 DTO 객체를 만들어 쓸 수 있는 장점이 있다.
- PHP의 기본 문법을 사용하지 않고 라이브러리 의존적이라서 새로운 개념을 배워야한다는 압박감을 줄 수 있지만, DTO 개념을 PHP에서 사용하고자 한다면 필수적이며, 객체지향의 원리에 맞고 타입 제한이 되어 있는 데이터전달 객체를 사용한 프로그래밍을 하려면 굉장히 유용한 방법이다.
- PHP8 부터는 라이브러리에 의존하지 않고서도 DTO를 쉽게 작성할 수 있으므로 더 이상 DTO 라이브러리를 사용하는 이점은 없어졌다.

### DTO 메퍼를 사용하는 것을 추천하는 이유
- DTO 구조를 만들 때, 초기 값을 생성자에 할당하는 방식을 사용한다. 초기 값을 생성자에 할당하는 방식의 문제는 생성자의 인자 순서를 하나하나 확인을 해야 하는 것이다. 객체를 사용하는 입장에서 볼 때 생성자 할당은 어떤 멤버에 어떤 값을 할당하는지 알 수 없게 한다. 
- 그러면 setter를 통해서 값을 할당하면 되지 않느냐고 할 수 있지만 클래스를 사용한다는 통념상 생성자는 객체를 생성할 때 setter는 초기 할당 이후 멤버를 바꿀 때 사용한다. 이런 통념에 비춰봤을 때 setter를 사용한다는 것은 객체가 가진 상태를 변경한다는 것을 의미하며 값의 변경이 이뤄졌다는 의미를 가진다. 따라서 가능하면 상태 변경이 없는 객체의 경우 생성자를 통한 초기값 할당을 하는 방법을 권유한다.
- 이런 측면을 고려했을 때, 상태 변경이 없는 객체의 초기 할당을 위해 생성자를 사용해야 하고 생성자의 순서를 기억할 필요 없이 어떤 멤버에 할당할지 명확하게 하기 위하여 연관 배열을 DTO의 생성자에 넣는 방식의 사용을 하는 것이 좋다. 멤버와 할당값을 연관 배열의 키-벨류 형식으로 집어넣는 것이 DTO를 외부에서 인스턴스로 사용할 때 명확하고 알기 쉬운 방식이다. 이런 '연관 배열을 통한 멤버 할당방식을 매퍼 방식이라고 말한다.

## DTO의 구조
- DTO의 구조는 단순해야 한다.
- DTO는 데이터를 전달하는 목적으로 사용하기 때문에 비즈니스에 관한 로직을 처리를 하지 않는다.
- DTO에 들어 오는 데이터의 범위를 제한 하기 위해서 잘못된 값이 들어 올 경우, 에러를 발생 시키는 등의 로직을 처리할 수 있다.
```php
class BlogData
{
    /** @var string */
    private $title;
    
    /** @var Status */
    private $status;
    
    /** @var \DateTimeImmutable|null */
    private $publishedAt;
   
   /**
    * @param string $title 
    * @param Status $status 
    * @param \DateTimeImmutable|null $publishedAt 
    */
    public function __construct(
        $title,
        $status,
        $publishedAt = null
    ) {
        $this->title = $title;
        $this->status = $status;
        $this->publishedAt = $publishedAt;
    }
    
    /**
     * @return string 
     */
    public function getTitle()
    {
        return $this->title;    
    }
    
    /**
     * @return Status 
     */
    public function getStatus() 
    {
        return $this->status;    
    }
    
    /**
     * @return \DateTimeImmutable|null 
     */
    public function getPublishedAt() 
    {
        return $this->publishedAt;    
    }
}
```
- 객체 외부에서 사용할 수 없는 멤버 변수를 선언한다.
- 생성자를 통해 객체 생성 시 멤버 변수에 값을 할당한다.
- 각각의 멤버를 객체 외부에서 불러 올 수 있는 메소드를 작성한다.


### PHP 8.0에서의 DTO 구현
```php
class BlogData
{
    public function __construct(
        public string $title,
        public Status $status,
        public ?DateTimeImmutable $publishedAt = null,
    ) {}
}
```
- 클래스 내부에 멤버 변수를 따로 선언하지 않고, 생성자의 인자를 통해 멤버 변수를 생성할 수 있다.
- 멤버 메소드를 사용하지 않고 php 7~8 이후로 타입힌트로 어느 정도의 타입 제한을 가할 수 있기 때문에 데이터 검증 로직을 추가할 수 있는 setter나 getter 메소드를 생략하는 방식으로 DTO를 사용해 볼 수 있다. getter를 생략하여 간단히 DTO를 만들 수 있으므로 DTO를 만들 때의 보일러 플레이트로 인한 부담감을 많이 줄일 수 있게 되었다.
- php8 이후에는 생성자의 파라메터로 멤버를 선언할 수 있게 되었는데 이 문법의 도입으로 인해서 연관 배열을 스프레드 연산자로 생성자의 인자로 할당하면 연관 배열에 키에 매칭되는 멤버에 값이 할당되는 기능을 제공한다.
```php
new BlogData(...[
    "Status" => Status::published,
    "title" => "About Data Transfer Object",
    "publishedAt" => new DateTimeImmutable()
]);
```
- 생성자에 스프레드 연산자 `...`으로 할당된 연관 배열에서 연관 배열의 순서는 생성자의 파라메터가 정의된 순서와 다르다. 하지만, 생성자의 파라메터로 선언된 멤버 이름에 연관 배열의 키가 매핑이 되고 연관 배열의 값이 매핑된 멤버의 값으로 할당된다. 이러한 생성자 할당 방식으로 인해서 이전에는 DTO 라이브러리가 제공했던 연관 배열 할당 방식의 DTO를 PHP의 기본 문법으로 쉽게 구현할 수 있게 되어 DTO 라이브러리를 쓰는 이점이 사라졌다.


### PHP 8.1에서 VO(value object)의 구현
```
class BlogData
{
    public function __construct(
        public readonly string $title,
        public readonly Status $status,
        public readonly ?DateTimeImmutable $publishedAt = null,
    ) {}
}
```
- readonly는 아직 값이 할당되지 않았을 때만 값을 할당할 수 있으며 값이 하당 된 이후에는 멤버 변수 안에 들어 있는 값을 바꿀 수 없게 만든다. 따라서 멤버를 바꾸기 위한 setter를 사용할 수 없으며 멤버를 할당하기 위한 용도로맘 setter를 사용할 수 있다.
- 생성자에 readonly로 멤버를 선언하면 객체의 생성과 동시에 멤버의 값을 할당하거나 바꿀 수 없는 불변의 객체가 된다. 데이터의 변경이 없고 한 번 생성된 데이터 묶음을 전달할 때 유용하다.
- readonly로 선언된 멤버 변수에 객체가 담겨 있을 경우 객체를 가리키는 주소를 바꿀 수 없는 것이므로 다른 객체를 할당할 수 없다. 하지만 이미 할당된 객체의 내부를 변경할 수는 있다.
- 데이터 전달 객체의 멤버 값을 바꾸지 못하는 DTO를 Value Object라고 부른다. DTO가 데이터의 변경을 허용하는 방식인 것에 반해 VO는 데이터의 변경을 허용하지 않기 때문에 DTO와 분리해서 VO라는 명칭으로 별도로 분류하여 사용한다.

## 폴더구조
```
app
 |- Controllers
 |- Dto
 |- Models
 |- Vo
 |- Services
```
- 일반적인 MVC 또는 서비스 레이어가 들어간 프레임워크에서는 Dto와 Vo 폴더를 위와 같은 계층에 둔다.

```
app
 |- Domain1
     |- Controllers
     |- Dto
     |- Models
     |- Vo
     |- Services
 |- Domain2
     |- Controllers
     |- Dto
     |- Models
     |- Vo
     |- Services
 |- Domain3
     |- Controllers
     |- Dto
     |- Models
     |- Vo
     |- Services
```
- 도메인별로 나누는 구조를 가질 경우에는 각각의 도메인 하위에 Dto와 Vo 폴더를 배치한다.

## Reference
- https://library.gabia.com/contents/8488/
- https://medium.com/musinsa-tech/%EB%AA%A8%EB%8D%98-php%EC%97%90%EC%84%9C-%EB%B0%B0%EC%97%B4-%EB%8C%80%EC%8B%A0-dto-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-d9da20ea716e
- https://stitcher.io/blog/php-81-readonly-properties
- https://dev.to/scottshipp/avoid-getters-and-setters-whenever-possible-c8m
