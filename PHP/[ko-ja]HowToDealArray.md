## 도대체 php에서 배열을 어떻게 다뤄야 할까? (배열을 다루는 특별한 스킬 포함)
## 一体全体、PHPで配列をどう扱えばいいのか？（配列を扱うニッチなスキルを含む）

## 시작하기에 앞서
## はじめに

### php에서 배열의 특징
### phpの配列の特徴
- php에서는 배열이란 하나의 타입에 `[1,2,3,4,5]`와 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]`의 두 가지 방식을 사용할 수 있다. 첫 번째는 인덱싱 배열이고 두 번째는 연관 배열이라고 부른다.
- phpでは、配列とは一つのタイプで、`[1,2,3,4,5]`と`['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]`の二つの方式を使用できます。最初のはインデックス付き配列で、2番目は連想配列と呼ばれます。
- 정적 언어에서는 인덱싱 배열은 키가 존재하지 않는 대상이다. 메모리의 어떤 위치에 데이터를 일정 바이트 간격으로 순차적으로 읽게 된다. 어떤 인덱스의 값에 접근할 때 하나의 원소가 갖는 바이트 만큼 '인덱스 번호 x 하나의 원소가 차지하는 바이트 수'를 건너뛰는 방식으로 처리하기 때문에 굉장히 빠르다.
- 静的型付け言語では、インデックス付き配列はキーが存在しません。メモリ上の特定の位置にデータを一定のバイト間隔で順次に読み込みます。あるインデックスの値にアクセスする際には、1つの要素が持つバイト数分だけ「インデックス番号 x 1つの要素が占めるバイト数」を飛び越える方式で処理するため、非常に高速です。
- php에서의 인덱싱된 배열은 연관 배열과 내부 처리는 같은데 이는 `[1,2,3,4,5]`은 `[0 => 1, 1 => 2, 2 => 3, 3=> 4, 4 => 5]`와 동일하기 때문이다. 인덱싱 배열로 만들어도 어차피 php에서는 모두 연관배열로 처리한다.
- phpのインデクシング配列は連想配列と内部処理は同じように処理されます。というのは、`[1,2,3,4,5]`が`[0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5]`と同じであるためです。インデックス付き配列として作成しても、結局phpではすべて連想配列として処理されます。
- php의 배열은 인덱싱 배열이나 연관 배열이나 내부적으로는 해쉬테이블을 사용하여 처리 방식의 동일하므로 구분 없이 동일한 array 타입으로 다뤄진다.
- phpの配列はインデックス付き配列でも連想配列でも、内部的にはハッシュテーブルを使用して処理方式が同じであるため、区別なく同じ「array」タイプとして扱われます。

### 기능의 스펙 문제
### 機能のスペック問題
- 함수나 클래스를 정의하는 것은 스펙을 만드는 작업이다. 함수의 이름, 파라메터, 타입을 모두 포함하여 기능의 인터페이스를 나타내는 용어를 함수의 '서명'이라고 부른다. 함수의 서명으로 매개변수로 배열을 사용하게 되면, 배열 안의 어떤 값을 이용해야 할지 서명만 보고서는 알 수 없으며 내부의 구현을 확인해야 한다는 단점이 있다. 함수나 클래스의 캡슐화 된 서명만을 통해 가능한 해당 서명이 어떤 기능을 나타내는지 알 수 있어야 하며 배열을 전달한다면 어떤 구조의 배열을 받아야 할지 알아야 한다. 하지만, 배열 타입힌트의 파라메터로 인자를 받을 때는 배열으로 받을 수 있는 형태의 다양성으로 인해서 어떤 값을 받아야 할지 모호한 경우가 많다.
- 関数やクラスを定義するのは、仕様を作成する作業です。関数の名前、パラメーター、タイプをすべて含めて、機能のインターフェースを示す用語を関数の「シグネチャ(signature)」と呼びます。関数のシグネチャでパラメータとして配列を使用すると配列内のどの値を利用すべきかシグネチャだけでは分かりません。内部のコードを確認する必要があるという欠点があります。関数やクラスはカプセル化されたシグネチャだけを通じて、そのシグネチャがどのような機能を示しているのか分かるように作る必要があります。配列を渡すならどのような構造の配列を受け取るべきか知っておく必要があります。しかし、配列のタイプヒントのパラメータで引数を受け取る場合、配列で受け取ることができる形の多様性により、どの値を受け取るべきか曖昧なことが多いです。
- 복잡한 소프트웨어를 만들 수록 각 단위 기능의 테스트 가능성은 중요하다. 일반적으로 테스트가 가능하다는 것은 마치 순수함수와 같이 인풋에 대해 아웃풋을 가질 수 있어서 따로 떼어 내었을 때 인풋을 넣었을 때 아웃풋의 결과를 확인할 수 있는 것을 의미한다. 테스트 할 수 있는 기능은 어떤 역할을 할지 예상하기 쉽고, 예상대로 동작하는지를 확인하기 위한 테스트 코드를 작성하기 쉽다는 장점이 있다. 하지만 함수가 배열을 인풋으로 받을 때 배열의 어떤 형태를 인풋으로 받아야 할지 알 수 없기 때문에 함수의 동작을 확인할 때 모호한 경우가 있다.
- 複雑なソフトウェアを作るほど、各単位機能のテスト可能性は重要です。一般的にテストが可能であるということは、純粋関数のようにインプットに対してアウトプットを持つことができ、独立して取り出したときにインプットを入れるとアウトプットの結果を確認できることを意味します。テスト可能な機能はどのような役割を果たすか予測しやすく、予測どおりに動作するかどうかを確認するためのテストコードを作成しやすいという利点があります。しかし、関数が配列を入力として受け取るとき、どのような形の配列を入力として受け取るのかがわからないため、関数の動作を確認する際に曖昧な場合があります。
- 테스트하기 쉬운 코드가 되기 위해서는 함수나 클래스의 서명만으로 어떤 인풋을 넣었을 때 어떤 결과를 가져다 주는지 확인할 수 있어야 한다. 배열의 경우 구조의 형태가 다양해서 어떤 값을 넣어 주어야 할지 생각하기 어려운 경우가 많다. 결국 함수가 배열을 인자로 받는 경우 어떤 입력에 어떤 결과값을 갖는지 추측하기 어려운 경우가 많이 발생할 수 있고, 내부 구현을 꼭 확인헤야 하는 코드를 만들 가능성이 있다.
- テストしやすいコードにするためには、関数やクラスのシグネチャだけで、どんな入力を与えたときにどんな結果が得られるかを確認できる必要があります。配列の場合、その構造の形がいろいろあるため、どのような値を入れるべきか考えるのが難しいケースが多いです。結局、関数が配列を引数として受け取る場合、どの入力に対してどのような結果が得られるか予測しにくい場合が多く、内部のコードを確認しなければならないコードを作る可能性があります。
- 인풋에 대한 아웃풋이 명확한 스펙을 갖고 있다면 테스트 코드를 만들기 쉽고 해당 기능이 어떻게 동작하는지 확인하기 쉽다. 하지만 배열을 매개변수로 사용하게 되면, 어떤 구조의 배열을 전달해야 결과값을 확인할 수 있을지 기능의 스펙만을 보고는 알 수 없기 때문에 동작 확인 및 테스트하기 어려운 코드가 된다.
-　インプットに対するアウトプットが明確な仕様なら、テストコードを作成しやすく、機能がどのように動作するかを確認するのがしやすいです。しかし、配列をパラメータとして使用する場合、どのような構造の配列を渡すべきか機能の仕様だけではわからないため、動作確認及びテストしにくいコードになります。
- 함수에 전달된 배열을 내부에서 어떻게 처리를 할지, 어떤 값을 전달해야 해당 기능의 스펙에 맞는 동작을 만들어 낼 수 있을지를 확인하기 위해서 서명만 보고서는 충분하지 못하며 내부의 코드의 처리 과정을 확인해야 한다면, 값의 변화의 양상을 확인하기 위한 디버깅이 더 많이 필요해져 관리하기 어려운 코드가 된다. 프로그래밍에서 추상화는 내부의 로직을 확인하지 않더라도 어떤 기능인지 어느 정도 추론할 수 있도록 만드는 것인데, php의 배열을 함수의 파라메터로 받으면 함수나 메소드 서명만으로는 어떤 배열의 형태와 값을 전달해야 할지 알 수 없게 되는 문제점이 생긴다.
- 関数に渡された配列を内部でどのように処理するか、どのような値を渡せば機能の仕様に合う動作を作り出すのかを確認するためにシグネチャだけでは十分でなく、内部のコードの処理過程を確認する必要があるならば、値の変化の様相を確認するためのデバッグがより多く必要になり、管理が難しいコードになります。プログラミングにおいて抽象化は内部のロジックを確認しなくてもどのような機能かある程度推論できるようにすることですが、phpの配列を関数のパラメーターとして受け取ると、関数やメソッドのシグネチャだけではどのような形の配列を値で渡すべきかがわからなくなるという問題が生じます。

### 기사 작성의 목적
- 단순한 프로그램을 짜는 경우 그냥 모든 코드를 읽어도 되지만, 코드의 길이가 늘어나고, 프로젝트에 참여하는 인원이 늘어나고, 복잡한 로직을 처리해야 하고, 추상화를 도입하는 상황에서 모든 코드를 읽고 해석하는 것은 비효율적이다. 프로젝트를 관리하고 성장시키기 위해서는 코드가 명확하고 이해하기 쉬워야 하고, 테스트하기 쉬워야 하며, 재사용 하기 좋아야 한다. 많은 프로젝트에서 이를 위한 더 많은 룰을 도입하고 있다.
- 単純なプログラムを書く場合はすべてのコードを読んでも問題ありませんが、コードの長さが増え、プロジェクトに参加する人数が増え、複雑なロジックを処理する必要がある場合、抽象化を導入する場合、すべてのコードを読んで解釈することは非効率です。プロジェクトを管理し、成長させるためには、コードが明確で理解しやすく、テストしやすく、再利用しやすい必要があります。多くのプロジェクトではこれらを達成するためのさらに多くのルールを導入しています。
- 이를 위한 방법 중 하나로 함수의 서명만으로 함수의 기능을 추측할 수 있게 만들고 함수의 내부 코드를 몰라도 사용할 수 있도록 추상화 하는 것이다. 함수를 추상화 할 때 배열을 전달해야 한다면 어떻게 하면 함수가 요구하는 배열의 구조를 명확하게 표현할 수 있는지에 대해 여러가지 방법을 소개한다. 각각의 장단점이 있기 때문에 상황에 따라 적절한 솔루션을 채택하여 사용하길 바란다.
- これを達成する方法の一つは、関数のシグネチャだけで関数の機能を推測できるようにし、関数の内部コードを知らなくても使用できるように抽象化することです。関数を抽象化する際に配列を渡す必要がある場合、関数が要求する配列の構造を明確に表現する方法についていくつか紹介します。それぞれに長所と短所があるため、状況に応じて適切なソリューションを採用してください。

## 본론
## 本論

### 문자열 매개변수의 문제
### 文字列パラメータの問題
- 문자열 매개변수의 예를 생각 해 보자. 일반적인 코딩 스타일에서 문자열에 대해 어떤 일반적인 처리를 하는 것이 아니라, 어떤 식별자로 문자열을 사용하는 코딩 스타일은 좋게 여기지 않는 경우가 많다. 타입에 의해 제한되는 방식과 달리 문자열 매개 변수는 문자열에 오기가 발생한 경우 런타임에 에러를 감지하지 못할 수도 있고, IDE가 코딩의 실수를 알려주지 않는 경우도 있다. 컴파일 언어는 컴파일 타임의 타입 체크 또는 IDE의 사용하는 코드를 정의된 코드로 이동하는 기능 등을 사용해서 코딩의 실수를 줄이기 위해서 문자열 매개변수를 사용하는 것을 권장하지 않는 코딩 프렉티스가 존재한다.
- 文字列パラメーターの例を考えてみましょう。一般的なコーディングスタイルでは、文字列に対して何らかの一般的な処理をするのではなく、何らかの識別子として文字列を使用するコーディングスタイルは好まない場合が多いです。型によって制限される方式とは異なり、文字列パラメーターは文字列に誤りが発生した場合、ランタイムでエラーを検出できないことがあり、IDEがコーディングミスを通知しないこともあります。コンパイル言語は、コンパイル時のタイプチェックまたはIDEで使用するコードを定義されたコードに移動する機能などを使用して、コーディングミスを減らすために、文字列パラメーターの使用を推奨しないコーディングプラクティスが存在します。
- 무조건 문자열 매개변수를 사용하지 말라는 것은 아니다. 일반적인 문자열에 대한 처리를 하는 경우에는 문자열을 매개변수로 전달하는 것은 괜찮다. 하지만, 함수 내부에서 특정한 문자열에 대해서만 별도의 처리할 때 함수는 특정 문자열에 의존적인 처리를 가진다. 이런 경우 문자열은 어떤 상태를 구분하는 식별자의 역할을 하는데 이를 문자열로 처리하면 실수를 유발할 가능성을 높인다.
- 無条件に文字列パラメーターを使用しないというわけではありません。一般的な文字列に対する処理を行う場合には、文字列をパラメーターとして渡すのは問題ありません。しかし、関数内部で特定の文字列に対してのみ別途の処理をする際は、関数は特定の文字列に依存する処理を持ちます。このような場合、文字列は何らかの状態を区別する識別子の役割をしますが、それを文字列として処理するとミスを誘発する可能性が高まります。
- 식별자의 용도로 문자열을 사용하기 보다는 enum을 사용하거나 커스텀 클래스를 만들어 `new CutstomTeyp(문자열)`의 생성자로 문자열을 전달하고 `__invoke` 매직 메소드를 통해서 벨리데이션 된 문자열을 사용하는 방법을 사용하는 것을 추천한다. 문자열은 너무 다양한 값이 들어 올 수 있기 때문에 식별자로 문자열을 사용할 경우에는 런타임이나 IDE 등의 툴을 이용한 코딩의 실수를 방지하는 기능이 동작하지 않을 가능성이 높기 때문에 버그를 만들어 낼 가능성을 높인다. 이러한 스타일을 제약할 수 있도록 enum이나 커스텀 class를 만들어 타입힌트로 이들 타입을 사용하는 것을 추천한다.
- 識別子の用途に文字列を使用するのではなく、enumを使用したりカスタムクラスを作成して`new CustomType(文字列)`のコンストラクターに文字列を渡し、`__invoke`マジックメソッドを通じてバリデーションされた文字列を使用する方法をお勧めします。文字列は非常に多様な値になるため、識別子として文字列を使用する場合、ランタイムやIDEなどのツールを使用したコーディングミス防止機能が動作しない可能性が高く、バグを発生させる可能性が高まります。このようなスタイルを制約するために、enumやカスタムクラスを作成し、タイプヒントとしてこれらのタイプを使用することをお勧めします。
- enum의 경우는 `enum Gender: string { case Man = 'man'; case Woman = 'woman'; }` `$canPregnant = function(Gender $gender): bool { ... }`의 예를 생각해 보자. 문자열 파라메터로 `'man'` `'woman'`을 전달하도록 만들면 `$canPregnant = function(string $gender): bool { ... }`의 `string $gender` 파라메터로 `'man'` `'woman'`을 전달해야 할지, `'m'` `'w'`을 전달해야 할지, `'male'` `'femail'`을 전달해야 할지, `'m'`, `'f'`를 전달해야 할지 함수의 내부 구현을 확인하지 않으면 알 수가 없다. 이에 반해 enum을 사용하면 함수가 어떤 파라메터를 사용하는지 명확한 스펙을 알 수 있다.
- enumの例として、`enum Gender: string { case Man = 'man'; case Woman = 'woman'; }` `$canPregnant = function(Gender $gender): bool { ... }`を考えてみましょう。文字列パラメーターで`'man'`や`'woman'`を渡す場合、`$canPregnant = function(string $gender): bool { ... }`の`string $gender`パラメーターに`'man'`や`'woman'`を渡すべきか、`'m'`や`'w'`を渡すべきか、`'male'`や`'female'`を渡すべきか、`'m'`や`'f'`を渡すべきか、関数の内部実装を確認しなければわかりません。それに対して、enumを使用すれば関数がどのパラメーターを使用するのか明確な仕様を知ることができます。
- 문자열이 너무 다양한 값이 될 수 있으므로 때문에 어떤 기능의 스펙을 정하기 위해서 enum이나 커스텀 class를 만들어 타입힌트로 사용하는 것과 마찬가지로 배열 또한 단위 기능의 스펙상의 제약을 걸기 위해 타입힌트를 사용하는 방법을 생각하는 편이 좋다.
- 文字列が非常に多様な値になれるので、機能の仕様を定義するためにenumやカスタムクラスを作成してタイプヒントとして使用するのと同様に、配列も機能の仕様上の制約を設けるためにタイプヒントを使用する方法を考えるのが良いでしょう。

#### 커스텀 타입의 예시
#### カスタムタイプ例

```php
class StrYmType
{
    private string $yyyymm;

    public function __construct(string $yyyymm) {
        $year = intval(substr($yyyymm, 0, 4));
        $month = intval(substr($yyyymm, 4, 2));

        if (strlen($yyyymm) === 6 && checkdate($month, 1, $year)) {
            $this->yyyymm = $yyyymm;
        } else {
            throw new Error('invalid Ym');
        }
    }
    
    public function __invoke(): string
    {
    	return $this->yyyymm;
    }
}

$fn = function (StrYmType $yearMonth) {
    echo 'result: '.$yearMonth().PHP_EOL;
};

$fn(new StrYmType('202406')); // result: 202406
$fn(new StrYmType('2024-06')); // Uncaught Error: invalid Ym
```
- 위의 코드는 YYYYMM 형식의 문자열인지 확인하는 클래스를 만들어 함수 `$fn`의 매개변수 타입힌트로 사용하였다.
- 上記のコードは、YYYYMM形式の文字列かどうかを確認するクラスを作成し、関数`$fn`のパラメータのタイプヒントとして使用しています。
- 타입힌트를 통하여 특수한 문자열만을 받을 수 있는 커스텀 타입을 만들어 전달되는 값의 유형을 제한할 수 있다.
- タイプヒントを通じて、特定の文字列のみを受け取ることができるカスタムタイプを作成し、渡される値の種類を制限することができます。
- 입력 값의 유형과 반환 값의 유형이 다르기 때문에 정확히는 타입이라 부를 수 없고, 타입 어셜션을 위한 타입정도로 부를 수 있을 것 같다.
- 入力値の型と戻り値の型が異なるため、厳密には型と呼べなく、型アサーションのための型と呼べると思います。

```php
class StrYmType
{
    private function __construct(private readonly string $yyyymm) {}

    public static function new(string $yyyymm): self
    {
        $year = intval(substr($yyyymm, 0, 4));
        $month = intval(substr($yyyymm, 4, 2));

        if (strlen($yyyymm) === 6 && checkdate($month, 1, $year)) {
            $new = new self($year.$month);
        } else {
            throw new Error('invalid Ym');
        }
        
        return $new;
    }
    
    public function get(): string
    {
    	return $this->yyyymm;
    }
}

$fn = function (StrYmType $yearMonth) {
    echo 'result: '.$yearMonth->get().PHP_EOL;
};

$fn(StrYmType::new('202406')); // result: 202406
$fn(StrYmType::new('2024-06')); // Uncaught Error: invalid Ym
```

- `__invoke` 또는 `new StrYmType` 등의 코드 사용에 거부감을 느낀다면 위와 같은 느낌의 코드를 만들 수도 있다.
- `__invoke`や`new StrYmType`といったコードの使用に違和感を覚える場合は、上記のようなコードを作成することもできます。

### 일반적인 배열 처리
### 一般的な配列処理
- php의 배열도 문자열과 마찬가지 문제를 갖는다. 배열은 형태와 구조 다양하기 때문에 어떤 구조의 배열을 전달해야 할지 알 수 없다는 문제가 있다. 문자열이 식별자로 사용될 경우 어떤 문자열이 기능 내부의 특별한 처리 케이스를 갖는지 확인해야 하듯이 배열도 어떤 구조의 배열을 전달해야 사용하려는 기능에서 원하는 결과를 얻을 수 있는지는 내부 구현을 확인하지 않고는 알 수 없는 문제가 있다.
- phpの配列も文字列と同じような問題を抱えています。配列の形と構造が多様なので、どの構造の配列を引数として渡せばよいかがわからないという問題があります。文字列が識別子として使用される場合、どの文字列が機能内部の特別な処理ケースを持つか確認する必要があるように、配列もどの構造の配列を渡せば使用しようとしている機能で望む結果を得られるかは、内部コードを確認しなければわからない問題があります。
- 배열을 매개변수로 사용하는 기능이 있다면 배열의 구조에 관계 없이, 모든 배열의 구성에 대해 동작하는 스펙을 만드는 것이 좋다. 특정 배열의 구조에 의존하는 것이 아닌 배열의 모든 데이터를 순회하는 방식의 처리를 하는 기능으로 만든다. 또한 특정한 키에 의존하는 기능 또는 특정한 키의 값에 대한 특수한 처리를 한다면 어떤 키에 어떤 처리를 하는지 알 수 없기 때문에 내부의 코드 동작의 특수 처리를 하는 부분을 확인하지 않는 이상 기능의 동작의 결과를 추측하기 어렵게 된다.
- 配列をパラメーターとして使用する機能がある場合、配列の構造に関係なく、すべての配列の構成に対して動作する仕様を作るのが良いです。特定の配列の構造に依存するのではなく、配列のすべてのデータを巡回する方式の処理を行う機能で作ります。また、特定のキーに依存する機能や特定のキーの値に対する特別な処理を行う場合、どのキーにどの処理を行うかがわからないため、内部のコード動作の特別な処理を確認しない限り、機能の動作結果を予測するのが難しくなります。
- 만약 배열의 특정한 키나 특정한 값에 대한 처리를 하는 것이라면 특정한 키를 지정하여 처리할 수 있도록 `$key`, `$needle`과 같은 매개 변수를 갖는 함수를 만들어 처리하도록 하며, 기능의 스펙(함수의 이름, 파라메터명과 타입, 반환타입 등)으로 내부의 특수한 처리를 명확히 드러내도록 정의할 필요가 있다.
- もし配列の特定のキーや特定の値に対する処理を行うことなら、特定のキーを指定して処理できるように`$key`や`$needle`のようなパラメーターの関数を作成し、機能の仕様（関数の名前、パラメーター名・タイプ、戻り値など）で内部の特別な処理を明確に示すように定義する必要があります。

```php
$add10 = function (array $arr): array {
    array_walk($arr, function (int $value, string $key) use (&$arr) {
        $arr[$key] = $arr[$key] + 10;
    });
    return $arr;
};

var_dump($add10(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]));
```
- 배열의 모든 원소에 10을 더하는 위와 같은 함수가 있다고 하자. 그런데 어떤 요구사항이 추가가 되어 b 키에는 20을 더해야 하는 상황이 생겼다.
- 配列のすべての要素に10を加える上記のような関数があるとしましょう。しかし、ある要件が追加され、bキーには20を加えなければならない状況が生じました。

```php
$add10 = function (array $arr): array {
    array_walk($arr, function (int $value, string $key) use (&$arr) {
        if($key === 'b') $arr[$key] = $arr[$key] + 20;
        else $arr[$key] = $arr[$key] + 10;
    });
    return $arr;
};

var_dump($add10(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]));
```
- 위와 같이 기존의 함수에다가 특별한 추가 처리를 하게 되면 `$add10`이란 함수명은 잘못된 것이 된다. 이런 경우, 함수의 기존의 의미를 최대한 유지하는 방식으로 코딩하든가, 함수명을 바꾸는 작업을 해 줘야 한다.
- 上記のように既存の関数に特別な追加処理を行うと、`$add10`という関数名は誤ったものになります。このような場合、関数の既存の意味をできるだけ維持する方法でコーディングするか、それとも関数名を変更する必要があります。
- 함수명을 바꾸면 add10But20WhenB 이라는 명칭의 함수가 된다. 함수명이 바뀌는 것은 기능이 바뀌는 것이다. 하나의 함수가 여러 코드에서 사용되고 있는 경우 함수의 기능이 바뀌는 것은 의존하고 있는 다른 코드의 동작에 영향을 줄 수 있다. 따라서 함수명을 변경하는 방법도 있지만, 함수를 하나 더 만드는 방법으로 해결할 수도 있다.
- 関数名を変更すると「add10But20WhenB」という名前の関数になります。関数名が変わることは機能が変わることです。一つの関数が複数のコードで使用されている場合、関数の機能が変わると依存している他のコードの動作に影響を与える可能性があります。したがって、関数名を変更する方法もありますが、新しい関数を作成する方法で解決できます。
```php
$add10 = function (array $arr): array {
    array_walk($arr, function (int $value, string $key) use (&$arr) {
        $arr[$key] = $arr[$key] + 10;
    });
    return $arr;
};

$add10WhenKeyExisted = function (array $arr, string $key): array {
    if (array_key_exists($key, $arr)) $arr[$key] += 10;
    return $arr;
};

var_dump($add10WhenKeyExisted($add10(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]), 'b'));
```
- 'add10WhenKeyExisted'라는 함수를 만들어서 특정한 키에 대한 변경을 할 수 있도록 하였다. 이런식으로 배열을 다룰 때는 특수한 처리를 함수 보다는 일반적으로 동작하는 함수를 만들어 사용하면 여러 코드의 맥락에서 함수의 동작을 직접 바꾸기 보다는 여러 함수를 조합해 코드를 만드는 것이 가능해진다.
- 「add20WhenKeyExisted」という関数を作成し、特定のキーに対する変更を行えるようにしました。このように配列を扱う際には、特別な処理を行う関数よりも、一般的に動作する関数を作成して使用すると、複数のコードの文脈で関数の動作を直接変更するのではなく、複数の関数を組み合わせてコードを作成することが可能になります。
- 강타입 언어가 타입이 맞지 않는 모든 코드를 컴파일러 또는 타입 체커로 확인하여, 변경된 코드의 영향을 쉽게 확인하고 고칠 수 있는 것과 달리 타입 처리가 약한 언어는 공통된 코드의 동작을 변경하면 이를 사용하고 있는 전체 코드를 실행하여 동작을 확인하는 과정이 필요하다. 공통으로 사용되는 코드를 변경하는 것 보다는 일반적으로 동작하는 함수를 만들고 위와 같이 조합하는 방식으로 사용하면 공통 기능을 그대로 두고 필요한 부분에만 합수를 추가하여 동작을 변경할 수 있으므로 메인테인스 안정성이 높아진다는 장점이 있다.
- 強い型の言語では、タイプが合わないすべてのコードをコンパイラまたは型チェッカーで確認して、変更されたコードの影響を簡単に確認して修正できますが、型処理が弱い言語では、共通のコードの動作を変更すると、それを使用しているすべてのコードを実行して動作を確認する必要があります。共通で使用されるコードを変更するよりも、一般的に動作する関数を作成し、上記のように組み合わせる方法で使用すれば、共通機能をそのままにして、必要な部分にのみ関数を追加して動作を変更できるため、メンテナンスの安定性が向上するという利点があります。
- 위의 예제의 함수들은 함수명 `add10WhenKeyExisted`과 매개변수 `array $arr`, `string $key` 그리고 반환 타입 `:array`만 보고서도 배열에서 지정한 키 값이 존재하면, 지정한 키의 값에 10을 더한 결과를 내는 인풋으로 넣은 배열과 동일한 구조를 갖는 배열을 반환하겠구나라고 추측할 수 있다. 이렇게 배열을 다룰 때는 배열의 형태에 의존하기 보다는 배열에 대한 일반적인 처리를 하는 기능을 만드는 것으로 동작을 예측 할 수 있는 코드를 만들 수 있다.
- 上記の例の関数は、関数名`add10WhenKeyExisted`とパラメーター`array $arr`、`string $key`及び戻り値`:array`だけを見ても、配列の指定したキーの値が存在する場合、指定したキーの値に10を加えた結果を出す、入力として与えた配列と同じ構造の配列を返すことが予測できます。このように配列を扱う際には、配列の形態に依存することより、配列に対する一般的な処理を行う機能を作成することで、動作を予測できるコードを作成することができます。

### 특수한 배열 형태의 의존하는 경우
### 特殊な配列の形式に依存する場合

#### 자바스크립트에서 특수한 배열 형태를 처리하는 방법
#### JavaScriptで特殊な配列形式を処理する方法
- 자바스크립트에서 배열은 자바스크립트의 배열은 php가 키-벨류 형태인 것과 달리 인덱스 키만 가지고 문자열 키를 가지지 않은 형태이며, 문자열 키를 갖는 게념은 오브젝트이다. php의 연관배열은 자바스크립트의 배열과 오브젝트 둘 다의 성질을 갖고 있다.
- JavaScriptの配列はphpのようにキーと値の形式ではなく、インデックスキーのみあり、文字列キーはありません。文字列キーがある概念はオブジェクトです。phpの連想配列は、JavaScriptの配列とオブジェクトの両方の性質があります。
- 자바스크립트에서는 비구조화 할당 패턴 (Destructuring Assignment Pattern)이라는 개념이 존재한다. 다음은 비구조화 할당 패턴의 예시이다.
- JavaScriptには分割代入パターン（デストラクチャリング代入パターン・Destructuring Assignment Pattern）という概念があります。以下は分割代入パターンの例です。
```js
const fn = ({a, b, c, d}) => console.log(a, b, c, d);
fn({a: 1, b: 2, c: 3, d: 4}); // 1 2 3 4
```
- 자바스크립트 함수의 파라메터로 오브젝트 형태에서 값만 빠진 `{a, b, c, d}`와 같은 파라메터의 코드를 쓰면 `fn({a: 1, b: 2, c: 3, d: 4})`는 a가 1, b가 2, c가 3, d가 4의 값을 가지며, `fn({a: 1, b: 2, c: 3})`은  a가 1, b가 2, c가 3, d가 undefined의 값을 갖는다. `fn({a: 1, b: 2, e: 3})`의 경우는 a가 1, b가 2, c가 undefined, d가 undefined의 값을 갖는다.
- JavaScriptの関数パラメータとしてオブジェクト形式で値のみ抜き出された`{a, b, c, d}`のようなパラメータを使うと、`fn({a: 1, b: 2, c: 3, d: 4})`では「a「が「1」、「b」が「2」、「c」が「3」、「d」が「4」の値を持ちます。また、`fn({a: 1, b: 2, c: 3})`では「a」が「1」、「b」が「2」、「c」が「3」、「d」が「undefined」の値になります。`fn({a: 1, b: 2, e: 3})`の場合は「a」が「1」、「b」が「2」、「c」が「undefined」、「d」が「undefined」の値になります。
```js
const fn = ({a, b}, c, d) => console.log(a, b, c, d);
fn({a: 1, b: 2}, c: 3, d: 4); // 1 2 3 4
```
- 위와 같이 일부는 비구조화 할당 패턴을 활용하여 인자로 형태가 정해진 오브젝트를 받고, 일부는 그냥 값을 받을 수 있다. 자바스크립트는 비구조화 할당 패턴을 통해서 특수한 형태의 오브젝트 구조에 의존하는 사양의 기능을 만들 수 있다.
- 上記のように、一部のパラメータは分割代入パターンを利用して引数として形式が決まるオブジェクトで受け取り、一部のパラメータは通常の値として受け取ることができます。JavaScriptでは分割代入パターンを通じて、特殊な形式のオブジェクト構造に依存する仕様の機能を作ることができます。

#### 특정한 키를 갖는 배열을 처리하는 방법
#### 特定のキーを持つ配列を処理する方法
```php
$fn = function (array $arr) {
    foreach($arr as $e) {
    	var_dump($e);
    }	
};

$fn(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]);
```
- php에서는 자바스크립트의 비구조화 할당 패턴의 파라메터와 같이 특수한 형태의 배열을 받을 수는 없다. 특수한 구조의 배열을 받고 싶다면, 배열을 사용하지 않고 받고자 하는 대상을 모두 파라메터로 지정하는 방법을 사용한다.
- phpでは、javaScriptの分割代入のように特定の形状の配列を受け取ることはできません。特定の構造の配列を受け取りたい場合は、配列を使わず、受け取りたい要素を全てパラメータとして指定する方法を使用します。
- 배열 내부의 특정 키의 값이 중요한 것이라면, 파라메터로 특정 키가 포함된 배열을 받지 않고 배열의 키 값을 파라메터에 인자로 전달하는 것도 처리할 대상을 분명히 하기 때문에 괜찮은 방법이다. 그리고 배열이 아닌 배열의 키를 파라메터명으로 지정하더라도 php에서는 인자로 배열을 전달하여 배열의 키에 대응하는 파라메터명으로 키에 대응하는 값을 인자로 받을 수 있다.
- 配列内部の特定のキーの値が重要である場合、関数のパラメータとして特定のキーを含む配列を受け取るのではなく、配列のキーの値をパラメータに引数で渡すことも、処理対象を明確にすることができるので良い方法です。また、配列のキーをパラメータ名として定義しても、phpでは引数として配列を渡して、配列のキーに対応するパラメータ名で配列のキーに応じる値を引数で引き取られます。

```php
$fn = function (int $a, int $b, int $c, int $d) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
    var_dump($d);
};

$fn(...['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], ...['d' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], d: 4);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], c: 3, d: 4);
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => 3, 'd' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], 4);
// Fatal error: Cannot use positional argument after argument unpacking
```
- 배열 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]`을 스프레드 문법 `...`을 사용해서 함수의 인자로 할당하면 함수의 파라메터에 파라메터와 같은 이름의 키를 가진 배열의 원소들이 매핑 되는 것을 볼 수 있다. 위의 예제에서 `...['a' => 1, 'b' => 2]`와 같이 인자를 전달할 때 배열의 키로 파라메터의 이름을 지정하여 전달했다면 `'a' =>`는 `$a`에 `'b' => `는 `$b`에 값을 전달하여 `$a`는 1을 `$b`는 2의 값을 받는다.
- 配列 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]`をスプレッド構文`...`を使って関数の引数として渡すと、関数のパラメータにパラメータと同じ名前のキーに応じる配列の要素がマッピングされることがわかります。上記の例では、`...['a' => 1, 'b' => 2]`として引数を渡すと、配列のキーがパラメータの名前と一致するように渡されるため、`'a' =>`は`$a`に、 `'b' => `は `$b` に値が渡され、`$a`は「1」、`$b`は「2」の値が入ります。
- 또한 `...['a' => 1, 'b' => 2]`으로 일부 인자를 파라메터 이름을 지정해서 전달을 하는 방식을 사용했다면 `...['c' => 3], ...['d' => 4]`, `...['c' => 3], d: 4`와 같이 뒤 따르는 나머지 인자도 파라메터의 이름을 지정해서 전달하는 방식으로 사용해 주어야 한다. 인자를 전달할 때 파라메터의 이름을 지정하는 방법은 연관 배열의 키를 파라메터의 이름으로 지정한 배열을 전달하거나, `c: 3, d: 4`와 같이 '파라메터명: 전달할_인자'의 방식으로 특정 파라메터를 지정해서 인자를 전달하는 방법이 있다. 둘 다 이름을 지정하여 전달하는 방식으로 인자를 나열할 때의 콤마(,)를 사용하여 혼용할 수 있다. 파라메터명을 지정한 인자 할당 방식을 공식 용어로 '명명된 인자'(named arguments)라고 부른다.
- また、 `...['a' => 1, 'b' => 2]` で一部の引数をパラメータ名を指定して渡す場合は、 `...['c' => 3], ...['d' => 4]` や `...['c' => 3], d: 4` のように、続く引数もパラメータ名を指定して渡す必要があります。引数を渡すときにパラメータ名を指定する方法には、連想配列のキーをパラメータ名として指定した配列を渡す方法と、`c: 3, d: 4`のように「パラメータ名: 渡す引数」 の形式で特定のパラメータを指定して渡す方法があります。どちらも名前を指定して渡す方法であり、引数を列挙するときのカンマ（,）を使って混用することができます。パラメータ名を指定して渡す方法を公式な用語で「名付けられた引数」（named arguments）と呼びます。
- 함수의 인자를 지정할 때 파라메터명을 지정하는 방식을 통해서 특수한 구조를 갖는 배열을 전달할 수 있다는 것을 알 수 있다. 하지만 일차원 배열의 구조화만 할 수 있다는 단점이 있고, 파라메터명이 지정된 것과 지정되지 않은 인자 전달 방식을 혼용하기 위해서는 `$fn(1, 2, ...['c' => 3, 'd' => 4])`와 같이 `1, 2`으로 파라메터명이 지정되지 않은 인자 전달 방식을 먼저 나열한 다음 `...['c' => 3, 'd' => 4]`으로 파라메터명이 지정된 인자 할당 방식을 뒤에 배치해야 한다. 이름이 지정된 방식을 먼저 앞에 배치하고 이름이 지정되지 않는 방식을 뒤에 배치할 수는 없으므로 인자의 순서에 제한이 있다는 단점이 있다. 또한 어느 파라메터부터 어느 파라메터까지가 배열을 스프레드 문법 `...`으로 전달해야 하는 배열인지 알 수 없다는 문제가 있다. 다음 내용을 보자.
- 関数の引数を指定する際にパラメータ名を指定する方法を使用することで、特定の構造の配列を渡すことができます。しかし、一次元配列の構造化しかできないという欠点があり、パラメータ名が指定された引数と指定されていない引数を混用するためには、 `$fn(1, 2, ...['c' => 3, 'd' => 4])` のように `1, 2` というパラメータ名が指定されていない引数を先に列挙し、`...['c' => 3, 'd' => 4]`というパラメータ名が指定された引数を後に配置する必要があります。名前が指定された引数を先に配置し、名前が指定されていない引数を後に配置することはできないため、引数の順序に制限があるという欠点があります。また、どのパラメータからどのパラメータまでがスプレッド構文`...`で渡す配列なのかを判別することができないという問題もあります。（次の内容で記述）

#### 스프레드 연관 배열 파라메터를 구분하는 방법
#### スプレッド連想配列パラメーターを区別する方法

1. 클로저 사용하기
1. クロージャを使用
```php
$fn = function (int $a, int $b): Closure {
    return function (int $c , int $d) use ($a, $b) {
        var_dump($a);
        var_dump($b);
        var_dump($c);
        var_dump($d);
    };
};

$fn(1, 2)(...['c' => 3, 'd' => 4]);
```
- 위와 같이 배열을 받을 대상과 그렇지 않을 대상을 구분하기 위해서 클로저를 사용해서 일반 값을 받을 대상과 배열 값을 받을 대상을 구분감 있게 분리하는 것도 방법이지만 반환되는 클로저 함수의 사양도 알아야 하는 등 복잡해진다는 단점이 존재한다.
- 上記のように、配列を受け取る対象とそうでない対象を区別するためにクロージャを使用して、一般的な値を受け取る対象と配列の値を受け取る対象を明確に分離する方法もありますが、返されるクロージャ関数の仕様も把握する必要があるなど、複雑になるというデメリットがあります。

2. 주석 사용하기
2. コメントを使用する
```php
$fn = function (int $a, int $b, /*[*/ int $c, int $d /*]*/) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
    var_dump($d);
};

$fn(1, 2, ...['c' => 3, 'd' => 4]);
```
- 위와 같이 주석을 사용하여, 배열이 전달되는 부분을 표기하는 방법이 존재한다. 다음과 같이 개행을 넣어 구분감을 주는 방법도 존재한다.
- 上記のように、コメントを使用して配列が渡される部分を表記する方法があります。次のように改行を入れて区別感を出す方法もあります。

3. 주석과 개행 사용하기
3. コメントと改行使用する
```php
$fn = function (
        int $a, int $b,
        int $c, int $d, // ...[]
    ) {
        var_dump($a);
        var_dump($b);
        var_dump($c);
        var_dump($d);
    };

$fn(1, 2, ...['c' => 3, 'd' => 4]);
```
- 하지만, 이런 주석 처리 방식은 보편적인 방법이 아니기 때문에, 프로젝트나 부서별로 주석처리 규칙을 만들어 사용해야 한다.
- しかし、このようなコメント処理方法は一般的ではないため、プロジェクトや部署ごとにコメント処理規則を作って使用する必要があります。

4. 파라메터명에 특별한 명명법 사용하기
4. パラメーター名に特別な命名法使用する
```php
$fn = function (
        int $a, int $b, int $_c, int $_d,
    ) {
        var_dump($a);
        var_dump($b);
        var_dump($_c);
        var_dump($_d);
    };


$fn(1, 2, ...['_c' => 3, '_d' => 4]);
```
- 위와 같이 배열의 키로 파라메터의 값을 할당할 때는 배열의 키 이름에 특별한 룰을 부여해 구분하는 방법도 있다.
- このように、配列のキーをパラメータの値として割り当てる場合、配列のキー名に特別なルールを設けて区別する方法もあります。

- 연관배열의 특정 키에 의존하는 기능이라면 기능의 동작을 추론하기 어렵기 때문에 배열 타입의 파라메터를 사용하는 방법 대신 전달되는 배열을 구성하는 키를 파라메터로 나열하는 방식을 고려해 볼 수 있다.
- 連想配列の特定のキーに依存する機能であれば、機能の動作を推論するのが難しいため、配列型のパラメーターを使用する方法の代わりに、渡される配列を構成するキーをパラメーターとして列挙する方法を検討することができます。

#### 가변 파라메터로 배열을 받는 방법
#### 可変パラメータで配列を受け取る方法
- php에서 함수는 가변 함수 문법([RFC: Syntax for variadic functions](https://wiki.php.net/rfc/variadics))의 가변 파라메터(variadic parameter)를 이용해서 배열을 받을 수 있다. 가변 인자(variadic arguments)를 받는다는 것은 하나의 파라메터가 받을 수 있는 인자의 갯수에 제한 없이 계속 받을 수 있는 문법이다. 파라메터에 '...배열'의 문법을 사용하여 가변 인자를 받는 파라메터를 만들 수 있다.
- phpでは、関数は可変関数の構文([RFC: Syntax for variadic functions](https://wiki.php.net/rfc/variadics))の可変パラメータ(variadic parameter)を使用して配列を受け取ることができます。可変引数(variadic arguments)を受け取るとは、一つのパラメータが受け取ることができる引数の数に制限なく続けて受け取ることができる構文です。パラメータに「...配列」の構文を使用して、可変引数を受け取るパラメータを作成することができます。
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, 2, 3); // int(1) int(2) array(1) { [0]=> int(3) }
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5); // int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5, 6, 7); // int(1) int(2) array(5) { [0]=> int(3) [1]=> int(4) [2]=> int(5) [3]=> int(6) [4]=> int(7) }
echo "=========================================".PHP_EOL;
$fn(1, 2, ...[3,4,5]); // int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
```
- 파라메터를 `...$c`으로 설정한 것 덕분에 `$fn(1, 2, 3)`, `$fn(1, 2, 3, 4, 5)`, `$fn(1, 2, 3, 4, 5, 6, 7)`으로 인자의 갯수를 늘려도 계속 인자를 받을 수 있다.
- パラメータを`...$c`として設定することで、`$fn(1, 2, 3)`, `$fn(1, 2, 3, 4, 5)`, `$fn(1, 2, 3, 4, 5, 6, 7)`と引数の数を増やしても、引数を受け取ることができます。
- `...$c`에 타입을 붙일 수 있는데 그럼 가변 인자로 받을 모든 인자는 타입이 지정된다.. 파라메터가 `int ...$c`으로 정의가 되어 있으면, `...$c`에 해당하는 모든 인자들은 정수 타입이어야 한다.
- `...$c`に型を付けることができますが、そうすると可変引数で受け取るすべての引数はタイプが指定さます。パラメータが`int ...$c`として定義されている場合、`...$c`に該当するすべての引数は整数型でなければなりません。
- (php에는 없는) 일부 언어에서는 제네릭이란 문법을 제공한다. 제네릭을 사용하면 배열을 사용할 때 `<T>[]`으로 타입을 설정하는 것으로 배열의 모든 원소의 타입은 T 타입이 되도록 강제할 수 있다.
- （phpにはありませんが）一部の言語ではジェネリックという文法を提供しています。ジェネリックを使用すると、配列を使用する際に`<T>[]`と型を設定することで、配列のすべての要素の型をT型に強制することができます。
- 가변 파라메터에 타입을 붙여 스프레드 문법으로 배열을 인자로 받으면, 배열에 제네릭을 붙여 원소의 타입을 제한하는 것과 같은 설정을 할 수 있다.
- 可変パラメータに型を付け、スプレッド構文で配列を引数として受け取ることで、配列にジェネリックを付けて要素の型を制限するような設定ができます。
- 단점으로는 가변 파라메터는 파라메터를 나열할 때 가장 마지막에 위치해야 하며, 반드시 파라메터 중 하나만 가변 파라메터로 지정할 수 있다.
- 短所としては、可変パラメータはパラメータを列挙する際に必ず最後に位置し、必ずパラメータの中で一つだけ可変パラメータとして指定できます。
- 가변 파라메터는 인자를 계속해서 받을 수 있기 때문에, 가변 파라메터 뒤에 정의된 파라메터의 인자를 받을 수 없다. 다음의 예를 보자.
- 可変パラメータは引数を引き続き受け取ることができるため、可変パラメータの後に定義されたパラメータの引数を受け取ることができません。次の例を見てみましょう。
```php
$fn = function($a, ...$b, $c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, ...[2, 3, 4], 5); // Fatal error: Only the last parameter can be variadic
```

#### 스프레드 문법의 배열을 가변 파라메터에 전달할 수 없는 경우
#### スプレッド構文の配列を可変パラメーターに渡せない場合
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, 2, 3);
// int(1) int(2) array(1) { [0]=> int(3) }
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5)
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5, 6, 7);
// int(1) int(2) array(5) { [0]=> int(3) [1]=> int(4) [2]=> int(5) [3]=> int(6) [4]=> int(7) }
echo "=========================================".PHP_EOL;
$fn(1, 2, ...[3,4,5]);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => 3]);
// int(1 int(2) array(1) { ["c"]=> int(3) }
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => [3, 4, 5]]);
// Argument #3 must be of type int, array given
echo "=========================================".PHP_EOL;
$fn(1, 2, c: ...[3, 4, 5]);
// Parse error: syntax error, unexpected token "..."
echo "=========================================".PHP_EOL;
$fn(a: 1, b: 2, ...[3, 4, 5]);
// Cannot use argument unpacking after named arguments
```
- 가변 파라메터는 인자의 수를 제한하지 않는다는 의미를 기본적으로 갖지만, 가변 파라메터에 배열을 스프레드 문법 `...`을 사용해서 `$fn(1, 2, ...[3,4,5])`와 같이 할당하는 방법을 통해서 인덱싱 된 배열을 받는다는 의미를 부여할 수 있다. 또 `$fn(1,2,3)`, `$fn(1,2,3,4)`, `$fn(1,2,3,4,5)`처럼 가변 파라메터는 인자를 여럿 받을 수 있다. 곧, 함수에 가변 파라메터를 사용했다면 인자를 여럿 받을 수 있다는 것과 스프레드 문법을 사용해서 배열을 받을 수 있다는 두 가지 의미로 해석될 수 있다.
- 可変パラメーターは引数の数に制限がないという基本的に意味があります。可変パラメーターに配列をスプレッド構文`...`を使用して`$fn(1, 2, ...[3,4,5])`のように割り当てる方法を通じて、インデックス付き配列を受け取ることができます。また、 `$fn(1,2,3)`、 `$fn(1,2,3,4)`、 `$fn(1,2,3,4,5)`のように可変パラメーター引数を複数受け取れます。 つまり、関数に可変パラメーターを使用したことは引数を複数受け取ることができるということと、スプレッド構文を使用して配列を受け取ることができるという二つの意味に解釈できます。
- `$fn(1, 2, ...[3, 'key' => 4, 5]);`와 같이 배열에 키가 지정된 값을 보내면 키와 일치하는 파라메터명을 매칭한다. 가변 파라메터는 파라메터의 마지막에 위치하기 때문에 `$fn(1, 2, 가변인자)`와 같이 가변 파라메터 이외의 인자는 미리 다 넣은 상태에서 마지막에 가변 인자를 할당한다. 이 경우 `...['c' => '3']`로 값을 전달할 수는 있지만, `...['c' => '3', 4, 5]`은 파라메터 명을 지정하여 전달하는 방식(`'c' => '3'`) 뒤에 파라메터를 지정하지 않은 방식(`4, 5`)의 전달을 하고 있으므로 문법적으로 불가능하며, 파라메터를 지정하지 않은 방식인 파라메터 이름을 마지막에 지정하는 방식(`3, 4`) 뒤에 파라메터를 지정하는 방식(`'c' => 5`)인 `...[3, 4, 'c' => 5]`로 사용하면、키를 지정한 방식과 키를 지정하지 않은 방식을 혼용할 수 있다.
- `$fn(1, 2, ...[3, 'key' => 4, 5]);`のように配列にキーが指定された値を送ると、キーと一致するパラメーター名をマッチング探します。可変パラメーターはパラメーターの最後に位置するため、`$fn(1, 2, 可変引数)`のように可変パラメーター以外の引数はあらかじめすべて指定した状態で、その最後に可変引数を割り当てます。この場合、`...['c' => '3']`で値を渡すことはできますが、`...['c' => '3', 4, 5]`はパラメーター名を指定して渡す方法（`'c' => '3'`）の後にパラメーターを指定しない方法（`4, 5`）で渡すことになるため、文法的に不可能です。パラメーターを指定しない方法である(`3, 4`)の次にパラメーター名を指定する方法（`'c' => 5`）を使うと混在させることができるので、`...[3, 4, 'c' => 5]`で使用すると、キーを指定する方式とキーを指定しない方式を混用できます。
- `$fn(1, 2, ...['c' => [3, 4, 5]])`으로 파라메터명을 지정해서 가변 파라메터에 값을 보내 보자. 가변 파라메터 `...$c`의 타입을 int으로 한 경우 `[3, 4, 5]`으로 array가 전달되어 타입에러가 발생한다. 그렇다고 `$fn(1, 2, ...['c' => ...[3, 4, 5]])`을 사용하면 `...['c' => ...[3, 4, 5]]`과 `...[3, 4, 5]`의 `...`은 서로 다른 문법으로 전자의 `...`은 배열을 풀어 인자로 할당하는 문법이고, 후자의 `...`는 배열을 푸는데 배열의 키-벨류의 벨류에 들어가는 값으로는 하나의 값이 들어가야 하는데 배열을 풀어 여러 값이 할당되므로 문법 에러가 발생한다.
- `$fn(1, 2, ...['c' => [3, 4, 5]])`のようにパラメーター名を指定して可変パラメーターに値を送る場合、可変パラメーター`...$c`のタイプをintにすると、`[3, 4, 5]`が配列として渡され、タイプエラーが発生します。しかし、`$fn(1, 2, ...['c' => ...[3, 4, 5]])`を使用すると、`...['c' => ...[3, 4, 5]]`と`...[3, 4, 5]`の`...`は異なる文法で、前者の`...`は配列を展開して引数に割り当てる文法ですが、後者の`...`は配列を展開するため、配列のキーと値ペアで値として単一の値が必要ですが、複数の値が割り当てられるため文法エラーが発生します。
- 이런 문법적인 제약 때문에 가변 파라메터로 정의된 파라메터(`int ...$c`)에 파라메터명을 사용하여 스프레드 문법의 배열을 전달(`['c' => ...[1,2,3]]`)할 수 없다는 것을 알 수 있다. 또한 `$fn(1, 2, c: ...[3, 4, 5])` 방식의 파라메터를 지정하여 가변 인자에 배열을 스프레드 연산자로 전달하는 것도 지원하지 않는 문법이다. 파라메터명으로 인자를 할당하는 방식으로는 가변 파라메터에 인자를 할당할 수 없기 때문에, 가변 파라메터를 사용했을 때 스프레드 문법으로 배열을 전달하고 싶다면, 파라메터명을 사용하여 인자를 전달하는 방식을 사용하지 않고, 콤마(,)로 인자를 나열하는 방식으로 '...배열'을 전달해야 한다.
- このような文法的な制約のため、可変パラメーターとして定義されたパラメーター（`int ...$c`）にパラメーター名を使用してスプレッド構文の配列を渡すことはできません。また、`$fn(1, 2, c: ...[3, 4, 5])`のようにパラメーターを指定して可変引数に配列をスプレッド演算子で渡すこともサポートされていない文法です。パラメーター名を指定して引数を割り当てる方法では可変パラメーターに引数を割り当てることができないため、可変パラメーターを使用してスプレッド構文で配列を渡したい場合、パラメーター名を使用して引数を渡す方法を使用せず、コンマ（,）で引数を並べる方法で`...配列`を渡す必要があります。

#### 가변 파라메터에 스프레드 문법의 배열 전달하기
#### 可変パラメーターにスプレッド構文の配列を渡す
- 가변 파라메터의 이름을 지정해서 스프레드 문법의 배열을 전달하는 것은 불가능하다는 것을 앞서 확인하였다. 그러나 방법이 없는 것은 아니다. 가변 파라메터는 파라메터 이름을 지정하지 않고 스프레드 문법의 배열을 사용하고, 나머지 인자는 명명된 인자를 스프레드 문법으로 전달하는 방식으로 가변 파라메터에 배열을 전달할 수 있다. 다음의 예를 보자.
- 可変パラメーターに名前を付けてスプレッド構文の配列を渡すことはできないと前述しましたが、方法がないわけではありません。可変パラメーターには名前を指定せずにスプレッド構文の配列を使用し、残りの引数は名前付き引数としてスプレッド構文で渡す方法があります。次の例を見てみましょう。
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, 2, ...[3, 4, 5]);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(1, ...['b' => 2], ...[3, 4, 5]);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...[3, 4, 5]);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(...['a' => 1], ...['b' => 2], ...[3, 4, 5]);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(...['a' => 1], ...[3, 4, 5], ...['b' => 2]);
// int(1) int(2) array(3) { [0]=> int(3) [1]=> int(4) [2]=> int(5) }
echo "=========================================".PHP_EOL;
$fn(...[3, 4, 5], ...['b' => 2], ...['a' => 1]);
// Uncaught Error: Named parameter $b overwrites previous argument
echo "=========================================".PHP_EOL;
$fn(1, ...[3, 4, 5], ...['b' => 2]);
// Uncaught Error: Named parameter $b overwrites previous argument
```
- 먼저 스프레드 문법을 사용한 연관 배열을 통해 파라메터명을 지정하여 인자를 전달한 후, 스프레드 문법으로 파라메터명이 지정되지 않은 배열을 전달하는 것으로 가변 파라메터에 인자를 전달하는 방식을 사용한다.
- まず、スプレッド構文を使った連想配列でパラメーター名を指定して引数を渡し、その後スプレッド構文でパラメーター名を指定しない配列を渡すことで可変パラメーターに引数を渡す方法を使います。
- `$fn(1, ...['b' => 2], ...[3, 4, 5])`의 경우는 첫 번째 인자는 파라메터명을 지정하지 않고 그 다음 인자 부터 파라메터명을 지정하였다. 그리고 가변 파라메터는 파라메터명을 지정하지 않은 것을 알 수 있다. `$fn(...['a' => 1, 'b' => 2], ...[3, 4, 5])`의 예를 보아도 가변 파라메터 이외의 파라메터는 스프레드 문법이 붙은 연관 배열을 사용하고 가변 파라메터는 인덱싱된 배열을 사용하는 것을 통해, 파라메터의 이름을 지정하는 방식으로도 가변 파라메터만 이름을 지정하지 않는 방식으로 인덱싱된 배열을 스프레드 구문으로 가변 파라메터에 전달할 수 있다.
- `$fn(1, ...['b' => 2], ...[3, 4, 5])`の例では、最初の引数はパラメーター名を指定せず、次の引数からパラメーター名を指定しています。そして、可変パラメーターはパラメーター名を指定していないことがわかります。`$fn(...['a' => 1, 'b' => 2], ...[3, 4, 5])`の例でも、可変パラメーター以外のパラメーターはスプレッド構文が付いた連想配列を使用し、可変パラメーターはインデックス付き配列を使用することで、パラメーターの名前を指定する方式でも可変パラメーターのみ名前を指定しない方式でインデックス付き配列をスプレッド構文で可変パラメーターに渡すことができます。
- 단, 가변 파라메터를 첫 번째 인자의 가장 먼저 전달하면 안 되는데 `$fn( ...[3, 4, 5], ...['b' => 2], ...['a' => 1])`의 예제를 보자. 가변 파라메터를 첫 번째 인자로 할당하여 `$a`에 3, `$b`에 4, `$c`에 5를 할당해 버려서 이미 `$b`의 값이 전달된 상태에서 `...['b' => 2]`으로 `$b` 파라메터에 다시 값을 전달해서 'Named parameter $b overwrites previous argument'라는 에러가 발생하게 된다. 마찬가지로 `$fn(1, ...[3, 4, 5], ...['b' => 2])`도 `$a`에 1, `$b`에 3, `$c`에 `[4, 5]`를 할당한 상태에서 `...['b' => 2]`으로 이미 인자가 전달된 `$b` 파라메터에 2를 할당하는 코드가 되어 같은 에러가 발생한다.
- ただし、可変パラメーターを最初の引数として渡してはいけません。例えば、`$fn( ...[3, 4, 5], ...['b' => 2], ...['a' => 1])`の例を見てみましょう。可変パラメーターを最初の引数として渡すと、`$a`に「3」、`$b`に「4」、`$c`に「5」が割り当てられて、すでに`$b`の値が渡された状態で`...['b' => 2]`で再度`$b`に値を渡すことになり、「Named parameter $b overwrites previous argument」というエラーが発生します。同様に、`$fn(1, ...[3, 4, 5], ...['b' => 2])`でも、`$a`に「1」、`$b`に「3」、`$c`に`[4, 5]`を割り当てた後、`...['b' => 2]`で再度`$b`に値を渡すことになるため、同じエラーが発生します。
- 가변 파라메터는 함수의 파라메터 중에서 하나만 지정할 수 있고, 마지막 파라메터로 정의해야 한다. 명명된 인자를 하나라도 할당한 이후에는 가변 인자를 제외한 나머지 인자도 명명된 인자로 할당해야 하고 어차피 나머지가 명명된 인자로 할당되기 때문에 가변 인자를 전달하기 위한 스프레드 문법의 배열은 최대 하나만 존재하는 가변 파라메터에 전달될 수 있기 때문에 어느 순서에도 위치할 수 있다. `$fn(...['a' => 1], ...[3, 4, 5], ...['b' => 2])`를 `...[3, 4, 5]`가 마지막 위치로 전달되지 않아도 동작하는 것을 확인할 수 있다.
- 可変パラメーターは関数のパラメーターの中で一つだけ指定されて、最後のパラメーターとして定義しなければなりません。名前付き引数を一つでも渡した後は、可変パラメーターを除く残りの引数も名前付き引数として渡す必要があります。結局のところ、残りは名前付き引数として渡されるため、可変パラメーターに渡すスプレッド構文の配列は最大一つだけ存在し、どの順序でも位置することができます。`$fn(...['a' => 1], ...[3, 4, 5], ...['b' => 2])`で、`...[3, 4, 5]`が最後の位置に渡されなくても動作することが確認できます。
- 하나의 가변 파라메터만 사용 가능하고, 명명된 인자 뒤에 스프레드 문법의 배열로 가변 파라메터를 할당해야 한다는 제약이 있지만, 가변 파라메터를 사용하는 것으로 배열 원소의 타입이 지정된 배열을 함수의 선언부를 통해 정의할 수 있다.
- 可変パラメーターは一つしか使用できないし、名前付き引数の後にスプレッド構文の配列で可変パラメーターを渡さないといけないという制約がありますが、可変パラメーターを使用することで、配列要素の型が指定された配列を関数の宣言部で定義できます。

#### 가변 파라메터 사용시 유의점 1
#### 可変パラメータを使用する際の注意点 1
- 스프레드 문법의 연관 배열을 인자로 전달할 때, 연관 배열의 키와 일치하는 파라메터명을 가진 쪽에 키의 값을 전달한다. 그러나 연관 배열의 키에 매핑되는 파라메터명이 없는 경우, 모두 가변 파라메터로 전달된다. 이 때문에 가변 파라메터에는 스프레드 문법으로 연관 배열을 함수에 전달할 때 파라메터 명에 존재하지 않는 나머지 값이 전달될 수 있다는 단점이 있다.
- スプレッド構文の連想配列を引数として渡すとき、連想配列のキーと一致するパラメータ名がある場合キーの値を一致するパラメーターに渡します。しかし、連想配列のキーにマッピングされるパラメータ名がない場合、すべて可変パラメータに渡されます。このため、可変パラメータにはスプレッド構文で連想配列を関数に渡す時、パラメータ名に存在しない残りの値が渡される可能性があるという欠点があります。
```php
$fn = function ($a, $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, ...['b' => 2, 'c' => 3], ...['d' => 4, 'e' => 5]);
int(1) int(2) array(3) { ["c"] => int(3) ["d"] => int(4) ["e"] => int(5) }
```
- 파라메터는 `$a`, `$b`, `$c`가 존재한다. 연관 배열의 키로는 b, c, d, e가 전달되었다. 첫 번째 인자 1은 `$a`에 매핑이 되고, 스프레드 문법으로 전달된 배열의 키 b는 `$b`에 전달된다. 그런데 연관 배열의 키 c, d, e는 모두 `$c`에 배열의 키-벨류로 전달 되는 것을 확인할 수 있다. 스프레드 구문과 함께 사용된 연관 배열의 키에 매칭되는 파라메터명이 없는 경우 모두 가변 파라메터로 전달되었다.
- パラメータは`$a`, `$b`, `$c`が存在します。連想配列のキーとして「b」, 「c」, 「d」, 「e」が渡されました。最初の引数1は`$a`にマッピングされ、スプレッド構文で渡された配列のキー「b」は`$b`に渡されます。しかし、連想配列のキー「c」, 「d」, 「e」はすべて`$c`に配列のキーとバリューのペアとして渡されることが確認できます。スプレッド構文とともに使用された連想配列のキーにマッチするパラメータ名がない場合、すべて可変パラメータとして渡されました。
- 곧, 가변 파라메터에 전달할 의도가 없는 값도 스프레드 구문으로 전달된 배열의 키가 매칭되는 파라메터가 존재하지 않는 실수가 생기면 가변 파레메터에 전달할 의도가 없는 값도 가변 파라메터로 들어가게 되는 문제점이 있다.
- すなわち、可変パラメータに渡す意図がない値もスプレッド構文で渡された配列のキーがマッチするパラメータが存在しないミスが生じると、可変パラメータに渡す意図がない値も可変パラメータに入ってしまう問題点があります。
- 또한 명명된 인자와 가변 파라메터에 전달할 값을 연관 배열으로 구분하기 어렵다는 것을 `$fn(1, ...['b' => 2, 'c' => 3], ...['d' => 4, 'e' => 5])`을 통해 알 수 있다. 이 때문에 가변 파라메터에는 연관 배열 보다는 인덱싱된 배열을 전달해서 구분감을 주는 등의 고려도 필요하다.
- また、名前付き引数と可変パラメータに渡す値を連想配列で区別することが難しいことが`$fn(1, ...['b' => 2, 'c' => 3], ...['d' => 4, 'e' => 5])`でわかります。このため、可変パラメータには連想配列よりもインデックス付き配列を渡して区別感をあるように設定などの考慮も必要です。
- 이러한 문제점 때문에 가변 파라메터를 사용할 때는 함수의 파라메터 수를 적게하여 실수할 여지를 적게 했을 때 사용할만 하다.
- このような問題点のため、可変パラメータを使用するときは、関数のパラメータ数を少なくしてミスの余地を少なくしたときに使用するのが良いです。

#### 가변 파라메터 사용시 유의점 2
#### 可変パラメータを使用する際の注意点 2
```php
$fn = function ($a, $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, 2, 3, 4); // int(1) int(2) array(2) { [0]=> int(3) [1]=> int(4) }
$fn('1', '2', '3', '4'); // string(1) "1" string(1) "2" array(2) { [0]=> int(3) [1]=> int(4) }
```
- `$fn('1', '2', '3', '4')` 부분을 보면, 파라메터 `$c`의 값으로 `array(2) { [0]=> int(3) [1]=> int(4)}`의 값이 전달된다. 인자 전달 시 파라메터의 타입과 불일치하면 php는 암묵적인 형 변환을 한다.
- `$fn('1', '2', '3', '4')` の部分を見ると、パラメーター `$c` の値として `array(2) { [0]=> int(3) [1]=> int(4) }` の値が渡される。引数が渡された際にパラメーターの型と一致しない場合、phpは暗黙の型変換を行います。
- 암묵적인 형 변환은 의도치 않은 결과를 만들기도 한다. 예를 들어 '123abc'을 '123'으로 변환시키는 것으로 버그를 만들 수 있다. 가변 파라메터로 타입을 제한할 때는 스트릭트 모드를 통해서 암묵적인 형변환을 막는 것을 추천한다.
- 暗黙の型変換は意図しない結果を招くことがあります。例えば、`'123abc'`が`'123'`に変換されることでバグを引き起こす可能性があります。可変パラメーターに型を制限する場合、ストリクトモードを使用して暗黙の型変換を防ぐことをお勧めします。

```php
declare(strict_types=1);

$fn = function ($a, $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
};

$fn(1, 2, 3, 4); // int(1) int(2) array(2) { [0]=> int(3) [1]=> int(4) }
$fn('1', '2', '3', '4'); // Fatal error: Uncaught TypeError: {closure}(): Argument #3 must be of type int, string given
```
- `declare(strict_types=1)`으로 스트릭트 모드에서 실행하게 되면, 전달된 인자와 파라메터의 타입이 다를 경우 에러를 발생시킨다.
- `declare(strict_types=1)` でストリクトモードで実行すると、渡された引数とパラメーターの型が異なる場合、エラーが発生させます。

### phpdoc을 사용하기
### phpdocを使用する
- phpdoc에는 array shape라는 기능이 있다. 이는 주석을 통해서 배열의 형태를 나타내는 것으로, 파라메터로 배열을 사용할 때 어떤 형태의 배열을 받는지 알 수 있게 해 준다.
- phpdocには「array shape」という機能があります。これはコメントを通じて配列の形を示すもので、パラメーターとして配列を使用する際にどのような形の配列を受け取るかを示すことができます。

#### array shape
- [array-shapes](https://phpstan.org/writing-php-code/phpdoc-types#array-shapes)의 문서는 phpstan이란 정적 분석을 사용할 때 정적분석에 의한 추론으로 올바른 값이 들어갔는지 확인할 수 있는 기능을 제공한다. [phpstorm IDE의 array-shape 지원](https://blog.jetbrains.com/phpstorm/2022/02/phpstorm-2022-1-eap-3/)으로 phpdoc의 array-shapes 구문을 사용할 때, 코드에서 지정한 값의 타입 및 접근 방식 등의 추론을 통한 자동 완성이 강화되었다.
- [array-shapes](https://phpstan.org/writing-php-code/phpdoc-types#array-shapes)のドキュメントは、phpstanという静的解析ツールを使用する際に、静的解析による推論で正しい値が入っているかを確認できる機能を提供します。[phpstorm IDEのarray-shapeサポート](https://blog.jetbrains.com/phpstorm/2022/02/phpstorm-2022-1-eap-3/)により、phpdocのarray-shapes構文を使用する際、コードで指定した値の型やアクセス方式などの推論による自動補完が強化されました。
```php
/**
 * @param $arr array{c: int, d: int}
 */
$fn = function (int $a, int $b, array $arr) {
    var_dump($a);
    var_dump($b);
    var_dump($arr['c']);
    var_dump($arr['d']);
};

$fn(1, 2, ['c' => 3, 'd' => 4]);
```
- 위와 같은 코드를 작성하게 되면, IDE에 의해서 `$arr[|]` (|는 문자열 입력 커서의 포인터)정도만 입력해도 `$arr['c']`, `$arr['d']`에 대한 자동완성이 보여지게 된다. 만약 자동완성 리스트가 나오지 않는다면 `['.']`으로 dot(.)을 사용해 보자. 이런 방식을 통해서 배열에 존재하는 키를 알 수 있다.
- 上記のようなコードを書くと、IDEによって `$arr[|]`（|はカーソルのポインター）を入力するだけで`$arr['c']`、`$arr['d']`の自動補完が表示されます。もし補完リストが表示されない場合は、`['.']` のようにドット（.）を試してみましょう。この方法を使えば、配列に存在するキーを確認できるます。
- 하지만 이러한 지원은 어디까지나 주석으로 코드의 변경에 따라 주석이 업데이트 되지 않는 경우가 생길 수 있으므로 개인적으는 php 문법적인 제약이 이뤄졌으면 바람이 있으며, 배열의 구조를 표기하지 못하는 것이 마음에 들지 않기 때문에 어쩔 수 없이 쓰는 방편일 뿐이다.
- ただし、このようなサポートはあくまでコメントによるものであり、コードの変更に伴ってコメントが更新されない場合があります。そのため、個人ではphp文法による制約が実現されることを望んでいます。単に配列の構造を記述できないのが不満なので仕方なく使う一つの手段に過ぎません。

#### docblock generic
```php
/**
 * @param $arr array<int, string>
 */
$fn = function (int $a, int $b, array $arr) {
    var_dump($a);
    var_dump($b);
    var_dump($arr[0]);
    var_dump($arr[1]);
};

$fn(1, 2, ['c', 'd']);
```
- 제네릭을 사용해서 위와 같이 표기할 수도 있다. php에서 인덱싱 된 배열의 키는 정수이므로 제네릭 표시 `<int, string>`의 첫 번째 타입은 키의 타입으로 인덱스를 의미하므로 int를 두 번째 타입으로 키에 대응하는 벨류의 타입으로 `<int, string>`으로 주석처리 하였다.
- ジェネリックを使って上記のように記述することもできます。phpではインデックス付き配列のキーは整数なので、ジェネリック表示 `<int, string>`の最初の型はキーの型を意味し、インデックスを示すためintを使用し、2番目の型にはキーに対応する値の型として`<int, string>`でコメントを付けました。

#### array shape, docblock generic의 제약사항 설정하기
#### array shape, docblock genericの制約事項を設定する
- 단순히 주석만으로 표기하므로 문법적인 제약이 없는 문제점이 있는 것에 대한 대안으로 함수 내부 코드의 맨 윗줄에 사전 조건을 달아주는 방법을 사용해 볼 수 있다.
- 単にコメントだけで表記するため、文法的な制約がないという問題点に対する代替として、関数の内部コードの最上行に前提条件を付ける方法を使用することができます。
- 정적 타입 검사는 시간이 걸리고, 프로젝트에 따라 도입되지 않은 경우도 있기 때문에 간단히 코드를 동작 시키는 것으로 잘못된 형식인지 확인하기 위한 방법을 제공한다.
- 静的解析による検査は時間がかかるし、プロジェクトに静的解析が導入されてない場合、簡単にコードを動作させることで間違った形式か確認するための方法を提供します。
```php
/**
 * @param $arr array{c: int, d: int}
 */
$fn = function (int $a, int $b, array $arr) {
    assert(array_key_exists('c', $arr), "Key 'c' does not exist in the array.");
    assert(is_int($arr['c']), "Value of 'c' key must be an integer.");
    assert(array_key_exists('d', $arr), "Key 'c' does not exist in the array.");
    assert(is_int($arr['d']), "Value of 'd' key must be an integer.");
    var_dump($a);
    var_dump($b);
    var_dump($arr['c']);
    var_dump($arr['d']);
};

$fn(1, 2, ['c' => 3, 'd' => 4]);
```
```php
/**
 * @param $arr array<int, int>
 */
$fn = function (int $a, int $b, array $arr) {
    assert(array_reduce(array_keys($arr), fn($acc, $v) => $acc && is_int($v), true), 'All array keys must be integers.');
    assert(array_reduce($arr, fn($acc, $v) => $acc && is_string($v), true), 'All array values must be strings.');
    var_dump($a);
    var_dump($b);
    var_dump($arr[0]);
    var_dump($arr[1]);
};

$fn(1, 2, ['c', 'd']);
```
- assert 문법은 로컬이나 테스트 환경에서 동작하고 실제 서버에서는 동작하지 않도록 설정한 후 사용하는 문법이다. 배열에 원소가 많다면 모든 원소를 순회해서 키나 값을 확인해야 하기 때문에 리소스가 많이 들어간다. 따라서 assert로 배열의 제약사항을 확인할 수 있는 코드를 짜는 것은 적절하다. (php에서 assert가 실제 서버에서 동작하지 않게 하기 위해서는 php.ini의 설정이 필요하다.)
- assert文法はローカルやテスト環境で動作し、実際のサーバーでは動作しないように設定した後使用する文法です。配列に要素が多い場合、すべての要素を巡回してキーや値を確認しなければならないため、リソースが多くかかります。したがって、assertで配列の制約事項を確認できるコードを書くのが適切です。（phpでassertが実際のサーバーで動作しないようにするには、php.iniの設定が必要です。）
- assert 문법은 코드의 시작점에 적어서 함수의 선언부와 함께 읽을 수 있도록 만드는 것이 좋다.
- assert文法はコードの始点に書いて関数の宣言部と一緒に読むことができるようにするのが良いです。

### DTO 사용하기
### DTOを使用する
- DTO란 Data Transfer Object의 약자이다. 데이터 전송 객체는 데이터를 전달할 때의 규격을 정한다. DTO는 데이터를 전달하는 운반자의 역할을 하기 때문에 비즈니스 로직이나 벨리데이션 이외의 알고리즘이 들어가지 않는 값을 담을 수 있도록 만든다.
- DTOとはData Transfer Objectの略称です。データ転送オブジェクトは、データを伝達する際の規格を定めます。DTOはデータを伝達するキャリアの役割なので、ビジネスロジックやバリデーション以外のアルゴリズムが含まれない値のみを持つようにします。
- php에서는 클래스를 통해서 타입을 만들 수 있다. 클래스를 하나 만들어 파라메터로 클래스를 타입힌트로 사용하고, 해당 클래스로 만든 오브젝트를 인자로 전달하는 것을 통해 전달 받는 인자의 스펙을 명확하게 할 수 있다.
- phpではクラスを使用して型を作成することができます。クラスを作成し、パラメータにそのクラスをタイプヒントとして使用し、作成したオブジェクトを引数として渡すことで、受け取る引数の仕様を明確にすることができます。
```php
$fn = function($a, $b, Dto $cdObj) {
    var_dump($a);
    var_dump($b);
    var_dump($cdObj->c);
    var_dump($cdObj->d);
};

$fn(1, 2, new Dto(3, 4));
echo "=========================================".PHP_EOL;
$fn(1, 2, new Dto(...[3, 4]));
echo "=========================================".PHP_EOL;
$fn(1, 2, new Dto(...['c' => 3, 'd' => 4]));

class Dto
{
    public function __construct(
        public int $c,
        public int $d,
    ) {
    }
}
```
- 위의 예를 보면 Dto라는 클래스를 함수 `$fn`의 파라메터의 타입힌트로 지정하였다. `$fn` 함수는 값을 받을 때 `new Dto(3, 4)`로 객체화 된 파라메터로 전달 받는다. 배열이었다면 `['c' => 3, 'd' => 4]`의 값이 전달되었을 것이다. DTO는 퍼블릭 멤버로 정의한 데이터만 받을 수 있고 가져올 수 있다. 위의 예제에서 Dto 클래스는 c와 d라는 값을 받고, c와 d 값을 꺼내 쓸 수 있도록 제한되어 있다. 배열을 타입힌트로 했다면 함수 `$fn`은 어떤 형태의 배열을 받아야 할지 명확하지 않기 때문에 내부의 구현을 확인해야 한다. 하지만 DTO는 데이터의 구조가 정해져 있기 때문에 어떤 값을 사용하는지 알 수 있다.
- 上記の例を見ると、Dtoというクラスを関数`$fn`のパラメータのタイプヒントとして指定しています。`$fn`関数は、値を受け取る際に`new Dto(3, 4)`でオブジェクト化されたパラメータを受け取ります。配列であれば`['c' => 3, 'd' => 4]`の値が渡されることになります。DTOはパブリックメンバーで定義したデータのみを受け取り、取り出すことができます。上記の例ではDtoクラスはcとdという値を受け取り、cとdの値を取り出せるように制限されています。配列をタイプヒントにした場合、関数`$fn`はどのような形式の配列を受け取るべきか明確ではないため、内部の実装を確認する必要がありますが、DTOはデータの構造が決まっているため、どの値を使用するのかが分かります。
- 문제는 타입힌트를 사용하기 위해서 클래스를 만들어야 한다는 것인데, 함수에 인자를 전달하기 위해서 인자를 생성할 때 DTO 객체를 생성하기 위해서 클래스 코드가 존재해야 하며, 함수의 파라메터를 타입힌트로 쓰기 위해서 클래스 코드가 존재해야 한다. php에서는 일반적으로 하나의 php 파일에는 하나의 클래스를 정의하는 것이 일반적이다. 하나의 파일에 정의된 클래스를 다른 파일에서 사용하기 위해서는 네임스페이스를 정의해 줘야 하고, 네임스페이스를 통해서 클래스를 import 해야 DTO 클래스를 타입힌트로 사용할 수 있다. 단순히 함수의 파라메터에 배열을 사용하는 것을 피하기 위해 DTO 클래스를 별도의 파일로 분리해야 하므로 파일의 배치, 폴더 구조, 네임스페이스 정의 등 보일러 플레이트가 많아진다는 단점이 생긴다. 일반적으로 DTO 클래스는 별도의 DTO를 모아둔 폴더에 정의한다. 이를 위해서 DTO를 분류하기 위한 폴더를 정의해야 하고, DTO 클래스의 php 파일을 생성하는 수고가 든다.
- 問題は、タイプヒントを使用するためにクラスを作成しなければならないことです。関数に引数を渡すために、引数を生成する際DTOオブジェクトを生成するためには、クラスコードが存在する必要があります。また、関数のパラメータをタイプヒントとして使用するためには、クラスコードが存在する必要があります。phpでは通常、一つのphpファイルには一つのクラスを定義するのが一般的です。一つのファイルに定義されたクラスを他のファイルで使用するためには、名前空間を定義する必要があり、名前空間を通じてクラスをインポートしなければ、DTOクラスをタイプヒントとして使用することができません。単に関数のパラメータに配列を使用するのを避けるためにDTOクラスを別ファイルに分けなければならないため、ファイルの配置、フォルダ構造、名前空間の定義などボイラープレートが増えるという欠点があります。一般的にDTOクラスは別のDTOを集めたフォルダに定義します。これにより、DTOを分類するためのフォルダを定義し、DTOクラスのphpファイルを生成する手間がかかります。
- DTO는 일반적으로 getter와 setter를 갖는다. 하지만 위의 예에서는 getter와 setter를 사용하지 않는 것으로 보일러 플레이트를 상당히 줄였다. getter와 setter를 사용하면 int, string 등과 같은 일반적인 타입보다 더 작은 범위, 예를 들어 자연수 범위라든가 날짜 형식의 문자열이라든가 좀 더 구체적인 값을 받을 수 있다. 앞서 커스텀 타입에 대해 설명하였다. getter setter 없는 DTO 대신에 커스텀 타입 클래스를 멤버 변수의 타입 힌트로 붙여주는 것을 통해서 getter, setter가 없이도 유사한 역할을 하는 단순화된 DTO 클래스를 만들 수 있다.
- DTOは通常、getterとsetterが定義されています。しかし、上記の例ではgetterとsetterを使用しないことでボイラープレートを大幅に削減させました。getterとsetterを使用すると、intやstringなどの一般的な型よりも、例えば自然数の範囲や日付形式の文字列など、より具体的な値を受け取ることができます。前述のカスタムタイプについて説明しました。getterやsetterのないDTOの代わりに、カスタムタイプクラスをメンバ変数のタイプヒントとして付けることで、getterやsetterなしでも同様の役割を果たす簡略化されたDTOクラスを作成することができます。
```php
$fn = function($a, $b, Dto $cdObj) {
    var_dump($a);
    var_dump($b);
    var_dump($cdObj->c);
    var_dump(($cdObj->yyyymm)());
    var_dump($cdObj->yyyymm->__invoke());
    var_dump(call_user_func($cdObj->yyyymm));
};

$fn(1, 2, new Dto(3, new StrYmType('202407')));

class Dto
{
    public function __construct(
        public int $c,
        public StrYmType $yyyymm,
    ) {
    }
}

class StrYmType
{
    public function __construct(private string $yyyymm) {
        $year = intval(substr($yyyymm, 0, 4));
        $month = intval(substr($yyyymm, 4, 2));

        if (checkdate($month, 1, $year)) {
            $this->yyyymm = $yyyymm;
        } else {
            throw new Error('invalid Ym');
        }
    }
    
    public function __invoke(): string
    {
    	return $this->yyyymm;
    }
}
```
- `StrYmType` 클래스가 `__invoke` 함수를 사용했기 때문에 `Dto` 클래스를 주형으로 한 오브젝트의 멤버 `$cdObj->yyyymm`에 접근할 때 `$cdObj->yyyymm()`으로 접근하면 `StrYmType` 인스턴스의 메소드를 접근하는 문법이 되므로 멤버가 없다는 에러가 발생한다. 따라서 멤버 변수로 접근을 한 후에 해당 값을 함수로 실행하는 방식의 코드 `($cdObj->yyyymm)()`, `$cdObj->yyyymm->__invoke()`, `call_user_func($cdObj->yyyymm)`를 적어 주었다.
- `StrYmType`クラスが`__invoke`関数を使用したため、`Dto`クラスを型とするオブジェクトのメンバー`$cdObj->yyyymm`にアクセスする際に`$cdObj->yyyymm()`とアクセスすると`StrYmType`インスタンスのメソッドを呼び出す文法となるのでメンバーがないというエラーが発生します。そのため、メンバー変数にアクセスした後にその値を関数として実行する方式のコード`($cdObj->yyyymm)()`, `$cdObj->yyyymm->__invoke()`, `call_user_func($cdObj->yyyymm)`を記述しました。

#### DTO 클래스의 보일러 플레이트 줄이기
#### DTOクラスのボイラープレート減らす
- PSR(PHP Standards Recommendations)에 따르면 'Namespaces and classes MUST follow an "autoloading" PSR: [PSR-0, PSR-4]'으로 클래스와 네임스페이스는 PSR-0과 PSR-4를 따라야 한다고 되어 있다. PSR-0과 PSR-4는 오토로딩(php에서의 import와 export의 구현)에 관한 규약이다. 반드시 import와 export가 될 수 있도록 만들어야 하는데, 이를 따른다면 하나의 파일에 하나의 하나의 클래스(+인터페이스, 추상클래스, 이넘)를 정의해고 네임 스페이스를 달아 주어야 한다.
- PSR(PHP Standards Recommendations)によれば、「Namespaces and classes MUST follow an "autoloading" PSR: [PSR-0, PSR-4]」とされており、クラスと名前空間はPSR-0およびPSR-4に従わなければならないとされています。PSR-0およびPSR-4は、phpにおける自動ローディング（importおよびexportの実装）に関する規約です。必ずimportおよびexportが行われるように作られなければならず、そのためには1つのファイルに1つのクラス（+インターフェース、抽象クラス、enum）を定義し、名前空間を付け加えなければなりません。
- 하지만 php의 문법으로는 하나의 파일에 여러 클래스를 만들 수 있으며 문법적으로 제약되어 있지는 않다. 오토로딩은 php에서 import와 export를 구현하기 위해서 만든 것으로 외부로 export 되는 클래스를 메인 클래스로 하고 네임스페이스를 달고 외부로 export할 필요가 없는 클래스는 같은 파일에서 네임스페이스를 정의하지 않는 방식으로 사용하면, 오토로딩의 동작에 영향을 주지 않으면서 한 파일에 두 개 이상의 클래스를 만들 수 있기 때문에 메인 클래스에서 필요한 DTO를 하나의 파일에 만들어 보일러 플레이트를 줄일 수 있다. 하지만, PSR에는 'classes MUST follow an "autoloading" PSR'라고 적혀있기 때문에 import하지 않는 서브 클래스라도 클래스이므로 오토로딩 규칙을 따라야 한다. PSR을 위반하고 싶지 않은 경우에는 같은 폴더에 서브 클래스를 정의하는 방법을 사용할 수 있다.
- しかし、phpの文法では一つのファイルに複数のクラスを定義することが可能で、文法的に制約されていません。オートローディングは、phpでimportおよびexportを実装するために作られたもので、外部にexportされるクラスをメインクラスとし、名前空間を付けてexportする必要のないクラスは同じファイルで名前空間を定義しない方法で使用することができます。このようにすると、オートローディングの動作に影響を与えずに一つのファイルで複数のクラスを定義することができ、メインクラスで必要なDTOを一つのファイルにまとめてボイラープレートを減らすことができます。しかし、「classes MUST follow an "autoloading" PSR」という記述があるため、importしないサブクラスであってもクラスであるため、オートローディングの規則に従わなければなりません。PSRを遵守するためには、同じフォルダにサブクラスを定義する方法を使用することができます。
- PSR을 따르면서 좀 더 보일러 플레이트를 줄이기 위해서는 같은 네임스페이스인 메인 클래스와 동일한 폴더에 클래스 파일을 하나 더 생성하면 import 할 때 필요한 네임스페이스를 생략할 수 있고 DTO를 분류하기 위한 폴더를 만들 필요가 없기 때문에 좀 더 간단히 DTO 클래스를 작성할 수 있는 장점이 있다. 하지만 여전히 DTO 클래스를 export 하기 위해서 네임스페이스를 정의해야 하기 때문에 약간의 보일러 플레이트를 요구한다.
- PSRを遵守しながらも、少しでもボイラープレートを減らすためには、同じ名前空間であるメインクラスと同じフォルダにクラスファイルを一つ追加すると、importする際に必要な名前空間を省略することができ、DTOを分類するためのフォルダを作成する必要がないため、少し簡単にDTOクラスを作成することができます。ただし、DTOクラスをexportするためには、名前空間を定義する必要があるため、少しのボイラープレートが必要です。
- 동일 네임스페이스는 해당 네임스페이스 범위 내의 네임스페이스를 가진 클래스 사용하기 적합하며, 여러 클래스에서 사용되어야 하는 DTO의 경우 별도의 DTO 파일을 모아 둔 폴더를 사용하는 것을 권장한다.
- 同じネームスペースは、そのネームスペースの範囲内にある名前空間のクラスに使用するのに適していますが、複数のクラスで使用されるDTOの場合は、別のDTOファイルをまとめたフォルダを使用することをお勧めします。

### 캡슐화 이용하기
### カプセル化の活用
- DTO를 사용하기 위해서는 별도의 파일을 만들어 클래스를 정의 해야 한다는 불편함, 하나의 파일에 둘 이상의 클래스를 만드는 등의 방식이 맘에 들지 않는 경우, 배열의 데이터를 특정 방식으로만 조작할 수 있도록 제한을 건 익명 클래스(Anonymous class)를 만드는 방법이 있다.
- DTOを使用するには、別のファイルにクラスを定義する必要があるという不便さや、一つのファイルに複数のクラスを定義する方法などが気に入らない場合、配列のデータを特定の方法でのみ操作できるように制限する匿名クラス(Anonymous class)を作成する方法があります。
- 배열에 관한 모든 조작을 익명 클래스에 위임하는 방법을 사용하여, 데이터 저장소의 컨트롤에 관해서는 캡슐화된 오브젝트에 맡기고 오브젝트에서 제공하는 메소드를 사용해서 값의 생성, 변경, 취득하는 방식을 사용한다. 이 방법은 배열에 관한 구체적인 조작을 익명 클래스 외부에서 하지 않는 것으로 배열에 대한 관심사가 집중된 익명 클래스 이외에서는 배열에 대한 구체적인 조작을 피하는 방식으로 사용된다.
- 配列に関するすべての操作を匿名クラスに委任して、データストアのコントロールに関してはカプセル化されたオブジェクトに任せて、オブジェクトが提供するメソッドを使用して値の生成、変更、取得を行います。この方法は、配列に関する具体的な操作を匿名クラスの外で行わず、配列に関する関心事を匿名クラス以外に集中させる方法として使用されます。
```php
$cdStoreObj = new class {
    private array $arr;

    public function setC(int $c): self
    {
        $this->arr['c'] = $c;
        return $this;
    }

    public function setD(int $d): self
    {
        $this->arr['d'] = $d;
        return $this;
    }

    public function getArr(): array
    {
        return $this->arr;
    }
};

$cdStoreObj->setC(3)->setD(4);

$fn = function($a, $b, object $cdObj) {
    $cdArr = $cdObj->getArr();
    var_dump($a);
    var_dump($b);
    var_dump($cdArr['c'] ?? 'Key c is not exists');
    var_dump($cdArr['d'] ?? 'Key d is not exists');
};

$fn(1, 2, $cdStoreObj);
```
- 익명 클래스를 사용해서 오브젝트를 만드는 방법은 익명 클래스를 타입힌트로 사용할 수 없기 때문에 적당한 타입인 object을 주었다. 타입힌트로 지정할 수 없기 때문에 IDE의 추론도 제약된다. 그러나 같은 폴더에 정의했기 때문에 경우에 따라 IDE가 추론해 주는 경우도 있다.
- 匿名クラスを使用してオブジェクトを作成する方法は、匿名クラスにをタイプヒントとして使用できないため、適切な型としてobjectを指定しました。タイプヒントを指定できないため、IDEの推論も制限されます。しかし、同じフォルダに定義されている場合、IDEが推論を行うこともあります。
- 배열의 메소드를 통해서 값을 정의하기 때문에 위 `$cdStoreObj`는 c값과 d값만을 세팅 및 변경할 수 밖에 없고, c값과 d값만 취득할 수 밖에 없다는 것을 알 수 있다. 그런데 배열을 사용하는 것에 비해서 더 나은 것이 없어 보인다. 왜냐하면 `object $cdObj` 대신에 `array $cdArr`을 만들면 되기 때문에 굳이 익명 클래스를 적을 필요가 없기 때문이다.
- 配列のメソッドを介して値を定義するため、上記の `$cdStoreObj`は「c」値と「d」値の設定および変更しかできず、「c」値と「d」値しか取得できないことがわかります。しかし、配列を使用する場合と比較しても良い点が見当たりません。なぜなら`object $cdObj`の代わりに`array $cdArr`を作成すれば良いため、匿名クラスを書く必要がないからです。
- 오브젝트 타입의 값은 다양한 구현이 존재하면 일반적인 구현이란 것이 존재하지 않는다. 배열과 달리 오브젝트를 전달 받았다는 것은 오브젝트 내부의 프로퍼티나 메소드를 접근하지 않고 사용하거나 특수한 형태의 오브젝트를 사용해 해당 오브젝트에 정의된 메소드를 사용하기 위한 용도로 사용된다. 오브젝트 타입의 타입힌트를 사용했다면 개발자는 전달된 오브젝트의 명세를 확인할 것이다. 익명 클래스를 배열 대신에 전달하는 방식은 전달되는 배열의 데이터가 많고 복잡한 경우, 캡슐화된 객체를 통해서 배열을 다루어 배열을 어떻게 다뤄야 할지 그 사양을 나타내고 있으므로, 전달되어야 하는 오브젝트로 어떻게 배열을 다루어 전달을 해야할지 알 수 있게 해 준다. 따라서 단순한 배열인 경우에는 그냥 array 타입으로 받는 것이 좋겠지만, 복잡한 배열인 경우에는 위와 같은 방식을 사용할 수도 있다. 또한 익명 클래스를 사용한 것은 하나의 파일에서 사용하기 위한 방식이므로 타입힌트나 리스코프치환 등을 의식할 필요는 없다.
- オブジェクトタイプの値はさまざまな実装が存在し、一般的な実装というものは存在しません。配列とは異なり、オブジェクトを受け取ったことは、オブジェクト内部のプロパティやメソッドにアクセスせずに使用するか、特殊な形式のオブジェクトを使用してそのオブジェクトに定義されたメソッドを使用する目的で使用されます。オブジェクト型のタイプヒントを使用していた場合、開発者は渡されたオブジェクトの仕様を確認するでしょう。匿名クラスを配列の代わりに渡す方法は、渡される配列のデータが多く複雑な場合、カプセル化されたオブジェクトを介して配列を扱う方法を示し、どのようにしてオブジェクトで配列を扱って渡すべきかを示しています。したがって、単純な配列の場合は単に「array」型で受け取る方が良いですが、複雑な配列の場合はこのような方法も使用できます。また、匿名クラスを使用するのは、単一のファイル内で使用するための手段であり、タイプヒントやリスコフの置換などについて意識する必要はありません。
- 함수 `$fn`에서 `$cdArr['c'] ?? 'Key c is not exists'` `$cdArr['d'] ?? 'Key d is not exists'`라는 코드를 만들었는데 이는 `$fn`이 전달되는 익명 클래스 `cdStoreObj`의 setter가 사용이 되든지 되지 않든지에 상관 없이 함수가 동작되도록 만들었기 때문이다. `$cdStoreObj->setC(3)->setD(4)`이든, `$cdStoreObj->setC(3)`이든, `$cdStoreObj->setD(4)`이든 모두 성립하는 일반적인 구현이 되도록 만들 필요가 있다.
- 関数`$fn`において、`$cdArr['c'] ?? 'Key c is not exists'`および`$cdArr['d'] ?? 'Key d is not exists'`というコードを作成しました。これは、`$fn`が匿名クラス`cdStoreObj`のsetterメソッドが使用されるか否かに関わらず動作するようにするためです。`$cdStoreObj->setC(3)->setD(4)` や `$cdStoreObj->setC(3)`、 または `$cdStoreObj->setD(4)` のいずれの場合でも成立できる汎用的な実装にする必要があります。
- 만약 단일 파일이 아닌 여러 파일에서 사용되는 함수 또는 메소드인 경우에는 클래스로 만들어 타입 힌트로 객체를 받는 것이 좋다.
- 単一のファイルではなく、複数のファイルで使用される関数やメソッドの場合、クラスとして実装してタイプヒントを使用してオブジェクトを受け取るのが良いです。

## 감상
## さいごに
- php의 배열 타입을 사용할 때, 배열이 인덱싱된 배열을 받는지, 연관 배열을 받는지, 배열의 특수한 인덱스나 키에 의존하는 로직이 들어가는지, 함수의 선언부의 정의만으로 동작이 어떻게 이뤄질지 예측하기 어려운 경우가 있다. 추상화를 하는 이유 중 하나는 동작하는 모든 코드를 읽지 않고도 이해하고 사용하려는 목적이 있다. 추상화된 코드의 선언부만 보고 대략적인 동작을 추측할 수 있어야 하며, 추측한 동작 이외의 예외적인 동작의 가능성을 최대한 낮춰 예측 가능한 코드를 만들어야 모든 코드를 일일이 확인하지 않고도 복잡도가 높은 로직을 처리할 수 있다.
- phpの配列型を使用する際、配列がインデックス付き配列を受け取るか、連想配列を受け取るか、特定のインデックスやキーに依存するロジックが含まれているかを予測することは困難な場合があります。抽象化の理由の一つは、動作するすべてのコードを確認しなくても理解して使用する目的があります。抽象化されたコードの定義部分だけを見ておおよその動作を推測できる必要があり、推測した動作以外の例外的な動作の可能性をできるだけ低くして、予測可能なコードを作成することで、すべてのコードを一つ一つ確認せずに複雑なロジックを処理できるようになります。
- php는 엄격하지 않게도 만들 수 있고, 엄격하게도 만들 수 있는 자유도가 높은 언어이다. 생산성을 위해서 상황에 따라 덜 엄격하게 만들기도 하며, 프로젝트 관리를 위해 더 구체적이고 엄격하게 만들 수도 있다. 프로젝트가 성장함에 따라 덜 엄격한 로직에서 더 엄격한 로직으로 전환하기 쉽게 코드를 짤 수 있는 역량이 요구된다. php는 다른 엄격한 언어에 비해 비교적 제약이 적은 동적 언어라서 쉽다는 편견이 있지만, 상황에 맞게 유연하게도 엄격하게도 짤 수 있는 특성을 가진 의외로 어려운 언어가 php이기도 하다. 프로젝트에 참여하는 구성원이 어떻게 엄격하게 만드는지에 관한 지식이 없다면, 엄격하지 않은 코드가 갖고 있는 로직을 올바르게 해석할 수 있는 정보 부족으로 인해 코드를 의도한 바와 달리 이해할 가능성이 높아지고, 잘못된 이해와 기존의 엄격하지 못한 코딩 방식을 참고하여 코드를 만들어 더 엉망인 코드를 만들어 내는 문제점이 생긴다. 이 때문에 프로젝트가 성장하면서 사내 스터디 도입, 엄격한 코드 관리, 강타입 언어로의 전환 등을 모색한다.
- phpは柔軟にも厳密にも作ることができる自由度の高い言語です。生産性を高めるために状況に応じてより柔軟にすることもありますが、プロジェクト管理のためにより具体的で厳密にすることもあります。プロジェクトが成長するにつれて、柔軟なロジックから厳密なロジックへの切り替えが容易にコーディングできる能力が求められます。phpは他の厳密な言語と比べて比較的制約が少ない動的言語という偏見がありますが、状況に応じて柔軟にも厳密にもコーディングできる特性を持つphpは意外にも難しい言語です。プロジェクトに参加するメンバーがどのように厳密にするかについての知識がない場合、厳密でないコードが持つロジックを正しく解釈できない情報不足により、コードを意図した通りに理解する可能性が高まり、誤った理解と従来の厳密でないコーディングスタイルを参考にしてコードを作成し、より混乱したコードを作成してしまう問題が生じます。このため、プロジェクトが成長するにつれて社内スタディの導入、厳密なコード管理、強い型言語への転換などを模索します。
- 이런 문제를 야기하는 대표적인 케이스로 php의 배열을 꼽을 수 있으며, php에서 배열을 다루는 여러가지 방식 또는 배열을 대체하는 방법을 소개하는 것을 통해서 상황에 맞는 적절한 솔루션을 찾을 수 있도록 글을 작성하였다. 커스텀 타입 및 커스텀 타입을 사용한 DTO, 스프레드 문법을 사용한 인자 할당 방식, 가변 파라메터를 사용한 유사 제네릭 문법, 캡슐화를 사용하는 방식등 틈새 기술도 소개하였다. 도움이 되길 바란다.
- これらの問題を引き起こす代表的なケースとして、phpの配列を挙げることができます。phpで配列を扱うさまざまな方法や、配列を代替する方法を紹介することで、状況に応じた適切なソリューションを見つけるための記事を書きました。カスタムタイプやカスタムタイプを利用したDTO、スプレッド構文を使用した引数割り当て方法、可変パラメーターを利用する擬似ジェネリック文法、カプセル化を使用した方法など、ニッチなスキルも紹介しました。役立つことを願っています。
