## 도대체 php에서 배열을 어떻게 다뤄야 할까? (배열을 다루는 특별한 방법 포함)
## 一体全体、PHPで配列をどう扱えばいいのか？（配列を扱うニッチな方法を含む）

### php에서 배열의 특징
### phpの配列の特徴
- php에서는 배열이란 하나의 타입에 `[1,2,3,4,5]`와 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]`의 두 가지 방식을 사용할 수 있다. 첫 번째는 인덱싱 배열이고 두 번째는 연관 배열이라고 부른다.
- phpでは、配列とは一つのタイプで、`[1,2,3,4,5]`と`['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]`の二つの方式を使用できます。最初のはインデックス配列で、2番目は連想配列と呼ばれます。
- 정적 언어에서는 인덱싱 배열은 키가 존재하지 않는 대상이다. 메모리의 어떤 위치에 데이터를 일정 바이트 간격으로 순차적으로 읽게 된다. 이런 방식으로 접근을 하기 때문에 배열의 각각의 인덱스에 해당하는 값에 접근할 때 빠른 속도로 처리한다.
- 一般の静的言語では、インデックス配列はキーが存在しない対象です。メモリのある位置にデータを一定のバイト間隔で順次読み取ります。この方式でアクセスするため、配列の各インデックスに該当する値にアクセスするときに高速な速度で処理します。
- php에서의 인덱싱된 배열은 연관 배열과 같은데 이는 `[1,2,3,4,5]`은 `[0 => 1, 1 => 2, 2 => 3, 3=> 4, 4 => 5]`와 동일하기 때문이다. 인덱싱 배열로 만들어도 어차피 php에서는 모두 연관배열로 처리한다.
- phpのインデクシング配列は連想配列に同じです。というのは、`[1,2,3,4,5]`が`[0 => 1, 1 => 2, 2 => 3, 3 => 4, 4 => 5]`と同じであるためです。インデックス配列として作成しても、結局phpではすべて連想配列として処理されます。
- php의 배열은 인덱싱 배열이나 연관 배열이나 내부적으로는 해쉬테이블을 사용하여 처리 방식의 동일하므로 구분 없이 동일한 array 타입으로 다뤄진다.
- phpの配列はインデックス配列でも連想配列でも、内部的にはハッシュテーブルを使用して処理方式が同じであるため、区別なく同じ「array」タイプとして扱われます。

### 기능의 스펙 문제
### 機能のスペック問題
- 함수나 클래스를 정의하는 것은 스펙을 만드는 작업이다. 함수의 이름, 파라메터, 타입을 모두 포함하여 기능의 인터페이스를 나타내는 용어를 함수의 '서명'이라고 부른다. 함수의 서명으로 매개변수로 배열을 사용하게 되면, 배열 안의 어떤 값을 이용해야 할지 서명만 보고서는 알 수 없으며 내부의 구현을 확인해야 한다는 단점이 있다. 함수나 클래스 캡슐화 된 서명만을 통해 가능한 해당 서명이 어떤 기능을 나타내는지 알 수 있어야 하며 배열을 전달한다면 어떤 구조의 배열을 받아야 할지 알아야 한다. 하지만, 배열 타입힌트의 파라메터로 인자를 받을 때는 배열으로 받을 수 있는 형태의 다양성으로 인해서 어떤 값을 받아야 할지 모호한 경우가 많다.
- 関数やクラスを定義するのは、仕様を作成する作業です。関数の名前、パラメーター、タイプをすべて含めて、機能のインターフェースを示す用語を関数の「シグネチャ(signature)」と呼びます。関数のシグネチャでパラメータとして配列を使用すると配列内のどの値を利用すべきかシグネチャだけでは分かりません。内部のコードを確認する必要があるという欠点があります。関数やクラスはカプセル化されたシグネチャだけを通じて、そのシグネチャがどのような機能を示しているのか分かるように作る必要があります。配列を渡すならどのような構造の配列を受け取るべきか知っておく必要があります。しかし、配列のタイプヒントのパラメータで引数を受け取る場合、配列で受け取ることができる形の多様性により、どの値を受け取るべきか曖昧なことが多いです。
- 복잡한 소프트웨어를 만들 수록 각 단위 기능의 테스트 가능성은 중요하다. 일반적으로 테스트가 가능하다는 것은 마치 순수함수와 같이 인풋에 대해 아웃풋을 가질 수 있어서 따로 떼어 내었을 때 인풋을 넣었을 때 아웃풋의 결과를 확인할 수 있는 것을 의미한다. 테스트 할 수 있는 기능은 어떤 역할을 할지 예상하기 쉽고, 예상대로 동작하는지를 확인하기 위한 테스트 코드를 작성하기 쉽다는 장점이 있다. 하지만 배열을 인풋으로 받을 때 배열의 어떤 형태를 인풋으로 받아야 할지 알 수 없기 때문에 동작이 잘 이뤄지는 것인지 모호한 경우가 생길 수 있다.
- 複雑なソフトウェアを作るほど、各単位機能のテスト可能性は重要です。一般的にテストが可能であるということは、純粋関数のようにインプットに対してアウトプットを持つことができ、独立して取り出したときにインプットを入れるとアウトプットの結果を確認できることを意味します。テスト可能な機能はどのような役割を果たすか予測しやすく、予測どおりに動作するかどうかを確認するためのテストコードを作成しやすいという利点があります。しかし、配列をインプットとして受け取るとき、どのような形の配列をインプットとして受け取るべきかがわからないため、動作がうまく行うのか曖昧な予測できないし、テストしにくい場合があります。
- 테스트하기 쉬운 코드가 되기 위해서는 함수나 클래스의 서명만으로 어떤 인풋을 넣었을 때 아웃풋이 어떤 형태의 아웃풋을 받는지 확인할 수 있어야 한다. 배열의 경우 구조의 형태가 다양해서 어떤 값을 넣어 주어야 할지 생각하기 어려운 경우가 많다. 결국 배열을 인자로 받는 경우 어떤 입력에 어떤 결과값을 갖는지 추측하기 어려운 경우가 많이 발생할 수 있고, 내부 구현을 꼭 확인헤야 하는 코드를 만들 가능성이 있다.
- テストしやすいコードになるためには、関数やクラスのシグネチャだけでどのようなインプットを入れたら、どのようなアウトプットが得られるかを確認できる必要があります。配列の場合、その構造の形がいろいろあるため、どのような値を入れるべきか考えるのが難しいケースが多いです。結局、配列を引数として受け取る場合、どの入力に対してどのような結果が得られるか予測しにくい場合が多く、内部のコードをを確認しなければならないコードを作る可能性があります。
- 인풋에 대한 아웃풋이 명확한 스펙을 갖고 있다면 테스트 코드를 만들기 쉽고 해당 기능이 어떻게 동작하는지 확인하기 쉽다. 하지만 배열을 매개변수로 사용하게 되면, 어떤 구조의 배열을 전달해야 결과값을 확인할 수 있을지 기능의 스펙만을 보고는 알 수 없기 때문에 동작 확인 및 테스트하기 어려운 코드가 된다.
-　インプットに対するアウトプットが明確な仕様なら、テストコードを作成しやすく、機能がどのように動作するかを確認するのがしやすいです。しかし、配列をパラメータとして使用する場合、どのような構造の配列を渡すべきか機能の仕様だけではわからないため、動作確認及びテストしにくいコードになります。
- 전달된 배열을 내부에서 어떻게 처리를 할지, 어떤 값을 전달해야 해당 기능의 스펙에 맞는 동작을 만들어 낼 수 있을지를 확인하기 위해서 서명만 보고서는 충분하지 못하며 내부의 코드의 처리 과정을 확인해야 한다면, 값의 변화의 양상을 확인하기 위한 디버깅이 더 많이 필요해진져 관리하기 어려운 코드가 된다. 프로그래밍에서 추상화는 내부의 로직을 확인하지 않더라도 어떤 기능인지 어느 정도 추론할 수 있도록 만드는 것인데, php의 배열을 파라메터로 받으면 함수나 메소드 서명만으로는 어떤 배열의 형태와 값을 전달해야 할지 알 수 없게 되는 문제점이 생긴다.
- 渡された配列を内部でどのように処理するか、どのような値を渡せば機能の仕様に合う動作を作り出すのかを確認するためにシグネチャだけでは十分でなく、内部のコードの処理過程を確認する必要があるならば、値の変化の様相を確認するためのデバッグがより多く必要になり、管理が難しいコードになります。プログラミングにおいて抽象化は内部のロジックを確認しなくてもどのような機能かある程度推論できるようにすることですが、phpの配列をパラメーターとして受け取ると、関数やメソッドのシグネチャだけではどのような形の配列と値を渡すべきかがわからなくなるという問題が生じます。

### 문자열 매개변수의 문제
### 文字列パラメータの問題
- 문자열 매개변수의 예를 생각 해 보자. 일반적인 코딩 스타일에서 문자열에 대해 어떤 일반적인 처리를 하는 것이 아니라, 어떤 식별자로 문자열을 사용하는 코딩 스타일은 좋게 여기지 않는 경우가 많다. 타입에 의해 제한되는 방식과 달리 문자열 매개 변수는 문자열에 오기가 발생한 경우 런타임에 에러를 감지하지 못할 수도 있고, IDE가 코딩의 실수를 알려주지 않는 경우도 있다. 컴파일 언어는 컴파일 타임의 타입 체크 또는 IDE의 사용하는 코드를 정의된 코드로 이동하는 기능 등을 사용해서 코딩의 실수를 줄이기 위해서 문자열 매개변수를 사용하는 것을 권장하지 않는 코딩 프렉티스가 존재한다.
- 文字列パラメーターの例を考えてみましょう。一般的なコーディングスタイルでは、文字列に対して何らかの一般的な処理をするのではなく、何らかの識別子として文字列を使用するコーディングスタイルは好まない場合が多いです。型によって制限される方式とは異なり、文字列パラメーターは文字列に誤りが発生した場合、ランタイムでエラーを検出できないことがあり、IDEがコーディングミスを通知しないこともあります。コンパイル言語は、コンパイル時のタイプチェックまたはIDEで使用するコードを定義されたコードに移動する機能などを使用して、コーディングミスを減らすために、文字列パラメーターの使用を推奨しないコーディングプラクティスが存在します。
- 무조건 문자열 매개변수를 사용하지 말라는 것은 아니다. 일반적인 문자열에 대한 처리를 하는 경우에는 문자열을 매개변수로 전달하는 것은 괜찮다. 하지만, 함수 내부에서 특정한 문자열에 대해서만 별도의 처리할 때 함수는 특정 문자열에 의존적인 처리를 가진다. 이런 경우 문자열은 어떤 상태를 구분하는 식별자의 역할을 하는데 이를 문자열로 처리하면 실수를 유발할 가능성을 높인다.
- 無条件に文字列パラメーターを使用しないというわけではありません。一般的な文字列に対する処理を行う場合には、文字列をパラメーターとして渡すのは問題ありません。しかし、関数内部で特定の文字列に対してのみ別途の処理をする際は、関数は特定の文字列に依存する処理を持ちます。このような場合、文字列は何らかの状態を区別する識別子の役割をしますが、それを文字列として処理するとミスを誘発する可能性が高まります。
- 식별자의 용도로 문자열을 사용하기 보다는 enum을 사용하거나 커스텀 클래스를 만들어 `new CutstomTeyp(문자열)`의 생성자로 문자열을 전달하고 `__invoke` 매직 메소드를 통해서 벨리데이션 된 문자열을 사용하는 방법을 사용하는 것을 추천한다. 문자열은 너무 다양한 값이 들어 올 수 있기 때문에 식별자로 문자열을 사용할 경우에는 런타임이나 IDE 등의 툴을 이용한 코딩의 실수를 방지하는 기능이 동작하지 않을 가능성이 높기 때문에 버그를 만들어 낼 가능성을 높인다. 이러한 스타일을 제약할 수 있도록 enum이나 커스텀 class를 만들어 타입힌트로 이들 타입을 사용하는 것을 추천한다.
- 識別子の用途に文字列を使用するのではなく、enumを使用したりカスタムクラスを作成して`new CustomType(文字列)`のコンストラクターに文字列を渡し、`__invoke`マジックメソッドを通じてバリデーションされた文字列を使用する方法をお勧めします。文字列は非常に多様な値になるため、識別子として文字列を使用する場合、ランタイムやIDEなどのツールを使用したコーディングミス防止機能が動作しない可能性が高く、バグを発生させる可能性が高まります。このようなスタイルを制約するために、enumやカスタムクラスを作成し、タイプヒントとしてこれらのタイプを使用することをお勧めします。
- enum의 경우는 `enum Gender: string { case Man = 'man'; case Woman = 'woman'; }` `$canPregnant = function(Gender $gender): bool { ... }`의 예를 생각해 보자. 문자열 파라메터로 `'man'` `'woman'`을 전달하도록 만들면 `$canPregnant = function(string $gender): bool { ... }`의 `string $gender` 파라메터로 `'man'` `'woman'`을 전달해야 할지, `'m'` `'w'`을 전달해야 할지, `'male'` `'femail'`을 전달해야 할지, `'m'`, `'f'`를 전달해야 할지 함수의 내부 구현을 확인하지 않으면 알 수가 없다. 이에 반해 enum을 사용하면 함수가 어떤 파라메터를 사용하는지 명확한 스펙을 알 수 있다.
- enumの例として、`enum Gender: string { case Man = 'man'; case Woman = 'woman'; }` `$canPregnant = function(Gender $gender): bool { ... }`を考えてみましょう。文字列パラメーターで`'man'`や`'woman'`を渡す場合、`$canPregnant = function(string $gender): bool { ... }`の`string $gender`パラメーターに`'man'`や`'woman'`を渡すべきか、`'m'`や`'w'`を渡すべきか、`'male'`や`'female'`を渡すべきか、`'m'`や`'f'`を渡すべきか、関数の内部実装を確認しなければわかりません。それに対して、enumを使用すれば関数がどのパラメーターを使用するのか明確な仕様を知られます。
- 또한 문자열이 너무 다양한 값이 될 수 있으므로 때문에 어떤 기능의 스펙을 정하기 위해서 enum이나 커스텀 class를 만들어 타입힌트로 사용하는 것과 마찬가지로 배열 또한 단위 기능의 스펙상의 제약을 걸기 위해 타입힌트를 사용하는 방법을 생각하는 편이 좋다.
- また、文字列が非常に多様な値になれるので、機能の仕様を定義するためにenumやカスタムクラスを作成してタイプヒントとして使用するのと同様に、配列も機能の仕様上の制約を設けるためにタイプヒントを使用する方法を考えるのが良いでしょう。

#### 커스텀 타입의 예시
#### カスタムタイプ例
```php
class StrYmType
{
    private string $yyyymm;

    public function __construct(string $yyyymm) {
        $year = intval(substr($yyyymm, 0, 4));
        $month = intval(substr($yyyymm, 4, 2));
        if(checkdate($month, 1, $year)) $this->yyyymm = $yyyymm;
    	else throw new Error('invalid Ym');
    }
    
    public function __invoke(): string
    {
    	return $this->yyyymm;
    }
}

$fn = function (StrYmType $yearMonth) {
    echo 'result: '.$yearMonth().PHP_EOL;
};

$fn(new StrYmType('202406')); // result: 202406
$fn(new StrYmType('2024-06')); // Uncaught Error: invalid Ym
```
- 위의 코드는 YYYYMM 형식의 문자열인지 확인하는 클래스를 만들어 함수 `$fn`의 매개변수 타입힌트로 사용하였다.
- 上記のコードは、YYYYMM形式の文字列かどうかを確認するクラスを作成し、関数`$fn`のパラメータのタイプヒントとして使用しています。
- 타입힌트를 통하여 특수한 문자열만을 받을 수 있는 커스터마이징 타입을 만들어 전달되는 값의 유형을 제한할 수 있다.
- タイプヒントを通じて、特定の文字列のみを受け取ることができるカスタムタイプを作成し、渡される値の種類を制限することができます。

### 일반적인 배열 처리
### 一般的な配列処理
- php의 배열도 문자열과 마찬가지 문제를 갖는다. 배열은 형태와 구조 다양하기 때문에 어떤 구조의 배열을 전달해야 할지 알 수 없다는 문제가 있다. 문자열이 식별자로 사용될 경우 어떤 문자열이 기능 내부의 특별한 처리 케이스를 갖는지 확인해야 하듯이 배열도 어떤 구조의 배열을 전달해야 사용하려는 기능에서 원하는 결과를 얻을 수 있는지는 내부 구현을 확인하지 않고는 알 수 없는 문제가 있다.
- phpの配列も文字列と同じような問題を抱えています。配列の形と構造が多様なので、どの構造の配列を引数として渡せばよいかがわからないという問題があります。文字列が識別子として使用される場合、どの文字列が機能内部の特別な処理ケースを持つか確認する必要があるように、配列もどの構造の配列を渡せば使用しようとしている機能で望む結果を得られるかは、内部コードを確認しなければわからない問題があります。
- 배열을 매개변수로 사용하는 기능이 있다면 배열의 구조에 관계 없이, 모든 배열의 구성에 대해 동작하는 스펙을 만드는 것이 좋다. 특정 배열의 구조에 의존하는 것이 아닌 배열의 모든 데이터를 순회하는 방식의 처리를 하는 기능으로 만든다. 또한 특정한 키에 의존하는 기능 또는 특정한 키에 대한 특수한 처리를 한다면 어떤 키에 어떤 처리를 하는지 알 수 없기 때문에 내부의 코드 동작의 특수 처리를 하는 부분을 확인하지 않는 이상 기능의 동작의 결과를 추측하기 어렵게 된다.
- 配列をパラメーターとして使用する機能がある場合、配列の構造に関係なく、すべての配列の構成に対して動作する仕様を作るのが良いです。特定の配列の構造に依存するのではなく、配列のすべてのデータを巡回する方式の処理を行う機能にします。また、特定のキーに依存する機能や特定のキーに対する特別な処理を行う場合、どのキーにどの処理を行うかがわからないため、内部のコード動作の特別な処理を確認しない限り、機能の動作結果を予測するのが難しくなります。
- 만약 배열의 특정한 키나 특정한 값에 대한 처리를 하는 것이라면 특정한 키를 지정하여 처리할 수 있도록 `$key`, `$needle`과 같은 매개 변수를 갖는 함수를 만들어 처리하도록 하며, 기능의 스펙(함수의 이름, 파라메터명과 타입, 반환타입 등)으로 내부의 특수한 처리를 명확히 드러내지 않는 기능은 만들지 않는 편이 좋다.
- もし配列の特定のキーや特定の値に対する処理を行うことなら、特定のキーを指定して処理できるように`$key`や`$needle`のようなパラメーターの関数を作成し、機能の仕様（関数の名前、パラメーター名・タイプ、戻り値など）で内部の特別な処理を明確に示さない機能は作らない方が良いです。

```php
$add10 = function (array $arr): array {
    array_walk($arr, function (int $value, string $key) use (&$arr) {
        $arr[$key] = $arr[$key] + 10;
    });
    return $arr;
};

var_dump($add10(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]));
```
- 배열의 모든 원소에 10을 더하는 위와 같은 함수가 있다고 하자. 그런데 어떤 요구사항이 추가가 되어 b 키에는 20을 더해야 하는 상황이 생겼다.
- 配列のすべての要素に10を加える上記のような関数があるとしましょう。しかし、ある要件が追加され、bキーには20を加えなければならない状況が生じました。

```php
$add10 = function (array $arr): array {
    array_walk($arr, function (int $value, string $key) use (&$arr) {
        if($key === 'b') $arr[$key] = $arr[$key] + 20;
        else $arr[$key] = $arr[$key] + 10;
    });
    return $arr;
};

var_dump($add10(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]));
```
- 위와 같이 기존의 함수에다가 특별한 추가 처리를 하게 되면 `$add10`이란 함수명은 잘못된 것이 된다. 이런 경우, 함수의 기존의 의미를 최대한 유지하는 방식으로 코딩하든가, 함수명을 바꾸는 작업을 해 줘야 한다.
- 上記のように既存の関数に特別な追加処理を行うと、`$add10`という関数名は誤ったものになります。このような場合、関数の既存の意味をできるだけ維持する方法でコーディングするか、それとも関数名を変更する必要があります。
- 함수명을 바꾸면 add10But20WhenB 이라는 명칭의 함수가 된다. 함수명이 바뀌는 것은 기능이 바뀌는 것이다. 하나의 함수가 여러 코드에서 사용되고 있는 경우 함수의 기능이 바뀌는 것은 의존하고 있는 다른 코드의 동작에 영향을 줄 수 있다. 따라서 함수명을 변경하는 방법도 있지만, 함수를 하나 더 만드는 방식으로 해결하는 것도 방법이다.
- 関数名を変更すると「add10But20WhenB」という名前の関数になります。関数名が変わることは機能が変わることです。一つの関数が複数のコードで使用されている場合、関数の機能が変わると依存している他のコードの動作に影響を与える可能性があります。したがって、関数名を変更する方法もありますが、新しい関数を作成する方法で解決することも一つの方法です。
```php
$add10 = function (array $arr): array {
    array_walk($arr, function (int $value, string $key) use (&$arr) {
        $arr[$key] = $arr[$key] + 10;
    });
    return $arr;
};

$add20WhenKeyExisted = function (array $arr, string $key): array {
    if (array_key_exists($key, $arr)) $arr[$key] = 20;
    return $arr;
};

var_dump($add20WhenKeyExisted($add10(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]), 'b'));
```
- 'add20WhenKeyExisted'라는 함수를 만들어서 특정한 키에 대한 변경을 할 수 있도록 하였다. 이런식으로 배열을 다룰 때는 특수한 처리를 함수 보다는 일반적으로 동작하는 함수를 만들어 사용하면 여러 코드의 맥락에서 함수의 동작을 직접 바꾸기 보다는 여러 함수를 조합해 코드를 만드는 것이 가능해진다.
- 「add20WhenKeyExisted」という関数を作成し、特定のキーに対する変更を行えるようにしました。このように配列を扱う際には、特別な処理を行う関数よりも、一般的に動作する関数を作成して使用すると、複数のコードの文脈で関数の動作を直接変更するのではなく、複数の関数を組み合わせてコードを作成することが可能になります。
- 강타입 언어가 타입이 맞지 않는 모든 코드를 컴파일러 또는 타입 체커로 확인하여, 변경된 코드의 영향을 쉽게 확인하고 고칠 수 있는 것과 달리 타입 처리가 약한 언어는 공통된 코드의 동작을 변경하면 이를 사용하고 있는 전체 코드를 실행하여 동작을 확인하는 과정이 필요하다. 공통으로 사용되는 코드를 변경하는 것 보다는 일반적으로 동작하는 함수를 만들고 위와 같이 조합하는 방식으로 사용하면 공통 기능을 그대로 두고 필요한 부분에만 합수를 추가하여 동작을 변경할 수 있으므로 메인테인스 안정성이 높아진다는 장점이 있다.
- 強い型の言語では、タイプが合わないすべてのコードをコンパイラまたは型チェッカーで確認して、変更されたコードの影響を簡単に確認して修正できますが、型処理が弱い言語では、共通のコードの動作を変更すると、それを使用しているすべてのコードを実行して動作を確認する必要があります。共通で使用されるコードを変更するよりも、一般的に動作する関数を作成し、上記のように組み合わせる方法で使用すれば、共通機能をそのままにして、必要な部分にのみ関数を追加して動作を変更できるため、メンテナンスの安定性が向上するという利点があります。
- 위의 예제의 함수들은 함수명 `add20WhenKeyExisted`과 매개변수 `array $arr`, `string $key` 그리고 반환 타입 `:array`만 보고서도 배열에서 지정한 키 값이 존재하면, 지정한 키의 값에 20을 더한 결과를 내는 인풋으로 넣은 배열과 동일한 구조를 갖는 배열을 반환하겠구나라고 추측할 수 있다. 이렇게 배열을 다룰 때는 배열의 형태에 의존하기 보다는 배열에 대한 일반적인 처리를 하는 기능을 만드는 것으로 동작을 예측 할 수 있는 코드를 만들 수 있다.
- 上記の例の関数は、関数名`add20WhenKeyExisted`とパラメーター`array $arr`、`string $key`及び戻り値`:array`だけを見ても、配列の指定したキーの値が存在する場合、指定したキーの値に20を加えた結果を出す、入力として与えた配列と同じ構造の配列を返すことが予測できます。このように配列を扱う際には、配列の形態に依存することより、配列に対する一般的な処理を行う機能を作成することで、動作を予測できるコードを作成することができます。

### 특수한 배열 형태의 의존하는 경우

#### 자바스크립트에서 특수한 배열 형태를 처리하는 방법
- 자바스크립트에서 배열은 자바스크립트의 배열은 인덱스 키만 가지고 벨류가 매핑된 형태이며, 다양한 키를 갖는 문법은 오브젝트이어야 한다. php의 연관배열은 자바스크립트의 배열과 오브젝트 둘 다의 표현을 갖고 있다.
- 자바스크립트에서는 비구조화 할당 패턴 (Destructuring Assignment Pattern)이라는 개념이 존재한다. 다음은 비구조화 할당 패턴의 예시이다.
```js
const fn = ({a, b, c, d}) => console.log(a, b, c, d);
fn({a: 1, b: 2, c: 3, d: 4}); // 1 2 3 4
```
- 자바스크립트 함수의 파라메터로 오브젝트 형태에서 값만 빠진 `{a, b, c, d}`와 같은 파라메터의 코드를 쓰면 `fn({a: 1, b: 2, c: 3, d: 4})`는 a가 1, b가 2, c가 3, d가 4의 값을 가지며, `fn({a: 1, b: 2, c: 3})`은  a가 1, b가 2, c가 3, d가 undefined의 값을 갖는다. `fn({a: 1, b: 2, e: 3})`의 경우는 a가 1, b가 2, c가 undefined, d가 undefined의 값을 갖는다.
```js
const fn = ({a, b}, c, d) => console.log(a, b, c, d);
fn({a: 1, b: 2}, c: 3, d: 4); // 1 2 3 4
```
- 위와 같이 일부는 비구조화 할당 패턴을 활용한 형태가 정해진 오브젝트를 받고, 일부는 그냥 값을 받을 수 있다. 자바스크립트는 비구조화 할당 패턴을 통해서 특수한 형태의 오브젝트 구조에 의존하는 사양의 기능을 만들 수 있다.

#### 특정한 키를 갖는 배열을 처리하는 방법
```php
$fn = function (array $arr) {
    foreach($arr as $e) {
    	var_dump($e);
    }	
};

$fn(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]);
```
- 자바스크립트의 비구조화 할당 패턴의 파라메터와 같이 특수한 형태의 배열을 받을 수는 없다. 따라서 특수한 구조의 배열을 받고 싶다면, 배열을 사용하지 않고 받고자 하는 대상을 모두 파라메터로 지정하는 방법을 사용한다.

```php
$fn = function (int $a, int $b, int $c, int $d) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
    var_dump($d);
};

$fn(...['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], ...['d' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], d: 4);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], c: 3, d: 4);
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => 3, 'd' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], 4); // Fatal error: Cannot use positional argument after argument unpacking
```
- 배열 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]`을 스프레드 문법 `...`을 사용해서 함수의 인자로 할당하면 함수의 파라메터에 파라메터와 같은 이름의 키를 가진 배열의 원소들이 매핑 되는 것을 볼 수 있다. 위의 예제에서 `...['a' => 1, 'b' => 2]`와 같이 인자를 전달할 때 배열의 키로 파라메터의 이름을 지정하여 전달했다면 `'a' =>`는 `$a`에 `'b' => `는 `$b`에 값을 전달하여 `$a`는 1을 `$b`는 2의 값을 받는다.
- 또한 `...['a' => 1, 'b' => 2]`으로 일부 인자를 파라메터 이름을 지정해서 전달을 하는 방식을 사용했다면 `...['c' => 3], ...['d' => 4]`, `...['c' => 3], d: 4`와 같이 뒤 따르는 나머지 인자도 파라메터의 이름을 지정해서 전달하는 방식으로 사용해 주어야 한다. 인자를 전달할 때 파라메터의 이름을 지정하는 방법은 연관 배열의 키를 파라메터의 이름으로 지정한 배열을 전달하거나, `c: 3, d: 4`와 같이 '파라메터명: 전달할_인자'의 방식으로 특정 파라메터를 지정해서 인자를 전달하는 방법이 있다. 둘 다 이름을 지정하여 전달하는 방식으로 인자를 나열할 때의 콤마(,)를 사용하여 혼용할 수 있다. 파라메터명을 지정한 인자 할당 방식을 공식 용어로 '명명된 인자'(named arguments)라고 부른다.
- 함수의 인자를 지정할 때 파라메터명을 지정하는 방식을 통해서 특수한 구조를 갖는 배열을 전달할 수 있다는 것을 알 수 있다. 하지만 일차원 배열의 구조화만 할 수 있다는 단점이 있고, 파라메터명이 지정된 것과 지정되지 않은 인자 전달 방식을 혼용하기 위해서는 `$fn(1, 2, ...['c' => 3, 'd' => 4])`와 같이 `1, 2`으로 파라메터명이 지정되지 않은 인자 전달 방식을 먼저 나열한 다음 `...['c' => 3, 'd' => 4]`으로 파라메터명이 지정된 인자 할당 방식을 뒤에 배치해야 한다. 이름이 지정된 방식을 먼저 앞에 배치하고 이름이 지정되지 않는 방식을 뒤에 배치할 수는 없으므로 인자의 순서에 제한이 있다는 단점이 있다. 또한 어느 파라메터부터 어느 파라메터까지가 배열을 스프레드 문법 `...`으로 전달해야 하는 대상인지 알 수 없다는 문제가 있다.

#### 스프레드 연관 배열 파라메터를 구분하는 방법
```php
$fn = function (int $a, int $b): Closure {
    return function (int $c , int $d) use ($a, $b) {
        var_dump($a);
        var_dump($b);
        var_dump($c);
        var_dump($d);
    };
};

$fn(1, 2)(...['c' => 3, 'd' => 4]);
```
- 위와 같이 배열을 받을 대상과 그렇지 않을 대상을 구분하기 위해서 클로저를 사용해서 일반 값을 받을 대상과 배열 값을 받을 대상을 구분감 있게 분리하는 것도 방법이지만 반환되는 클로저 함수의 사양도 알아야 하는 등 복잡해진다는 단점이 존재한다.
```php
$fn = function (int $a, int $b, /*[*/ int $c, int $d /*]*/) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
    var_dump($d);
};

$fn(1, 2)(...['c' => 3, 'd' => 4]);
```
- 위와 같이 주석을 사용하여, 배열이 전달되는 부분을 표기하는 방법이 존재한다. 다음과 같이 개행을 넣어 구분감을 주는 방법도 존재한다.
```php
$fn = function (
        int $a, int $b,
        int $c, int $d, // ...[]
    ) {
        var_dump($a);
        var_dump($b);
        var_dump($c);
        var_dump($d);
    };

$fn(1, 2)(...['c' => 3, 'd' => 4]);
```
- 하지만, 이런 주석 처리 방식은 보편적인 방법이 아니기 때문에, 프로젝트나 부서별로 주석처리 규칙을 만들어 사용해야 한다.
- 연관배열의 특정 키에 의존하는 기능이라면 기능의 동작을 추론하기 어렵기 때문에 배열 타입의 파라메터를 사용하는 방법 대신 전달되는 배열을 구성하는 키를 파라메터로 나열하는 방식을 고려해 볼 수 있다.

#### 인덱싱 된 배열(indexed array)을 받는 방법
- 인덱싱 된 배열은 배열의 원소로 키가 없는 배열로 파이썬과 같은 언어에서 리스트라고 부른다. 대부분의 언어에서 배열이라고 하면 인덱싱된 배열을 의미하며, 연관배열은 자바스크립트에서는 오브젝트, 자바에서는 hashMap의 자료구조와 비슷하다.
- `['a', 'key' => 'b', 'c']`의 예를 보면 'a'에는 '0'의 키가 부여되고, 'c'에는 '1'의 키가 부여된다. php에서는 키가 없는 배열의 경우 키가 없는 원소의 앞에 나열된 원소부터 0부터 정수의 키가 부여된다. 예를 들어 `[1,2,3]`이란 배열이 있다면 `['0' => 1, '1' => 2, '2' => 3]`이 되는 식이다.
- 키-벨류 쌍을 가지는 연관 배열과 달리 인덱싱 된 배열은 가변 함수 문법([RFC: Syntax for variadic functions](https://wiki.php.net/rfc/variadics))의 가변 파라메터(variadic parameter)를 이용해서 배열을 받을 수 있다. 가변 인자(variadic arguments)를 받는다는 것은 인자의 갯수가 제한이 없다는 의미의 문법이다. 파라메터에 '...변수'의 문법을 사용하여 가변 인자를 받는 파라메터를 만들 수 있다.
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    foreach($c as $key => $value) {
    	echo 'key: ';
        var_dump($key);
        echo 'value: ';
        var_dump($value);
    }
};

$fn(1, 2, 3); // int(1) int(2) key: int(0) value: int(3)
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5); // int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5, 6, 7); // int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5) key: int(3) value: int(6) key: int(4) value: int(7)
echo "=========================================".PHP_EOL;
$fn(1, 2, ...[3,4,5]); // int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
```
- 파라메터를 `...$c`으로 설정한 것 덕분에 `$fn(1, 2, 3)`, `$fn(1, 2, 3, 4, 5)`, `$fn(1, 2, 3, 4, 5, 6, 7)`으로 인자의 갯수를 늘려도 계속 인자를 받을 수 있다.
- `...$c`에 타입을 붙일 수 있는데 그럼 가변 인자로 받을 모든 대상은 지정한 타입이 되어야 한다. 파라메터가 `int ...$c`으로 정의가 되어 있으면, `...$c`에 해당하는 모든 인자들은 정수 타입이어야 한다.
- (php에는 없는) 일부 언어에서는 제네릭이란 도구를 제공한다. 제네릭을 사용하면 배열을 사용할 때 `<T>[]`으로 타입을 설정하는 것으로 배열의 모든 원소의 타입은 T 타입이 되도록 강제할 수 있다.
- 가변 파라메터에 타입을 붙여 스프레드 연산자로 배열을 인자로 받으면, 배열에 제네릭을 붙여 원소의 타입을 제한하는 것과 같은 설정을 할 수 있다.
- 단점으로는 가변 파라메터는 파라메터를 나열할 때 가장 마지막에 위치해야 하며, 파라메터 중 하나만 가변 파라메터로 지정할 수 있다. 가변 파라메터는 파라메터를 계속해서 받을 수 있기 때문에, 가변 파라메터 뒤에 정의된 파라메터의 인자를 받을 수 없다. 다음의 예를 보자.
```php
$fn = function($a, ...$b, $c) {
    var_dump($a);
    var_dump($b);
    foreach($c as $key => $value) {
    	echo 'key: ';
        var_dump($key);
        echo 'value: ';
        var_dump($value);
    }
};

$fn(1, ...[2, 3, 4], 5); // Fatal error: Only the last parameter can be variadic
```

#### 스프레드 문법의 배열을 가변 파라메터에 전달할 수 없는 경우
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    foreach($c as $key => $value) {
    	echo 'key: ';
        var_dump($key);
        echo 'value: ';
        var_dump($value);
    }
};

$fn(1, 2, 3);
// int(1) int(2) key: int(0) value: int(3)
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5, 6, 7);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5) key: int(3) value: int(6) key: int(4) value: int(7)
echo "=========================================".PHP_EOL;
$fn(1, 2, ...[3,4,5]);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => 3]);
// int(1) int(2) key: string(1) "c" value: int(3)
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => [3, 4, 5]]);
// Argument #3 must be of type int, array given
echo "=========================================".PHP_EOL;
$fn(1, 2, c: ...[3, 4, 5]);
// Parse error: syntax error, unexpected token "..."
echo "=========================================".PHP_EOL;
$fn(a: 1, b: 2, ...[3, 4, 5]);
// Cannot use argument unpacking after named arguments
```
- 가변 파라메터는 인자의 수를 제한하지 않는다는 의미를 기본적으로 갖지만, 가변 파라메터에 배열을 스프레드 문법 `...`을 사용해서 `$fn(1, 2, ...[3,4,5])`와 같이 할당하는 방법을 통해서 인덱싱 된 배열을 받는다는 의미를 부여할 수 있다. 곧 가변 파라메터는 인자를 여럿 받을 수 있다는 것과 스프레드 문법을 사용해서 배열을 받을 수 있다는 두 가지 의미로 해석될 수 있다.
- `$fn(1, 2, ...[3, 'key' => 4, 5]);`와 같이 배열에 키가 지정된 값을 보내면 키와 일치하는 대상을 파라메터에서 찾는다. 가변 파라메터는 파라메터의 마지막에 위치하기 때문에 `$fn(1, 2, 가변인자)`와 같이 가변 파라메터 이외의 인자는 미리 다 넣은 상태에서 마지막에 가변 인자를 할당한다. 이 경우 `...['c' => '3']`로 값을 전달할 수는 있지만, `...['c' => '3', 4, 5]`은 파라메터 명을 지정하여 전달하는 방식(`'c' => '3'`) 뒤에 파라메터를 지정하지 않은 방식(`4, 5`)의 전달을 하고 있으므로 문법적으로 불가능하며, 파라메터를 지정하지 않은 방식 파라메터 이름을 마지막에 지정하는 방식(`3, 4`) 뒤에 파라메터를 지정하는 방식(`'c' => 5`)인 `...[3, 4, 'c' => 5]`는 사용가능하다.
- `$fn(1, 2, ...['c' => [3, 4, 5]])`으로 파라메터명을 지정해서 가변 파라메터에 값을 보내 보자. 가변 파라메터 `...$c`의 타입을 int으로 한 경우 `[3, 4, 5]`으로 array가 전달되어 타입에러가 발생한다. 그렇다고 `$fn(1, 2, ...['c' => ...[3, 4, 5]])`을 사용하면 `...['c' => ...[3, 4, 5]]`과 `...[3, 4, 5]`의 `...`은 서로 다른 문법으로 전자의 `...`은 배열을 풀어 인자로 할당하는 문법이고, 후자의 `...`는 배열을 푸는데 배열의 키-벨류의 벨류에 들어가는 값으로는 하나의 값이 들어가야 하는데 배열을 풀어 여러 값이 할당되므로 문법 에러가 발생한다.
- 이런 문법적인 제약 때문에 가변 파라메터로 정의된 파라메터(`int ...$c`)에 파라메터명을 사용하여 스프레드 문법의 배열을 전달(`['c' => ...[1,2,3]]`)할 수 없다는 것을 알 수 있다. 또한 `$fn(1, 2, c: ...[3, 4, 5])` 방식의 파라메터를 지정하여 가변 인자에 배열을 스프레드 연산자로 전달하는 것도 지원하지 않는 문법이다. 파라메터명으로 인자를 할당하는 방식으로는 가변 파라메터에 인자를 할당할 수 없기 때문에, 가변 파라메터를 사용했을 때 스프레드 연산자로 배열을 전달하고 싶다면, 파라메터명을 사용하여 인자를 전달하는 방식을 사용하지 않고, 콤마(,)로 인자를 나열하는 방식으로 '...배열'을 전달해야 한다.

#### 가변 파라메터에 스프레드 문법의 배열 전달하기
- 가변 파라메터의 이름을 지정해서 스프레드 문법의 배열을 전달하는 것은 불가능하다는 것을 앞서 확인하였다. 그러나 방법이 없는 것은 아니다. 가변 파라메터는 파라메터 이름을 지정하지 않고 스프레드 문법의 배열을 사용하고, 나머지 인자는 명명된 인자를 스프레드 문법으로 전달하는 방식으로 가변 파라메터에 배열을 전달할 수 있다. 다음의 예를 보자.
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    foreach($c as $key => $value) {
    	echo 'key: ';
        var_dump($key);
        echo 'value: ';
        var_dump($value);
    }
};

$fn(1, 2, ...[3, 4, 5]);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(1, ...['b' => 2], ...[3, 4, 5]);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...[3, 4, 5]);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(...['a' => 1], ...['b' => 2], ...[3, 4, 5]);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(...['a' => 1], ...[3, 4, 5], ...['b' => 2]);
// int(1) int(2) key: int(0) value: int(3) key: int(1) value: int(4) key: int(2) value: int(5)
echo "=========================================".PHP_EOL;
$fn(...[3, 4, 5], ...['b' => 2], ...['a' => 1]);
// Uncaught Error: Named parameter $b overwrites previous argument
echo "=========================================".PHP_EOL;
$fn(1, ...[3, 4, 5], ...['b' => 2]);
// Uncaught Error: Named parameter $b overwrites previous argument
```
- 먼저 스프레드 문법을 사용한 연관 배열을 통해 파라메터명을 지정하여 인자를 전달한 후, 스프레드 문법으로 파라메터명이 지정되지 않은 배열을 전달하는 것으로 가변 파라메터에 인자를 전달하는 방식을 사용한다.
- `$fn(1, ...['b' => 2], ...[3, 4, 5])`의 경우는 첫 번째 인자는 파라메터명을 지정하지 않고 그 다음 인자 부터 파라메터명을 지정하였다. 그리고 가변 파라메터는 파라메터명을 지정하지 않은 것을 알 수 있다. `$fn(...['a' => 1, 'b' => 2], ...[3, 4, 5])`의 예를 보아도 가변 파라메터 이외의 파라메터는 스프레드 문법이 붙은 연관 배열을 사용하고 가변 파라메터는 인덱싱된 배열을 사용하는 것을 통해, 파라메터의 이름을 지정하는 방식으로도 가변 파라메터만 이름을 지정하지 않는 방식으로 인덱싱된 배열을 스프레드 연산자로 가변 파라메터에 전달할 수 있다.
- 단, 가변 파라메터를 첫 번째 인자의 가장 먼저 전달하면 안 되는데 `$fn( ...[3, 4, 5], ...['b' => 2], ...['a' => 1])`의 예제를 보자. 가변 파라메터를 첫 번째 인자로 할당하여 `$a`에 3, `$b`에 4, `$c`에 5를 할당해 버려서 이미 `$b`의 값이 전달된 상태에서 `...['b' => 2]`으로 `$b` 파라메터에 다시 값을 전달해서 'Named parameter $b overwrites previous argument'라는 에러가 발생하게 된다. 마찬가지로 `$fn(1, ...[3, 4, 5], ...['b' => 2])`도 `$a`에 1, `$b`에 3, `$c`에 `[4, 5]`를 할당한 상태에서 `...['b' => 2]`으로 이미 인자가 전달된 `$b` 파라메터에 2를 할당하는 코드가 되어 같은 에러가 발생한다.
- 가변 파라메터는 함수의 파라메터 중에서 하나만 지정할 수 있고, 마지막 파라메터로 정의해야 한다. 명명된 인자를 하나라도 할당한 이후에는 가변 인자를 제외한 나머지 인자도 명명된 인자로 할당해야 하고 어차피 나머지가 명명된 인자로 할당되기 때문에 가변 인자를 전달하기 위한 스프레드 문법의 인덱싱된 배열은 최대 하나만 존재하는 가변 파라메터에 전달될 수 있기 때문에 어느 순서에도 위치할 수 있다. `$fn(...['a' => 1], ...[3, 4, 5], ...['b' => 2])`를 `...[3, 4, 5]`가 마지막 위치로 전달되지 않아도 동작하는 것을 확인할 수 있다.
- 하나의 가변 파라메터만 사용 가능하고, 명명된 인자 뒤에 스프레드 문법의 배열로 가변 파라메터를 할당할 수 있다는 제약이 있지만, 가변 파라메터를 사용하는 것으로 배열 원소의 타입이 지정된 배열을 함수의 선언부를 통해 정의하는 방법을 사용할 수 있다.

### phpdoc을 사용하기
- phpdoc에는 array shape라는 기능이 있다. 이는 주석을 통해서 배열의 형태를 나타내는 것으로, 파라메터로 배열을 사용할 때 어떤 형태의 배열을 받는지 알 수 있게 해 준다.

### array shape
- [array-shapes](https://phpstan.org/writing-php-code/phpdoc-types#array-shapes)의 문서는 phpstan이란 정적 분석을 사용할 때 정적분석에 의한 추론으로 올바른 값이 들어갔는지 확인할 수 있는 기능을 제공한다. [phpstorm IDE의 array-shape 지원](https://blog.jetbrains.com/phpstorm/2022/02/phpstorm-2022-1-eap-3/)으로 phpdoc의 array-shapes 구문을 사용할 때, 코드에서 지정한 값의 타입 및 접근 방식 등의 추론을 통한 자동 완성이 강화되었다.
```php
/**
 * @param $arr array{c: int, d: int}
 */
$fn = function (int $a, int $b, array $arr) {
    var_dump($a);
    var_dump($b);
    var_dump($arr['c']);
    var_dump($arr['d']);
};

$fn(1, 2, ['c' => 3, 'd' => 4]);
```
- 위와 같은 코드를 작성하게 되면, IDE에 의해서 `$arr[|]` (|는 문자열 입력 커서의 위치)정도만 입력해도 `$arr['c']`, `$arr['d']`에 대한 자동완성이 보여지게 된다. 이런 방식을 통해서 배열에 어떤 값이 들어가 있는지 알 수 있게 해 준다는 것이다.
- 하지만 이러한 지원은 어디까지나 주석으로 코드의 변경에 따라 주석이 업데이트 되지 않는 경우가 생길 수 있으므로 개인적으는 php 문법적인 제약이 이뤄졌으면 바람이 있으며, 배열의 구조를 표기하지 못하는 것이 마음에 들지 않기 때문에 어쩔 수 없이 쓰는 방편일 뿐이다.
```php
/**
 * @param $arr array<int, string>
 */
$fn = function (int $a, int $b, array $arr) {
    var_dump($a);
    var_dump($b);
    var_dump($arr[0]);
    var_dump($arr[1]);
};

$fn(1, 2, ['c', 'd']);
```
- 제네릭을 사용해서 위와 같이 표기할 수도 있다. php에서 인덱싱 된 배열의 키는 수이므로 제네릭 표시 `<int, string>`의 첫 번째 타입은 키의 타입으로 인덱스를 의미하므로 int를 두 번째 타입으로 키에 대응하는 벨류의 타입으로 `<int, string>`을 할당해 주었다.

#### array shape의 제약사항 설정하기
- 단순히 주석만으로 표기하므로 문법적인 제약이 없는 문제점이 있는 것에 대한 대안으로 함수 내부 코드의 맨 윗줄에 사전 조건을 달아주는 방법을 사용해 볼 수 있다.
```php
/**
 * @param $arr array{c: int, d: int}
 */
$fn = function (int $a, int $b, array $arr) {
    assert(array_key_exists('c', $arr), "Key 'c' does not exist in the array.");
    assert(is_int($arr['c']), "Value of 'c' key must be an integer.");
    assert(array_key_exists('d', $arr), "Key 'c' does not exist in the array.");
    assert(is_int($arr['d']), "Value of 'd' key must be an integer.");
    var_dump($a);
    var_dump($b);
    var_dump($arr['c']);
    var_dump($arr['d']);
};
```
```php
/**
 * @param $arr array<int, string>
 */
$fn = function (int $a, int $b, array $arr) {
    assert(array_reduce(array_keys($arr), fn($acc, $v) => $acc && is_int($v), true), 'All array keys must be integers.');
    assert(array_reduce($arr, fn($acc, $v) => $acc && is_string($v), true), 'All array values must be strings.');
    var_dump($a);
    var_dump($b);
    var_dump($arr[0]);
    var_dump($arr[1]);
};

$fn(1, 2, ['c', 'd']);
```
- assert 문법은 로컬이나 테스트 환경에서 동작하고 실제 서버에서는 동작하지 않도록 설정한 후 사용하는 문법이다. 배열에 원소가 많다면 모든 원소를 순회해서 키나 값을 확인해야 하기 때문에 리소스가 많이 들어간다. 따라서 assert로 배열의 제약사항을 확인할 수 있는 코드를 짜는 것은 적절하다.
- assert 문법은 코드의 시작점에 적어서 함수의 선언부와 함께 읽을 수 있도록 만드는 것이 좋다.

### DTO 사용하기
- DTO란 Data Transfer Object의 약자이다. 데이터 전송 객체는 데이터를 전달할 때의 규격을 정한다. Dto는 데이터를 전달하는 운반자의 역할을 하기 때문에 비즈니스 로직이나 어떤 알고리즘이 들어가지 않는 값을 담을 수 있도록 만든다.
- php에서는 클래스를 통해서 타입을 만들 수 있다. 클래스를 하나 만들어 파라메터로 클래스를 타입힌트로 사용하고, 해당 클래스로 만든 오브젝트를 인자로 전달하는 것을 통해 전달 받는 인자의 스펙을 명확하게 할 수 있다.
```php
$fn = function($a, $b, Dto $cdObj) {
    var_dump($a);
    var_dump($b);
    var_dump($cdObj->c);
    var_dump($cdObj->d);
};

$fn(1, 2, new Dto(3, 4));
echo "=========================================".PHP_EOL;
$fn(1, 2, new Dto(...[3, 4]));
echo "=========================================".PHP_EOL;
$fn(1, 2, new Dto(...['c' => 3, 'd' => 4]));

class Dto
{
    public function __construct(
        public int $c,
        public int $d,
    ) {
    }
}
```
- 위의 예를 보면 Dto라는 클래스를 함수 `$fn`의 파라메터의 타입힌트로 지정하였다. `$fn` 함수는 값을 받을 때 `new Dto(3, 4)`로 객체화 된 파라메터로 전달 받는다. 배열이었다면 `['c' => 3, 'd' => 4]`의 값이 전달되었을 것이다. Dto는 메소드로 정의한 데이터만 받을 수 있고 가져올 수 있다. 위의 예제에서 Dto 클래스는 c와 d라는 값을 받고, c와 d 값을 꺼내 쓸 수 있도록 제한되어 있다. 배열을 타입힌트로 했다면 함수 `$fn`은 어떤 형태의 배열을 받아야 할지 명확하지 않기 때문에 내부의 구현을 확인해야 한다. 하지만 Dto는 가질 수 있는 값이 정해져 있기 때문에 어떤 값을 배열에서 사용하는지 알 수 있다.
- 문제는 타입힌트를 사용하기 위해서 클래스를 만들어야 한다는 것인데, 함수에 인자를 전달하기 위해서 인자를 생성하는 부분에서 객체를 생성하기 위해서 클래스 코드가 존재해야 하며, 함수의 파라메터를 타입힌트로 쓰기 위해서 클래스 코드가 존재해야 한다. php에서는 일반적으로 하나의 php 파일에는 하나의 클래스를 정의하는 것이 일반적이다. 하나의 파일에 정의된 클래스를 다른 파일에서 사용하기 위해서는 네임스페이스를 정의해 줘야 하고, 네임스페이스를 통해서 클래스를 import 해야 Dto 클래스를 타입힌트로 사용할 수 있다. 단순히 함수의 파라메터에 배열을 사용하는 것을 피하기 위해 DTO 클래스를 별도의 파일로 분리해야 하므로 파일의 배치, 폴더 구조, 네임스페이스 정의 등 보일러 플레이트가 많아진다는 단점이 생긴다. 일반적으로 DTO 클래스는 별도의 DTO를 모아둔 폴더에 정의한다. 이를 위해서 DTO를 분류하기 위한 폴더를 정의해야 하고, DTO 클래스의 php 파일을 생성해야 한다.

#### Dto 클래스의 보일러 플레이트 줄이기
- PSR(PHP Standards Recommendations)에 따르면 'Namespaces and classes MUST follow an "autoloading" PSR: [PSR-0, PSR-4]'으로 클래스와 네임스페이스는 PSR-0과 PSR-4를 따라야 한다고 되어 있다. PSR-0과 PSR-4는 오토로딩(php에서의 import와 export의 구현)에 관한 규약이다. 반드시 import와 export가 될 수 있도록 만들어야 하는데, 이를 따른다면 하나의 파일에 하나의 하나의 클래스(인터페이스, 추상클래스, 이넘)를 정의해고 네임 스페이스를 달아 주어야 한다.
- 하지만 php의 문법으로는 하나의 파일에 여러 클래스를 만들 수 있으며 문법적으로 제약되어 있지는 않다. 오토로딩은 php에서 import와 export를 구현하기 위해서 만든 것으로 외부로 export 되는 클래스를 메인 클래스로 하고 네임스페이스를 달고 외부로 export할 필요가 없는 클래스는 같은 파일에서 네임스페이스를 정의하지 않는 방식으로 사용하면, 오토로딩의 동작에 영향을 주지 않으면서 한 파일에 두 개 이상의 클래스를 만들 수 있기 때문에 메인 클래스에서 필요한 DTO를 하나의 파일에 만들어 보일러 플레이트를 줄일 수 있다. 하지만, PSR에는 'classes MUST follow an "autoloading" PSR'라고 적혀있기 때문에 PSR을 위반하고 싶지 않은 경우에는 같은 폴더에 서브 클래스를 정의하는 방법을 사용할 수 있다.
- PSR을 따르면서 좀 더 보일러 플레이트를 줄이기 위해서는 같은 네임스페이스를 갖는 폴더에 클래스 파일을 하나 더 생성하면 import 할 때 필요한 네임스페이스를 생략할 수 있고 DTO를 분류하기 위한 폴더를 만들 필요가 없기 때문에 좀 더 간단히 DTO 클래스를 작성할 수 있는 장점이 있다. 하지만 여전히 DTO 클래스를 export 하기 위해서 네임스페이스를 정의해야 하기 때문에 약간의 보일러 플레이트를 요구한다.

### 캡슐화 이용하기
- DTO를 사용하기 위해서는 별도의 파일을 만들어 클래스를 정의 해야 한다는 불편함, 하나의 파일에 둘 이상의 클래스를 만드는 등의 방식이 맘에 들지 않는 경우, 배열의 데이터를 특정 방식으로만 조작할 수 있도록 제한을 건 익명 클래스(Anonymous class)를 만드는 방법이 있다.
- 배열에 관한 모든 조작을 익명 클래스에 위임하는 방법을 사용하여, 데이터 저장소의 컨트롤에 관해서는 캡슐화된 오브젝트에 맡기고 오브젝트에서 제공하는 메소드를 사용해서 값의 생성, 변경, 취득하는 방식을 사용한다. 이 방법은 배열에 관한 구체적인 조작을 익명 클래스 외부에서 하지 않는 것으로 배열에 대한 관심사가 집중된 익명 클래스 이외에서는 배열에 대한 구체적인 조작을 피하는 방식으로 사용된다. 
```php
$cdStoreObj = new class {
    private arrary $arr;

    public function setC(int $c): self
    {
        $this->arr['c'] = $c;
        return $this;
    }

    public function setD(int $d): self
    {
        $this->arr['d'] = $d;
        return $this;
    }

    public function getArr(): array
    {
        return $this->arr;
    }
};

$controllData->setC(3)->setD(4);

$fn = function($a, $b, object $cdObj) {
    $cdArr = $cdObj->getArr();
    var_dump($a);
    var_dump($b);
    var_dump($cdArr['c']);
    var_dump($cdArr['d']);
};

$fn(1, 2, $cdStoreObj);
```
- 익명 클래스를 사용해서 오브젝트를 만드는 방법은 익명 클래스를 타입힌트로 사용할 수 없기 때문에 적당한 타입인 object을 주었다. 타입힌트로 지정할 수 없기 때문에 IDE의 추론도 제약된다. 그러나 같은 폴더에 정의했기 때문에 경우에 따라 IDE가 추론해 주는 경우도 있다.
- 배열의 메소드를 통해서 값을 정의하기 때문에 위 `$cdStoreObj`는 c값과 d값만을 세팅 및 변경할 수 밖에 없고, c값과 d값만 취득할 수 밖에 없다는 것을 알 수 있다. 그런데 배열을 사용하는 것에 비해서 더 나은 것이 없어 보인다. 왜냐하면 `object $cdObj` 대신에 `array $cdArr`을 만들면 되기 때문에 굳이 익명 클래스를 적을 필요가 없기 때문이다.
- 오브젝트는 다양한 구현이 존재하면 일반적인 구현이란 것이 존재하지 않는다. 배열과 달리 오브젝트를 전달 받았다는 것은 오브젝트 내부의 프로퍼티나 메소드를 접근하지 않고 사용하거나 특수한 형태의 오브젝트만을 사용하는 것이기 때문에 개발자는 전달된 오브젝트의 구현을 확인하려고 할 것이다. 익명 클래스를 배열 대신에 전달하는 방식은 전달되는 배열의 데이터가 많고 복잡한 경우, 캡슐화된 객체를 통해서 배열을 다루어 배열을 어떻게 다뤄야 할지 그 사양을 나타내고 있으므로, 전달되어야 하는 오브젝트로 어떻게 배열을 다루어 전달을 해야할지 알 수 있게 해 준다. 따라서 단순한 배열인 경우에는 그냥 array 타입으로 받는 것이 좋겠지만, 복잡한 배열인 경우에는 위와 같은 방식을 사용할 수도 있다.

## 감상
- php의 배열 타입을 사용할 때, 배열이 인덱싱된 배열을 받는지, 연관 배열을 받는지, 배열의 특수한 인덱스나 키에 의존하는 로직이 들어가는지, 함수의 선언부의 정의만으로 동작이 어떻게 이뤄질지 예측하기 어려운 경우가 있다. 추상화를 하는 이유 중 하나는 동작하는 모든 코드를 읽지 않고도 사용하려는 목적이 있다. 추상화된 코드의 선언부만 보고 대략적인 동작을 추측할 수 있어야 하며, 추측한 동작 이외의 예외적인 동작의 가능성을 최대한 낮춰 예측 가능한 코드를 만들어야 모든 코드를 일일이 확인하지 않고 코드를 만들어 갈 수 있다.
- 단순한 프로그램을 짜는 경우 그냥 모든 코드를 읽어도 되지만, 코드의 길이가 늘어나고, 프로젝트에 참여하는 인원이 늘어나고, 복잡한 로직을 처리해야 하고, 추상화를 도입하는 상황에서 모든 코드를 읽고 해석하는 것은 비효율적이다. 프로젝트를 관리하고 성장시키기 위해서는 명확하고 이해하기 쉬워야 하고, 재사용 하기 좋아야 하기 때문에 이를 위한 더 많은 룰을 도입해야 한다.
- php는 엄격하지 않게도 만들 수 있고, 엄격하게도 만들 수 있는 자유도가 높은 언어이다. 생산성을 위해서 상황에 따라 덜 엄격하게 만들기도 하며, 프로젝트 관리를 위해 더 구체적이고 엄격하게 만들 수도 있다. 그래서 덜 엄격한 로직에서 더 엄격한 로직으로 전환하기 쉽게 코드를 짤 수 있는 역량이 요구된다. php는 다른 엄격한 언어에 비해 비교적 제약이 적은 동적 언어라서 쉽다는 편견이 있지만, 상황에 맞게 유연하게도 엄격하게도 짤 수 있는 특성을 가진 의외로 어려운 언어가 php이기도 하다. 프로젝트에 참여하는 구성원이 어떻게 엄격하게 만드는지에 관한 지식이 없다면, 동적 언어의 변수가 다양한 값의 특성으로 인해 코드를 의도한 바와 달리 이해할 가능성이 높아지고, 잘못된 이해를 바탕으로 코드를 만들어 더 엉망인 코드를 만들어 내는 문제점이 생긴다. 잘 이해하고 잘 이해할 수 있도록 추상화 할 수 있는 능력이 필요하기 때문에 프로젝트가 성장하면서 사내 스터디 도입, 엄격한 코드 관리, 강타입 언어로의 전환 등을 모색한다.
- 이런 문제를 야기하는 대표적인 케이스로 php의 배열을 꼽을 수 있으며, php에서 배열을 다루는 여러가지 방식 또는 배열을 대체하는 방법을 소개하는 것을 통해서 상황에 맞는 적절한 솔루션을 찾을 수 있도록 글을 작성하였다. 도움이 되길 바란다.

## Reference
- https://www.php.net/manual/en/functions.arguments.php
