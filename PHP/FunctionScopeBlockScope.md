# 함수 스코프와 블록 스코프

# 도입

문법상의 계보로 따졌을 때 C 계열의 언어가 있다. C, C++, C#, JAVA, Javascript, php는 C의 문법적 스타일을 물려 받은 언어로 C계열의 언어라고 부른다.

많은 사람들이 처음 php를 접할 때는 C 계열의 언어인 것에 비해, 다른 C 계열의 언어와 다른 문법적인 특징을 가지는 것이 많아서 php에 거부감을 느끼는 경우가 있다. 이런 거부감을 느끼게 하는 요인 중 하나는 php에는 변수를 선언하는 키워드가 없고, 블록 스코프가 없다는 점이다.

php를 잘 활용하기 위해서는 블록 스코프가 있는 언어와 블록 스코프가 없는 언어의 차이점을 잘 이해하고, 블록 스코프가 없는 언어의 코딩 스타일을 이해하는 것이 중요하다.

# 본론

## 스코프란?

스코프란 변수의 유효 범위를 뜻한다. 보통은 블록 또는 함수 블록이 열렸을 때, 블록 내부에서 선언된 변수는 블록이 닫히면 소멸한다. 블록 안에서 선언된 변수는 블록 밖에서 사용할 수 없다.

## 인터프리터 언어

ES6 이전의 자바스크립트, PHP, 파이썬 등의 인터프리터 언어는 함수 스코프를 가진다.

## 자바스크립트로 이해하기

자바스크립트는 `var`로 선언된 변수는 함수 스코프를 가지고 있고, `const`나 `let`으로 선언된 변수는 블록 스코프를 가지고 있다.

(이 글은 php를 위한 설명이므로 다음 자바스크립트의 예에서 좀 더 알기 쉽도록 변수에 $를 붙여 주었다.)

### 블록 스코프

```js
if (true) {
    let $a = 10;
}

console.log($a); // Uncaught ReferenceError: $a is not defined
```

블록 내에서 선언된 $a는 블록 밖에서 접근할 수 없다.

```js
fn = function () {
    let $a = 10;
}

console.log($a); // Uncaught ReferenceError: $a is not defined
```

함수 내에서 선언된 $a는 블록 밖에서 접근할 수 없다.

### 함수 스코프

```js
if (true) {
    var $a = 10;
} else {
    var $b = 20;
}

console.log($a); // 10
console.log($b); // undefined
```

자바스크립트의 전역 변수는 전역 스코프를 함수 스코프로 한다. 함수 내부에 있지 않지만 함수 스코프의 변수는 전역 스코프를 함수 스코프로 사용한다고 보면된다.

자바스크립트에서는 php의 `isset`과 같은 정의된 변수인지 아닌지 확인하는 기능이 존재하지 않는다. 그래서 변수를 선언하는 코드가 실행되지 않더라도 변수를 사용하는데 에러가 발생하지 않도록 해야 한다. 자바스크립트는 에러를 발생시키지 않는 대신 `undefined` 값으로 표기하는 방식을 사용한다.

함수 스코프를 가진 변수 $b는 실행이 되지 않았음에도 불구하고 에러가 아니라 `undefined` 값이된다.

```js
const fn = function () {
    var $a = 10;
}

console.log($a); // Uncaught ReferenceError: $a is not defined
```

함수 스코프 안에서 선언된 변수는 함수 밖에서 접근할 수 없다.

함수 스코프를 가지는 변수가 블록 안에서 선언되었을 때는 `undefined` 값으로 접근할 수 있었던 것에 반해서, 함수 스코프 밖에서는 `undefined` 값으로 접근하는 것이 아닌 에러를 발생시킨다.

## php 코드

### 블록 스코프 없음

```php
if (true) {
    $a = 10;
}

var_dump($a); // 10
```

블록 안에서 선언되었지만, 블록 밖에서 블록 안에서 선언된 변수를 사용할 수 있다.

```php
if (false) {
    $a = 10;
}

var_dump($a); // Warning: Undefined variable $a
```

자바스크립트에서 함수 스코프를 사용하는 `var` 선언 키워드는 변수를 호이스팅하여 런타임에 실행되지 않은 변수더라도 에러가 아닌 `undefined`가 할당되도록 한다. 함수 스코프를 사용하는 php이지만 자바스크립트의 호이스팅과 같은 기술이 없어서 에러가 발생한다.

```php
if (false) {
    $a = 10;
}

var_dump($a ?? null); // null
```

php에는 `isset`, `??`, `??=`등의 문법으로 정의되지 않은 변수를 확인하는 키워드가 있기 때문에, 정의되지 않은 변수 사용이 에러를 발생시키더라도 실행 중에 에러를 발생시키지 않고 코드를 전개할 수 있다.

### 함수 스코프 있음

```php
$fn = function () {
    $a = 10;
};

var_dump($a); // Warning: Undefined variable $a
```

`$a` 변수의 선언은 함수 내에서 이뤄지기 때문에 함수 밖에서 이 변수를 사용할 때 정의되지 않았다는 에러가 발생한다.

## 블록 스코프의 장점

블록을 사용하면, 변수는 블록 안에서 선언되고, 선언된 블록 밖에서는 접근할 수 없게 된다. 이는 변수가 소멸된다기 보다는 접근을 못하게 되는 것으로 블록 안에서 선언하고 블록의 닫힘과 함께 쓰임을 다하는 블록 안에서만 쓰이는 임시적인 변수를 부담없이 만들 수 있다는 장점이 있다. 변수를 많이 만들더라도 로직의 흐름을 기술하는 부분의 변수의 갯수를 억제하고, 흐름을 구성하는 부분에서 임시로 사용할 변수를 부담없이 생성할 수 있다는 장점이 있다.

### 블록 스코프가 없을 때의 문제

블록 스코프가 없고 함수 스코프만 사용할 수 있는 언어에서, 블록은 변수의 유효 범위를 설정하는 용도가 아닌, 제어의 흐름을 나타내는 if, for, switch 등의 문법들과 함께 이들 문법의 작용 범위를 정하는 용도로 사용된다. 블록 스코프가 없기 때문에 함수 내에 선언되는 모든 변수는 블록 안에 있더라도 이들 블록을 감싸는 함수 스코프 안에 변수가 추가된다.

블록 스코프라면, 블록의 내부에 임시 변수를 사용해서 쓸 수 있겠지만, 블록 스코프가 없는 경우는 임시적으로 사용할 변수를 선언할 때, 블록의 종료와 함께 사라지는 것이 아니고 블록들을 감싸고 있는 함수 스코프에 그대로 남게 된다는 문제점이 발생한다.

특정 맥락에서 일시적으로 사용하는 변수가 함수 스코프 전체에 남게 되면서, 함수 내부의 로직이 길어지면 길어질수록 일시적으로 사용되는 변수가 함수 스코프 영역에 더 많아지는 문제가 발생한다. 이 때문에 무엇이 쓰는 변수이고 무엇이 쓰이지 않는 변수인지 구분하기 어렵게 된다.

## 블록 스코프가 꼭 필요할까?

블록 스코프가 없을 때 로직이 길어질 수록 임시적으로 쓰이는 변수가 늘어나게 되므로, 블록 스코프를 도입하자는 의견에 대해, 애초에 하나의 함수 스코프를 길게 잡는 것이 올바른 코딩 프렉티스가 아니라는 의견으로 맞선다.

하지만 때때로 하나의 스코프 내에 장황하게 쓸 수 밖에 없는 로직이 있고, 로직을 분리하는 것이 어색한 경우가 있을 수 있으므로 블록 스코프를 도입하는 것이 좋다는 의견이 있다.

## 필요하다면 함수 스코프를 사용하자.

기본적으로 하나의 함수 스코프의 로직을 장황하게 작성하지 않기 위해서 노력해야 한다. 함수로 로직을 나누는 것이 어려운 경우, 함수 스코프를 사용하여 로직을 분리해서 작성할 것을 권한다.

함수를 사용하는 것은 로직의 명칭을 부여하기 때문에 해당 스코프가 갖는 역할이 무엇인지 나타내고 개념적인 분리를 통해서 블록 내부의 코드를 읽지 않고서도 코드의 흐름이나 맥락을 함수의 시그니처를 통해서 알 수 있게 해 준다는 장점이 있다. php의 함수는 외부 변수를 캡쳐하기 위해서 `use` 키워드를 사용해야 하기 때문에, 지정한 함수의 동작을 위해서 어떤 외부 변수를 사용해야 하는지도 쉽게 알 수 있다.

블록은 함수의 시그니처를 쓰지 않아도 되어 편리한 반면, 특별한 명칭이 없기 때문에 블록의 역할을 사용된 문법과 맥락에 따라 생각해 내야 하는데, 블록 스코프가 없고 함수 스코프만 있는 언어는 함수를 사용하면 이름을 붙여주기 때문에 임시 변수를 사용하는 경우 적절한 함수 추상화를 권장하는 압력을 받는다.

함수로의 추상화는 함수의 시그니처로 함수의 역할을 대략적으로 알 수 있도록 하며, 임시 변수를 가져야 하는 블록에 이름을 부여하여 단위 로직의 사용 의도를 명확하게 할 수 있다는 장점이 있다.

### 즉시 실행함수 사용하기

때때로 함수로 분리하는 것은 코드를 늘려 장황한 느낌을 줄 수 있어 함수 사용을 피하고 싶을 수 있다. 또한 굳이 재사용할 필요가 없는데도 함수로 만들게 되면 마치 재사용해야 할 것과 같은 인상을 줄 수 있어 함수 사용을 피하고 싶을 수 있다. 또한 흐름상 변수만 격리하는 패턴의 코드를 만들고 싶은 경우가 있다. 이 때는 즉시 실행 함수를 사용하여 코드를 만들 수 있다.

#### 즉시 실행함수의 예

```php
$outerVariable = 10;

$result = (function () use ($outerVariable) {
    $innerVariable = 20;
    return $innerVariable + $outerVariable;
})();

var_dump($result); // 30
```

익명 함수를 정의함과 동시에 `(function () {})()`의 방식으로 함수를 변수에 담지 않고 실행하는 방법이다. php에서는 블록 스코프가 없으므로, 블록 스코프 대신에 함수 스코프를 사용해서 스코프의 범위 내에서만 임시적으로 사용할 수 있는 변수를 사용하는 문법을 사용할 수 있다.

#### 스코프 중첩을 장려하지 않는 문법

즉시 실행 함수 사용의 문제는 함수 스코프에 외부의 변수를 전달하기 위해서 `use` 키워드로 함수 밖에서 함수 내부에 사용할 변수를 전달해 주어야 하므로 보일러 플레이트가 많아진다는 점이 있다.

하지만 스코프를 만들 때 마다 변수를 캡쳐하기 위해서 보일러 플레이트를 많이 사용해야 하므로 많은 익명 함수로 스코프를 만들 때 깊은 중첩은 그 만큼 더 많은 보일러 플레이트를 만들기 때문에 스코프의 중첩을 억제한다.

일반적으로 스코프의 중첩이 많은 로직은 읽기 어렵고, 메인테인스 하기 어려운 경우가 많기 때문에 깊은 중첩을 장려하지 않게 하는 압력이 있다는 것은 좋은점이다.

하지만, 일부 케이스에 대해서는 로직을 분리하기 보다는 깊은 중첩이 나은 경우가 있을 수도 있다. 하지만 극소수의 케이스를 위해서 깊은 중첩이란 안티 패턴을 장려할 필요는 없을 것이다. `use` 키워드로 외부 스코프의 변수를 캡쳐하는 것은 보일러 플레이트를 늘리지만, 보일러 플레이트 때문에 중첩을 장려하지 않기 때문에 괜찮은 문법이라 할 수 있다.

#### 함수 스코프 남발의 코드 스멜 논란

블록 스코프가 없기 때문에 임시적으로 사용할 변수의 공간을 만들기 위해 즉시 실행 함수의 사용을 남발하는 코드를 만들 수 있는데, 다른 언어의 코드 베이스에서 보기 어려운 코드 스멜이 나는 코드가 될 수 있다는 점이다. 이걸 블록 스코프가 없고 함수 스코프만 있는 언어가 가지는 적합한 코딩 스타일인지, 코드 스멜인지 논란의 소지가 있다.

#### 객체지향으로 스코프 중첩 억제하기

최근의 자바스크립트는 객체지향 보다는 절차지향과 함수형 프로그래밍을 활용하여 코드를 작성하는 경우가 많다. 그래서 로직의 흐름을 나타내는 코드의 부분을 담당하는 코드를 블록으로 스코프를 구분하여 임시 변수 생성하는 코딩이 좋다.

php는 객체지향 기법을 장려하는 언어로 로직의 큰 흐름에서 부분을 담당하는 코드는 메소드로 분리해서 코드를 작성하는 스타일이 권장되므로 객체 지향을 잘 활용한다면 함수 스코프를 남발하는 코드의 작성은 억제되므로 익명 함수의 남발을 줄일 수 있다.

## 알아두면 좋은 것들

### unset을 사용한 임시 변수 관리

때때로, 코드의 전개 과정에서 짧은 단위의 코드에서만 사용되고 더 이상 사용되지 않는 임시 변수를 만들 때는 `unset`을 활용하여 함수 스코프의 변수가 오염되지 않도록 코드를 만드는 것이 좋을 수 있다.

함수 스코프의 코드가 짧은 경우에는 `unset`을 굳이 사용하지 않아도 되지만, 하나의 스코프에서 코드가 길어질 경우에는 `unset`으로 사용이 끝난 변수를 제거하여 변수 공간이 오염되지 않는 전략을 사용할 수 있다.

하지만 블록이 없기 때문에 선언된 변수가 언제 `unset`이 되는지 확인해야하는 문제가 있으므로, 한 눈에 알아볼 수 있을 정도의 몇 줄 정도의 짧은 코드에 한해서만 선언된 코드와 동시에 값의 할당을 해제하는 방식을 써야 한다. '매우 긴 로직 + 몇 줄 정도의 짧은 코드'에서만 `unset`을 통한 변수의 할당 해제가 적합한 코딩 스타일이다. 그 이외의 임시 변수의 선언 후, 이 변수를 사용하는 코드의 길이가 길어질 경우 함수 스코프를 할당하여 해결하도록 하자.

`unset`을 남발하는 것은 CPU의 리소스 소모를 증가시키므로 좋은 코딩 스타일은 아니다. 하지만, `unset`으로 더 이상 변수가 정의되지 않게 되는 경우, 추가되는 코드를 작성하는 사람이 해당 변수를 사용하려고 해도 접근할 수 없게 되기 때문에 임시 사용을 하기 위해 사용한 변수라서 더 이상 접근하면 안 되는구나를 확실하게 알게 해 준다.

### 스코프와 변수 섀도잉 (Variable Shadowing)

변수 섀도잉이란? 스코프 밖의 변수를 스코프 안에서 별도의 캡쳐 구문 없이 사용할 수 있는 블록 스코프를 가진 언어에서 스코프 밖의 변수와 동일한 이름의 변수를 스코프 안에서 선언해서, 상위 스코프의 변수를 하위 스코프에서 덮어 씌우는 것을 의미한다.

스코프의 중첩이 깊어지면, 특정 변수가 상위 스코프의 어디에서 가져온 것인지 하위 스코프의 어디에서 섀도잉이 되었는지 파악해야 하는 문제가 생긴다. 변수명이 같기 때문에 어디서 선언된 변수인지 알아야 변수를 사용할 때 잘못된 사용을 방지할 수 있다. 자바스크립트에서 변수 선언 키워드로 `const`가 존재하는 것은 하위 스코프의 변수가 덮어 써 지는 것을 방지하기 위함이다.

php에서 함수 스코프는 `use` 키워드를 사용해서 함수 스코프 밖의 변수를 함수 내부로 가져와야 하고, `use` 문으로 어떤 이름의 변수명을 캡쳐하는지 알 수 있기 때문에 함수 내부에서 선언한 변수를 `use` 키워드로 가져온 것과 동일하게 선언할 가능성이 적다. 자바스크립트가 의도하지 않았는데 변수 섀도잉이 일어나는 것을 방지하기 위해 `const`를 도입한 것과 달리 php의 스코프는 자동 섀도잉이 일어나지 않기 때문에 `const`와 같은 선언 키워드가 필수적으로 요구되지 않는다.

php에서 화살표 함수 `fn($param) => $param + $captured`는 `use` 키워드 없이 외부의 변수를 캡쳐할 수 있는데, 화살표 함수는 `=>` 뒤에 바로 반환 값이 위치해야 하기 때문에 화살표 안에서 새롭게 선언되는 변수는 화살표 함수의 파라메터이다. 변수의 선언과 동시에 사용하는 것을 바로 알 수 있으므로, 상위 스코프의 변수를 덮어 씌우더라도 바로 사용되는 임시 변수이기 때문에 변수가 덮어 씌워진 것이므로 로직에 큰 영향을 끼치지 않는다.

## 마지막으로

php 백앤드 개발을 하고 있다면, 자바스크립트를 함께 사용하는 경우가 많다. 그런데 자바스크립트에는 잘 되는데, php에서는 잘 안되는, php에서는 되는데 자바스크립트에서는 잘 안되는 여러가지 특징에 혼란스런 경험이 있을 것이다.

특히 자바스크립트는 변수의 선언 키워드 `var`, `const`, `let`가 존재하는데, php에서는 왜 없는지 의문을 느끼는 사람들이 있을 것이다. 블록 스코프, 함수 스코프의 개념과 관련된 좋은 코딩 스타일에 대한 개념을 이해하면, (지역변수에) 변수의 선언 키워드가 없는 php의 코드를 작성하는데 특별한 불편함이 없이 코딩을 잘 할 수 있는 이유를 이해할 수 있다.

## References

- https://externals.io/message/109029
- https://stackoverflow.com/questions/16557218/when-unset-should-really-be-used
