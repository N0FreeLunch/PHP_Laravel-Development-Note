## Assert란?
- Assert는 어떤 값의 조건을 검사하는 기능으로, Assert 문에 부여한 조건이 거짓일 경우 에러를 내거나 프로그램의 실행을 중단하는 등의 역할을 한다.
- 자바나 C#과 같은 언어에서는 예외를 부여하며, C++의 경우는 메시지와 함께 프로세스의 실행을 종료한다.
- 보통 Assert는 개발 환경에서 동작하며, 프로덕션 환경에서는 비활성화 되도록 설정이 된다. 이는 Assert와 같은 검사가 프로그램의 실행 속도를 늦추기 때문이다.
- 로컬의 개발 환경에서 테스트를 할 때만 활성화하여 실수나, 버그를 방지하는데 사용한다.

### Assert를 어떻게 사용해야 할까?
- 어떤 함수가 있다고 하자. 함수 내부로 들어오는 모든 케이스를 대비하는 코드를 만들 수도 있지만 이는 비효율적이다. 함수 내로 들어올 수 있는 값의 범위를 한정해서 해당 범위에서만 동작하는 로직을 만드는 것으로 코드를 좀 더 간결하게 만들 수 있다. `assert`를 사용해서 함수 내부로 들어오는 값을 검증하여 함수 내에서 이뤄질 코드의 동작을 특정 범위 내로 제한할 수 있으므로 코드를 간결하게 짜는데 도움을 준다.

### 컴파일 언어에서 Assert
- 컴파일 언어에서 주로 검사하는 대상은 값의 범위를 검사한다기 보다는 타입이 올바른지 검사한다. 타입의 경우에는 컴파일러에서 검증하면 되기 때문에 굳이 Assert를 사용할 필요가 없으며, 논리적으로 허용되는 범위의 값인지 아닌지 검사하는데 사용된다.

### Assert의 장점과 단점
#### 장점
- 앞서 짜여진 코드에서 Assert를 사용한 기능이 있고 이를 뒤에서 짠 코드에서 사용할 때, 함수에 잘못된 입력이 일어나면 개발 과정에서 Assert가 알려주는 에러를 감지하고 에러를 발생시키므로 개발자가 코드의 실행을 검증하는 과정에서 실수를 감지할 수 있게 해 준다.

#### 단점
- 하지만, Assert는 런타임에 확인하는 동작이므로 새로운 기능을 추가한 사람이 해당 로직에 대한 충분한 실행을 했을 때 감지할 수 있으며, 가끔 코드를 충분히 실행하지 않을 때도 있기 때문에 Assert가 버그를 완전히 잡아준다는 기대를 할 수는 없다. 왜냐면 Assert는 실제 환경에서는 무시되는 코드이기 때문에 개발 환경에서 충분히 실행하지 못한다면 QA도 런타임에서도 포착하지 못하는 경우가 발생할 수 있다.
- 주로 Assert는 프로그램의 논리적인 실행에 의해서만 판단되기 때문에 다양한 방식으로 어떤 기능을 실행하는 소프트웨어에서 모든 케이스에 대한 검증을 하지 않는다면, Assert를 사용한다고 하더라도 개발 환경에서 에러를 감지하지 못할 경우가 생길 수 있다.

### Assert는 만능이 아니다.
- 어떤 사람이 어떤 로직에 대해 개발을 했다면 그가 짠 로직의 모든 케이스를 검증했다고 가정한다. 그렇다면 그 다음에 코드를 짜는 사람도 그 사람이 짠 모든 케이스에 대해 검증을 했다고 가정한다. 그런데 두 경우에서 공통적으로 사용하는 기능의 변경이 일어난 경우, 앞서 짠 로직의 코드는 코드 변경에 대해 충분한 검토가 이뤄지지 않게 된다. 이런 부분까지 Assert가 확인해 주지는 않는다.
- Assert는 단지 사람의 실수를 줄여줄 뿐이다.
- 다양한 케이스에 대해서 검증을 할 수 있는 테스트 코드가 있다면 Assert는 버그의 원인을 찾는데 도움이 될 수 있다. (테스트 코드에서 사용하는 Assert와 현재 말하고 있는 Assert는 약간 다르다. 로직의 인풋에 대한 아웃풋을 검증하는 테스트 코드와 달리 그냥 Assert는 로직 내부의 코드가 실행 될 때의 값을 검증하는 것이기 때문이다.)

### 프로덕션 Assert
- 기본적으로 Assert는 개발환경에서 사용하는 것을 기원으로 두지만, 어차피 특정한 입력을 전제로 하기 위해서 Assert를 사용하는 것이라면 잘못된 값이 들어왔을 때는 실행되지 않아야 하는 로직이란 것이다. 프로덕션 환경에서 Assert를 활성화하여 에러를 발생시키는 것을 통해서 미리 검증되지 않은 케이스에 대해 동작하는 코드를 에러로 보고함으로써 코드를 보완할 수 있다는 점이다.
- C++과 같은 언어에서 Assert는 프로세스를 졸료시키지만, 자바는 예외로 처리하고, C#은 프로덕션에서도 동작하는 별도의 Assert 기능을 도입해 두었다. Assert가 예외로 처리된다면 Assert를 통해서 입력값을 검증할 수 있을 것이다. 보통 컴파일 언어는 속도를 중시하여 프로덕션에서 이를 활성화하지 않지만, php와 같은 어차피 느린 언어라서 조금 느려도 큰 지장이 없는 비즈니스의 경우에는 Assert를 사용해서 프로덕션에서 입력된 값을 검증하는 것이 나쁘지 않을 수 있다.
- 또는 테스트 코드가 충분히 도입이 될 때까지 Assert를 사용해서 임시적으로 로직의 결점을 찾아내는 방법이 있을 것이다. 테스트 코드의 도입이 충분히 이뤄지지 않은 경우라면, 트레픽이 많지 않은 서비스일 가능성이 높고, 이 경우 속도가 좀 느려도 괜찮은 경우가 있을 것이다. 서비스의 트레픽 정도 따라서 Assert를 프로덕션에서 활성화할지 하지 않을지를 생각해 볼 수 있을 것이다.
- 하지만 Assert는 프로덕션 환경에서는 설정하지 않는데, 이는 Assert라는 문법이 도입된 목적인 프로덕션 환경에서의 리소스를 소모하지 않기 위한 용도로 만들어졌기 때문이다. 프로덕션 환경에서 에러를 띄우려면 도입된 목적에 맞지 않는 Assert 문법을 사용하지 않고, 커스텀 에러를 만들어 던져 프로세스를 멈추면 된다.

### 동적 언어에서의 Assert
- 동적 언어는 타입 제한이 강하지 않으며, 타입을 생략하는 경우도 많다. 동적 언어는 정적 언어와 달리 정적 추론으로 코드의 실수를 잡아주는 케이스도 적다. 또한 컴파일 과정에서 코드의 실행을 검증하지도 않는다. 엄격한 타입의 제한을 갖기 어려운 php에서 Assert을 사용해서 입력값을 검증하고 프로덕션에서도 제한을 거는 코딩을 하는 것을 생각해 볼 수 있다.
- 프로덕션에서 사용할 코드라면 굳이 Assert라는 것을 사용할 필요가 있는지를 생각해 볼 수 있을 것이다. 그냥 커스텀 예외를 만들면 되는 것 아닌가라는 생각을 할 수 있다. 그렇다. Assert가 커스텀 예외/에러를 만들어 던지는 것에 비해 간결한 문법을 갖고 있기 때문에 Assert가 커스텀 예외/에러를 대체할 수 있을 거라 생각해 볼 수도 있을 것이다.
- Assert는 catch로 잡아서 처리하는 에러는 아니라 완전 프로세스를 정지한 후 이를 발생 시킨 로직의 원인을 찾아 코드를 수정해야 하는 에러이다. php에서는 Assert를 통과하지 못했을 때 예외가 아닌 AssertionError라는 에러가 발생한다. 일반적으로 catch 문에 잡는 것은 예외인 Exception 류를 잡는데 Error가 발생했으므로 이에 유의하여 catch 문에 예외만을 포착하도록 잘 만들어 두었다면 에러를 캡쳐하지 않을 것이고 의도된 프로세스의 실행 중단에 이를 수 있다.
- 따라서 Assert가 커스텀 예외/에러를 대체할 수 있을 거라 생각할 수도 있을 것이다. 하지만 Assert는 환경에 따라 에러를 발생시키도록 설정할 수도 있고, 에러를 발생시키지 않게 설정할 수도 있다. 이는 프로젝트에 사용된 모든 Assert의 기능을 변경하는 것으로 일부 Assert는 에러를 발생하게 하고, 일부 Assert는 에러를 발생하지 않도록 설정하도록 만들어진 것이 아니다. 프로덕션 환경에서 무조건 Assert를 통과하지 못했을 때 에러가 발생하도록 했다면 일부 케이스에 관해서는 에러가 발생하지 않도록 하고 싶어도 할 수 없기 때문에 프로덕션 환경에서 에러를 발생시키고자 하는 것은 Assert가 아닌 커스텀 예외/에러로 처리하는 것이 옳다.

### php에서의 assert
[공식문서](https://www.php.net/manual/en/function.assert.php)에서는 다음과 같이 설명하고 있다.
> assert() allows for the definition of expectations: assertions that take effect in development and testing environments, but are optimised away to have zero cost in production.

> Assertions should be used as a debugging feature only. One use case for them is to act as sanity-checks for preconditions that should always be true and that if they aren't upheld this indicates some programming errors. Another use case is to ensure the presence of certain features like extension functions or certain system limits and features.

> As assertions can be configured to be eliminated, they should not be used for normal runtime operations like input parameter checks. As a rule of thumb code should behave as expected even if assertion checking is deactivated.

- 위의 내용을 요약하면
  1. assertion의 목적은 개발환경이나 테스팅환경에서는 적용되지만, 프로덕션 환경에서는 실행을 하지 않아 리소스를 소모하는 비용을 없애는 것에 있다.
  2. assertion은 디버깅용으로만 사용되어야 하며, 어떤 기능의 전제조건이 만족되지 않으면 에러를 발생시키는 목적 또는 어떤 기능을 실행하는데 필요한 확장 기능의 설치 및 활성화 여부, 시스템의 제약사항을 나타내는 용도로 사용된다.
  3. assertion은 제거되어도 런타임의 기능에 영향을 주지 않는 방식으로 사용되어야 한다.
- 곧, 시스템의 논리상 발생해서는 안 되는 케이스가 발생했을 때 이를 알리기 위해서 존재하는 기능으로, 정상적으로 동작하고 있다면 assert 부분이 실행되지 않을 것이므로 assert를 사용하든 사용하지 않든 동일하다는 것을 의미한다.

### Assert는 주석을 코드로 옮긴 것
- 많은 경우 런타임에 발생할 수 있는 모든 케이스를 개발 환경에서 모두 테스트 할 수는 없을 것이다. 그로 인해서 assert가 있더라도 개발 환경에서 포착하지 못한 버그가 존재할 수 있다. 그렇기에 Assert는 버그를 완전히 없애기 위한 용도로 사용되는 것이라고는 할 수 없다. 이런 불완전한 기능을 프로그래밍 언어의 문법으로 추가한 것은, 이 코드가 동작하기 위한 전제 조건 및 이러한 코드는 실행될 수 없다는 등의 용도로서 런타임의 버그를 확실하게 잡겠다는 것이 아닌, 어떤 상황에서 동작한다라는 주석을 코드화하여 표현한 것이라고 할 수 있다.
- 개발자는 Assert를 읽고 해당 기능의 전제 조건 및 제약사항을 이해하고 그에 맞게 개발하는 것이며, 단순히 주석을 코드화한 것이므로 개발자에게 기능의 전제 조건 및 제약사항을 알리기 위한 용도일 뿐, 버그를 잡기위해 반드시 사용해야 하는 기능을 의미하지는 않는다는 것에 주의하자.

### 왜 Exception이 아닌 Assert를 사용할까?
- 런타임에 동작을 멈추기 위해서는 전역 예외를 사용한다. `Exception` 클래스를 하위 클래스를 정의하지 않고 그냥 그대로 사용하는 것이다. 전역 에외를 일으키는 `Exception` 클래스의 인스턴스는 `catch` 문에서는 `Exception`의 하위 타입을 사용하며 `Exception` 클래스를 그대로 잡지 않는 코딩 방식을 사용하기 때문에 `catch` 문에서 잡지 않는 `Exception` 클래스를 이용해서 처리를 멈추는 스타일의 코딩을 한다.
- 만약 어떤 개발자가 해당 로직은 실행되지 않기 때문에 혹시라도 싪행되었을 때 예외를 처리한다면 전역 예외를 사용해서 처리를 멈출 수 있을 것이다. Assert를 실행되지 않는 로직에 사용하는 것은 상당히 많은 케이스에서 볼 수 있지만, 전역 예외를 사용하는 방식으로 처리를 해도 된다.
- 프로덕션에서 삭제해도 되는 것이 Assert라면 누가 봐도 이러한 값은 들어오지 않을 거라고 생각하는 부분에서 그냥 아무런 전제 조건 없이 두어도 괜찮을 경우, 그냥 두는 것 보다는 Assert를 사용해서 전제 조건을 명확하게 할 수 있다.
- 큰 규모의 프로그램을 짤 경우에는 개발자가 전체적인 흐름을 이해하지 못하는 경우가 생길 수 있다. 특정 부분에서의 코드를 작성하는데 확실하게 예외로 멈춰야 하는 코드인지 확신이 없는 경우, 개인적으로는 이렇게 전제 조건을 두고 코드를 짰어라고 표시해 둘 때 Assert를 사용할 수 있다. 전제를 두고 짠 것이기 때문에 만약 좀 더 거시적인 관점에서 속해 있는 기능의 전제 조건이 가정하는 범위를 넓히거나 좁히면서 기능을 수정할 수도 있고, Assert로 가정한 전제 조건이 옳아라는 확신이 생겼을 때 예외나 좀 더 세분화된 타입을 사용한 코드로 바꿀 수도 있을 것이다.
- 어떤 기능을 개발할 때 Assert로 전제 조건을 지정하여 해당 범위에서만 개발을 하고, 해당 기능 뿐만 아니라 맥락적으로 해당 부분의 고려하여 예외를 처리하는 것이 맞는 경우 예외를 사용하도록 하는 편이 좋다.

### 전제 조건과 사후 조건
- 예를 들어 어떤 함수를 만든다고 하자. 함수에 들어오는 인자나 클로저의 캡쳐된 값은 전제 조건에 해당하고 함수의 반환 값은 사후 조건에 해당한다. 전제 조건에 대한 함수의 반환 값이 어느 정도의 유효범위 내에 있는지 확인할 때 전제 조건과 사후조건을 확인하는 용도로 assert를 사용하여 개발자의 의도를 만들었을 수도 있다.
