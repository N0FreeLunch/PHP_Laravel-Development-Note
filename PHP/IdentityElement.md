## 항등원

### 닫혀 있음
- 대표적인 정수의 연산 덧셈, 뺄셈, 곱셈, 나머지 등이 있다. 나눗셈의 경우 정수 연산에서 소수점 연산이 되지만 프로그래밍 언어에서 나머지를 버릴 수 있으므로 나눗셈도 포함될 수 있겠다.
- 이들 연산의 특징은 정수와 정수의 연산 결과가 정수가 된다는 것이다. 곧, 정수 연산에 대해 닫혀 있는 특징을 갖는다.

### 정수의 항등원
- 임의의 값에 0은 더했을 때, 그 값은 그대로이며 연산이 결과에 영향을 주지 않는다.
- 임의의 값에 0을 뺐을 때, 그 값은 그대로이며 연산이 결과에 영향을 주지 않는다.
- 임의의 값에 0을 곱했을 때, 그 값은 0이며 연산의 결과는 어떤 값의 영향을 제거하고 0의 영향만을 남긴다.
- 임의의 값에 0을 나눴을 때, 나눌 수 없기 때문에 무한 루프가 발생하거나 프로그래밍 언어에 따라 에러를 발생시킨다.
- 임의의 값에 1을 더했을 때, 그 결과값은 1이 더해진 값으로 달라진다.
- 임의의 값에 1을 뺐을 때, 그 값은 1이 빼진 값으로 달라진다.
- 임의의 값에 1을 곱했을 때, 그 값은 그대로이며 연산이 결과에 영향을 주지 않는다.
- 임의의 값에 1을 나눴을 때, 그 값은 그대로이며 연산이 결과에 영향을 주지 않는다.
- 연산 전의 값과 연산 이후의 값이 항상 같을 때 연산과 함께 사용된 값을 항등원이라고 한다. 0은 덧셈과 뺄셈에 대해서 항등원이며 1은 곱셈과 나눗셈에 대해 항등원이다.

### 항등원은 행위가 일어나지 않는 값
- 어떤 창고에 물건을 저장할 때 0은 아무것도 넣지 않은 것으로 물건을 0개 창고에 저장한다는 것은 어떤 행위가 일어나지 않은 것을 의미한다.
- 어떤 대상을 확대하는데 기본적으로 1의 값이 할당이 되어 있다면 곱하기 1을 하기 때문에 연산 전후의 값이 같아서 아무것도 하지 않는 것이 된다. 배율로 수수료를 포함한 가격을 책정한다고 하자. 초기값이 1로 설정되어 있다면 곱하기 1을 하게 되어 기본값이 된다.

### 행위의 유무를 구분하는 값
- php에서 기본타입은 정수, 소수점 수(float이나 double), 배열, 문자열, 불리언, 오브젝트, callable(호출 가능한 값), iterable(반복 가능한 값), null, resource(어떤 타입으로 정의할 수 없는 나머지 타입)이 존재한다.
- 정수, 소수점 수, 배열, 문자열, 불리언은 행위를 하지 않는 의미로 쓰는 값이 존재한다. 정수의 경우 `0`, 소수점 수의 경우 `0.0`, 배열의 경우 `[]`, 불리언의 경우 `false` 등은 어떤 동작을 실행하지 않는 의미로 사용될 경우가 있다.
- 하지만 이들 행위의 유무는 어떤 연산인지에 따라 달라지며 무조건 빈값이라고 해서 결정되는 것은 아니다. 빈값이 아닌 항등원이어야 연산에 대해 아무런 일도 일어나지 않는 값이 될 수 있다.

### if문을 통한 구분의 필요 없음
- 항등원을 변수의 초기값으로 쓰게 되면 어떤 연산에 대해서 if 문을 통해서 연산에 앞서 사용할 값인지 사용하지 말아야 할 값인지 구분할 필요가 없어진다. 어차피 초기값이 항등원이므로 연산을 해도 동일한 값이 되기 때문에 로직을 실행하지 않은 것과 동일한 결과를 얻는다.
- 어떤 연산에 대해 분기가 줄어들기 때문에 좀 더 깔끔한 로직을 만들 수 있다는 장점이 있다.

### 문자열의 항등원

#### dot
- dot(.)은 문자열을 결합하는 연산이다. 임의의 문자열에 대해서 빈 문자열을 dot(.)으로 결합하면 그 결과는 이전의 문자열과 동일하다. 빈 문자열은 dot(.) 연산의 항등원이다.
```php
echo "hello"."";
echo "hello"."world";
```
- `"hello".""`에서 `""`는 문자열 결합 연산 dot(.)에 대한 항등원에 해당한다.

#### str_replace
- `str_replace(array|string $search, array|string $replace, string|array $subject, int &$count = null): string|array`
```php
$hello = "hello";
echo str_replace("", "_", $hello);
```
- `str_replace`에서 어떤 값을 찾아서 해당 값을 `-`으로 바꾸는 위의 코드를 실행한다고 하자.
- search 부분에 빈 문자열 `""`이 들어가면 대체할 대상을 아무것도 찾지 않으므로 대체할 대상이 없어서 위의 결과는 "hello"가 그대로 나온다.
- 곧 빈 문자열은 `str_replace`의 search 부분에서 사용될 때, 아무것도 대체하지 않은 원본 결과를 반환하므로 항등원의 역할을 한다. 

### 배열의 항등원
#### 스프레드 연산자
```php
$oneToFive = [1, 2, 3, 4, 5];
$emptyArr = [];
var_dump([10, 11, 12, ...$oneToFive]);
var_dump([10, 11, 12, ...$emptyArr]);
```
- `[10, 11, 12, ...$oneToFive]`은 `[10, 11, 12]` 배열 안에 스프레드 연산자 형태의 배열을 포함될 때 `$oneToFive` 배열 안의 원소들이 `[10, 11, 12]`의 배열에 포함되어 나온다.
- 그러나 빈 배열을 스프레드 연산자로 포함하면, `[10, 11, 12]`으로 아무 원소도 추가되지 않은 결과가 나온다. 스프레드 연산자에 대해 빈 배열의 배열 안에서의 포함이란 연산에 대해 항등원이라고 볼 수 있다.

#### array_walk
- `array_walk(array|object &$array, callable $callback, mixed $arg = null): bool`를 생각해 보자.
- 배열 그 자체를 변경하고자 하는 경우 `&$array`으로 `&` 참조 기호를 사용하며, 배열 안에 든 값만 이용하고 싶다면 `$array`으로 참조 기호 없이 사용한다.
- 이 함수는 반환값을 갖는 함수가 아니다. 원본 값 그 자체를 변화 시키거나 원본 값을 활용한 다른 값을 만드는 것인데, 주어진 배열이 빈 배열 `[]`인 경우 주어진 콜백함수를 실행하지 않는다. 곧 결과값이 원본 그대로이다. 따라서 빈 배열은 `[]`은 `array_walk` 내장 함수에 대해 항등원의 역할을 한다.

#### array_map
- `array_map(?callable $callback, array $array, array ...$arrays): array`을 생각해 보자.
- 배열을 받아 콜백함수에 정의된 방식을 통해서 배열의 각 원소를 변경하고 새로운 배열을 만드는 함수이다.
- 빈 배열이 주어질 경우 `array_map`은 각각의 원소에 대해 콜백함수를 적용해야 하는데 원소가 없으므로 콜백함수를 적용하지 않고 원소가 없는 빈 배열을 반환한다. `array_map`은 빈 배열에 대해 항등원의 역할을 한다.

### 빈 값
- 프로그래밍 언어에서 다루는 많은 경우에서 빈 값은 여러 연산의 항등원에 해당한다. 따라서 초기값으로 빈 값을 할당하는 관습이 생겼다.

### 빈값, 항등원, null
- 어떤 변수의 기본값으로 빈값을 할당해야 할까? 항등원을 할당해야 할까? null을 할당해야 할까?

### null의 이점
- null은 다른 타입과 병용해서 비할당을 나타낼 때 사용한다.
- 어떤 연산을 할 때 타입이 다르면 에러가 발생하는 경우가 많다. php7 이후에는 타입을 적극적으로 사용하고 있고, php에서 제공하는 각종 기능들도 특정 타입에만 동작하는 경우가 많다.
- 어떤 타입의 값이 할당되어야 로직의 동작이 가능한데 아직 미할당을 `null`으로 두면 어떤 기능이 동작할 때 잘못된 값이 들어왔다며 에러를 발생 시키므로 로직의 전개에 앞서 할당되지 않은 실수를 예방할 수 있다.

### 빈 값의 이점
- 빈 값은 어떤 연산을 함에 있어서 영향을 끼치지 않는 경우가 많다. 따라서 `null`인 경우 따로 처리를 하는 로직을 적을 필요 없이 그냥 빈 값을 그대로 사용해도 로직에 영향을 주지 않는 방법을 통해서 분기 처리를 줄일 수 있다는 장점이 있다.
- 하지만 일부 로직에서는 빈 값이 로직에 영향을 주는 경우가 있을 수 있는데, 로직을 만들 때 빈 값은 코드에 영향을 주지 않도록 코드를 짜면 해결되는 일이긴 하다. 그러면 빈 값을 연산이나 로직의 항등원으로 이용할 수 있다.
- 기본적으로 각 타입의 빈값을 비할당으로 사용해도 괜찮은데 `null` 타입을 병용하는 것은 빈 값을 두 개 사용하는 것으로 어떤 것을 빈 값으로 사용하는지 모호하게 한다.
- 값이 할당되지 않았을 경우 에러를 발생시킬 수 있는 `null`을 병용하여, 각 타입의 빈값을 사용하지 않고 `null`만을 사용하도록 하자고 할 수도 있지만, 로직의 동작 과정에서 `null`이 아닌 빈 값이 변수에 할당되는 경우가 생길 수도 있고 이 경우 다시 `null`으로 바꾸어 처리해야 하는 문제점이 생긴다. `null`인 경우만 따로 처리하는 로직에 빈 값이 들어가서 미할당에 대한 경우를 따로 처리하는 로직이 동작하지 않을 수 있기 때문이다. 결국에는 `null`과 빈 값 모두를 체크하는 로직이 만들어지게 될 가능성이 있기 때문에 그냥 하나의 타입의 빈 값을 사용할 수 있을 때는 `null` 없이 빈 값만 사용해 주는 편이 좋아 보인다.

### 항등원
- 사실 로직을 빈 값을 항등원으로 이용할 수 있도록 만들어 주면 된다. 값을 로직에 맞추는 것이 아니라, 로직의 항등원을 빈 값이 되도록 로직을 만드는 편이 좋다.
- 예를 들어 수수료를 계산하는 로직에서 기본값을 `1`로 하고 수수료가 5%일 때 변수에 `1.05` 할당하고 곱하는 방식의 로직이 아닌, 계산할 때 `1+0`, 수수료가 5%일 때는 `1+0.05`와 같이 변수에 0이 기본값으로 할당하고 변수에 `0.05`를 넣는 방식의 코딩 스타일로 바꿀 수 있을 것이다.
- 일부 순수 함수형 코딩을 사용할 때는 항등원을 나타내는 값이 정해져 있고 어느 연산을 하더라도 항등원값은 항등원이기 때문에 기본값으로 사용하기 좋다. 하지만 순수 함수형 코딩이 좋지 않은 언어의 경우 일관된 항등원 값이 없기 때문에 빈 값을 항등원으로 쓸 수 있는 로직을 만드는 편이 좋다.

### null을 병용할 것인가?
- 빈 값을 우선적으로 사용하도록 한다.
- 빈 값을 로직에 사용할 때 항등원으로 작용하도록 로직을 구성하자. 곧 빈 값을 로직에 사용할 때는 연산을 거처도 아무런 처리도 일어나지 않은 결과와 동일한 결과가 나오게 로직을 구성하도록 하자.
- 만약 빈 값을 로직에 사용할 때 아무런 처리를 하지 않은 결과와 동일한 결과를 갖지 못하는 경우에는 `null`을 병용하는 방법을 생각해 볼 수 있을 것이다.
