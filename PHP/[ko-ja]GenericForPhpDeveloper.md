# PHP 개발자를 위한 제네릭
# PHPエンジニアのためのジェネリクス

# 도입
# はじめに

php에는 다른 언어에서 흔히 볼 수 있는 제네릭이라는 문법이 없다. PHPStan이나 Psalm과 같은 정적 분석 도구를 활용하면 docblock의 [`@template`](https://PHPStan.org/blog/generics-by-examples) 주석을 통해 제네릭을 사용할 수 있지만, 많은 양의 레거시 코드가 존재하면 정적분석 툴을 도입한다고 했을 때 코드의 수정이 만만치 않고 기존의 코딩 스타일을 정적 분석에 맞는 코딩 스타일로 바꿔야 하기 때문에 불편함이 생기므로 쉬이 도입하지 못하는 경우도 많다.

PHPには、他の言語でよく見られる「ジェネリクス」という文法が存在しません。しかし、PHPStanやPsalmのような静的解析ツールを活用することで、docblockの[`@template`](https://PHPStan.org/blog/generics-by-examples)コメントを使ってジェネリクスを利用することが可能です。とはいえ、レガシーコードが大量に存在する場合、静的解析ツールを導入しようとしても、コードの修正が容易ではなく、既存のコーディングスタイルを静的解析に適したスタイルへ変更する必要があるため、導入が困難なケースも少なくありません。

php에는 제네릭 문법이 없어서 아쉽지만 제네릭이 없더라도 제품을 개발하는데 있어 큰 지장을 주지는 않는다. 본 글은 php에서 제네릭이 없더라도 크게 불편하지 않았던 이유, 제네릭이 없더라도 이를 극복하고 php를 잘 활용할 수 있는 방법에 대해 서술한다.

PHPにはジェネリクスの文法がないのは残念ですが、ジェネリクスがなくても製品開発において大きな支障はありません。本記事では、PHPにジェネリクスがなくてもそれほど不便を感じなかった理由や、ジェネリクスがなくてもそれを克服してPHPを有効に活用する方法について述べます。

# 본론
# 本論

## 연관배열의 문제
## 連想配列の問題

php는 연관 배열이라는 자료 구조를 사용한다. 연관배열은 키-벨류 쌍의 데이터를 저장하는 방식이다. php에서 키를 지정하지 않고 배열에 데이터를 저장을 해도 0,1,2,3...의 인덱스가 생기는데 php에서 배열은 반드시 키를 가져야 하는 연관배열이므로 키를 지정하지 않은 경우 자동으로 0 이상의 정수 키를 생성하기 때문이다.

PHPは「連想配列」というデータ構造を使用します。連想配列とは、キーと値のペアでデータを保存する形式です。PHPではキーを指定せずに配列にデータを保存しても、0、1、2、3…というインデックスが自動的に付与されます。これは、PHPの配列は必ずキーを持つ連想配列であり、キーを明示的に指定しなかった場合、自動的に0以上の整数キーが生成されるためです。

다양한 종류의 자료 구조를 사용하는 다른 언어들과 달리 php는 데이터 구조로 주로 연관 배열을 사용하는데, 연관 배열은 다양한 자료구조를 연관 배열 하나로 대신할 수 있다는 장점을 가지고 있다. 여러 자료 구조에 대한 이해 없이도 간단히 사용할 수 있어서 쉽게 사용할 수 있다는 장점이 있지만, 연관배열은 너무 다양한 구조를 가질 수 있기 때문에 배열을 다루기 위해서는 배열 안에 어떤 데이터가 전달 되는지 알아야 한다는 문제점이 있다.

さまざまな種類のデータ構造を使用する他の言語とは異なり、PHPでは主に連想配列がデータ構造として使われます。連想配列は、さまざまなデータ構造を1つの連想配列で代用できるという利点があります。複雑なデータ構造の理解がなくても簡単に使えるため、扱いやすいというメリットがありますが、その一方で連想配列は非常に多様な構造を持つことができるため、配列を扱う際にはその中にどのようなデータが渡されているのかを把握しておく必要があるという問題点もあります。

```php
[
    'a' => 1,
    'b' => 'B',
    'c' => [
        'q' => [ 'r' => 's' ],
        't' => [ 'u' => false ],
    ],
    'd' => new class { public int $x = 'y'; }
    100 => 'z'
]
```

위와 같은 배열을 다루어야 할 때 이 배열을 어떻게 처리해야 할지 배열의 원소를 일관된 방법으로 다룰 수 있는 방법이 없거나 생각하기 어렵다.

上記のような配列を扱う場合、その配列をどのように処理すればよいのか、配列の要素を一貫した方法で扱う手段がなかったり、考えにくかったりします。

그에 반해서 배열의 모든 원소가 동일한 타입이라면 배열을 순회하면서 원소를 일관된 방식으로 다룰 수 있기 때문에 코딩하기에 좋다.

それに対して、配列のすべての要素が同じ型であれば、配列を走査しながら要素を一貫した方法で扱うことができるため、コーディングしやすくなります。

```php
$arr = [
    'a' => 1,
    'b' => 2,
    'c' => 100,
    'd' => 200,
];

foreach($arr as $k => $e) {
    if ($e >= 100) {
        echo "Key $k's value is 100 or more.";
    }
};

```

배열의 키는 문자열이라는 것만 알면, 배열 내부의 값이 어떤지에 관계 없이, 배열의 값은 정수이므로 if문을 통해서 수치 비교를 수행할 수 있고, echo를 통해서 문자열로 출력 할 수 있다.

配列のキーが文字列であることさえ分かっていれば、配列の中の値がどのようなものであっても、値が整数であれば if 文による数値比較を行うことができ、echoを使って文字列として出力することも可能です。

## 개념적 제네릭
## 概念的なジェネリクス

개념적 제네릭은 "가능한 다양한 타입"을 다룰 수 있는 범용적 알고리즘이나 로직을 지향하며, 특정 타입에 의존하지 않는 처리를 할 수 있을 때 '제네릭하다'고 말한다.

概念的なジェネリクスとは、「可能な限り多様な型」を扱える汎用的なアルゴリズムやロジックを指し、特定の型に依存しない処理ができる場合に「ジェネリックである」と言います。

### 타입 의존적이란?
### 型依存的とは？

제네릭을 사용하는 기능은 제네릭으로 지정한 값을 다루는 방식에 제한이 있을 수 있다. 예를 들어 변수 `$a`에 할당된 값이 `int|string` 타입이라고 가정하자. 이 변수에 연결되는 코드를 만들기 위해서는 `strtoupper($a)`와 같은 문자열을 대상으로 하는 함수와 연결하면 안 된다. 왜냐하면, `$a`가 정수인 경우 에러가 발생하여 `$a`가 가질 수 있는 타입 모두에 대해 동작하지 않기 때문이다. 그에 반해 `intval($a)`는 정수와 문자열 모두에 사용될 수 있으므로 변수 `$a`에 연결해도 좋은 코드이다. 이렇게 전달하려는 값의 타입 중에서 일부 타입에 대해서만 처리된다면 특정 타입에 의존적인 것이고 전달되려는 값의 타입 모두를 처리할 수 있는 것이 타입에 의존하지 않는다는 의미이다.

ジェネリクスを使用する機能には、ジェネリクスで指定した値の扱い方に制限がある場合があります。例えば、変数 `$a` に割り当てられた値の型が `int|string` だと仮定します。この変数に対してコードを作成する際、`strtoupper($a)`のような文字列を対象とする関数とは結びつけてはいけません。なぜなら、`$a`が整数の場合にエラーが発生し、`$a`が取りうるすべての型に対して動作しないためです。それに対して`intval($a)`は整数と文字列の両方に使用できるため、変数`$a`に対して使用しても問題ありません。このように、渡される値の型のうち一部の型にしか対応しない場合は特定の型に依存していることになり、渡される値のすべての型に対応できる場合は型に依存しないという意味になります。

- `strtoupper` 함수의 시그니처 : `strtoupper(string $string): string`
- `strtoupper` 関数のシグニチャー : `strtoupper(string $string): string`
- `intval` 함수의 시그니처 : `intval(mixed $value, int $base = 10): int`
- `intval` 関数のシグニチャー : `intval(mixed $value, int $base = 10): int`

어떤 함수 fn에 대해서 fn의 파라메터는 여러 타입의 인자를 사용할 수 있을 때 특정 타입에 대한 의존성이 줄어든다. fn에 문자열 s를 전달했을 때 정수 i를 전달했을 때 fn(s), fn(t) 각각에 대해 함수가 동작할 때 fn이 문자열 s에 대해서만 성립하는 것과 달리, 좀 더 다양한 타입에 대해서 성립하기 때문에 타입 의존성이 줄어든다.

ある関数`fn`において、パラメーターが複数の型の引数を受け取れる場合、特定の型への依存度が減少します。
例えば、`fn`に文字列`s`を渡した場合と整数`i`を渡した場合、それぞれ`fn(s)`、`fn(i)`が正常に動作するなら、`fn`は文字列`s`のみを対象とする場合とは異なり、より多様な型に対応しているため、型への依存度が低くなります。

제네릭(generic)은 포괄적인이라는 뜻을 가진 용어로, 특정 타입 뿐만 아닌 다양한 타입에 대해서 성립하는 기능을 의미한다. 이후의 설명을 통해서 더 구체적으로 이해해 보자.

ジェネリック（generic）は「包括的な」という意味を持つ用語で、特定の型だけでなく多様な型に対応可能な機能を指します。以下の説明でより具体的に理解していきましょう。

### 타입스크립트의 제네릭
### タイプスクリプトのジェネリクス

php 개발자라면 자바스크립트에 대한 지식이 어느 정도 있을 것이다. 타입스크립트는 자바스크립트에 타입을 추가한 것으로 간단한 타입스크립트의 예를 통해 제네릭을 쉽게 이해할 수 있다.

PHP開発者であれば、ある程度JavaScriptの知識があります。TypeScriptはJavaScriptに型を追加したもので、簡単なTypeScriptの例を通じてジェネリクスを簡単に理解することができます。

타입스크립트는 자바스크립트의 배열의 원소의 타입을 지정할 수 있는 제네릭을 제공한다. `Array<T>`에서 T 부분에 타입을 넣는 것을 통해서 배열의 원소 타입을 제한 할 수 있다.

TypeScriptは、JavaScriptの配列の要素の型を指定できるジェネリクスを提供しています。`Array<T>`のTの部分に型を指定することで、配列の要素の型を制限することができます。

T 부분에 원하는 타입을 지정하는 것을 통해서 `Array<int>`, `Array<string>`, ... 등과 같이 여러 타입에 대해서 성립하는 기능을 만들 수 있다.

Tの部分に任意の型を指定することで、`Array<int>`や`Array<string>`など、様々な型に対応する機能を作ることができます。

#### 타입 스크립트 코드의 예

#### タイプスクリプトコードの例

```ts
const elements: Array<number> = [1, 2, 3, 4, 5];
```

타입 Array 옆에 `<number>`를 붙여주는 것을 통해서 배열 안의 모든 원소는 `number`으로 타입이 정해져서 배열 안에 다른 타입을 넣을 경우, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다.

型Arrayの横に `<number>` を付けることで、配列内のすべての要素が `number` 型に決まり、配列に他の型を入れた場合、IDEの静的解析やコンパイラによるエラーが発生します。

```ts
const elements: Array<string> = ['a', 'b', 'c', 'd', 'e'];
```

마찬가지로 `<string>`을 붙여주는 것을 통해서 배열 안의 모든 원소는 `string`으로 타입이 정해져서 배열 안에 다른 타입을 넣을 경우, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다.

同様に `<string>` を付けることで、配列内のすべての要素が `string` 型に決まり、配列に他の型を入れた場合、IDEの静的解析やコンパイラによるエラーが発生します。

#### 제네릭과 유니온
#### ジェネリクスとユニオン

```ts
const elements: Array<T> = [e1, e2, e3, e4, e5];
```

위 코드에서 타입 T에 대해서 `e1`, `e2`, `e3`, `e4`, `e5`를 사용하게 되면, 각각의 원소는 `<T>`에 지정한 타입이 되어야 한다. 배열을 사용할 때 원하는 타입을 지정할 수 있기 때문에 `<T>`로 타입을 지정해 사용하는 것은 특정 타입에 의존적이지 않은 기능을 제공한다.

上記のコードでは、型Tに対して `e1`, `e2`, `e3`, `e4`, `e5` を使うと、それぞれの要素は `<T>` で指定した型でなければなりません。配列を使うときに希望する型を指定できるため、`<T>` で型を指定して使うことは特定の型に依存しない機能を提供します。

```ts
const elements: Array<number | string> = [1, 'a', 3, 'b', 5];
```

`<T>` 부분에 `<number | string>`으로 유니온 타입을 지정하면 배열 안의 원소는 `number` 타입과 `string` 타입을 두 종류의 값을 넣을 수 있기 때문에, IDE의 정적분석이나 컴파일러에 의한 에러가 발생하지 않는다. 단, 각각의 원소를 꺼내 쓸 때 원소가 수인 경우와 문자열인 경우를 모두를 처리해 주어야 한다.

`<T>` の部分に `<number | string>` のようにユニオン型を指定すると、配列内の要素は `number` 型と `string` 型の2種類の値を入れることができるため、IDEの静的解析やコンパイラによるエラーは発生しません。ただし、それぞれの要素を取り出して使うとき、要素が数値の場合と文字列の場合の両方を処理する必要があります。

#### 제네릭의 유용성
#### ジェネリクスの有用性

```ts
const elements: Array<string> = ['a', 'b', 'c', 'd', 'e'];

console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
console.log((elements.pop() ?? '').toUpperCase());
```

`.toUpperCase()` 메소드는 문자열인 대상에서만 사용할 수 있는 메소드이다. 만약 `numbers.pop()`으로 꺼낸 값이 문자열이 아니라면, 꺼낸 값에 `.toUpperCase()`을 사용한 코드는 IDE의 정적분석이나 컴파일러에 의한 에러가 발생하게 된다. 배열에서 더 이상 꺼낼 데이터가 없을 때 `undefined`를 반환하므로 `.toUpperCase()`에 연결하기 위해서 빈 문자열이 되도록 `?? ''` 코드를 추가해 주었다.

`.toUpperCase()` メソッドは、文字列型の対象でのみ使えるメソッドです。もし `numbers.pop()` で取り出した値が文字列でなければ、取り出した値に `.toUpperCase()` を使ったコードはIDEの静的解析やコンパイラによるエラーが発生します。配列からこれ以上取り出すデータがない場合は `undefined` が返されるので、`.toUpperCase()` に繋げるために空文字列になるように `?? ''` のコードを追加しています。

만약 `elements.pop()`으로 꺼낸 값이 문자열 뿐만 아닌 수 타입인 경우 `.toUpperCase()` 메소드가 존재하지 않기 때문에 사용할 수 없다. 제네릭을 사용해서 배열의 원소 타입을 문자열로 제한했기 때문에, `.toUpperCase()`을 붙이는 코드를 사용할 수 있다.

もし `elements.pop()` で取り出した値が文字列だけでなく数値型の場合、`.toUpperCase()` メソッドは存在しないため使えません。ジェネリクスを使って配列の要素型を文字列に限定したことで、`.toUpperCase()` を付けるコードが使えるようになります。

### 제네릭 문법
### ジェネリック構文

php 함수나 메소드의 매개변수나 반환 값이 특정 타입에 관계 없이 값이 전달되므로, 타입에 의존하지 않기 때문에 개념적으로는 제네릭하다고 할 수 있다.

PHPの関数やメソッドの引数や戻り値は、特定の型に関係なく値が渡されるため、型に依存しないという点で概念的にはジェネリックであると言えます。

이에 반해 사용하기에 앞서 사용할 타입을 구체적으로 지정해 주어야 하는 것을 '제네릭 문법'이라고 한다. 타입 스크립트의 예를 들면 배열(`Array<T>`)은 타입에 의존적이지 않지만, `<>` 부분에 `<string>`이나 `<number>` 등의 타입을 지정하는 것을 통해서 지정한 이후로는 지정한 타입만으로 사용하도록 강제하는 것이 제네릭 문법이다.

それに対して、使用する前に利用する型を具体的に指定しなければならないものを「ジェネリック構文」と呼びます。TypeScriptの例で言えば、配列（`Array<T>`）は型に依存しませんが、`<>` の部分に `<string>` や `<number>` などの型を指定することで、それ以降は指定した型のみで使用するように強制されるのがジェネリック構文です。

자료구조에서는 제네릭이 특히 자주 사용된다. 그 이유는, 자료구조가 저장할 값의 타입에 관계없이 동작할 수 있도록 하기 위해서다. 예를 들어 제네릭이 없다면, 특정 자료구조가 A 타입만 저장하도록 만들어졌을 경우, B나 C 타입의 데이터를 저장하려면 각각의 타입에 맞는 자료구조를 따로 만들어야 한다. 하지만, 제네릭 개념을 적용한 자료구조라면 어떠한 타입에 구애받지 않고 같은 자료구조를 타양한 타입을 다루는데 활용할 수 있다.

データ構造ではジェネリックが特によく使われます。その理由は、データ構造が格納する値の型に関係なく動作できるようにするためです。例えばジェネリックがなければ、特定のデータ構造がA型のみを格納するように作られている場合、B型やC型のデータを格納したければ、それぞれの型に合わせたデータ構造を別々に作成しなければなりません。しかし、ジェネリックの概念を適用したデータ構造であれば、どのような型にもとらわれず、同じデータ構造を様々な型の扱いに利用することができます。

## php로 제네릭 이해하기
## PHPでジェネリクスを理解する

데이터를 넣은 순서대로 데이터가 뽑히는 Last In First Out 자료구조를 php로 간단히 만들어 보자.

データを入れた順番とは逆にデータが取り出される「後入れ先出し（LIFO）」のデータ構造をPHPで簡単に作ってみましょう。

```php
class Lifo
{
    private array $array = [];

    public function push($value)
    {
        $this->array[] = $value;
    }

    public function pop()
    {
        return array_pop($this->array);
    }
}

$lifo = (new Lifo);
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');
var_dump($lifo->pop());
var_dump($lifo->pop());
var_dump($lifo->pop());
```

`push('a')` `push('b')` `push('c')`의 순서대로 데이터를 넣었고, 마지막에 넣은 값 부터 차례로 값이 뽑힌다.

`push('a')`、`push('b')`、`push('c')`の順にデータを追加し、最後に追加した値から順番に値が取り出されます。

### 타입힌트 생각해 보기
### タイプヒントについて考えてみる

문자열의 값을 넣는다고 생각해 보자. 그럼 `public function push(string $value)`와 `public function pop(): string`이란 타입힌트를 줄 수 있다.

文字列の値を入れると考えてみましょう。`public function push(string $value)` や `public function pop(): string` のようにタイプヒントを付けることができます。

정수를 넣는다고 생각해 보자. 그럼 `public function push(int $value)`와 `public function pop(): int`이란 타입힌트를 줄 수 있다.

整数を入れると考えてみましょう。`public function push(int $value)` や `public function pop(): int` のようにタイプヒントを付けることができます。

임의의 타입을 넣는다고 생각해 보자. 그럼 `public function push(mixed $value)`와 `public function pop(): mixed`이란 타입힌트를 줄 수 있다. 하지만 이 경우에는 데이터를 꺼냈을 때 어떤 타입인지 타입이 특정되지 않는다.

任意の型を入れると考えてみましょう。`public function push(mixed $value)` や `public function pop(): mixed` のようにタイプヒントを付けることができます。しかしこの場合、データを取り出したときにどの型なのか特定できません。

위 클래스의 내부 구조를 모르고 클래스의 인터페이스만 안다고 하자. `push`와 `pop` 메소드가 있다는 것만 알고 있다. 클래스 내부에 타입힌트를 주고 싶은데, php는 제네릭 문법이 없기 때문에 외부에서 저장할 데이터의 타입을 결정할 방법이 없다.

上記のクラスの内部構造を知らず、クラスのインターフェースだけ知っているとしましょう。`push` と `pop` メソッドがあることだけ分かります。クラス内部でタイプヒントを付けたいのですが、PHPにはジェネリック構文がないため、外部から保存するデータの型を決定する方法がありません。

만약 php가 제네릭을 지원한다면 `Lifo` 클래스를 사용할 때 클래스 내부에서 데이터를 저장할 때 외부에서 전달된 타입으로 제약을 걸 수 있을 것이다. `new Lifo<Type>` 이렇게 제네릭 문법을 사용해서 타입을 전달하면, `public function push(Type $value)`와 `public function pop(): Type`으로 `Type` 자리에 클래스에서 `<Type>`으로 지정한 값의 타입 들어가 타입 안정적인 코드를 작성할 수 있다.

もしPHPがジェネリクスをサポートしていれば、`Lifo` クラスを使うときにクラス内部でデータを保存する際、外部から渡された型で制約をかけることができます。`new Lifo<Type>` のようにジェネリック構文で型を渡せば、`public function push(Type $value)` や `public function pop(): Type` のように、`Type` の部分にクラスで `<Type>` と指定した型が入り、型安全なコードを書くことができます。

제네릭이 있다면 `<string>`을 넣으면 `push(string $value)`와 `pop(): srting`이 되고, `<number>`을 넣으면 `push(number $value)`와 `pop(): number`가 된다.

ジェネリクスがあれば `<string>` を入れると `push(string $value)` や `pop(): string` となり、`<number>` を入れると `push(number $value)` や `pop(): number` となります。

### 각각의 타입에 대한 코드 작성해 보기

### 各型ごとのコードを書いてみる

#### 정수를 저장하는 lifo

#### 整数を保存するLIFO

```php
class Lifo
{
    private array $array = [];

    public function push(int $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): ?int
    {
        return array_pop($this->array);
    }
}
```

#### 문자열을 저장하는 lifo
#### 文字列を保存するLIFO

```php
class Lifo
{
    private array $array = [];

    public function push(string $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): ?string
    {
        return array_pop($this->array);
    }
}
```

#### 타입 파라메터가 존재한다면?
#### 型パラメータが存在する場合は？

제네릭 문법은 타입 파라메터를 통해서 사용하고자 하는 타입을 지정하는 것이다. 제네릭이 없는 php에서는 타입을 파라메터처럼 외부에서 주입 할 수 없지만, 제네릭이 있다면 다음과 같은 코드를 만들 수 있을 것이다.

ジェネリック構文とは、型パラメータを通じて使用したい型を指定するものです。ジェネリクスがないPHPでは、型をパラメータのように外部から注入することはできませんが、ジェネリクスがあれば次のようなコードを作ることができます。

```php
class Lifo<T>
{
    private array<T> $array = [];

    public function push(T $value)
    {
        $this->array[] = $value;
    }

    public function pop(): ?T
    {
        return array_pop($this->array);
    }
}

$lifoString = new Lifo<string>;
$lifo->push('a');
$lifo->push('b');
$lifo->push('c');

$lifoInt = new Lifo<int>;
$lifo->push(1);
$lifo->push(2);
$lifo->push(3);
```

타입 힌트 위치에 T라는 타입 파라메터를 사용하고 클래스를 객체로 인스턴스화 할 때 타입 파라메터에 전달할 타입을 `<string>`이나 `<int>`로 지정하면, T의 위치에 `string`이나 `int`의 타입 제약이 걸린다.

型ヒントの位置にTという型パラメータを使い、クラスをオブジェクトとしてインスタンス化する際に型パラメータに渡す型を `<string>` や `<int>` のように指定すれば、Tの位置に `string` や `int` の型制約がかかります。

#### 타입스크립트로 이해하기
#### TypeScriptで理解する

제네릭을 지원하는 타입스크립트로 php 코드를 타입스크립트로 바꿔 이해해 보자.

ジェネリクスをサポートするTypeScriptで、PHPコードをTypeScriptに置き換えて理解してみましょう。

```php
class Lifo<T> {
    private array: T[] = [];

    public push(value: T): void {
        this.array.push(value);
    }

    public pop(): T | undefined {
        return this.array.pop();
    }
}

const lifo = new Lifo<string>();
lifo.push('a');
lifo.push('b');
lifo.push('c');

console.log(lifo.pop()); // 'c'
console.log(lifo.pop()); // 'b'
console.log(lifo.pop()); // 'a'
console.log(lifo.pop()); // undefined
```

Lifo라는 클래스에 제네릭 문법으로 `<string>` 타입을 지정하는 것을 통해서 `lifo.push()`으로 값을 넣을 때, `lifo.pop()`으로 값을 꺼낼 때 문자열만을 (꺼낼 값이 없을 때는 `undefinded`) 반환하도록 한다.

Lifoというクラスにジェネリック構文で `<string>` 型を指定することで、`lifo.push()` で値を追加したり、`lifo.pop()` で値を取り出す際に、文字列だけが（取り出す値がないときは `undefined`）返されるようにします。

`Lifo<string>`, `Lifo<number>`으로 제네릭 문법에 어떤 타입을 지정하느냐에 따라 `Lifo` 클래스 내부의 T로 되어 있는 부분의 타입이 달라진다. T는 어떤 타입을 받을지를 정하는 매개변수의 역할로 타입을 받는 타입 파라메터의 역할을 한다.

`Lifo<string>` や `Lifo<number>` のように、ジェネリック構文でどの型を指定するかによって、`Lifo` クラス内部のTとなっている部分の型が変わります。Tはどの型を受け取るかを決めるパラメータであり、型を受け取る型パラメータの役割を果たします。

## 컴파일 언어의 제네릭과 php의 제네릭
## コンパイル言語のジェネリクスとPHPのジェネリクス

### 컴파일 언어에서의 제네릭
### コンパイル言語におけるジェネリクス

컴파일 언어에서는 자료구조를 사용할 때 저장할 데이터의 타입을 명확히 지정해야 한다. 자료구조는 다양한 타입에 대해서 동작하기 위해 제네릭을 사용한다. 여러 타입을 지정하고 싶은 경우에는 유니온 타입 또는 공통의 인터페이스 및 상위 클래스를 타입으로 지정해야 한다.

コンパイル言語では、データ構造を使用する際に格納するデータの型を明確に指定しなければなりません。データ構造は様々な型に対応するためにジェネリクスを使用します。複数の型を指定したい場合は、ユニオン型、共通のインターフェース、または親クラスを型として指定する必要があります。

이 때 제네릭으로 지정하지 않은 다른 타입의 값을 사용할 수는 없는데, 어떤 자료 구조에서 데이터를 꺼내 쓸 때 타입 또는 인터페이스가 달라지면 런타임의 동작에서 잘못된 타입을 참조하거나 전달하는 치명적인 에러가 발생할 수 있기 때문에 지정한 타입에 대한 맞물리는 (int를 반환하면 int를 다루는 코드에 연결하고 string을 사용하면 string을 다루는 코드에 연결하는) 코드를 사용하도록 제한을 하기 위해서이다.

このとき、ジェネリクスで指定していない別の型の値を使用することはできません。なぜなら、あるデータ構造からデータを取り出す際に型やインターフェースが異なると、ランタイムで誤った型を参照・渡してしまい致命的なエラーが発生する可能性があるため、指定した型に合致する（intを返すならintを扱うコードへ、stringならstringを扱うコードへ）コードしか使えないように制限するためです。

컴파일 언어는 타입을 통해서 제한된 방식의 코딩 스타일을 제공하고 컴파일을 통해서 기계어나 기계어에 가까운 레벨의 중간언어(JAVA의 Bytecode, C#의 CLI : Common Intermediate Language)로 번역을 한다. 컴파일 타임에 엄격히 타입 검사를 하므로 런타임에서 타입을 체크하지 않아도 타입에러가 발생하지 않는다.

コンパイル言語は、型によって制限されたコーディングスタイルを提供し、コンパイルによって機械語や機械語に近い中間言語（Javaのバイトコード、C#のCLI：Common Intermediate Language）へと変換されます。コンパイル時に厳格な型チェックを行うため、ランタイムで型チェックをしなくても型エラーが発生しません。

자료구조의 케이스를 생각해 보자. 저장하고 꺼내쓰는 작업을 하는데 데이터를 꺼냈을 때 어떤 타입인지 알아야 어떤 코드를 연결할지 알 수 있다. 컴파일 언어는 런타임에 타입 체크를 하지 않기 때문에 데이터를 꺼냈을 때 어떤 타입인지 체크하는 동작을 하지 않고 꺼내 쓴다. 이 때 메모리에 저장된 값과 전달하려는 런타임의 코드 실행에서 타입 불일치가 일어나면 치명적인 에러가 발생할 수 있다.

データ構造のケースを考えてみましょう。保存や取り出しの操作を行う際、データを取り出したときにどの型なのかを知ることで、どのコードにつなげるかを決定できます。コンパイル言語はランタイムで型チェックを行わないため、データを取り出す際に型をチェックする動作をせず、そのまま値を渡します。このとき、メモリに保存されている値と渡そうとするランタイムのコード実行時に型不一致が起きると、致命的なエラーが発生する可能性があります。

php의 경우 타입 불일치가 일어나면 언어 자체의 에러를 예외 처럼 던져 스텍 트레이스를 생성하는 것에 반해 기계어나 중간 언어로 번역된 코드를 실행하는 컴파일 언어는 의도적으로 타입을 체크하지 않는 한 타입 불일치가 런타임에 일어나면 이를 처리할 수 없고 프로그램은 크레시가 발생할 것이다. 그래서 이런 일이 발생하지 않도록 컴파일 타임에 강력하고 엄격한 정적 검사를 수행한다.

PHPの場合、型不一致が発生すると言語自体のエラーが例外のようにスローされ、スタックトレースが生成されますが、機械語や中間言語に変換されたコードを実行するコンパイル言語では、意図的に型チェックを行わない限り、ランタイムで型不一致が発生した場合にこれを処理できず、プログラムはクラッシュしてしまいます。そのため、このような事態が発生しないよう、コンパイル時に強力かつ厳格な静的検査が行われます。

그래서 컴파일 언어는 이용할 타입을 컴파일 타임에 지정해 두어야 한다. 자료 구조의 사용과 동시에 자료 구조 안에 들어갈 타입을 지정해서 자료 구조에 데이터를 넣고 꺼낼 때 명확한 타입을 정하여 연결되는 코드의 동작을 런타임 코드 실행 이전에 보증하기 위한 것이 컴파일 언어에서 제네릭이라고 부르는 문법이다.

そのため、コンパイル言語では利用する型をコンパイル時に指定しておく必要があります。データ構造の使用と同時に、そのデータ構造に入る型を指定し、データ構造にデータを入れたり取り出す際に明確な型を定め、つなげるコードの動作をランタイムのコード実行前に保証するための仕組みが、コンパイル言語で「ジェネリクス」と呼ばれる構文です。

### 유니온 타입에 대한 일반적인 코딩 스타일
### ユニオン型に関する一般的なコーディングスタイル

위에서 소개한 예제의 Lifo 클래스에서 내부에 타입힌트를 `string`으로 정의했는지 `int`로 정의했는지에 따라서 배열 안의 데이터로 전달할 수 있는 대상은 문자열이 되기도 하며, 정수가 되기도 한다. 문자열만을 저장하는 Lifo를 쓰고 싶다면 문자열 타입힌트를 갖는 클래스를 만들어야 하고, 정수만을 저장하는 Lifo를 쓰고 싶다면 정수 타입힌트를 갖는 클래스를 만들어야 한다. 하나의 타입으로 제한되어 있기 때문에 `push` 메소드로 타입을 전달할 때, `pop` 메소드로 값을 꺼낼 때 하나의 타입에 대해서만 (꺼낼 대상이 없는 경우는 null을 추가로) 생각하면 된다.

上で紹介した例のLifoクラスでは、内部でタイプヒントを`string`で定義したか、`int`で定義したかによって、配列内に渡せるデータは文字列になったり整数になったりします。文字列のみを保存するLifoを使いたい場合は文字列のタイプヒントを持つクラスを作る必要があり、整数のみを保存するLifoを使いたい場合は整数のタイプヒントを持つクラスを作る必要があります。一つの型に限定されているため、`push`メソッドで型を渡すときや、`pop`メソッドで値を取り出すときは一つの型（取り出す対象がない場合はnullも追加）だけを考えれば済みます。

하지만 여러 클래스를 만드는 것은 효율적이지 못하다. 제네릭을 사용할 수 있다면 Lifo 클래스를 하나만 만들어 인스턴스화를 할 때 `new Lifo<string>` `new Lifo<int>` 등으로 타입을 지정해 주면 되지만 php는 제네릭을 사용할 수 없기 때문에, 유니온 타입이나 mixed 타입 힌트를 사용한다. 하지만 이렇게 되면 `push` 메소드로 타입을 전달할 때, `pop` 메소드로 값을 꺼낼 때 각각의 원소의 타입은 `int` 단일, `string` 단일이 아니라, `int|string`이므로 꺼낸 값을 처리할 때 `int`에 대해서도 `string`에 대해서도 성립하도록 코드를 만들어 주어야 한다. 제네릭으로 단일 타입을 사용할 때는 처리하지 않아도 되는 코드에 유니온을 쓰면서 타입에 따른 분기 처리 로직의 작성이 필요하게 된다.

しかし、複数のクラスを作るのは効率的とは言えません。ジェネリクスが使えれば、Lifoクラスを一つだけ用意し、インスタンス化する際に`new Lifo<string>`や`new Lifo<int>`のように型を指定すれば良いのですが、PHPではジェネリクスが使えないため、ユニオン型やmixedタイプヒントを使用します。しかしこの場合、`push`メソッドで型を渡すときや、`pop`メソッドで値を取り出すときに、それぞれの要素の型は`int`単体や`string`単体ではなく、`int|string`となるため、取り出した値を処理する際には`int`に対しても`string`に対しても成立するようにコードを書く必要があります。ジェネリクスで単一型を使う場合には不要だった処理も、ユニオン型を使うことで型ごとの分岐処理ロジックの記述が必要になります。

타입힌트를 사용하면 지정한 타입이 아니면 에러를 발생 시키는 것을 통해서 잘못된 타입의 값이 전달 되었을 때 발생하는 타입 에러를 통해서 타입이 잘못된 이유를 찾고 이를 개선하여 코드를 정확하게 작성하고, 이후에는 타입힌트로 제한한 범위에 한정하여 코드를 정해진 타입 범위 내에서 IDE의 도움을 받아 안정적으로 구현할 수 있다.

タイプヒントを使うことで、指定した型以外が渡された場合にエラーを発生させ、誤った型の値が渡された理由をタイプエラーから特定し、これを改善することで正確なコードを書き上げることができ、以降はタイプヒントで限定された範囲内でIDEの支援を受けながら安全に実装できます。

때때로, 실제 전달되지도 않는 여러 타입에 대한 로직 처리를 할 필요는 없기 때문에 타입힌트로 지정한 타입 모두에 대한 처리가 아닌 일부 타입에 대해서만 처리 로직을 만드는 경우가 생긴다. php와 같은 동적 타이핑 언어의 경우 런타임에서 타입을 확인하기 때문에 타입이 `int | string`이더라도 실제 전달되는 값이 `int`만 사용된다면 `int`에 대해서만 처리하고, `string`만 사용된다면 `string`에 관한 처리를 해도 잘 동작한다.

時には、実際には渡されない複数型のロジック処理を書く必要がない場合もあるため、タイプヒントで指定した全ての型ではなく一部の型のみ処理ロジックを作ることもあります。インタプリタ言語の場合、PHPのような動的型付け言語の場合、ランタイムで型がチェックされるため、型が `int | string` であっても、実際に渡される値が`int`だけなら`int`だけを処理し、`string`だけが使われる場合は`string`に関する処理をしても正常に動作します。

타입 시스템이 강한 언어의 경우 유니온 타입이 전달되면 모든 타입 케이스에 대한 분기 로직을 작성해 주어야 한다. `int | string`가 전달되었다면 반드시 `int`에 대한 처리와 `string`에 대한 처리 모두를 해 주어야 한다. php에서도 강력한 정적 분석 툴을 사용하는 경우 타입 안정성을 위해 유니온 타입이 갖는 모든 타입에 대한 처리를 작성해 주어야 한다. (그렇지 않으면 정적 분석 툴을 통과하지 못한다.)

タイプシステムが強い言語の場合、ユニオン型が渡された際には全ての型ケースに対する分岐ロジックを書かなければなりません。`int | string`が渡された場合、必ず`int`用と`string`用の処理を両方記述する必要があります。PHPでも強力な静的解析ツールを使う場合、型安全のためにユニオン型の全ての型に対する処理を記述しなければなりません（そうしなければ静的解析ツールを通過できません）。

타입힌트가 `?int`으로 되어 있다면 연결되는 로직은 `int`와 `null` 모두에 대한 처리 로직을 만들어야 하며, `null`이 실제로 사용하지 않는 값이라면 `?int`가 아닌 `int`만 사용하여 타입힌트에서 제거하는 것이 해당 코드를 사용할 때 불필요한 처리를 추가로 작성한다.

タイプヒントが`?int`（null許容int）になっている場合、結びつくロジックは`int`と`null`の両方の処理を作らなければならず、もし`null`が実際には使われない値であれば`?int`ではなく`int`だけにしてタイプヒントから除外することで、そのコードを使うときに不要な処理の追加を避けることができます。

일반적으로는 인터프리터 언어가 유니온 타입에 대해 전달되는 값이 유니온 타입으로 지정한 타입 중에서 특정한 타입만 전달되는 것을 전제한다고 하더라도 해당 일부 타입에 대해서 코드를 짜는 것이 아닌 유니온 타입이 갖는 전체 타입에 대한 처리 로직을 추가하는 것이 일반적인 코딩 스타일이다.

一般的には、インタプリタ言語でユニオン型に対して渡される値がユニオン型で指定した型の中の特定の型だけになることが前提だとしても、その一部の型だけでなく、ユニオン型が持つ全ての型に対する処理ロジックを追加するのが一般的なコーディングスタイルです。

### 유니온 타입과 `assert`로 제네릭 대체하기
### ユニオン型と`assert`によるジェネリクスの代用

php에서는 타입힌트로 사용하고자 하는 타입의 내부 타입을 설정하는 제네릭 문법이 없기 때문에, 기본적으로는 유니온 타입, 공통의 인터페이스, 공통의 상위 클래스 등 여러 타입에 대해서 성립하는 로직을 만들되, 값을 전달할 때 또는 값을 꺼내 쓸 때 유니온 타입 중에서 일부 타입, 서브 클래스나 인터페이스 중 일부 타입에 대해서만 로직이 동작한다는 전제를 두고 코드를 작성하는 방법이 있다.

PHPでは、タイプヒントで使用したい型の内部型を設定するジェネリクス構文が存在しないため、基本的にはユニオン型、共通のインターフェース、共通の親クラスなど、複数の型に対応するロジックを作りますが、値を渡すときや取り出すときに、ユニオン型の中の一部の型やサブクラス、インターフェースの一部の型に対してのみロジックが動作するという前提でコードを書く方法があります。

#### 사전 조건을 통한 조건 부여
#### 事前条件による条件付け

```php
declare(strict_types = 1);

$list = rand(0, 1) ? range(0, 30) : range('a', 'z');

assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true));

$result = array_map(fn($v) => $v+1, $list);

var_dump($result);
```

위 코드에서 `$list`는 0에서 30까지의 정수 또는 a부터 z까지의 문자열인 원소를 가지는 모두 정수 원소를 가지거나 모두 문자열 원소를 가지는 코드이다.

上記のコードでは、`$list`は0から30までの整数またはaからzまでの文字列の要素を持ち、すべて整数の要素か、すべて文字列の要素を持つコードです。

`array_map(fn($v) => $v+1, $list)` 부분의 코드는 문자열일 때는 동작하지 않고, 수(`int`)인 경우에만 동작한다. `$list`의 원소는 명시적인 타입힌트는 없지만 암묵적으로는 int 또는 string이다.

`array_map(fn($v) => $v+1, $list)`の部分のコードは、文字列の場合には動作せず、数値（int）の場合にのみ動作します。`$list`の要素には明示的な型ヒントはありませんが、暗黙的にはintまたはstring型です。

`assert`를 통해서 만약 배열의 모든 원소가 정수가 아니면 에러로 종료하도록 만들어져 있다. 이는 해당 라인 다음 줄 부터의 코드는 정수가 아니라면 실행될 수 없다는 전제 조건을 설정한 것이다.

`assert`によって、もし配列のすべての要素が整数でなければエラーで終了するようになっています。これは、その行以降のコードは整数でなければ実行できないという前提条件を設定しているのです。

이 전제조건으로 인해서, 배열의 원소가 int 또는 string 타입을 갖지만 `assert`와 같은 전제 조건을 설정할 수 있는 코드를 통해서 개발자는 이 코드의 배열은 내부 원소가 int 타입이니까 int 타입에 대해서만 처리하자고 생각할 수 있다.

この前提条件によって、配列の要素がintまたはstring型であっても、`assert`のような前提条件を設定するコードを通して、開発者は「この配列は内部要素がint型だからint型だけを処理しよう」と考えることができます。

위의 코드는 PHPStan, Psalm과 같은 강력한 정적 분석 도구에 의해서는 문자열 원소에 대한 처리를 하지 않았다는 에러 메시지가 발생하는데, `array_reduce` 등으로 사전조건을 지정하는 경우, 배열의 모든 원소를 확인하는 약간 복잡한 코드가 들어간 `assert`문의 타입 제한은 정적 분석 도구가 분석하지 못하기 때문에 `$list`의 원소가 `int`만이 전달된다는 사전 조건을 지정하더라도 여전히 `int`와 `string` 모두에 대한 처리를 해야 한다고 지적한다는 문제점이 있으며 개발자에게 타입 조건을 알려줄 뿐이다.

上記のコードは、PHPStanやPsalmのような強力な静的解析ツールによって、文字列要素に対する処理を行っていないというエラーメッセージが表示されます。`array_reduce`などで前提条件を指定する場合、配列のすべての要素を確認する少し複雑なコードが含まれる`assert`文による型制限は静的解析ツールが解析できないため、`$list`の要素がintのみであるという前提条件を指定しても、依然としてintとstringの両方に対する処理が必要だと指摘される問題があり、開発者に型の条件を伝えるだけにとどまります。

### 유니온 타입의 문제
### ユニオンタイプの問題

제네릭을 사용할 때는 타입 매개변수 T에 대해 `new Lifo<string>`, `new Lifo<int>`와 같이 타입을 지정하면, `$lifo->push($value)`로 데이터를 넣을 때 `$value`의 타입이 <Type>에서 지정한 타입으로 고정되고, `$el = $lifo->pop()`으로 데이터를 뽑을 때 `$el`의 타입이 제네릭에서 지정한 타입 또는 `null`이 된다.

ジェネリクスを使用する場合、型パラメータTに対して `new Lifo<string>` や `new Lifo<int>` のように型を指定すれば、`$lifo->push($value)` でデータを追加するときに `$value` の型が `<Type>` で指定した型に固定され、`$el = $lifo->pop()` でデータを取り出すときに `$el` の型がジェネリクスで指定した型、または `null` になります。

그런데 `Lifo`의 타입 매개 변수가 T가 아닌 mixed 타입으로 고정되어 있다면, `Lifo`는 타입의 제한 없이 어느 값이든 사용할 수 있다. 하지만 `$lifo->push($value)`으로 값을 전달할 때 어떠한 타입도 가능하고, `$el = $lifo->pop()`으로 꺼내 쓸 때도 어떠한 타입도 가능하기 때문에 `$el`을 처리하기 위해서 모든 타입에 대해서 동작하는 코드를 작성해야 한다. 이는 불가능하므로 처리 후의 타입을 최소한으로 제한을 해야 한다.

しかし、`Lifo` の型パラメータが T ではなく mixed 型で固定されている場合、`Lifo` は型の制限なくどんな値でも使用できます。ただし、`$lifo->push($value)` で値を渡すときも、`$el = $lifo->pop()` で値を取り出すときも、あらゆる型が可能になるため、`$el` を処理するにはすべての型に対応するコードを書かなければなりません。これは不可能なので、処理後の型を最低限に絞る必要があります。

php에 제네릭이 없는 대신 mixed 또는 유니온 타입을 쓰되, 값을 전달하거나 얻을 때 `assert`와 같은 도구를 통해 타입의 전제 조건을 설정하는 것을 통해 제네릭 없이도 타입 안정적인 코드를 만들 수 있다.

PHPにはジェネリクスがないため、mixedやユニオン型を使い、値を渡したり取得したりする際に `assert` などのツールを使って型の前提条件を設定することで、ジェネリクスがなくても型安全なコードを作ることができます。

하지만 제네릭으로 타입 제한을 걸면 꺼내 쓸 때마다 타입을 확인할 필요가 없으며 기능을 생성하는 타이밍에(`new Lifo<string>`, `new Lifo<int>`) 제네릭으로 타입이 결정되어 있다. 따라서 IDE의 정적 추론을 편하게 이용할 수 있는 반면, 타입을 확인하는 방법은 꺼내 쓸때마다 타입을 확인하는 코드를 작성해 주어야 하는 단점이 있다. 다음 내용을 통해서 구체적으로 이해해 보자.

しかし、ジェネリクスで型制限をかける場合、取り出すたびに型を確認する必要がなく、機能を生成するタイミング（`new Lifo<string>` や `new Lifo<int>`）でジェネリクスによって型が決定されます。したがって、IDEによる静的推論を便利に利用できる一方で、型を確認する方法では、取り出すたびに型確認のコードを書く必要があるというデメリットがあります。次の内容で具体的に理解してみましょう。

### Type narrowing

여러 타입을 갖는 변수에서 일부의 타입만을 사용하는 경우 `assert`를 통해서 타입의 범위를 좁힐 수 있다. 이 기능은 다양한 정적 분석 툴에서 [type narrowing](https://PHPStan.org/writing-php-code/narrowing-types)이라는 기능으로 지원되는 기능으로, phpstorm 등과 같은 IDE를 사용하면, 유니온 타입 및 상위 클래스 인터페이스로 구성된 타입을 부분 집합의 타입 또는 하위 타입에 대해서 동작하는 것을 전제한다고 IDE에 알려 준다.

複数の型を持つ変数で一部の型だけを使用する場合、`assert`を使って型の範囲を絞ることができます。この機能は、さまざまな静的解析ツールで [type narrowing](https://PHPStan.org/writing-php-code/narrowing-types)（型の絞り込み）としてサポートされており、PHPStormなどのIDEを使用すると、ユニオン型や親クラス・インターフェースで構成された型について、部分集合の型やサブタイプに対して動作することを前提としてIDEに知らせることができます。

IDE는 유니온 타입이 가진 모든 타입에 대한 처리를 하지 않으면 타입 미스매칭으로 지적한다. 또는 공통 인터페이스, 상위 클래스 등의 타입의 변수를 처리할 때, 특정 서브 인터페이스 또는 서브 클래스에 대한 처리를 할 때도 타입 미스매칭으로 지적한다. 타입 좁히기를 사용하면 전달 될 수 있는 여러 타입 중에서 특정 타입에 대해서 성립한다는 전제를 `assert`로 IDE에 알려 주어 부분 집합의 타입 또는 서브 클래스 및 인터페이스에 대해 IDE 또는 정적 분석이 통과되도록 할 수 있다.

IDEは、ユニオン型が持つすべての型に対する処理を行わないと型ミスマッチとして指摘します。また、共通インターフェースや親クラスなどの型の変数を処理する際に、特定のサブインターフェースやサブクラスに対する処理を行う場合でも型ミスマッチとされます。型の絞り込み（type narrowing）を使うことで、渡される可能性のある複数の型のうち特定の型に対してのみ成り立つという前提を`assert`でIDEに知らせ、部分集合の型やサブクラス、インターフェースに対する処理もIDEや静的解析を通過できるようにできます。

#### 코드를 통해 이해하기 1
#### コードを通して理解する 1

```php
declare(strict_types = 1);

class TypeNarrowing
{
    public int|string $numeric;
}

function addOne(int $value): int {
    return $value + 1;
}

$list = [100, '100'];

$obj = (new TypeNarrowing);
$obj->numeric = $list[rand(0,1)];

assert(is_int($obj->numeric));

$result = addOne($obj->numeric);
var_dump($result);
```

`TypeNarrowing`의 멤버 변수 `$numeric`는 int 또는 string 타입을 가진다. `$obj->numeric` 코드에서 위의 코드만 보고서는 `100`이 할당될지, `'100'`이 할당될지 알 수 없다. `addOne` 함수는 `int` 타입만을 받는데 문자열 타입이 전달되면 에러가 발생한다. 이 때문에 IDE에 의한 정적 분석 또는 정적 분석 툴에 의해 `addOne($obj->numeric)`부분에 `int` 뿐만 아닌 `string`을 전달할 수 있는데 `addOne`은 `int` 타입만을 받기 때문에 정적 분석에 따른 에러가 발생한다.

`TypeNarrowing`のメンバー変数 `$numeric` は int または string 型を持ちます。`$obj->numeric` というコードだけでは、上記のコードから `100` が代入されるのか、`'100'` が代入されるのかは分かりません。`addOne` 関数は `int` 型のみを受け取りますが、文字列型が渡されるとエラーになります。そのため、IDEによる静的解析や静的解析ツールによって、`addOne($obj->numeric)` の部分で `int` だけでなく `string` も渡される可能性があるため、`addOne` が `int` 型のみを受け取ることから静的解析上のエラーが発生します。

앞서 배열의 원소를 모두 확인하는 `assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true))`와 같은 코드는 정적 분석 도구가 배열의 내부 원소 타입을 제한했다고 판별하기 어려울 정도의 복잡성을 지녔지만, 단순히 `is_int($var)`, `is_string($var)`, `|| is_null($var)` 등과 같은 코드를 사용하면 정적 분석 도구에서 [Type narrowing 키워드로 지정된 방식](https://PHPStan.org/writing-php-code/narrowing-types#type-checking-functions)이므로 IDE와 정적 분석 도구들은 이를 기반으로 타입의 범위를 좁힐 수 있도록 지원한다.

前述の、配列の要素をすべて確認する `assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true))` のようなコードは、静的解析ツールが配列の内部要素の型を制限していると判定するのが難しいほど複雑ですが、単純に `is_int($var)`、`is_string($var)`、`|| is_null($var)` などのコードを使えば、静的解析ツールで[Type narrowingキーワードで指定された方式](https://PHPStan.org/writing-php-code/narrowing-types#type-checking-functions)なので、IDEや静的解析ツールはそれに基づいて型の範囲を狭めることができます。

위의 코드에서 `assert(is_int($obj->numeric))` 부분의 주석을 해제하면 `$obj->numeric`의 타입은 `int|string`이지만 `assert`로 타입 좁히기를 하면 `int`로 인식되기 때문에 정적 분석에 의한 지적을 피할 수 있다.

上記のコードで `assert(is_int($obj->numeric))` 部分のコメントを外すと、`$obj->numeric`の型は`int|string`ですが、`assert`で型を絞り込むことで `int` と認識され、静的解析による指摘を回避できます。

#### 코드를 통해 이해하기 2
#### コードを通して理解する 2

```php
declare(strict_types = 1);

class Lifo
{
    // @PHPStan-ignore-next-line
    private array $array = [];

    public function push(mixed $value): void
    {
        $this->array[] = $value;
    }

    public function pop(): mixed
    {
        return array_pop($this->array);
    }
}

$stringList = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($stringList));

$lifoString = (new Lifo);
array_walk($stringList, function ($v) use ($lifoString) {
    assert(is_string($v));
    $lifoString->push($v);
});

for($i=0; $i < count($stringList) ; $i++) {
    $output = $lifoString->pop();
    assert(is_string($output));
    echo $output;
}

$numberList = json_decode(json_encode(range(1, 10)) ?: '[]');

assert(is_array($numberList));

$lifoInteger = (new Lifo);
array_walk($numberList, function ($v) use ($lifoInteger) {
    assert(is_int($v));
    $lifoInteger->push($v);
});

for($i=0; $i < count($numberList) ; $i++) {
    $output = $lifoInteger->pop();
    assert(is_int($output));
    echo $output;
}
```

`json_decode(json_encode(range('a', 'i')) ?: '[]')`, `json_decode(json_encode(range(1, 10)) ?: '[]')`의 코드를 사용한 이유는 결과 값의 타입을 정적 분석 도구가 알 수 없게 하기 위해서이다.

`json_decode(json_encode(range('a', 'i')) ?: '[]')`や`json_decode(json_encode(range(1, 10)) ?: '[]')`というコードを使った理由は、結果値の型を静的解析ツールが特定できないようにするためです。

`assert(is_array($stringList))`, `assert(is_array($numberList))`는 알 수 없는 타입의 값의 타입이 배열이라는 전제를 설정하여 정적 분석 도구로 하여금 `array_walk`에 의한 순회를 가능하게 한다.

`assert(is_array($stringList))`や`assert(is_array($numberList))`は、不明な型の値に対して「配列である」という前提を設定し、静的解析ツールによる`array_walk`での走査を可能にしています。

배열 내부의 원소의 타입을 알 수는 없지만, `->push($v)` 전의 `assert(is_int($v))`, `assert(is_string($v))`를 통해서 사용하려는 타입과 다른 타입의 배열의 원소는 전달되지 않는다는 전제 조건을 설정한다.

配列内部の要素の型は分かりませんが、`->push($v)`の前に`assert(is_int($v))`や`assert(is_string($v))`を使うことで、使用したい型以外の配列要素が渡されないという前提条件を設定しています。

위의 코드에서 `echo $output;`의 코드를 사용할 때 값은 문자열로 형변환 되어 출력 된다. 값에 따라 문자열로 변환 될 수 있는 것이 있고 없는 것이 존재한다. PHPStan의 정적 분석기로 위 코드를 실행해 보면 `$lifoString->pop();`의 반환 타입이 mixed가 되어 있기 때문에 문자열로 변환 할 수 없는 값이 나올 수 있어 타입 에러가 발생한다. 그러나 `assert(is_int($output))`, `assert(is_string($output))`으로 `echo`로 출력할 수 있는 타입의 전제 조건을 설정하는 것을 통해서 IDE에 사용하는 타입을 알려주면 정적 추론에 의한 지적을 사라지게 할 수 있다.

上記のコードで`echo $output;`を使用すると、値は文字列に型変換されて出力されます。値によっては文字列に変換できるものとできないものがあります。PHPStanなどの静的解析ツールでこのコードを実行すると、`$lifoString->pop();`の返り値の型がmixedとなっているため、文字列に変換できない値が出る可能性があり、型エラーが発生します。しかし、`assert(is_int($output))`や`assert(is_string($output))`で`echo`で出力可能な型の前提条件を設定することで、IDEに使用する型を伝え、静的推論による指摘を回避できます。

이렇게 제네릭이 없어도 `assert`를 통한 타입을 좁히기를 통해서 제네릭 없이도 정적 분석을 만족하는 코드를 만들 수 있다.

このように、ジェネリクスがなくても`assert`による型の絞り込みを使うことで、ジェネリクスなしでも静的解析を満たすコードを作ることができます。

## 배열 원소에 대한 정적 분석
## 配列要素に対する静的解析

### 배열 원소에 대한 정적 분석의 한계
### 配列要素に対する静的解析の限界

```php
$list = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($list));

foreach($list as $el) {
    assert(is_string($el));
}

foreach($list as $el) {
    echo $el; // Parameter #1 (mixed) of echo cannot be converted to string.
}
```

심지어 위의 코드와 같이 배열 안의 모든 원소가 문자열임을 순회를 통해 모든 원소의 타입을 `assert(is_string($el))`으로 확인을 하더라도, 다음 순회 코드에서 IDE의 정적 분석이나 PHPStan과 같은 정적 분석 도구는 배열 내의 타입이 무엇인지 확인하지 못한다. 따라서 순회 코드를 작성할 때마다 `assert`를 통한 타입 좁히기 코드를 반복적으로 적어야 하는 문제점이 있다.

たとえ上記のコードのように、配列内のすべての要素が文字列であることをループで `assert(is_string($el))` によって確認したとしても、その後のループ処理において、IDEの静的解析やPHPStanなどの静的解析ツールは配列内の要素の型を認識できません。そのため、ループ処理を書くたびに `assert` を使った型の絞り込みコードを繰り返し記述しなければならないという問題があります。

### foreach vs array_walk

정적 분석 툴은 배열 안의 원소 타입을 추론할 수 없기 때문에, 배열의 원소가 무엇인지 IDE에 알려 주어야 한다. `assert`로 원소의 타입을 IDE나 정적 분석 도구에 알려 주기 위해서는 배열의 값을 하나씩 꺼냈을 때 가능하다. `assert` 구문 안에 `is_타입` 또는 `instanceof`으로 IDE의 정적 분석에 의한 자동완성을 사용할 수 있다.

静的解析ツールは配列内の要素の型を推論できないため、配列の要素が何であるかをIDEに伝える必要があります。`assert`で要素の型をIDEや静的解析ツールに伝えるには、配列の値を一つずつ取り出したときに可能です。`assert`文の中で`is_型`や`instanceof`を使うことで、IDEの静的解析による自動補完を利用できます。

`foreach` 또는 `for`를 사용할 때는, 루프를 순회할 때마다 배열에서 값을 하나씩 꺼내쓰는 코드를 작성할 것이다. 이 때, 순회하는 원소의 타입을 알 수 없으며 php 배열은 원소의 타입을 지정하지 못하기 때문에 정적 분석은 `mixed`로 대상을 판단할 것이다. 뽑은 값을 변수에 할당해 `assert`를 사용해서 타입을 좁혀 처리 대상이 되는 타입만을 정해준다. 그럼 IDE는 해당 타입으로 코드의 타입을 추론한다.

`foreach`や`for`を使用する場合、ループを回すたびに配列から値を1つずつ取り出すコードを書くことになります。このとき、巡回する要素の型は分からず、PHPの配列は要素の型を指定できないため、静的解析では`mixed`として扱われます。取り出した値を変数に代入し、`assert`を使って型を絞り込むことで、処理対象となる型だけを指定します。すると、IDEはその型としてコードの型を推論します。

`array_walk`도 배열을 순회하는 기능이지만, 함수를 하나 받아서 함수의 파라메터로 배열의 원소를 하나씩 전달 받아서 순회처리하는 기능이다. 그런데 배열의 원소 타입을 알 수 없어 `mixed`로 추론되는데, 순회 함수의 파라메터에 어떤 타입 힌트 T를 설정하면 정적 분석은 `mixed`로 추론되는데 특정 타입 T로 연결되는 코드를 만들었다면서 타입이 연결되지 않는다는 지적을 한다. 따라서 순회 함수의 파라메터에는 타입힌트를 쓰지 않거나 `mixed`로 정하고, 순회 함수 내부에서 파라메터 변수를 `assert`로 타입을 좁혀 처리 대상이 되는 타입만 지정하는 방법을 사용하여 정적 분석의 지적을 피하도록 한다.

`array_walk`も配列を巡回する機能ですが、関数を1つ受け取り、その関数のパラメータとして配列の要素を1つずつ渡して巡回処理を行います。しかし、配列の要素型が分からないため`mixed`と推論されます。巡回関数のパラメータに型ヒントTを設定すると、静的解析では`mixed`と推論されているのに特定の型Tに結びつけようとしたとみなされ、型が合わないという指摘を受けます。したがって、巡回関数のパラメータには型ヒントを付けないか`mixed`にし、関数内部でパラメータ変数を`assert`で型を絞り込み、処理対象となる型だけを指定する方法で静的解析の指摘を避けます。

```php
$list = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($list));

foreach($list as $el) {
    // assert(is_string($el));
    echo $el;
}

array_walk($list, function (string $el) {
    echo $el;
});

array_walk($list, function (mixed $el) {
    // assert(is_string($el));
    echo $el;
});
```

foreach 문에서 `$el`의 타입을 알 수 없기 때문에 `echo $el`으로 출력할 수 있는 문자열로의 변환이 가능한지 알 수 없다. 그래서 `assert`를 통해서 원소 각각의 타입이 문자열인지 확인해야 한다.

foreach文では `$el` の型が分からないため、`echo $el` で出力できる文字列への変換が可能かどうかも分かりません。そのため、`assert` を使って各要素の型が文字列かどうかを確認する必要があります。

`$list` 배열 내의 각각의 원소는 `mixed`으로 추론이 되는데, `array_walk` 함수의 순회함수의 파라메터의 타입힌트는 `string`이다. 바닐라 php에서는 이런 코딩 스타일도 실행에 문제가 없지만, 정적 분석 툴을 이용하고 있다면 타입 미스매칭으로 지적이 된다.

`$list` 配列内の各要素は `mixed` と推論されますが、`array_walk` 関数のコールバック関数のパラメータの型ヒントは `string` になっています。バニラPHPではこのようなコーディングスタイルでも実行上問題ありませんが、静的解析ツールを利用している場合は型ミスマッチとして指摘されます。

따라서 순회 함수의 파라메터 타입은 배열의 원소 타입으로 추론되는 것과 동일하게 해 주고, 각각의 원소를 사용할 때 `assert`로 실제 사용할 타입을 IDE에 알려 주도록 하자.

したがって、コールバック関数のパラメータの型は配列要素の型として推論されるものと同じにし、各要素を使用する際に `assert` で実際に使う型をIDEに伝えるようにしましょう。

### 배열의 원소가 단일 타입인 경우
### 配列の要素が単一型の場合

```php
class Item
{
    protected int $cached;

    public function __construct()
    {
        $this->cached = rand();
    }
	
    public function getCachedValue(): int
    {
        return $this->cached;
    }
}

class SubItem extends Item
{
    public function getCachedValueToString(): string
    {
        return strval($this->cached);
    }
}

$numberList = [];

for($i=0; $i<10; $i++) {
    $numberList[$i] = new SubItem;
}

foreach($numberList as $item) {
    echo $item->getCachedValue(), PHP_EOL;
}

echo PHP_EOL."------------".PHP_EOL;

array_walk($numberList, function (Item $item): void {
    echo $item->getCachedValue(), PHP_EOL;
});

array_walk($numberList, function (Item $item): void {
    echo $item->getCachedValueToString(), PHP_EOL;;
});
```

위의 코드에서 `foreach` 문을 사용하지 않고 `array_walk`로 콜백 함수를 사용한 코드를 사용하였다. 콜백함수를 사용하게 되면 각각의 원소에 대해 타입힌트를 적용할 수 있고 타입힌트로 인해 다른 타입이 들어오는 경우에는 에러를 내며, IDE는 타입힌트를 통해서 오브젝트 내부에 프로퍼티가 있는지 추론을 할 수 있어서 코드를 편하게 짜는데 도움을 준다.

上記のコードでは、`foreach` 文を使わずに `array_walk` でコールバック関数を利用しています。コールバック関数を使うことで、各要素に対して型ヒントを適用でき、型ヒントによって異なる型が渡された場合はエラーになります。また、IDEは型ヒントを通してオブジェクト内部にプロパティがあるかどうかを推論できるため、コーディングがしやすくなります。

php는 배열에 하나의 유형 뿐만 아닌 다양한 유형을 갖고 있기 때문에 배열에서 데이터를 뽑아 쓸때마다 불안한 느낌을 준다. 반복 가능한 유형에 콜백함수를 사용하는 표현으로 타입힌트를 걸어주면 타입을 한 번 짚고 넘어갈 수 있기 때문에 코드에 안정감을 주게 된다.

PHPは配列に単一の型だけでなく様々な型を持つことができるため、配列からデータを取り出すたびに不安を感じることがあります。イテラブルな型にコールバック関数を使って型ヒントを付けることで、一度型を確認でき、コードに安心感を与えることができます。

## phpdoc 제네릭
## phpdoc ジェネリクス

phpdoc을 사용하여 `/* @var array<int, Type> */` 또는 `/* @template Type */` 템플릿을 사용하면 php에서 제네릭을 사용할 수 있다.

phpdocを使用して `/* @var array<int, Type> */` や `/* @template Type */` のテンプレートを使うことで、phpでもジェネリクスを利用することができます。

```php
/**
 * @template T
 */
class Lifo
{
    /**
     * @var array<int, T>
     */
    private array $array = [];

    /**
     * @param T $value
     */
    public function push(mixed $value): void
    {
        $this->array[] = $value;
    }

    /**
     * @return T|null
     */
    public function pop(): mixed
    {
        return array_pop($this->array);
    }
}

/** @var Lifo<int> $lifo */
$lifo = new Lifo();
$lifo->push(1);
$lifo->push(2);

$sum = ($lifo->pop() ?? 0) + ($lifo->pop() ?? 0);
```

docblock generic은 언어의 네이티브 문법이 아니고 제 3자의 정적 분석 도구에 의존하며, 런타임의 타입 확인을 하지 않는다. 네이티브 문법이 아니기 때문에 언어의 내장 툴에 비해 작성해야 하는 보일러 플레이트의 양이 많으며, 언어의 동작에 영향을 주지 않기 위해서 런타임 체크가 없다. 또한 docblock으로 타입을 맞출 때, docblock 자체(/* ... */의 ...부분)는 IDE에 의한 구문 지적이 없기 때문에 docblock을 타이핑 할 때 실수하기 쉽고 무엇이 잘못되었는지 파악하기 어려운 문제가 있다.

docblockジェネリクスは言語のネイティブ文法ではなく、サードパーティの静的解析ツールに依存し、ランタイムでの型チェックは行いません。ネイティブ文法ではないため、言語の組み込みツールと比べて記述しなければならないボイラープレートが多くなり、また言語の動作に影響を与えないようにランタイムチェックもありません。さらに、docblockで型を指定する場合、docblock自体（/* ... */の...部分）はIDEによる構文チェックが行われないため、docblockのタイピング時にミスが発生しやすく、何が間違っているのか把握しにくいという問題があります。

또한 정적 분석 도구들은 타사 라이브러리이므로 프로젝트에 PHPStan을 사용하는데, 라이브러리는 Psalm을 사용하고 있다면, 라이브러리의 코드를 사용할 때 타입 추론이 안 되는 호환성 문제가 발생할 수 있다.

また、静的解析ツールはサードパーティ製なので、プロジェクトでPHPStanを使っているが、ライブラリ側はPsalmを使っている場合、ライブラリのコードを利用する際に型推論がうまく働かない互換性の問題が発生することがあります。

## 유니온 타입의 문제
## ユニオン型の問題

php의 각종 라이브러리가 유니온 타입으로 타입이 만들어져 있고, 제네릭을 사용하지 않기 때문에 라이브러리의 기능이 유니온 타입 또는 클래스 타입이라면 유니온 타입 중의 몇 가지 타입, 하위 타입 중의 무언가를 사용하는데 모든 코드에 대해, 정적 분석을 사용하면 라이브러리의 타입 힌트로 제공되는 모든 타입에 대한 처리를 만들어야 한다.

PHPのさまざまなライブラリはユニオン型で型が定義されており、ジェネリクスが使われていないため、ライブラリの機能がユニオン型やクラス型の場合、ユニオン型の中のいくつかの型やサブタイプのいずれかを使うことになります。そのため、すべてのコードで静的解析を使用すると、ライブラリの型ヒントで提供されるすべての型に対する処理を記述する必要があります。

예를 들어 라라벨의 Eloquent를 사용했을 때 `SomeModel::someQuery()->first()`라는 코드를 사용했을 때, [`Model|object|BuildsQueries|null`](https://api.laravel.com/docs/10.x/Illuminate/Database/Eloquent/Builder.html#method_first)가 타입힌트로 되어 있다. 라라벨 11 부터는 PHPStan으로 정적 분석이 되도록 [TValue|null](https://api.laravel.com/docs/11.x/Illuminate/Database/Eloquent/Builder.html#method_first)을 지원하지만, 라라벨 10 이전이라면, Model|object|BuildsQueries|null 정적 분석 툴을 사용하면 모든 타입에 대한 분기처리를 해야 한다. 하지만 일반적인 상황에서 실제 first가 반환하는 값은 SomeModel 클레스의 인스턴스 또는 null을 두 가지 타입 뿐이다.

たとえば、LaravelのEloquentを使う場合、`SomeModel::someQuery()->first()` というコードでは、[`Model|object|BuildsQueries|null`](https://api.laravel.com/docs/10.x/Illuminate/Database/Eloquent/Builder.html#method_first) が型ヒントになっています。Laravel 11以降ではPHPStanによる静的解析をサポートするために [TValue|null](https://api.laravel.com/docs/11.x/Illuminate/Database/Eloquent/Builder.html#method_first) となっていますが、Laravel 10以前の場合、Model|object|BuildsQueries|null なので静的解析ツールを使うとすべての型に対する分岐処理が必要になります。しかし、一般的な状況で実際にfirstが返す値はSomeModelクラスのインスタンス、またはnullの2種類だけです。

정적 분석 도구는 `assert`를 통해서 타입 좁히기 기능을 제공하기 때문에 `assert`로 유니온 또는 상위 타입에 실제 사용되는 일부 또는 하위 타입을 구체적으로 알려주는 것을 통해서 모든 타입에 대한 분기처리가 아니라, 실제 사용하는 타입에 대한 처리만 하는 코드를 작성하도록 도울 수 있다.

静的解析ツールは`assert`によって型の絞り込み機能を提供しているため、`assert`でユニオン型や上位型のうち、実際に使う型やサブタイプを具体的に指定することで、すべての型に対する分岐処理ではなく、実際に使用する型への処理だけを書くことができるようになります。

```php
$someData = SomeModel::someQuery()->first();
assert(is_null($someData) || $someData instanceof SomeModel);
```

SomeModel은 Model 인스턴스를 상속하여 정의한 모델으로 Model의 하위 타입이다. 따라서 타입 좁히기를 통해서 변수에 할당된 값이 SomeModel 타입 또는 null으로 정적 분석 툴과 IDE에 알려 준다. 그러면 `assert` 이후 라인 부터는 `$someData` 변수를 사용할 때 null과 SomeModel 두 가지 타입에 대한 처리만 하면 된다.

SomeModelはModelインスタンスを継承して定義されたモデルであり、Modelのサブタイプです。そのため、型の絞り込みを行うことで、変数に代入された値がSomeModel型またはnullであることを静的解析ツールやIDEに伝えることができます。そうすると、`assert`以降の行では、`$someData`変数を使用する際にnullとSomeModelの2つの型に対する処理だけを行えばよくなります。

Eloquent 모델 내에서 메소드를 오버라이딩 하는 방법도 존재한다. 마찬가지로 부모 클래스의 메소드의 반환 값이 Model|object|BuildsQueries|null 타입을 가지고 있으므로 타입 좁히기를 해 주어야 한다.

Eloquentモデル内でメソッドをオーバーライドする方法もあります。同様に、親クラスのメソッドの戻り値がModel|object|BuildsQueries|null型なので、型の絞り込みを行う必要があります。

```php
public function first(array|string $columns = ['*']): ?SomeModel
{
    $first = parent::first($columns);
    assert(is_null($first) || $first instanceof SomeModel);
    return $first;
}
```

위 방법은 first가 존재하는 클래스에 정의해 주어야 하기 때문에 first가 정의된 [BuilderClass](https://timacdonald.me/dedicated-eloquent-model-query-builders/)를 상속받는 클래스에 적어 주어야 한다.

この方法はfirstが定義されているクラスで定義する必要があるため、firstが定義されている[BuilderClass](https://timacdonald.me/dedicated-eloquent-model-query-builders/)を継承するクラスに記述する必要があります。

## Type narrowing의 문제
## Type narrowingの問題

타입스크립트는 타입에 의한 안정성을 최대한 확보하기 위해서 전달된 변수를 사용할 때 변수가 가진 모든 타입에 대한 처리를 요구한다. as를 사용해서 타입좁히기를 하면 모든 타입 중에서 일부 타입만 전달되는 것을 가정하고 코드를 전개하기 때문에 런타임에 좁힌 타입과 다른 타입이 전달될 경우 연결된 코드의 타입 추론이 잘못되어 런타임에 잘못된 동작을 하게 될 가능성이 존재한다.

TypeScriptは型による安全性を最大限に確保するため、渡された変数を使用する際に、その変数が持つすべての型に対する処理を要求します。`as`を使って型の絞り込み（type narrowing）を行うと、すべての型のうち一部の型だけが渡されることを前提にコードが展開されるため、実行時に絞り込んだ型とは異なる型が渡された場合、接続されたコードの型推論が誤り、実行時に不正な動作をする可能性があります。

다음 리액트 코드에서 `event.target`는 여러 태그 요소 중 하나를 자바스크립트의 인스턴스로 만든 것이다. 전달되는 태그는 여러 태그 중 어느 태그가 전달되는 것이고, 태그들 각각이 서로 다른 타입을 갖기 때문에 여러 타입 중 어느 하나를 알려 줘야 다음 코드를 작성할 수 있어서 as를 사용하여 타입 좁히기를 통해서 타입을 알려 주었다.

次のReactコードでは、`event.target`は複数のタグ要素のうちの一つをJavaScriptのインスタンスとして表しています。渡されるタグは複数のタグのうちどれかであり、それぞれのタグが異なる型を持つため、どの型かを明示しなければ次のコードを記述できません。そのため、`as`を使って型の絞り込みを行い、型を指定しています。

```ts
const handleClick = (event: React.MouseEvent) => {
  const target = event.target as HTMLButtonElement;
  console.log(target.value);
};
```

타입스크립트에서는 위의 코드 대신에, 제네릭을 통해서 다음과 같이 `.target`의 타입을 구체적으로 지정하는 방식을 추천한다. `React.MouseEvent<HTMLButtonElement>`으로 전달되는 이벤트 내부에서 사용할 타입을 정확하게 지정하는 것으로 `event.target`의 타입을 정확하게 도출해 낼 수 있도록 한다.

TypeScriptでは、上記のコードの代わりにジェネリクスを使って、次のように`.target`の型を具体的に指定する方法が推奨されています。`React.MouseEvent<HTMLButtonElement>`のように、渡されるイベントの内部で使用する型を正確に指定することで、`event.target`の型を正しく導き出せるようにしています。

```ts
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
  const target = event.target;
  console.log(target.value);
};
```

하지만 onClick 이벤트 핸들러는 런타임에서 호출되어 이벤트를 전달하므로 타입스크립트로 정한 타입과 실제 이벤트로 생성되어 이벤트 함수로 전달되는 인자의 타입 불일치가 있을 수 있으므로 개발 시 반드시 런타임에서 이상 동작이 없는지 확인을 해야 한다. 자바스크립트가 동작할 때 덕타이핑 미스매칭이 발생하지 않으면 잘못된 부분을 알지 못할 수도 있기 때문에 다음과 같이 잘못된 부분을 좀 더 명확히 체크하는 쪽이 좋다.

ただし、onClickイベントハンドラはランタイムで呼び出されてイベントが渡されるため、TypeScriptで指定した型と実際にイベントとして生成されてイベント関数に渡される引数の型が一致しない場合があります。そのため、開発時には必ずランタイムで異常な動作がないか確認する必要があります。JavaScriptが動作する際にダックタイピングのミスマッチが発生しなければ誤りに気付かないこともあるため、次のように間違っている部分をより明確にチェックする方が良いでしょう。

```ts
const handleClick = (event: React.MouseEvent) => {
  const target = event.target;
  if (target instanceof HTMLButtonElement) {
    console.log(target.innerText);
  } else {
    console.warn('type mismatching');
  }
};
```

### 런타임으로 동작 확인의 중요성
### ランタイムで動作確認を行う重要性

#### 비즈니스 로직의 표현
#### ビジネスロジックの表現

자바의 라이브러리들 처럼 새로운 클래스를 만들고, 클래스 간 연산 메서드를 정의하는 방식으로 새로운 타입을 만들어 추상화하는 것은 때때로 유용하다. 하지만 이 방식은 상황에 따라 어렵거나 불가능할 수 있으며, 비즈니스 로직의 제약을 간단히 표현할 수 있음에도 불구하고 타입 안정성을 지나치게 추구하다 보면 오히려 이해하기 어려운 코드가 될 수 있다.

Javaのライブラリのように新しいクラスを作成し、クラス間の演算メソッドを定義することで新しい型を作って抽象化する方法は、場合によっては有用です。しかしこの方法は、状況によっては難しかったり不可能な場合もあり、ビジネスロジックの制約を簡単に表現できるにもかかわらず、型の安全性を過度に追求すると、かえって理解しにくいコードになってしまうこともあります。

#### 외부에서 전달되는 값의 매핑
#### 外部から渡される値のマッピング

각종 외부에서 입력된 값을 프로그래밍 언어에 매핑하는 과정인 리퀘스트 데이터나 데이터베이스에서 가져온 값 등 외부 데이터를 프로그래밍 언어에 매핑하는 것은 대개 정해진 범위 내의 값이 전달되지만, 때때로 상정한 범위 이외의 값이 전달될 가능성도 있기 때문에 반드시 런타임 확인이 필요한 부분이다.

さまざまな外部から入力された値をプログラミング言語にマッピングする過程、たとえばリクエストデータやデータベースから取得した値など外部データをプログラミング言語にマッピングする際には、たいてい決められた範囲内の値が渡されますが、時には想定外の値が渡される可能性もあるため、必ずランタイムでの確認が必要な部分です。

#### 논리 문제
#### 論理の問題

타입으로는 검출할 수 없는 비즈니스 논리에 의해 발생하는 논리 문제를 해결하기 위해서는 런타임의 동작 확인을 해야한다. 이는 개발자 뿐만 아니라 서비스를 운용하는 사람들의 검증을 받아야 하는 부분이므로 반드시 런타임 동작을 통해서 비즈니스 로직에 문제가 없는지 개발자와 운용자의 인식 차이가 없는지 확인하는 것이 매우 중요하다.

型では検出できないビジネスロジックによるロジック問題を解決するためには、ランタイムでの動作確認が必要です。これは開発者だけでなく、サービスを運用する人たちの検証も受ける必要がある部分なので、必ずランタイム動作を通じてビジネスロジックに問題がないか、開発者と運用者の認識に違いがないかを確認することが非常に重要です。

#### 동일 타입 내의 값의 변화
#### 同一型内での値の変化

일반적인 웹 개발은 비즈니스 로직이 중요한 부분을 담당한다. 사용자의 입력값에 대한 적절한 벨리데이션, 입력값과 저장된 값을 비교하여 적절한 논리적인 제약사항을 표현하는 것들은 동일한 타입 안에서의 값의 차이가 중요한 로직이 많다. 또한 동일 타입에서도 값의 변화에 의존하는 다양한 계산 로직의 경우 런타임 값의 변화 확인이 중요하다.

一般的なWeb開発では、ビジネスロジックが重要です。ユーザーの入力値に対する適切なバリデーションや、入力値と保存された値を比較して適切な論理的制約を表現することなど、同じ型の中で値の違いが重要となるロジックが多くあります。また、同じ型であっても値の変化に依存するさまざまな計算ロジックの場合、ランタイムでの値の変化の確認が重要です。

### php에서 타입 좁히기가 괜찮은 방법인 이유
### PHPで型の絞り込み（Type narrowing）が有効な理由

`assert`를 통한 타입 체크 기능은 타입 좁히기를 사용하기 때문에 타입 시스템을 통한 안정성을 획득하는 측면에서 제네릭에 비할 수 없으며 불완전하다. 하지만, 대부분의 언어가 컴파일이 되면서 제네릭 타입이 삭제되어 런타임 타입 확인이 불가능한 것에 반해 (C#은 제네릭의 타입 삭제가 이뤄지지 않는 특별한 언어이므로 논외) php는 런타임에 거의 대부분의 타입을 확인할 수 있고, 빌드라는 시간이 걸리는 과정 없이 빠르게 실행하여 전달되는 타입의 적절성을 체크할 수 있으므로 제네릭이 없더라도 타입 안정적인 코드를 만들 수 있다.

`assert`による型チェック機能は、型の絞り込みを利用しているため、型システムによる安全性の面ではジェネリクスほど強力ではなく、不完全です。しかし、多くの言語ではコンパイル時にジェネリクス型が消去されてランタイムで型確認ができなくなるのに対し（C#はジェネリクスの型消去が行われない特殊な言語なので除外）、PHPはランタイムでほとんどの型を確認することができ、ビルドという時間のかかるプロセスなしに素早く実行して渡された型の適切性をチェックできるため、ジェネリクスがなくても型安全なコードを作ることができます。

php에서 실제 프로덕션 환경에서 타입으로 인한 문제가 자주 발생하는 코드를 작성한다면, 컴파일 언어를 사용해도 비슷한 문제를 만드는 코드를 작성할 가능성이 높다. php는 가능한 정적 분석에 의해 구문 분석이 가능한 방향의 코딩을 하는 스킬이 필요하고, 컴파일 언어는 컴파일러에 의해 잘못된 코드의 확인이 가능한 방향의 코딩을 하는 스킬이 필요하다.

もしPHPで実際のプロダクション環境で型による問題が頻発するようなコードを書いている場合、コンパイル言語を使っても同様の問題を引き起こすコードを書く可能性が高いです。PHPでは可能な限り静的解析による構文チェックができる方向でコーディングするスキルが必要であり、コンパイル言語ではコンパイラによって誤ったコードを検出できる方向でコーディングするスキルが必要です。

## PHP에 왜 제네릭이 없는가?
## なぜPHPにはジェネリクスがないのか？

php 파서의 모던화에 공헌했던 [니키타의 의견](https://www.reddit.com/r/PHP/comments/j65968/comment/g83skiz/?utm_source=share&utm_medium=web2x&context=3)을 보면 php에 제네릭을 도입하는 것이 쉬지 않다는 것을 알 수 있다. 제네릭을 사용한 php 파서에서 유형 추론의 복잡성 문제, php 파서의 대량의 리펙토링 문제, 런타임 성능 저하의 문제 등의 문제로 쉽사리 도입되지 못하고 있다.

PHPパーサーのモダン化に貢献した[ニキータの意見](https://www.reddit.com/r/PHP/comments/j65968/comment/g83skiz/?utm_source=share&utm_medium=web2x&context=3)を見ると、PHPにジェネリクスを導入することが容易ではないことがわかります。ジェネリクスを導入したPHPパーサーでは、型推論の複雑性の問題、パーサーの大規模なリファクタリングの問題、ランタイムパフォーマンスの低下など、さまざまな問題があり、簡単には導入できていません。

만약 제네릭을 도입하게 되더라도 더 이상 php라고 할 수 없을 정도의 변경사항이 발생할 수도 있다는 의견이 있다. php는 레거시 코드에 대한 최대한의 호환성을 유지하면서 업데이트가 되는 전략을 가지고 있으므로 제네릭 도입으로 기존의 코드를 너무 많이 수정해야 한다면, php의 호환성의 이점이 사라질 것이다.

もしジェネリクスを導入することになったとしても、それはもはやPHPとは呼べないほどの変更になる可能性がある、という意見もあります。PHPはレガシーコードに対する最大限の互換性を維持しながらアップデートされる戦略をとっているため、ジェネリクスを導入して既存のコードを大幅に修正しなければならないのであれば、PHPの互換性というメリットが失われてしまいます。

또한 php는 오픈소스로서 php의 코어에 자발적으로 공헌하는 개발자들에 의해 유지된다. 언어의 스펙을 변경할 수 있는 풀 타임 개발자를 상당한 비용을 지불해서 고용하기 어렵기 때문에 대규모의 리펙토링은 현실적으로 어려움이 있다. 최근 php 파운데이션의 설립으로 php 코어에 기여할 수 있는 풀타임의 개발자들을 고용하는 것으로 이 문제는 어느　정도 해결 될 것으로 보인다.

また、PHPはオープンソースであり、PHPコアは自発的に貢献する開発者によって維持されています。言語仕様を変更できるフルタイム開発者を多額の費用をかけて雇うのは難しいため、大規模なリファクタリングは現実的に困難です。最近ではPHPファウンデーションの設立により、PHPコアに貢献するフルタイム開発者を雇うことで、この問題はある程度解決される見込みです。

php의 제네릭 연구는 php 파운데이션의 [기사](https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections)를 참고하자.

PHPのジェネリクス研究については、PHPファウンデーションの[記事](https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections)も参考にしてください。

### 런타임 타임 확인을 고집하기
### ランタイム型チェックにこだわる理由

타입스크립트, 파이썬, 자바 등 많은 언어에서 제네릭을 지원하기 위해 컴파일 후 제네릭의 타입이 삭제되는 방식을 도입하여 런타임 타입을 확인할 수 없는 경우가 있다. 하지만 php는 가능한 런타임 타입 확인을 할 수 있는 언어로 남고자 하기 때문에 파이썬이나 타입스크립트와 같이 런타임에 타입이 삭제하는 방향의 변화를 거부한다. 런타임 타입 삭제 기능이 필요하다면 php 언어의 네이티브 기능이 아닌 docblock을 사용한 정적 분석이 타입 체크 기능을 잘 지원하기 때문에 phpdoc을 이용하도록 권장한다.

TypeScript、Python、Javaなど多くの言語では、ジェネリクスをサポートするためにコンパイル後にジェネリクスの型が消去され、ランタイムで型を確認できない場合があります。しかし、PHPはできるだけランタイムで型確認が可能な言語であり続けたいと考えているため、PythonやTypeScriptのようにランタイムで型が消える方向への変化を拒否しています。もしランタイム型消去機能が必要であれば、PHP言語のネイティブ機能ではなくdocblockを使った静的解析による型チェックが十分にサポートされているので、phpdocの利用が推奨されています。

TypeScript와 같이 컴파일 시점에 타입이 제거되는 언어에서 타입 미스매칭 에러가 발생했을 때, 복잡한 타입 체계(제네릭, 유니온, Higher-Kinded Type 등)를 사용하는 경우 어느 부분의 타입이 잘못 되었는지 파악하기 어려운 경우가 있다. 런타임에서 타입을 확인할 수 있다면 디버깅을 통해서 실행 중 어느 지점에서 잘못된 타입이 전달되었는지 디버깅을 통해 값의 변화를 확인하고 추적하기 쉽다.

TypeScriptのようにコンパイル時に型情報が削除される言語では、型ミスマッチのエラーが発生した際に、ジェネリクス、ユニオン型、Higher-Kinded Typeなどの複雑な型体系を使用している場合、どの部分の型が誤っているのかを特定するのが難しいことがあります。
もし実行時に型を確認できれば、デバッグを通じて、どのタイミングで誤った型が渡されたのかを値の変化から追跡しやすくなります。

하지만 런타임에 타입을 확인할 수 없다면 개발자는 IDE가 제안하는 타입 정의를 일일이 따라가며, 어느 부분에서 타입이 어긋났는지를 타입 체계를 따져가며 추론해야 하기 때문에 타입 문제를 해결하기 어렵다는 문제점 또한 존재한다.

しかし、実行時に型を確認できない場合、開発者はIDEが提案する型定義を一つ一つ追いながら、どの部分で型の齟齬が生じたのかを型体系に従って推論する必要があり、型の問題を解決するのが困難になるという課題もあります。

php는 값을 디버깅하면 타입의 변화를 추적할 수 있기 때문에 적절한 타입이 전달되었는지 추적 및 디버깅이 수월하다는 장점도 있다.

一方、PHPでは値をデバッグすることで型の変化を追跡することができるため、適切な型が渡されているかどうかの追跡やデバッグが容易であるという利点があります。

### 런타임 타입 체크 기능이 여전히 필요한 이유
### ランタイム型チェック機能が依然として必要な理由

php는 타입힌트를 통해서 런타임 타입 검사를 한다. 타입힌트는 정적 분석 도구나 IDE에 타입 검사를 할 수 있게 해 준다는 장점도 있지만, 런타임 타입 검사를 하기 때문에 무시해도 될 정도이긴 하지만 약간의 성능 저하를 유발한다. 이 때문에 일부 사람들은 php에서 제네릭을 도입하기 위해서 미래에는 타입힌트의 런타임 타입 확인 기능을 삭제하고, 타입스크립트와 같이 실제 코드가 실행되기 전에 타입 체크를 하는 언어로 바꾸자는 주장을 하기도 한다. 하지만 런타임 타입 체크를 하지 않는 것이 마냥 좋은 것은 아니다.

PHPは型ヒントを通じてランタイム型検査を行います。型ヒントは静的解析ツールやIDEによる型チェックができるという利点もありますが、ランタイムで型検査を行うため無視できる程度とはいえ若干のパフォーマンス低下を引き起こします。このため、一部の人たちはPHPでジェネリクスを導入するなら将来的には型ヒントのランタイム型検査機能を削除し、TypeScriptのように実際のコードが実行される前に型チェックを行う言語に変えようと主張することもあります。しかし、ランタイム型チェックを行わないことが必ずしも良いとは限りません。

런타임에서 타입을 확인하지 않는 것은 어떠한 값이든 전달 가능하다는 문제가 있다. 그래서 런타임에서 타입과 미스 매칭되는 값이 잘못 들어가지 않도록 외부의 값이 프로그래밍 언어로 매핑될 때 잘못된 타입으로 전달되지 않도록 정확한 타입으로 매핑 되는지 확인하는 작업이 필요하다. 타입스크립트의 경우 Zod, Ajv, Yup, Joi, Valibot 등의 라이브러리를 통해서 잘못된 타입이 매핑되지 않도록 방지한다. 자바나 C#의 경우 ORM의 정의와 실제 디비의 스키마가 불일치하는 임피던스 미스매칭 현상이 발생하지 않도록 주의해야 한다.

ランタイムで型を確認しない場合、どんな値でも渡せるという問題があります。したがって、ランタイムで型とミスマッチする値が誤って渡されないように、外部の値がプログラミング言語にマッピングされる際に、誤った型で渡されないように正確な型でマッピングされているかどうかを確認する作業が必要です。TypeScriptの場合、Zod、Ajv、Yup、Joi、Valibotなどのライブラリを使って誤った型のマッピングを防いでいます。JavaやC#の場合、ORMの定義と実際のデータベーススキーマが一致しないインピーダンスミスマッチ現象が発生しないよう注意が必要です。

또 다른 런타임 타입 확인이 없을 때의 문제는 런타임에 잘못된 값이 전달되지 않게 하기 위해 지나치게 엄격하게 타입을 지정해야 하는 문제가 생긴다. php에서는 정적 추론 도구를 사용하지 않은 개발로 많은 프로젝트가 만들어 졌는데, 개발 초기 단계 부터 엄격하게 타입의 정적 추론이 가능하도록 짜 놓은 프로젝트인 경우 리퀘스트로 데이터가 전달되는 부분이나 데이터베이스의 값을 프로그래밍 언어의 값으로 매핑하는 부분만 런타임 확인을 해 주면, 그 이후로는 런타임의 타입 검사를 배제해도 잘못된 타입이 들어가는 경우를 막을 수 있지만, 정적 추론 없이 오랫동안 작성되어 온 php 프로젝트라면 정적 추론을 위해 모든 데이터 전달 플로우에 타입을 넣어야 하는데 이는 현실적으로 어려운 문제에 직면할 수 있다.

もう一つ、ランタイム型チェックがない場合の問題は、ランタイムで誤った値が渡されないようにするため、過度に厳格な型定義が必要になることです。PHPでは静的推論ツールを使わずに多くのプロジェクトが作られてきましたが、開発初期から厳格な型の静的推論ができるように設計されたプロジェクトであれば、リクエストでデータが渡る部分やデータベースの値をプログラミング言語の値にマッピングする部分だけランタイムで確認すれば、その後はランタイム型検査を省いても間違った型が入るのを防ぐことができます。しかし、静的推論なしで長年書かれてきたPHPプロジェクトの場合、静的推論のためにすべてのデータフローに型を付与するのは現実的に困難な問題に直面することがあります。

또 다른 문제는 외부 라이브러리나 외부에서 전달된 값을 사용할 때 지정된 타입 이외의 다른 어떤 타입의 값이 전달되어 사용되는지 확신 할 수 없는 경우가 있다. 타입 안정적인 코드를 작성하려면 모든 예외 사항에 대한 어떤 타입의 처리를 할지에 대한 명세를 만들어야 한다는 것이다. 이런 것이 불가능한 경우가 있기 때문에 런타임의 타입 검사를 통해서 기대하지 못한 타입의 전달으로 처리될 수 없는 경우 에러를 발생 시켜 예측하지 못한 상황에 대해 다음 부터는 어떻게 처리 할지 추가적인 처리를 점진적으로 만들어 나가는 방식으로 대응하도록 한다.

さらに、外部ライブラリや外部から渡された値を使う場合、指定された型以外のどんな型の値が渡されてくるかわからないこともあります。型安全なコードを書くには、すべての例外ケースについてどんな型の処理をするか仕様を作る必要がありますが、これが不可能な場合もあるため、ランタイム型検査によって予期しない型の値が渡された場合にエラーを発生させ、予期しないケースへの対応を段階的に追加していく方法で対処します。

런타임의 타입 검사의 장점은 모든 데이터 전달 플로우의 타입이 명확하게 정의되고 벨리데이션도 완벽하게 갖춰지지 않는 상태에서 작성한 코드의 동작을 런타임으로 타입 미스매칭이 발생한 부분을 개선하는 것으로 작성한 코드의 타입 안정성을 확보할 수 있다는 장점을 갖고 있다.

ランタイム型検査の利点は、すべてのデータフローの型が明確に定義されておらずバリデーションも完璧でない状態で書かれたコードでも、ランタイムで型ミスマッチが発生した部分を改善することでコードの型安全性を確保できる点です。

제네릭 도입을 위해서 런타임 타임 검사를 제거하자는 의견이 제기되고 있지만, 수 많은 타입추론 불가능한 php의 코드에서 런타임 이전에 타입을 검사할 수 있는 시스템으로 변경하는 것은 현실적으로 불가능에 가깝기 때문에 런타임 타입 체크 기능을 유지하면서 php는 발전하고 있다.

ジェネリクス導入のためにランタイム型検査を撤廃しようという意見も出ていますが、型推論が難しいPHPの膨大なコードベースでランタイム前に型検査ができるシステムに移行するのは現実的にはほぼ不可能であり、PHPはランタイム型チェック機能を維持しつつ発展し続けています。

## assert와 docblock generic 섞어 쓰기
## assertとdocblockジェネリクスの併用

정적 분석 도구 및 IDE를 통해서 docblock의 제네릭을 사용할 수 있다. 하지만, docblock은 런타임의 타입을 보증할 수 없는 단점이 있기 때문에 assert와 함께 병행하는 것으로 효율적인 코드를 구성할 수 있다.

静的解析ツールやIDEを利用することで、docblockのジェネリクスを活用することができます。しかし、docblockには実行時の型を保証できないという欠点があるため、assertと併用することで効率的なコードを構成することが可能です。

```php
/**
 * @var array<int, string> $list
 */
$list = json_decode(json_encode(range('a', 'i')) ?: '[]');

assert(is_array($list));
assert(array_reduce($list, fn($acc, $v) => $acc && is_string($v), true));

foreach($list as $el) {
    // assert(is_string($el));
    echo $el;
}

array_walk($list, function (mixed $el) {
    // assert(is_string($el));
    echo $el;
});
```

`assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true))`는 배열의 모든 원소가 문자열인지 확인하는 전제조건을 설정한 코드이다. 이 코드는 앞서 IDE에 의해서 배열의 원소 타입 추론이 되지 않는다고 하였다. 따라서 배열을 순회 할 때 마다 `assert(is_string($el))`, ` assert(is_string($el))`를 써 주어야 한다고 하였다.


`assert(array_reduce($list, fn($acc, $v) => $acc && is_int($v), true))`というコードは、配列のすべての要素が整数であることを確認する前提条件を設定するものです。このコードでは、IDEによって配列の要素の型が推論されないことがあるため、配列をループするたびに`assert(is_string($el))`, ` assert(is_string($el))`のように、毎回型チェックを書く必要があるとされます。

하지만 `@var array<int, string> $list`라는 docblock을 사용하면 IDE는 타입을 배열의 원소 타입을 알 수 있고, `assert`로 배열의 원소 타입을 런타임에서 체크하도록 하였다. 이를 통해서 IDE와 정적 분석에 의한 타입 확인 및 런타임 타입 확인 둘을 만족하는 코드를 작성할 수 있어서 배열을 순회 할 때마다 `assert`로 각 원소의 타입을 확인할 필요가 없다.

しかし、`@var array<int, string> $list`というdocblockを使用すれば、IDEは配列の要素の型を認識することができ、加えて`assert`によって実行時に型チェックも行うようにすれば、静的解析と実行時チェックの両方を満たすコードを書くことができます。その結果、配列をループするたびに個々の要素に対して`assert`を使って型を確認する必要がなくなります。

## assert

`assert`는 환경에 따라서 코드를 실행할 수도 있고, 코드를 실행하지 않을 수도 있다. 개발환경이나 검증 환경에서는 `assert`를 사용하여 타입 체크를 하고, 프로덕션 환경에서는 `assert`의 코드가 실행되지 않도록 하는 것을 통해서 런타임 타입 확인에 필요한 리소스를 줄일 수 있다.

assertは環境によってコードが実行される場合と、実行されない場合があります。開発環境や検証環境ではassertを使って型チェックを行い、本番環境ではassertのコードが実行されないようにすることで、実行時の型チェックに必要なリソースを削減することができます。

컴파일러가 엄격한 타입체크를 하는 언어에서는 `assert`는 값의 적절성만을 체크하지만, php에서는 값의 적절성 뿐만 아니라 타입을 체크하고 타입 좁히기를 사용할 수 있다.

コンパイラが厳密な型チェックを行う言語では、assertは値の妥当性のみを検証するために使われますが、PHPでは値の妥当性だけでなく型のチェックや型の絞り込みにも利用することができます。

# 마지막으로
# 最後に

php는 언어에 내장된 제네릭이 없다. 하지만 docblock 제네릭을 사용하거나 유니온 타입을 사용하고 `assert`로 타입을 좁히는 방식과 컴파일 없이 빠르게 런타임 동작을 확인하는 것으로 제네릭이 없는 한계를 극복하면서 로직을 작성할 수 있다.

PHPには言語に組み込まれたジェネリクスがありません。しかし、docblockジェネリクスを利用したり、ユニオン型を使って`assert`で型の絞り込みを行う方法、そしてコンパイルなしで素早くランタイム動作を確認することで、ジェネリクスがないという制約を克服しながらロジックを記述することができます。

엄격한 타입 시스템이 아니기 때문에 런타임에 전달되는 타입을 확인해야 하는 단점이 있기도 하지만, 엄밀한 타입 정의를 생략하고 런타임 확인을 통해서 전달된 타입을 확인하는 것으로 쉽게 로직을 작성할 수 있다는 장점이 있다.

厳格な型システムではないため、ランタイムで渡される型を確認しなければならないというデメリットもありますが、厳密な型定義を省略してランタイムチェックによって渡された型を確認することで、簡単にロジックを記述できるというメリットがあります。

php만으로 비즈니스 로직을 구성하고, 서비스를 제공하는데 문제는 없다. 하지만, 최근 많은 언어들이 좋은 타입 시스템을 도입하고 있기 때문에 좋은 타입 시스템을 배울 수 있는 다른 언어도 함께 활용할 수 있는 개발 환경을 경험 해 보는 것도 좋을 것 같다.

PHPだけでビジネスロジックを構成し、サービスを提供することに問題はありません。しかし、最近は多くの言語が優れた型システムを導入しているため、良い型システムを学べる他の言語もあわせて活用できる開発環境を経験してみるのも望ましいでしょう。
