# php의 배열함수

## php 배열함수의 단점
- 대부분의 인기 있는 언어에서 배열에 관한 체이닝 함수는 필수적인 추세이다. 하지만 php에서는 기본적으로 제공되는 배열함수는 체이닝을 할 수 없다.
- php의 배열함수는 자바스크립트의 예와 같이 `[1,2,3,4,5].filter(e => e>=3).map(e => e+1)` 이렇게 체이닝을 하는 방법을 사용할 수가 없다.
- 배열 함수별로 인자의 구성이 저마다 다르다. 예를 들어 array_filter의 경우에는 첫 번째 인자가 배열, 두 번째 인자가 callable이다. 하지만 array_map의 경우에는 첫 번째 인자가 callable 두번째 인자가 배열이다. 이런 일관성의 불일치는 php의 배열함수를 쓰는 사람들에게 굉장한 불편함을 준다. 자주 사용하던 함수도 쓸 때 마다 인자의 순서 때문에 기억하기 어려워 문서를 확인해야 한다.

## 배열함수는 왜 인자의 순서가 다를까?
### 배열 순회 함수의 예외
- `array_map`함수는 `php`에서 일반적인 배열함수가 첫 번재 인자로 배열을 받는 것과 달리 콜백함수를 먼저 받기 때문에 코딩을 하다가 에러가 나서 다시 한 번 화야 하는 경우가 많은 함수이다.
- `array_map` 함수는 첫 번째 인자로 콜백함수를 받고, 두 번째 인자로 배열을 받는다. 3번째 인자부터 가변적으로 추가로 배열을 받을 수 있다. 여러 배열의 각 원소를 콜백 함수의 인자로 받아서 배열간의 복합적인 연산을 수행하기 위해서 만들어졌다. php의 배열 함수는 일반적으로 첫 번째 인자로 배열을 받는 것과 달리 첫 번째 인자로 콜백함수를 받고 두 번째 인자로 배열을 받았다. 콜백 함수의 인자로 여러 배열의 원소를 전달해야 하는 사양이기 때문에 여러 배열을 하나로 묶는 문법으로 만드는 것이 좋다. 따라서 기존의 첫 번째 인자로 배열을 받는 사양과는 다른 예외적인 인자 구성을 사용하였다. 물론 첫 번째 인자로 배열을 받고 마지막 인자로 함수가 오는 것 사양이 더 좋았을 것이다.

### 배열에서 특정 값을 지정하는 함수
- `in_array`, `array_key_exists`와 같은 함수들은 첫 번째 인자로 배열을 받지 않고 배열에서 어떤 값의 존재를 확인하기 위한 값을 지정한다. 두 번째 인자로 배열을 받는다.
- 배열에서 특정 값을 지정하는 것이므로 약간 사양이 달라서 다른 구성의 인자를 사용했다고 할 수는 있겠지만, 배열함수를 사용하는 사용자 입장에서는 이런 세세한 구분을 알기 보다는 그냥 배열 함수 종류에 해당하면 모두 배열을 첫 번째 인자로 받는다고 하는 편이 더 편하게 받아들일 것이다.

## 체이닝을 하지 않고 인자 방식으로 넘기는 방식으로 만들 경우
```
array_filter(
    fn($x) => $x >= 3,
    array_map(
        fn($x) => $x+1,
        array_map(
            fn($x) => $x+1,
            [1,2,3,4,5]
        ),
    )
)
```
- 끔찍한 코드가 되기 때문에 이런 방식의 사용을 지양해야 한다. 그러면 배열함수를 어떻게 사용해야 할까?

## 배열 함수를 사용하는 베스트프렉티스
```
$array = [1,2,3,4,5];
$array = array_filter($array, fn($x) => $x >= 3);
$array = array_map(fn($x) => $x+1, $array);
$array = array_map(fn($x) => $x+1, $array);
```
- 변수에 값을 재할당 하는 방식으로 사용해야 한다.
- 뒤에서도 살펴 보겠지만 php에서는 이런 방식의 사용이 배열 함수를 사용함에 있어서 가장 깔끔한 코드를 만든다.

## pipe 연산자 RFC 거부
```
[1,2,3,4,5]
|> fn($x) => array_filter($x, fn($x) => $x >= 3),
|> fn($x) => array_map(fn($x) => $x+1, $x),
|> fn($x) => array_map(fn($x) => $x+1, $x)
```
- 이런식으로 파이프 연산자를 도입해서 array_function의 체이닝을 할 수 있는 방식도 도입 되지 않았다.
- 파이프 연산자를 도입하면 그나마 쉽게 만들 수 있지만, 만약 도입한다고 해도 php의 기본 배열함수는 함수로 한 번 레핑을 해야 사용할 수 있는 단점이 있다.
- 변수에 값을 재할당 하는 방식으로 사용하는 베스트 프레틱스 방식에 비해서 코드상으로 전혀 나은 표현이라고 여겨지지 않기 때문에 RFC를 못 통과 한 게 아닐까 생각이 된다.

## 꼭 체이닝을 하고 싶다면?
```
array_reduce(
    [
        fn($x) => array_filter($x, fn($x) => $x >= 3),
        fn($x) => array_map(fn($x) => $x+1, $x),
        fn($x) => array_map(fn($x) => $x+1, $x)
    ]
, fn($x, $y) => $y($x), [1,2,3,4,5]);
```
- 이렇게 좀 불편하게 체이닝을 할 수는 있지만, 보일러 플레이트가 많은 단점이 존재한다.
- 이렇게 사용하는 것은 코드가 길어지고 해당 표현에 관한 지식이 있어야 하는 등 여러모로 불편한 점을 야기한다.
- 이렇게 짜게 된다면 아마 php에서는 리펙토링의 대상이 될 것.

## 지연평가 사용 불가
- 지연 평가란 f(x)의 결과를 y라고 할 때 이 결과에 g(y)와 같이 g함수를 사용해서 결과 값을 얻는 것이다. 하지만 연산한 결과에 연산한 결과에 연산한 결과를 넣는 것 보다 함수를 한꺼번에 묶어서 연산을 하는 방법이 있다. f·g 를 만들고 f·g(x)로 실행하여 결과 값을 얻는 것이다. 함수를 묶어서 실행할 수 있기 때문에 함수의 조합으로 하나의 도메인 로직 모듈 또는 기능의 단위를 묶어서 사용할 수 있어서 지연평가는 함수형 프로그래밍에서 아주 중요한 역할을 한다.
- 지연평가를 사용하기 위해서는 커링 가능한 함수를 만들어야 한다. 왜냐하면 일부 인자를 넣고 인자가 다 찰때까지 실행되는 것이 아니라 함수 자체로 존재해야 하기 때문이다.
- php의 기본 배열함수에 적용하기 위해서는 기존 함수를 변경할 수 있어야 하는데, 디폴트 배열함수는 변경 시도 자체가 불가능하기 때문에 사용할 수 없으며 지연평가를 위한 커링 함수를 만들기 위해서는 기본 배열함수를 변경 하는 것이 아닌 레핑을 해서 새로운 클로저를 만들어야 한다.
- php의 배열함수의 사례를 보고 알수 있지만 php의 기본 함수들은 함수 그 자체에 커링화 할 수 없기 때문에 지연평가를 만들지 못하고 지연평가가 되지 않기 때문에 함수들로 그룹화를 하는 방식의 함수형 프로그래밍을 할 수 없게 만든다. 따라서 함수형 프로그래밍을 쉽게 만들어 주는 커링이라든지 파이프연산자 등의 도입은 php의 디폴트 함수들과는 어울리지 않는다는 문제가 있다. 이런 php에 함수형 언어의 특징을 도입한다는 것은 아주 엉성한 형태의 프로그램을 만들 수 밖에 없다.

## callable에 대한 부정적 의견
- php의 클로저를 포함해서 php의 기본 함수들은 ()으로 호출할 수 있다. 이런 호출가능한 유형들을 callable이라고 한다. php 커뮤니티에서는 callable 유형에서 클로저를 제외한 나머지 callable 들에 대한 지원을 멈춰가고 있고 callable 유형을 사용할 수 있도록 표현식들을 확장하는 파이프연산자 문법 등에 대해 부정적인 의견을 가지고 있다. 

## 체이닝을 사용하고 싶다면?
- 함수형 라이브러리를 사용해 보자.
- 파이프 연산자에 대한 라이브러리 : https://github.com/boostphp/pipe-operator

## Reference
- https://www.php.net/manual/en/ref.array.php
