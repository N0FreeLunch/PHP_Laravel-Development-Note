# php의 배열함수

## php 배열함수의 단점

대부분의 인기 있는 언어에서 배열에 관한 체이닝 함수는 필수적인 추세이다. 하지만 php에서는 기본적으로 제공되는 배열함수는 체이닝을 할 수 없다.

php의 배열함수는 자바스크립트의 예와 같이 `[1,2,3,4,5].filter(e => e>=3).map(e => e+1)` 이렇게 체이닝을 하는 방법을 사용할 수가 없다.

배열 함수별로 인자의 구성이 저마다 다르다. 예를 들어 [`array_filter`](https://www.php.net/manual/en/function.array-filter.php)의 경우에는 첫 번째 인자가 `array`, 두 번째 인자가 `callable`이다. 하지만 `array_map`의 경우에는 첫 번째 인자가 `callable` 두번째 인자가 `array`이다.

이런 일관성의 불일치는 php의 배열함수를 쓰는 사람들에게 굉장한 불편함을 준다. 자주 사용하던 함수도 쓸 때 마다 인자의 순서 때문에 기억하기 어려워 문서를 확인해야 한다. php를 쓰는 사람들은 항상 이런 불만과 불편을 제기하며, 이런 불편함 때문에 php를 멀리하는 사람들도 있다.

## 배열함수는 왜 인자의 순서가 다를까?

### 배열 순회 함수의 예외

`array_map`함수는 `php`에서 일반적인 배열함수가 첫 번재 인자로 배열을 받는 것과 달리 콜백 함수를 먼저 받기 때문에 코딩을 하다가 첫 번째 인자로 배열을 넣었다가 에러가 나서 다시 한 번 화야 하는 경우가 많은 함수이다. 이런 불편함이 있음에도 여전히 인자의 순서 변경 등을 고려하지는 않는데, 그 이유를 살펴보자.

`array_map` 함수는 첫 번째 인자로 콜백함수를 받고, 두 번째 인자로 배열을 받는다. 3번째 인자부터 가변적으로 추가로 배열을 받을 수 있다. 배열 A, B가 있다고 하자. `(A[0], B[0])`, `(A[1], B[1])`, `(A[2], B[2])`, `(A[3], B[3])`... 이렇게 각 배열의 동일 키의 원소를 콜백 함수의 인자로 전달하여 동일 키를 가진 여러 원소들로 콜백함수의 로직을 구성할 수 있다.

php의 배열 함수는 일반적으로 첫 번째 인자로 배열을 받는 것과 달리 `array_map`은 첫 번째 인자로 콜백 함수를 받고 두 번째 인자로 배열을 받았다. 콜백 함수의 인자로 여러 배열의 원소를 전달해야 하는 사양이기 때문에 여러 배열을 하나로 묶는 문법으로 만드는 것이 좋다. 따라서 기존의 첫 번째 인자로 배열을 받는 일반적인 배열 함수의 사양과는 달리 배열을 가변 인자로 받기 위해서 가변 파라메터를 사용하는 문법을 사용하였다. 물론 첫 번째 인자로 배열을 받고 마지막 인자로 함수가 오는 것 사양이 최근의 트랜드와 부합했을 것이다.

php를 잘 활용하는 레벨의 프로그래머가 되면 상황에 따라 가변 파라메터를 적극 활용하게 되는데, 이 때가 되면 `array_map`의 활용도 편해질 것이다.

### 배열에서 특정 값을 지정하는 함수

`in_array`, `array_key_exists`와 같은 함수들은 배열의 순회 함수와 달리, 첫 번째 인자로 배열을 받지 않고 배열에서 어떤 값의 존재를 확인하기 위한 값(needle)을 지정한다. 두 번째 인자로 배열을 받는다.

배열에서 특정 값을 지정하는 것이므로 약간 사양이 달라서 다른 구성의 인자를 사용했다고 할 수는 있겠지만, 배열함수를 사용하는 사용자 입장에서는 이런 세세한 구분을 알기 보다는 그냥 배열 함수 종류에 해당하면 모두 배열을 첫 번째 인자로 받는다고 하는 편이 더 편하게 받아들이지 않을까?

## 체이닝 문제

### 체이닝을 하지 않고 인자 방식으로 넘기는 방식으로 만들 경우

```php
array_filter(
    fn($x) => $x >= 3,
    array_map(
        fn($x) => $x+1,
        array_map(
            fn($x) => $x+1,
            [1,2,3,4,5]
        ),
    )
)
```

끔찍한 코드가 되기 때문에 이런 방식의 사용을 지양해야 한다. 그러면 배열함수를 어떻게 사용해야 할까?

### 배열 함수를 사용하는 베스트프렉티스

```php
$array = [1,2,3,4,5];
$array = array_filter($array, fn($x) => $x >= 3);
$array = array_map(fn($x) => $x+1, $array);
$array = array_map(fn($x) => $x+1, $array);
```

변수에 값을 재할당 하는 방식으로 사용해야 한다.

뒤에서도 살펴 보겠지만 php에서는 이런 방식의 사용이 배열 함수를 사용함에 있어서 가장 깔끔한 코드를 만든다.

```php
$array = [1,2,3,4,5];
$array = array_filter($array, fn($x) => $x >= 3);
array_walk($array, fn(&$x) => $x+1);
array_walk($array, fn(&$x) => $x+1);
var_dump($array);
```

또는 배열을 참조해서 각 원소를 콜백함수에 참조로 넘겨주는 방식을 사용해서 `$array = ` 없이 코드를 줄일 수도 있다.

또한 `array_walk`를 사용하면 배열을 두 번째 인자로 받는 `array_map`과 달리, 배열을 첫 번째 인자로 받는 방식으로 사용 가능하다. 하지만 이 또한 참조를 지원하는 함수와 참조를 지원하지 않는 함수가 있기 때문에 어느 함수에서는 참조 방식을 사용하지 않고 어느 함수에서는 참조를 쓰는 방식이 되기 때문에 좋지 못하다는 단점이 있다.

`array_walk` 함수는 배열을 반환하는 방식이 아니라 참조하는 방식으로 변경하기 때문에 체이닝 방식으로 사용하지 못한다는 단점이 있다.

### 파이프 연산자 도입

php8.5 부터 파이프 연산자가 도입 되었다. [^1]

```php
[1,2,3,4,5]
|> fn($x) => array_filter($x, fn($x) => $x >= 3),
|> fn($x) => array_map(fn($x) => $x+1, $x),
|> fn($x) => array_map(fn($x) => $x+1, $x)
```

사실상 변수에 대입하는 방법에 비해 나을 것이 없지만, 임시 변수의 사용을 줄일 수 있다는 장점은 있다.

`|>`의 대상이 되는 함수는 배열이라는 인자를 하나 받는 함수이어야 한다. 위의 예제에서는 `fn` 함수의 구조를 그대로 보여줬지만 '$함수명'으로 대상을 가져오면 인자가 하나만 적용되어 체이닝을 할 수 있는 건지 선언된 함수를 확인하든지 체이닝용 함수라는 것을 명시 해 줘야 한다.

### 8.5 버전 미만인 경우 체이닝을 하고 싶다면?

```php
array_reduce(
    [
        fn($x) => array_filter($x, fn($x) => $x >= 3),
        fn($x) => array_map(fn($x) => $x+1, $x),
        fn($x) => array_map(fn($x) => $x+1, $x)
    ]
, fn($x, $y) => $y($x), [1,2,3,4,5]);
```

이렇게 좀 불편하게 체이닝을 할 수는 있지만, 보일러 플레이트가 많은 단점이 존재한다. 이렇게 사용하는 것은 코드가 길어지고 해당 표현에 관한 지식이 있어야 하는 등 여러모로 불편한 점을 야기한다. 이렇게 짜게 된다면 아마 php에서는 리펙토링의 대상이 될 것이다.

## 지연평가 사용 불가

지연 평가란 f(x)의 결과를 y라고 할 때 이 결과에 g(y)와 같이 g함수를 사용해서 결과 값을 얻는 것이다. 하지만 연산한 결과에 연산한 결과에 연산한 결과를 넣는 것 보다 함수를 한꺼번에 묶어서 연산을 하는 방법이 있다. f·g 를 만들고 f·g(x)로 실행하여 결과 값을 얻는 것이다. 함수를 묶어서 실행할 수 있기 때문에 함수의 조합으로 하나의 도메인 로직 모듈 또는 기능의 단위를 묶어서 사용할 수 있어서 지연평가는 함수형 프로그래밍에서 아주 중요한 역할을 한다.

지연평가를 사용하기 위해서는 커링 가능한 함수를 만들어야 한다. 왜냐하면 일부 인자를 넣고 인자가 다 찰때까지 실행되는 것이 아니라 함수 자체로 존재해야 하기 때문이다.

php의 기본 배열함수에 적용하기 위해서는 기존 함수를 변경할 수 있어야 하는데, 디폴트 배열함수는 변경 시도 자체가 불가능하기 때문에 사용할 수 없으며 지연평가를 위한 커링 함수를 만들기 위해서는 기본 배열함수를 변경 하는 것이 아닌 레핑을 해서 새로운 클로저를 만들어야 한다.

php의 배열함수의 사례를 보고 알수 있지만 php의 기본 함수들은 함수 그 자체에 커링화 할 수 없기 때문에 지연평가를 만들지 못하고 지연평가가 되지 않기 때문에 함수들로 그룹화를 하는 방식의 함수형 프로그래밍을 할 수 없게 만든다. 따라서 함수형 프로그래밍을 쉽게 만들어 주는 커링이라든지 파이프연산자 등의 도입은 php의 디폴트 함수들과는 어울리지 않는다는 문제가 있다. 이런 php에 함수형 언어의 특징을 도입한다는 것은 아주 엉성한 형태의 프로그램을 만들 수 밖에 없다.

### 함수형 라이브러리 사용

함수형 라이브러리를 사용해 보자.

- 파이프 연산을 위한 라이브러리 : https://github.com/boostphp/pipe-operator

- 파이프 연산을 위한 라이브러리 : https://github.com/Crell/fp

- 함수형 프로그래밍을 할 수 있도록 만들어진 라이브러리 : https://github.com/lstrojny/functional-php/tree/main

하지만 이런 라이브러리를 쓰는 것은 회사마다 프로젝트 마다 서로 다른 배열 라이브러리 사용을 초래하는 파편화의 문제에 직면할 수 있다는 문제점이 있다. 어렵지는 않겠지만 그에 따른 사용자의 학습 부담도 늘어나게 되는 문제를 가진다.

### 라라벨 컬렉션 라이브러리 사용

라라벨 컬렉션을 독립 패키지로 설치 가능해 졌다.

- 라라벨 컬렉션 라이브러리 : https://github.com/illuminate/collections

- 패키지 설치 방법 : https://packagist.org/packages/illuminate/collections

라라벨 프레임워크 내에서는 helper 함수로 배열을 컬렉션으로 바꿀 수 있는 `collect(배열)->메소드()`의 방식을 제공한다. 유닛 테스트를 위해서 helper 함수 보다는 클래스를 직접 사용하는 코드를 쓰는 쪽도 좋다.

```php
use Illuminate\Support\Collection;

Collection::make(배열)->메소드();
```

라라벨에서 간단히 사용할 수 있는 것과 달리 좀 더 코드량이 늘어나는 단점이 있긴하다.

라라벨은 php에서 가장 인기 있고 전망있는 라이브러리이다. 인기 있는 라라벨의 컬렉션을 별도의 라이브러리로 설치해서 사용할 수 있기 때문에, php 생태계에서 컬렉션 라이브러리를 다루는 사람을 잘 만날 수 있고, php 생태계에 있다면 라라벨을 추후에 접할 가능성이 상당히 높기 때문에 다른 사람들에게도 배움을 권유할만하다. 배열 보다는 컬렉션 라이브러리를 사용하는 추천하도록 하자.

#### 함수형 프로그래밍

기본적으로 라라벨의 컬렉션은 함수형 프로그래밍을 의도하여 만들어졌다기 보다는 php의 기본 배열 함수의 레퍼인 메소드가 많다. 따라서 각각의 함수는 함수형 프로그래밍으로 사용할 수 있다기 보다는 함수형 프로그래밍 기법을 차용해서 배열을 편하게 다룰 수 있다는 정도로 생각하는 편이 좋다.

#### 컬렉션 라이브러리 버전

라라벨 컬렉션 라이브러리는 라라벨 버전 8 버전 부터 별도 설치가 가능해졌기 때문에 라라벨 버전 8이 요구하는 php 버전이 요구된다.[^2] 그 이전의 버전에서 컬렉션 기능을 사용하고 싶은 경우에는 [collect](https://github.com/tighten/collect) 라이브러리를 사용하도록 한다.

[라라벨 라이브러리](https://github.com/laravel/framework)에서 composer.json 파일을 보면 `"illuminate/collections": "self.version"`라는 라이브러리 의존성을 가지고 있다. [컬렉션 라이브러리](https://github.com/illuminate/collections)의 버전과 라라벨 프레임워크의 버전이 일치하므로 라라벨 프레임워크가 사용하는 환경을 참고하면 된다. 컬렉션 라이브러리의 composer.json 파일에도 php 버전 의존성이 기재되어 있으므로 의존성을 보고 설치하면 된다.

### DS Vector 확장 설치

php 확장 패키지 중에 DS Vector라는 확장 기능이 존재한다.

라이브러리 : https://github.com/php-ds/ext-ds

라라벨 컬렉션은 php 코드로 짜여졌지만 DS Vector는 확장패키지이므로 저레벨의 언어인 C 언어로 짜여져 있어서 라라벨 컬렉션에 비해 빠른 속도를 제공한다.

php 배열 기능이 좋지 않기 때문에 대안이 될 수 있으므로 인기가 많을 것으로 예상했으나, 각종 자료구조에 익숙해야 사용할 수 있기 때문에 성능 보다는 구현에 관심이 많은 php 커뮤니티에서 인기가 있지는 않아 보인다.

확장 패키지를 설치해야 하는 문제가 있는데, 확장 프로그램의 설치는 php가 설치된 서버에 확장기능을 설치할 수 있는 권한이 있을 때 추가할 수 있다는 단점이 있으므로 어떤 php 개발 환경에서든 사용하지는 못하는 단점이 있다.

## References

- https://www.php.net/manual/en/ref.array.php
- https://externals.io/message/125809

[^1]: https://wiki.php.net/rfc/pipe-operator-v3
[^2]: https://dev.to/robertobutti/using-collections-package-outside-of-laravel-1alk
