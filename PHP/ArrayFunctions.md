# php의 배열함수

## php 배열함수의 단점
- 대부분의 인기 있는 언어에서 배열에 관한 체이닝 함수는 필수적인 추세이다. 하지만 php에서는 기본적으로 제공되는 배열함수는 체이닝을 할 수 없다.
- php의 배열함수는 자바스크립트의 예와 같이 `[1,2,3,4,5].filter(e => e>=3).map(e => e+1)` 이렇게 체이닝을 하는 방법을 사용할 수가 없다.
- 배열 함수별로 인자의 구성이 저마다 다르다. 예를 들어 array_filter의 경우에는 첫 번째 인자가 배열, 두 번째 인자가 callable이다. 하지만 array_map의 경우에는 첫 번째 인자가 callable 두번째 인자가 배열이다. 대체 왜 이런 식으로 함수를 설계했는지 알 수 없는데 이런 일관성의 불일치는 php의 배열함수를 쓰는 사람들에게 굉장한 불편함을 준다. 자주 사용하던 함수도 쓸 때 마다 인자의 순서 때문에 기억하기 어려워 문서를 확인해야 한다. 비슷한 유형의 함수들은 인자의 순서를 동일하게 만드는 등의 기본적인 설계가 중요하지만 php는 이 부분에 대한 개선을 하고 잇지 않다. (php 언어의 일관성이 없는 비판을 할 수 있는 부분)

## 체이닝을 하지 않고 인자 방식으로 넘기는 방식으로 만들 경우
```
array_filter(
    fn($x) => $x >= 3,
    array_map(
        fn($x) => $x+1,
        array_map(
            fn($x) => $x+1,
            [1,2,3,4,5]
        ),
    )
)
```
- 끔찍한 코드가 되기 때문에 이런 방식의 사용을 지양해야 한다. 그러면 배열함수를 어떻게 사용해야 할까?

## 배열 함수를 사용하는 베스트프렉티스
```
$array = [1,2,3,4,5];
$array = array_filter($array, fn($x) => $x >= 3);
$array = array_map(fn($x) => $x+1, $array);
$array = array_map(fn($x) => $x+1, $array);
```
- 변수에 값을 재할당 하는 방식으로 사용해야 한다.
- 뒤에서도 살펴 보겠지만 php에서는 이런 방식의 사용이 배열 함수를 사용함에 있어서 가장 깔끔한 코드를 만든다.

## pipe 연산자 RFC 거부
```
[1,2,3,4,5]
|> fn($x) => array_filter($x, fn($x) => $x >= 3),
|> fn($x) => array_map(fn($x) => $x+1, $x),
|> fn($x) => array_map(fn($x) => $x+1, $x)
```
- 이런식으로 파이프 연산자를 도입해서 array_function의 체이닝을 할 수 있는 방식도 도입 되지 않았다.
- 파이프 연산자를 도입하면 그나마 쉽게 만들 수 있지만, 만약 도입한다고 해도 php의 기본 배열함수는 함수로 한 번 레핑을 해야 사용할 수 있는 단점이 있다.
- 변수에 값을 재할당 하는 방식으로 사용하는 베스트 프레틱스 방식에 비해서 코드상으로 전혀 나은 표현이라고 여겨지지 않기 때문에 RFC를 못 통과 한 게 아닐까 생각이 된다.

## 꼭 체이닝을 하고 싶다면?
```
array_reduce(
    [
        fn($x) => array_filter($x, fn($x) => $x >= 3),
        fn($x) => array_map(fn($x) => $x+1, $x),
        fn($x) => array_map(fn($x) => $x+1, $x)
    ]
, fn($x, $y) => $y($x), [1,2,3,4,5]);
```
- 이렇게 좀 불편하게 체이닝을 할 수는 있지만, 보일러 플레이트가 많은 단점이 존재한다.
- 이렇게 사용하는 것은 코드가 길어지고 해당 표현에 관한 지식이 있어야 하는 등 여러모로 불편한 점을 야기한다.
- 이렇게 짜게 된다면 아마 php에서는 리펙토링의 대상이 될 것.

## 지연평가 사용 불가
- 지연 평가란 f(x)의 결과를 y라고 할 때 이 결과에 g(y)와 같이 g함수를 사용해서 결과 값을 얻는 것이다. 하지만 연산한 결과에 연산한 결과에 연산한 결과를 넣는 것 보다 함수를 한꺼번에 묶어서 연산을 하는 방법이 있다. f·g 를 만들고 f·g(x)로 실행하여 결과 값을 얻는 것이다. 함수를 묶어서 실행할 수 있기 때문에 함수의 조합으로 하나의 도메인 로직 모듈 또는 기능의 단위를 묶어서 사용할 수 있어서 지연평가는 함수형 프로그래밍에서 아주 중요한 역할을 한다.
- 지연평가를 사용하기 위해서는 커링 가능한 함수를 만들어야 한다. 왜냐하면 일부 인자를 넣고 인자가 다 찰때까지 실행되는 것이 아니라 함수 자체로 존재해야 하기 때문이다.
- php의 기본 배열함수에 적용하기 위해서는 기존 함수를 변경할 수 있어야 하는데, 디폴트 배열함수는 변경 시도 자체가 불가능하기 때문에 사용할 수 없으며 지연평가를 위한 커링 함수를 만들기 위해서는 기본 배열함수를 변경 하는 것이 아닌 레핑을 해서 새로운 클로저를 만들어야 한다.
- php의 배열함수의 사례를 보고 알수 있지만 php의 기본 함수들은 함수 그 자체에 커링화 할 수 없기 때문에 지연평가를 만들지 못하고 지연평가가 되지 않기 때문에 함수들로 그룹화를 하는 방식의 함수형 프로그래밍을 할 수 없게 만든다. 따라서 함수형 프로그래밍을 쉽게 만들어 주는 커링이라든지 파이프연산자 등의 도입은 php의 디폴트 함수들과는 어울리지 않는다는 문제가 있다. 이런 php에 함수형 언어의 특징을 도입한다는 것은 아주 엉성한 형태의 프로그램을 만들 수 밖에 없다.

## callable에 대한 부정적 의견
- php의 클로저를 포함해서 php의 기본 함수들은 ()으로 호출할 수 있다. 이런 호출가능한 유형들을 callable이라고 한다. php 커뮤니티에서는 callable 유형에서 클로저를 제외한 나머지 callable 들에 대한 지원을 멈춰가고 있고 callable 유형을 사용할 수 있도록 표현식들을 확장하는 파이프연산자 문법 등에 대해 부정적인 의견을 가지고 있다. 

## 체이닝을 사용하고 싶다면?
- 함수형 라이브러리를 사용해 보자.
- 파이프 연산자에 대한 라이브러리 : https://github.com/boostphp/pipe-operator


## Reference
- https://www.php.net/manual/en/ref.array.php
