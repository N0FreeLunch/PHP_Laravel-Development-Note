## phpdoc과 Typehint

### typehint의 특징

타입힌트는 런타임에 실제 타입과 일치하는지 확인하는 용도로 쓰인다. 만약 타입힌트에서 지정한 타입과 다른 값이 전달되거나 할당되게 되면 php는 에러를 발생시킨다.

타입힌트는 런타임에서 에러를 발생시킨다는 점이 중요한데, 개발자가 의도한 타입과 다른 타입이 전달되었을 때 에러를 발생시키기 때문이다. 이를 통해서 개발자는 변수의 데이터 변경에 영향을 주는 모든 코드들들 다 확인하지 않고서도 변수가 갖는 타입의 범위를 알 수 있고, 제한된 타입 범위 내에서의 동작을 생각할 수 있다.

또한 IDE, 정적 분석 도구에 의한 정적 타입 분석, 런타임에서 타입 에러를 발생시키는 것을 통해서 개발자가 생각한 타입의 범위와 다른 값이 전달되었을 때 에러가 발생하는 것을 확인할 수 있고, 왜 다른 타입의 값이 들어왔는지 확인하는 과정을 통해서 버그를 해결할 수 있다.

### phpdoc의 특징

phpdoc은 주석에 `@`로 시작하는 문법을 통해서 IDE나 정적 분석 도구에 의한 추론이 가능하게 하는 기능이다.

phpdoc은 실제 런타임에서 동작을 확인하는 것이 아니므로 실제 타입과는 다르지만, phpstan, psalm, phan 등의 정적 분석은 php 언어가 나타낼 수 없는 다양한 타입의 표현을 나타낼 수 있는 기능을 제공하며 제네릭, 타입 별칭 등을 만들 수 있다. 타입 뿐만 아니라 `@see`를 통해서 파일의 위치를 이동할 수 있고, `@link`를 통한 지정한 URL로 이동하는 기능을 IDE를 통해서 활용할 수 있는 등 편의성을 갖춘 다양한 기능들을 제공한다.

### 동적 프로퍼티

php에서 동적 프로퍼티란 클래스를 정의할 때 직접 멤버로 기술하는 멤버는 아니지만, 접근할 수 있는 프로퍼티를 의미한다.

```php
class B {
    public string $bProperty = "B value";
}

class A {
    private B $otherClassObject;

    public function __construct(B $otherClassObject) {
        $this->otherClassObject = $otherClassObject;
    }

    public function __get(string $noDefaultProperty): mixed {
        if (property_exists($this->otherClassObject, $noDefaultProperty)) {
            return $this->otherClassObject->$noDefaultProperty;
        }
        return "Property not found";
    }
}

$b = new B();
$a = new A($b);

var_dump($a->bProperty); // B value
```

과거의 php 코드를 보면 [`__get`](https://www.php.net/manual/en/language.oop5.overloading.php#object.get)을 사용한 코드로 존재하지 않는 프로퍼티나 공개되지 않은 프로퍼티에 접근할 때 `get` 메소드에 접근하려는 프로퍼티 이름을 전달하여 `__get` 메소드의 반환 값이 프로퍼티의 값이 되는 코드를 만들 수 있다. 최근의 php는 정적 분석이 가능한 정적 분석이 되는 코드를 만들고자 하지만, 정적 분석을 의식하여 언어의 스펙을 만들지 않았던 과거의 잔재로, 정적 분석이 되지 않는 안티 패턴의 코드이다. 피할 수 있다면 피하는 게 맞고, 특별히 써야 하는 것이 아니라면 쓰지 않는 것이 적합한 코드이다.

위의 코드는 A 클래스의 객체가 B 클래스의 객체의 프로퍼티에 접근하도록 하는 코드가 존재한다. 위의 코드를 보면 A 클래스에는 존재하지 않았던 멤버인 B 클래스 객체의 프로퍼티를 A 클래스의 인스턴스에서 접근 가능하다. `$a`는 A 클래스를 주형으로 만들어진 오브젝트인데, B 클래스를 주형으로 하는 오브젝트 프로퍼티의 값에 접근하는 기능을 가지고 있다. 이 경우, IDE는 `$a`에서 접근 가능한 `$b`의 프로퍼티를 리스트를 알려주지 않는다.

IDE를 통한 타입 및 프로퍼티 추론이 되지 않으면, IDE에서 확인해 주는 각종 잘못된 코드를 미리 확인하지 못하기 때문에 코드를 작성할 때 실수할 가능성이 높아지므로, 가능한 IDE에 의한 타입 및 프로퍼티 추론을 할 수 있는 코딩을 하는 것이 중요하다.

### 코드의 타입을 무시하고 주석의 타입을 적용하기

하나의 클래스가 다른 클래스의 프로퍼티에 접근 하는 경우, 다른 클래스의 퍼블릭 멤버를 `$obj->otherClassPublicMember`으로 사용할 수 있다. 이 때 접근 가능한 프로퍼티는 정적 분석이 가능하도록 선언되지 않은 멤버이기 때문에 `$obj->`을 했을 때 IDE의 자동 완성을 사용할 수 없지만 `/** @var T $obj`라고 (이 때 T는 타입을 의미한다.) phpdoc을 써 주면 IDE의 자동완성을 사용할 수 있다는 장점이 있다.

하지만 IDE의 자동 완성을 위해서 실제 타입과 다른 값을 쓸 수 있는 것은 정적 분석 툴에 의해서 잘못된 타입으로 인해서 해당 코드의 정적 추론이 잘못될 가능성이 생길 수 있다. 정적 추론을 무시하는 주석(`/* @phpstan-ignore-next-line */`)을 추가로 작성하여 실제 코드의 타입을 무시하고 phpdoc의 타입만을 사용하도록 할 수 있다.

```php
$b = new B();
/**
 * @var B $a
 * @phpstan-ignore-next-line
 */
$a = new A($b);

var_dump($a->bProperty); // B value
```

위의 방식에서 주의할 점은 `@phpstan-ignore-next-line`는 docblock의 맨 아랫줄에 위치해야 `@phpstan-ignore-next-line` 위쪽의 `@var B $a`는 적용이 되고, `@phpstan-ignore-next-line`의 아랫줄인 docblock의 선언과 코드의 불일치를 체크하는 부분은 무시되어 실제 코드의 타입은 무시되고 phpdoc으로 선언한 타입이 적용된다는 점이다.

위 코드의 문제는 강제로 B 타입으로 인식하도록 만들었기 때문에 $a가 A 타입으로 사용될 때 정적 분석에 의한 에러가 발생한다는 점이다.

### 주석의 문제

동작이 정의되는 코드와 달리 주석은 설명이기 때문에 코드는 최신으로 항상 업데이트 되지만, 주석은 최신으로 업데이트가 되지 않는 경우가 있다. phpdoc도 주석으로 작성을 하기 때문에 최신으로 업데이트 되지 않을 수 있다.

타입힌트는 런타임에 타입 체크를 할 수 있기 때문에 실제 값이 갖고 있는 타입이 무엇인지 확인할 수 있다. 그에 반해 phpdoc는 런타임에서 동작하는 값과 다른 타입을 할당하여 IDE의 자동완성을 만들어 낼 수 있다. 곧, phpdoc만으로는 실제 타입인지 아닌지 런타임 타입체크를 하지 않는 한 의도적으로 다른 타입의 값을 할당한 것인지, 잘못 적은 것인지 판단하기 모호한 부분이 생긴다.

따라서 가능한 타입힌트로 타입 안정성을 확보를 하고, 타입힌트로 타입 안정성을 확보하지 못하는 부분에서 phpdoc을 사용하여 타입을 부여하고 IDE의 자동완성을 사용하는 방식을 쓴다. 그렇게 하면 타입힌트가 아닌 phpdoc이 존재하는 코드에서는 타입힌트를 사용할 수 없는 특별한 이유가 있겠거니라고 생각을 하고 특별한 케이스로 판단을 할 수 있다는 장점이 있다.

### 유니온 타입

php의 어떤 오브젝트는 다른 오브젝트를 사용해서 오브젝트의 원본 클래스가 가진 프로퍼티가 아닌 외부 오브젝트의 프로퍼티를 접근할 수 있는 기능을 제공하기도 한다. 어떤 오브젝트의 클래스를 A, 다른 오브젝트의 클래스를 B라고 할 때, 항상 A 타입의 오브젝트만 전달되더라도 해당 오브젝트에서 제공된는 B의 프로퍼티를 접근하기 위해서 A|B의 형태의 유니온 타입으로 타입힌트를 거는 경우가 있다.

기본적으로 php는 코드가 실행이 될 때 타입을 확인하고 유니온 타입으로 기술한 타입 중 하나의 값만 전달되더라도 변수는 타입힌트를 통과한다. 그러나 B 클래스 기반의 오브젝트가 갖는 프로퍼티에 접근하기 위해서 실제 값은 A 베이스의 오브젝트이지만 B 클래스를 유니온으로 추가하여 IDE에 의한 B 오브젝트의 프로퍼티를 자동으로 접근할 수 있는 방식을 사용할 수 있다.

phpdoc을 사용해서 유니온 타입을 기술할 수 있지만 php의 기본 문법을 사용하면 보다 간결하게 IDE의 자동 완성을 사용할 수 있다는 장점이 존재한다.

#### 유니온 타입의 문제

```php
class A
{
    public string $a = 'A';
}

class B
{
    public string $b = 'B';
}

$fn = function (A|B $arg) {
    if(property_exists($arg, 'a')) echo $arg->a;
};
```

위의 에제에서 $arg가 항상 타입 A라고 하더라도 유니온 타입 `A|B`으로 정의되어 있기 때문에 `if(property_exists($arg, 'a'))`의 조건하에서 `$arg->a`으로 접근하는 코드가 아니라면 정적 분석에서 에러가 발생한다. 왜냐하면 B 타입에는 a 프로퍼티가 없기 때문이다. 실제로 전달되는 값은 A 타입만을 사용하므로 `$arg->a`으로도 문제가 없지만, 정적 분석은 B에 대한 처리를 하지 않는 것을 문제점으로 지적한다. phpstan에서는 php 코드는 원본 타입으로 정확히 하고, phpdoc을 사용해서 유니온 타입을 기술하는 경우 `if(property_exists($arg, 'a'))`의 조건이 없더라도 문제가 없으므로, phpdoc으로 유니온 타입을 사용해서 실제 타입으로는 접근할 수 없는 다른 타입의 프로퍼티를 IDE의 자동 완성을 얻는 방법을 사용할 수 있다.

```php
class A
{
    public string $a = 'A';
}

class B
{
    public string $b = 'B';
}

/**
 * @param A|B $arg
 */
$fn = function (A $arg) {
    echo $arg->a;
};
```
