## php docs과 type hint

### typehint의 특징
- 타입힌트는 런 타임에 실제 타입과 일치하는지 확인하는 용도로 쓰인다. 만약 타입힌트에서 지정한 타입과 다른 값이 전달되거나 할당되게 되면 php는 에러를 발생시킨다.
- 타입힌트는 런타임에서 에러를 발생시킨다는 점이 중요한데, 개발자가 의도한 타입과 다른 타입이 전달되었을 때 에러를 발생시키기 때문이다. 이를 통해서 개발자는 데이터 전달의 흐름에 해당하는 모든 코드들들 다 확인하지 않고서도 변수가 갖는 타입의 범위를 알 수 있고, 제한된 범위 내에서의 코드를 생각할 수 있다. 또한 런타임에서 타입 에러가 발생을 통해서 개발자가 생각한 타입의 범위와 다른 값이 전달되었을 때 에러가 발생하고 왜 다른 타입의 값이 들어왔는지 확인하는 과정을 통해서 버그를 해결할 수 있다.

### php docs의 특징
- php docs은 주석에 `@`로 시작하는 문법을 통해서 IDE나 정적 분석 도구에 의한 추론이 가능하게 하는 기능이다.
- php docs은 실제 런타임에서 동작을 확인하는 것이 아니므로 실제 타입과는 다르지만 특정 타입처럼 행동하는 대상을 나타내는데 유용하다. 예를 들어 하나의 클래스가 다른 클래스를 바인딩 하는 경우, 다른 클래스의 퍼블릭 멤버를 `$this->otherClassPublicMember`으로 사용할 수 있다. 이 때 바인딩한 클래스는 정적으로 선언되지 않은 멤버이기 때문에 `$this->`을 했을 때 IDE의 자동 완성을 사용할 수 없지만 `/** @var T $this`라고 (이 때 T는 타입을 의미한다.) php docs을 써 주면 IDE의 자동완성을 사용할 수 있다는 장점이 있다.
- 하지만 IDE의 자동 완성을 위해서 실제 타입과 다른 값을 쓸 수 있는 것은 정적 분석 툴에 의해서 잘못된 타입으로 인해서 해당 코드의 정적 추론이 잘못될 가능성이 생길 수 있다. 따라서 정적 추론을 무시하는 주석(`/* @phpstan-ignore */`)을 추가로 작성해야 하는 경우가 있다. 정적 분석 도구는 버그가 일어날 가능성이 있는 코딩 스타일 또는 코드를 감지하여 버그를 차단하는 역할을 하는데, 정적 추론을 무시하는 코드가 추가되어 감지가 되지 않기 때문에 정적 분석 툴에 의한 버그 방지가 불가능하고 런타임에 이르러서야 버그를 감지하는 경우가 생긴다.
- 정적 언어는 조금 귀찮지만 타입을 기술하는 것을 통해서 모든 코드의 타입이 연결되고 이를 통해서 자동 완성을 할 수 있다. 하지만 php는 동적 언어이고 다양한 변환에 의해 코드의 자동완성 기능을 잃게 되는 문제가 있다. 이 때 php docs를 통해서 코드의 자동완성을 만들어 낼 수 있다.

### 주석의 문제
- 동작이 정의되는 코드와 달리 주석은 설명이기 때문에 코드는 최신으로 항상 업데이트 되지만, 주석은 최신으로 업데이트가 되지 않는 경우가 있다. php docs도 주석으로 작성을 하기 때문에 최신으로 업데이트 되지 않을 수 있다.
- 타입힌트는 런타임에 타입 체크를 할 수 있기 때문에 실제 값이 갖고 있는 타입이 무엇인지 확인할 수 있다. 그에 반해 php docs는 런타임에서 동작하는 값과 다른 타입을 할당하여 IDE의 자동완성을 만들어 낼 수 있다. 곧, php docs만으로는 실제 타입인지 아닌지 런타임 타입체크를 하지 않는 한 의도적으로 다른 타입의 값을 할당한 것인지, 잘못 적은 것인지 판단하기 모호한 부분이 생긴다.
- 따라서 가능한 타입힌트로 타입 안정성을 확보를 하고, 타입힌트로 타입 안정성을 확보하지 못하는 부분에서 php docs를 사용하여 타입을 부여하고 IDE의 자동완성을 사용하는 방식을 쓴다. 그렇게 하면 타입힌트가 아닌 php docs가 존재하는 코드에서는 타입힌트를 사용할 수 없는 특별한 이유가 있겠거니라고 생각을 하고 특별한 케이스로 판단을 할 수 있다는 장점이 있다.

### 유니온 타입
- php의 어떤 오브젝트는 다른 오브젝트를 사용해서 오브젝트의 원본 클래스가 가진 프로퍼티가 아닌 외부 오브젝트의 프로퍼티를 접근할 수 있는 기능을 제공하기도 한다. 어떤 오브젝트의 클래스를 A, 다른 오브젝트의 클래스를 B라고 할 때, 항상 A 타입의 오브젝트만 전달되더라도 해당 오브젝트에서 제공된는 B의 프로퍼티를 접근하기 위해서 A|B의 형태의 유니온 타입으로 타입힌트를 거는 경우가 있다.
- 기본적으로 php는 코드가 실행이 될 때 타입을 확인하고 유니온 타입으로 기술한 타입 중 하나의 값만 전달되더라도 변수는 타입힌트를 통과한다. 그러나 B 클래스 기반의 오브젝트가 갖는 프로퍼티에 접근하기 위해서 실제 값은 A 베이스의 오브젝트이지만 B 클래스를 유니온으로 추가하여 IDE에 의한 B 오브젝트의 프로퍼티를 자동으로 접근할 수 있는 방식을 사용할 수 있다.
- phpdoc을 사용해서 유니온 타입을 기술할 수 있지만 php의 기본 문법을 사용하면 보다 간결하게 IDE의 자동 완성을 사용할 수 있다는 장점이 존재한다.
```php
class A
{
    public string $a;
}

class B
{
    public string $b;
}

$fn = function (A|B $arg) {
    if(property_exists($arg, 'a')) echo $arg->a;
};
```
- 위의 에제에서 $arg가 항상 타입 A라고 하더라도 유니온 타입 `A|B`으로 정의되어 있기 때문에 `if(property_exists($arg, 'a'))`의 조건하에서 `$arg->a`으로 접근하는 코드가 아니라면 정적 분석에서 에러가 발생한다. 왜냐하면 B 타입에는 a 프로퍼티가 없기 때문이다. 하지만 실제로 전달되는 값은 A 타입만을 사용하므로 `$arg->a`으로도 문제가 없지만, 정적 분석은 B에 대한 처리를 하지 않는 것을 문제점으로 지적한다. phpstan에서는 php 코드는 원본 타입으로 정확히 하고, phpdoc을 사용해서 유니온 타입을 기술하는 경우 `if(property_exists($arg, 'a'))`의 조건이 없더라도 문제가 없으므로, phpdoc으로 유니온 타입을 사용해서 실제 타입으로는 접근할 수 없는 다른 타입의 프로퍼티를 IDE의 자동 완성을 얻는 방법을 사용할 수 있다.
```php
class A
{
    public string $a;
}

class B
{
    public string $b;
}

/**
 * @param A|B $arg
 */
$fn = function (A $arg) {
    echo $arg->a;
};
```
