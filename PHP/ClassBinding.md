# 클래스 바인딩

클래스는 객체와 달리 그 자체로는 값으로 사용하거나 코드를 실행할 수 없다. 클래스를 주형으로 객체를 생성하여 사용을 하든지, 클래스의 정적 멤버에 접근하여 정적 변수의 값 또는 정적 메소드를 실행하든지의 방식을 사용할 수 있다.

객체를 통해서 클래스에 접근을 하려면 객체의 값에 클래스를 바인딩 해 주어야 한다. 기본적으로 A 클래스를 주형으로 생성된 객체는 A 클래스를 바인딩 하고 있고, B 클래스를 주형으로 하여 생성된 객체는 B 클래스를 바인딩한다.

## self와 static

클래스에서 `self`는 `self`의 코드가 기재된 클래스를 가리키며, 클래스내의 `static`은 `static` 코드가 실행된 클래스를 가리킨다.

객체를 생성할 때 `new self`는 해당 코드가 정의된 클래스를 주형으로 객체를 만들고, `new static`은 해당 코드가 정의된 클래스를 주형으로 객체를 만든다. 

c#과 자바와 같은 다른 객체 지향 언어에서는 실행하고 있는 클래스를 주형으로 한 객체를 만들기 위해서는 객체를 생성하는 코드가 포함된 메소드를 오버라이딩하여 실행하고 있는 클래스가 정의된 클래스가 되도록 만들어야 하지만, php는 객체를 생성하는 코드가 정의된 클래스를 바인딩 할 클래스로 할 것인지 (self를 사용), 객체를 생성하는 코드가 실행된 클래스를 바인딩 할 클래스로 할 것인지 (static을 사용) 정할 수 있다.

## static 보다 self인 이유

static을 사용하면 정확히 어떤 타입을 사용하는지 static 부분만 보고서는 알 수 없고, 어떤 클래스에서 실행되었는지에 따라 주형이 되거나 바인딩하는 클래스가 달라지므로 IDE 등에 의한 타입 추론을 하기 위해서는 실행 시점에서 선택되는 타입이 무엇인지 `assert($objFromStatic instanceof ExecutionClass)` 등과 같은 코드로 타입을 체크해서 IDE에 알려 주어야 정확한 타입 추론이 가능하다.

## References

- https://learn.microsoft.com/ko-kr/previous-versions/office/troubleshoot/office-developer/binding-type-available-to-automation-clients
