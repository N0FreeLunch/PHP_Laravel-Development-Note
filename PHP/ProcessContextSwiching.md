## PHP 엔진

PHP 코드 문서를 PHP 엔진으로 실행을 시키면 하나의 PHP 프로세스가 생성되고 해당 문서와 연결된 모든 PHP 코드들은 생성된 프로세스에 의해 실행된다.

## I/O 블락

I/O 작업이 일어나면 PHP의 코드는 블락이 된다. I/O 작업이 끝나야 코드가 실행이 되면서 CPU를 사용하게 된다.

I/O로 인해 코드 실행에 블락이 일어날 때, PHP는 효과적으로 CPU를 쓸까?

## Context switching

컨텍스트 스위칭은 문맥 교환이라는 용어로 CPU 계층에서, OS 계층에서, 프로그래밍 언어 계층에서 사용된다.

### CPU 계층에서의 컨텍스트 스위칭

CPU 계층에서의 컨텍스트 스위칭은 하나의 CPU가 A라는 프로세스의 연산을 처리하다가 I/O 블락이 일어나면 A의 처리를 잠시 멈추가 대기하고 있는 B라는 프로세스의 연산을 처리하는 것을 의미한다.

### OS 계층에서의 컨텍스트 스위칭

OS 계층에서의 컨텍스트 스위칭은 보통 스레드 단위로 일어나며, OS는 프로그램을 스레드 단위로 동작시킨다. 스레드에 할당된 작업이 OS의 시스템 API를 콜 하여 I/O 작업을 하게 되면 진행되던 작업은 블락되고 다른 작업을 스레드에 할당하여 동작시킨다.

CPU 갯수 보다 실행되는 OS의 스레드가 많은 경우 서로 OS는 각 프로세스에 CPU 자원을 어떻게 할당할지를 결정하는 알고리즘을 실행하고 이 알고리즘은 일반적은 OS에서 가능한 자원을 고르게 할당하려고 한다. 따라서 한 번 블락된 작업이 무한정 블락되는 것이 아니라 OS의 알고리즘에 따라 I/O 작업이 끝나면 다시 재할당되어 작업이 진행된다. OS의 자원할당을 결정하는 방법은 복잡하기 때문에 여기서는 설명을 스킵한다.

### 프로그래밍 언어에서의 컨텍스트 스위칭

하나의 루틴을 컨텍스트 스위칭한다. A라는 루틴이 I/O 작업을 하여 블락이 되면, B라는 루틴을 A루틴을 할당한 CPU에 할당한다. 고루틴(Go 언어), 코루틴(Python, Kotlin 등), BEAM(Elixir, Erlang), 가상 스레드(JAVA)는 프로그래밍 언어에서 만들어진 루틴으로, 프로그래밍 언어의 스케쥴링 기법에 의해 컨텍스트 스위칭이 일어난다. OS 계층의 컨텍스트 스위칭 보다 리소스를 소모하는 비용이 적어서 효율이 좋다.

## PHP에서의 컨텍스트 스위칭

PHP도 Swoole이나 [AMPHP](https://amphp.org/), [ReactPHP](https://reactphp.org/), [Fiber](https://www.php.net/manual/en/language.fibers.php) 등은 컨텍스트 스위칭을 한다. 이는 프로그래밍 언어에서의 컨텍스트 스위칭에 해당한다. AMPHP, ReactPHP, Fiber의 경우 프로세스가 실행되고 있는 싱글 스레드 내에서의 컨텍스트 스위칭이고 병렬성을 고려한 컨텍스트 스위칭은 아니다. 그에 반해 Swoole은 여러 CPU에 블락 또는 유휴 작업이 일어난 곳에 CPU를 할당하므로 효율적이고 빠르다.

Swoole, php amp, reactPHP, Fiber 이외의 CGI 방식의 보편적인 PHP의 사용에서 프로그래밍 언어 계층의 컨텍스트 스위칭을 하기 보다는 PHP 프로세스 각각에 대해서 컨텍스트 스위칭을 사용한다.

FastCGI의 전달으로 php 엔진에 의해 php 파일이 실행이 되고, 이때 젠드 엔진은 리퀘스트 하나에 대해서 하나의 프로세스를 생성한다. 복수의 리퀘스트에 의해서 복수의 PHP 프로세스가 실행이 된 상황일 경우에 OS의 컨텍스트 스위칭에 의해 하나의 PHP 프로세스가 블락된 상황이면 다른 PHP 프로세스를 블락된 프로세스가 할당된 CPU 스레드에 할당한다.

## PHP-FPM에서 프로세스 갯수 설정

만약 복수의 PHP 프로세스가 실행되어 있는데, 프로세스의 양보다 CPU 스레드의 갯수가 적을 경우 스케쥴링 기법에 따라 다르지만 일반적으로는 프로세스 각각에 가능한 공평하게 실행을 할당하려고 하기 때문에 컨텍스트 스위칭이 일어나게 된다.

PHP-FPM에서 CPU 양에 비해 너무 많은 PHP 프로세스를 생성하도록 허가하면 컨텍스트 스위칭이 자주 일어나고, 컨텍스트 스위칭 또한 스위칭에 컴퓨팅 자원을 사용하기 때문에 전체적인 처리 속도가 늦어지는 경우가 생긴다. 또한 각 프로세스가 CPU 자원을 분할하기 때문에 전체실행 속도가 늦어질 수 있다.

CPU 양에 비해 너무 적은 PHP 프로세스를 생성하도록 허가하면 A라는 PHP 프로세스가 블락되었을 경우 나머지 PHP 프로세스들도 각자 따로 스레드에 할당이 되었기 때문에 남는 PHP 프로세스가 없어서 A가 할당되어 있던 CPU는 유휴 상태가 된다.

CPU의 스래드 갯수에 비해 PHP 프로세스가 너무 많아도 효율이 떨어지고, 너무 적어도 효율이 좋지 않다는 원리를 알 수 있다. 어느 정도 할당을 할지는 어떤 기능을 사용하는지 어떤 코드에 부하가 몰리는지에 따라 다르기 때문에 일반화 할 수 없다. 모니터링을 하면서 적절한 수치를 찾아야 한다. CPU의 성능을 최적화한다는 것은 그 만큼 트레픽이 생겼다는 것이고 그렇다면 먼저 CPU 로드율에 대한 모니터링을 먼저 하는 편이 좋다. (AWS를 이용한다면 간단하게 CPU 로드율을 취득할 수 있으므로 이를 보고 프로세스 수를 설정하는 편이 좋다.)

일반적으로 CPU 스레드 대비 최대 프로세스의 갯수는 2배 내외에서 CPU로드율을 보고 조금씩 늘려가는 것이 좋다. 어떤 작업이 얼마나 행해지는지에 따라 달라지기 때문에 실제 CPU의 로드율을 확인해야 한다.

### 메모리를 고려한 할당

때때로 php 프로세스의 수를 메모리가 가용한 한계까지 설정한다는 글이 있곤 하다. 컴퓨터의 스레드의 갯수는 제한되어 있는데, 프로세스 수를 메모리 한계까지 올리는 것은 컨텍스트 스위칭 비용을 증가시키므로 좋은 전략이 될 수 없다. 스레드의 수는 한정되어 있는데, 프로세스의 수가 많다면 OS가 좋은 스케쥴링 기법을 쓰더라도 컨텍스트 스위칭 비용이 증가하는 문제점이 생기고, 이로 인해 php 프로세스의 작업 시간이 늘어날 수 있다. 웹의 리스폰스는 빠르게 처리 되어야 하는데, 느려진다면 좋지 않은 사용자 경험을 주게 된다.

php는 nginx나 apache 등의 웹 서버와 함께 사용하는데, 이들은 리퀘스트를 큐로 받아 적재한 후, php 엔진이 처리할 수 있는 상태가 되면 넘겨준다. 이 큐는 일시적인 처리를 위한 것으로 nginx나 apache에서 설정한 타임 아웃 시간이 지나면 타임 아웃 리스폰스를 반환하는 것과 함께 큐에서 소멸되어 애플리케이션으로 전달되지 않는다. PHP-FPM이 처리할 수 있는 최대 

nginx가 php 프로세스에 리퀘스트를 넘겨 줄 때, php 프로세스의 지연이 일어나지 않을 정도의 작업만 할당 되도록 전달하려는 리퀘스트의 수를 조절하고 리퀘스트가 처리 되면 nginx나 apache 큐의 리퀘스트를 넘기는 방식으로 만드는 편이 컨텍스트 스위칭 비용이 적으므로 처리 속도가 빠르다.

## swoole

PHP에서 동시성을 다루기 위한 방법으로 php amp, reactPHP, Fiber등이 있지만 swoole은 병렬성을 고려한 프로그래밍을 가능하게 한다. swoole의 코루틴은 고루틴을 모방하여 만들어졌다. 하지만 swoole에서 병렬 프로그래밍을 하기 위해서는 기존의 CGI 방식과는 호환이 맞지 않는 문제점이 있어서 swoole 자체로 웹 서버를 열어야 하고 일반적인 php 코딩 방식이 아닌 Swoole의 방식을 새롭게 익혀야 한다. Swoole은 언어 자체에서 병렬성을 코루틴 방식으로 지원하기 때문에 컨텍스트 스위칭 비용을 굉장히 절약할 수 있다는 것이 장점이다. swoole은 php 계열에서 잘 확립된 방법은 아니기 때문에 추후 서포트가 어떻게 될지 장담할 수 없다는 문제가 있으니 주의하도록 하자.
