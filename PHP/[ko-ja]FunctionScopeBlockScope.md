# 함수 스코프와 블록 스코프 (php에는 왜 var, let, const가 없을까?)
# 関数スコープとブロックスコープ （phpにはなぜ var, let, const がないのでしょうか？）

# 도입

문법상의 계보로 따졌을 때 C 계열의 언어가 있다. C, C++, C#, JAVA, Javascript, php는 C의 문법적 스타일을 물려 받은 언어로 C계열의 언어라고 부른다.

文法上の系譜で分類すると、C系統の言語があります。C、C++、C#、Java、JavaScript、PHPは、Cの文法的スタイルを受け継いだ言語であり、C系統の言語と呼ばれます。

많은 사람들이 처음 php를 접할 때는 C 계열의 언어인 것에 비해, 다른 C 계열의 언어와 다른 문법적인 특징을 가지는 것이 많아서 php에 거부감을 느끼는 경우가 있다. 이런 거부감을 느끼게 하는 요인 중 하나는 php에는 변수를 선언하는 키워드가 없고, 블록 스코프가 없다는 점이다.

多くの方が初めて、phpに触れる際、C系統の言語であるにもかかわらず、他のC系統の言語とは異なる文法的特徴が多いため、phpに対して抵抗感を覚えることがございます。こうした抵抗感を引き起こす要因の一つとして、phpには変数を宣言するためのキーワードが存在しないこと、およびブロックスコープがないことが挙げられます。

php를 잘 활용하기 위해서는 블록 스코프가 있는 언어와 블록 스코프가 없는 언어의 차이점을 잘 이해하고, 블록 스코프가 없는 언어의 코딩 스타일을 이해하는 것이 중요하다.

phpを適切に活用するためには、ブロックスコープがある言語とない言語の違いをよく理解し、ブロックスコープがない言語に適したコーディングスタイルを理解するのが重要です。

# 본론
# 本論

## 스코프란?
## スコープとは？

스코프란 변수의 유효 범위를 뜻한다. 보통은 블록 또는 함수 블록이 열렸을 때, 블록 내부에서 선언된 변수는 블록이 닫히면 엑세스가 불가능해지고, 가비지 컬렉터에 의해 소멸된다. 블록 안에서 선언된 변수는 블록 밖에서 사용할 수 없다.

スコープとは、変数の有効範囲を指します。通常、ブロックまたは関数ブロックが開かれた際に、そのブロック内で宣言された変数は、ブロックが閉じられるとアクセスできなくなり、ガベージコレクターによって消滅されます。ブロック内で宣言された変数は、ブロックの外部では使用できません。

## 자바스크립트로 이해하기
## JavaScriptで理解すること

자바스크립트는 `var`로 선언된 변수는 함수 스코프를 가지고 있고, `const`나 `let`으로 선언된 변수는 블록 스코프를 가지고 있다.

JavaScriptでは、`var`で宣言された変数は関数スコープを持ち、`const`や`let`で宣言された変数はブロックスコープを持ちます。

(이 글은 php를 위한 설명이므로 다음 자바스크립트의 예에서 좀 더 알기 쉽도록 변수에 $를 붙여 주었다.)

（本記事はphpを対象とした説明であるため、以下のJavaScriptの例では、より分かりやすくするために変数名に`$`を付けております。）

### 블록 스코프
### ブロックスコープ

```js
if (true) {
    let $a = 10;
}

console.log($a); // Uncaught ReferenceError: $a is not defined
```

블록 내에서 선언된 `$a`는 블록 밖에서 접근할 수 없다.

ブロック内で宣言された`$a`は、ブロックの外部からアクセスすることはできません。

```js
fn = function () {
    let $a = 10;
}

console.log($a); // Uncaught ReferenceError: $a is not defined
```

함수 내에서 선언된 `$a`는 블록 밖에서 접근할 수 없다.

関数内で宣言された`$a`は、関数の外部からアクセスすることはできません。

### 함수 스코프
### 関数スコープ

```js
if (true) {
    var $a = 10;
} else {
    var $b = 20;
}

console.log($a); // 10
console.log($b); // undefined
```

자바스크립트의 전역 변수는 전역 스코프를 함수 스코프로 한다. 함수 내부에 있지 않지만 함수 스코프의 변수는 전역 스코프를 함수 스코프로 사용한다고 보면된다.

JavaScriptのグローバル変数は、グローバルスコープを関数スコープとして扱います。関数の内部にない場合でも、関数スコープの変数はグローバルスコープを関数スコープとして使用すると考えることができます。

자바스크립트에서는 php의 `isset`과 같은 정의된 변수인지 아닌지 확인하는 기능이 존재하지 않는다. 그래서 변수를 선언하는 코드가 실행되지 않더라도 변수를 사용하는데 에러가 발생하지 않도록 해야 한다. 자바스크립트는 에러를 발생시키지 않는 대신 `undefined` 값으로 표기하는 방식을 사용한다.

JavaScriptには、phpの`isset`のように、変数が定義されているかどうかを確認する機能は存在いたしません。そのため、変数を宣言するコードが実行されていなくても、変数の使用時にエラーが発生しないようにする必要があります。JavaScriptでは、エラーを発生させるのではなく、代わりに`undefined`という値を用いる仕組みを採用しております。

함수 스코프를 가진 변수 $b는 실행이 되지 않았음에도 불구하고 에러가 아니라 `undefined` 값이 된다.

関数スコープを持つ変数`$b`は、コードが実行されなかった場合でもエラーではなく、`undefined` の値となります。

```js
const fn = function () {
    var $a = 10;
}

console.log($a); // Uncaught ReferenceError: $a is not defined
```

함수 스코프 안에서 선언된 변수는 함수 밖에서 접근할 수 없다.

関数スコープ内で宣言された変数は、関数の外部からアクセスすることはできません。

함수 스코프를 가지는 변수가 블록 안에서 선언되었을 때는 `undefined` 값으로 접근할 수 있었던 것에 반해서, 함수 스코프 밖에서는 `undefined` 값으로 접근하는 것이 아닌 에러를 발생시킨다.

関数スコープを持つ変数がブロック内で宣言された場合は、`undefined`の値としてアクセス可能であるのに対し、関数スコープの外部では`undefined`の値としてアクセスできるのではなく、エラーが発生いたします。

## php 코드
## phpコード

### 블록 스코프 없음
### ブロックスコープなし

```php
if (true) {
    $a = 10;
}

var_dump($a); // 10
```

변수 `$a`는 블록 안에서 선언되었지만, 블록 밖에서 블록 안에서 선언된 변수를 사용할 수 있다.

変数`$a`はブロック内で宣言されましたが、ブロック外でもブロック内で宣言された変数を使用することができます。

```php
if (false) {
    $a = 10;
}

var_dump($a); // Warning: Undefined variable $a
```

자바스크립트에서 함수 스코프를 사용하는 `var` 선언 키워드는 변수를 호이스팅하여 런타임에 실행되지 않은 변수더라도 에러가 아닌 `undefined`가 할당되도록 한다. 함수 스코프를 사용하는 php이지만 자바스크립트의 호이스팅과 같은 기술이 없어서 에러가 발생한다.

JavaScriptでは、関数スコープを使用する`var`宣言キーワードは変数をホイスティングし、ランタイムで実行されていない変数であってもエラーではなく`undefined`が割り当てられるようになります。関数スコープを使用するphpには、JavaScriptのホイスティングのような技術はないため、エラーが発生します。

```php
if (false) {
    $a = 10;
}

var_dump($a ?? null); // null
```

php에는 `isset`, `??`, `??=`등의 문법으로 정의되지 않은 변수를 확인하는 키워드가 있기 때문에, 정의되지 않은 변수 사용이 에러를 발생시키더라도 실행 중에 에러를 발생시키지 않고 코드를 전개할 수 있다.

phpには`isset`, `??`, `??=`などの文法を使用して、定義されていない変数を確認するキーワードがあるため、定義されていない変数の使用がエラーを引き起こす場合でも、実行中にエラーを発生させることなくコードを展開することができます。

### 함수 스코프 있음
### 関数スコープあり

```php
$fn = function () {
    $a = 10;
};

var_dump($a); // Warning: Undefined variable $a
```

`$a` 변수의 선언은 함수 내에서 이뤄지기 때문에 함수 밖에서 이 변수를 사용할 때 정의되지 않았다는 에러가 발생한다.

`$a`変数の宣言は関数内で行われるため、関数外でこの変数を使用すると「定義されていない」というエラーが発生いたします。

## 블록 스코프의 장점
## ブロックスコープの利点

블록을 사용하면, 변수는 블록 안에서 선언되고, 선언된 블록 밖에서는 접근할 수 없게 된다. 이러한 특징은 블록 안에서 선언하고 블록의 닫힘과 함께 쓰임을 다하는 블록 안에서만 쓰이는 임시적인 변수를 부담없이 만들 수 있다는 장점을 제공한다. 변수를 많이 만들더라도 로직의 흐름을 기술하는 부분의 변수의 갯수를 억제하고, 흐름을 구성하는 부분에서 임시로 사용할 변수를 부담없이 생성할 수 있다는 장점이 있다.

ブロックを使用することで、変数はブロック内で宣言され、宣言されたブロック外ではアクセスできなくなります。このような特徴は,ブロック内で宣言し、ブロックの閉じとともにその役割を終えるブロック内でのみ使用される一時的な変数を気軽に作成できるという利点があります。多くの変数を作成しても、ロジックの流れを記述する部分での変数の数を抑え、流れを構成する部分で一時的に使用する変数を気軽に生成できるという利点があります。

### 블록 스코프가 없을 때의 문제
### ブロックスコープがない場合の問題

블록 스코프가 없고 함수 스코프만 사용할 수 있는 언어에서, 블록은 변수의 유효 범위를 설정하는 용도가 아닌, 제어의 흐름을 나타내는 `if`, `for`, `switch` 등의 문법들과 함께 이들 문법의 작용 범위를 정하는 용도로 사용된다. 블록 스코프가 없기 때문에 함수 내에 선언되는 모든 변수는 블록 안에 있더라도 이들 블록을 감싸는 함수 스코프 안에 변수가 추가된다.

ブロックスコープがなく、関数スコープのみが使用できる言語では、ブロックは変数の有効範囲を設定する目的ではなく、制御の流れを示す`if`、`for`、`switch`などの文法とともに、これらの文法の作用範囲を決めるために使用されます。ブロックスコープがないため、関数内に宣言されるすべての変数は、ブロック内にあってもそれらのブロックを囲む関数スコープ内に変数が追加されます。

블록 스코프라면, 블록의 내부에 임시 변수를 사용해서 쓸 수 있겠지만, 블록 스코프가 없는 경우는 임시적으로 사용할 변수를 선언할 때, 블록의 종료와 함께 사라지는 것이 아니고 블록들을 감싸고 있는 함수 스코프에 그대로 남게 된다는 문제점이 발생한다.

ブロックスコープがあれば、ブロック内で一時的な変数を使うことができますが、ブロックスコープがない場合、一時的に使用する変数を宣言しても、ブロックの終了とともに消えるのではなく、ブロックを囲む関数スコープにそのまま残ってしまうという問題が発生します。

특정 맥락에서 일시적으로 사용하는 변수가 함수 스코프 전체에 남게 되면서, 함수 내부의 로직이 길어지면 길어질수록 일시적으로 사용되는 변수가 함수 스코프 영역에 더 많아지는 문제가 발생한다. 이 때문에 무엇이 쓰는 변수이고 무엇이 쓰이지 않는 변수인지 구분하기 어렵게 된다.

特定の文脈で一時的に使用する変数が関数スコープ全体に残るため、関数内部のロジックが長くなればなるほど、一時的に使用される変数が関数スコープ領域に増える問題が発生します。このため、何が使用される変数で何が使用されない変数なのかを区別することが難しくなります。

## 블록 스코프가 꼭 필요할까?
## ブロックスコープは本当に必要か？

블록 스코프가 없을 때 로직이 길어질 수록 임시적으로 쓰이는 변수가 늘어나게 되므로, 블록 스코프를 도입하자는 의견에 대해, 애초에 하나의 함수 스코프를 길게 잡는 것이 올바른 코딩 프렉티스가 아니라는 의견으로 맞선다.

ブロックスコープがない場合、ロジックが長くなるほど一時的に使われる変数が増えてしまいます。そのため、ブロックスコープを導入しようという意見に対して、そもそも一つの関数スコープを長くいコードを書くことが適切なコーディングプラクティスではないという反論があります。

하지만 때때로 하나의 스코프 내에 장황하게 쓸 수 밖에 없는 로직이 있고, 로직을 분리하는 것이 어색한 경우가 있을 수 있으므로 블록 스코프를 도입하는 것이 좋다는 의견이 있다.

しかし、時には一つのスコープ内で冗長に書かざるを得ないロジックが存在し、ロジックを分けることが不自然に感じられる場合もあるため、ブロックスコープを導入することが望ましいという意見もあります。

## 필요하다면 함수 스코프를 사용하자.
## 必要であれば関数スコープを使用しよう

기본적으로 하나의 함수 스코프의 로직을 장황하게 작성하지 않기 위해서 노력해야 한다. 함수로 로직을 나누는 것이 어려운 경우, 함수 스코프를 사용하여 로직을 분리해서 작성한다.

基本的に、一つの関数スコープ内のロジックを冗長に書かないように努力すべきです。ロジックを関数で分割することが難しい場合は、関数スコープを使用してロジックを分けて書きます。

함수를 사용하는 것은 로직의 명칭을 부여하기 때문에 해당 스코프가 갖는 역할이 무엇인지 나타내고 개념적인 분리를 통해서 블록 내부의 코드를 읽지 않고서도 코드의 흐름이나 맥락을 함수의 시그니처를 통해서 알 수 있게 해 준다는 장점이 있다. php의 함수는 외부 변수를 캡쳐하기 위해서 `use` 키워드를 사용해야 하기 때문에, 지정한 함수의 동작을 위해서 어떤 외부 변수를 사용해야 하는지도 쉽게 알 수 있다.

関数を使用することは、ロジックに名前を付けることになるため、そのスコープが持つ役割が何であるかを示し、概念的に分けることで、ブロック内のコードを読むことなくコードの流れや文脈を関数のシグネチャを通じて理解できるという利点があります。phpの関数は外部変数をキャプチャするために`use`キーワードを使用しなければならないため、指定した関数の動作のためにどの外部変数を使用するかが簡単に分かります。

블록은 함수의 시그니처를 쓰지 않아도 되어 편리한 반면, 특별한 명칭이 없기 때문에 블록의 역할을 사용된 문법과 맥락에 따라 생각해 내야 하는데, 블록 스코프가 없고 함수 스코프만 있는 언어는 함수를 사용하면 이름을 붙여주기 때문에 임시 변수를 사용하는 경우 적절한 함수 추상화를 권장하는 압력을 받는다.

ブロックは関数のシグネチャを使用しなくて済むので便利ですが、特別な名前がないため、ブロックの役割を使用された文法や文脈に基づいて考えなければならず、ブロックスコープがなく関数スコープのみがある言語では、関数を使うことで名前が付けられるため、臨時変数を使う場合には適切な関数の抽象化を行うことが推奨される圧力をを受けることになります。

함수로의 추상화는 함수의 시그니처로 함수의 역할을 대략적으로 알 수 있도록 하며, 임시 변수를 가져야 하는 블록에 이름을 부여하여 단위 로직의 사용 의도를 명확하게 할 수 있다는 장점이 있다.

関数への抽象化は、関数のシグネチャを通じて関数の役割をおおまかに理解できるようにし、臨時変数を使うべきブロックに名前を付けることで、単位ロジックの使用意図を明確にできるという利点があります。

### 즉시 실행함수 사용하기
### 即時実行関数を使用する

때때로 함수로 분리하는 것은 코드를 늘려 장황한 느낌을 줄 수 있어 함수 사용을 피하고 싶을 수 있다. 또한 굳이 재사용할 필요가 없는데도 함수로 만들게 되면 마치 재사용해야 할 것과 같은 인상을 줄 수 있어 함수 사용을 피하고 싶을 수 있다. 또한 흐름상 변수만 격리하는 패턴의 코드를 만들고 싶은 경우가 있다. 이 때는 즉시 실행 함수를 사용하여 코드를 만들 수 있다.

時には、関数で分割することがコードを増やして冗長な印象を与えるため、関数の使用を避けたい場合があります。また、再利用する必要がないのに関数なのに、まるで再利用すべきもののような印象を与えてしまうため、関数の使用を避けたいこともあります。さらに、流れとして変数だけを隔離するパターンのコードを作成したい場合もあります。このような時には、即時実行関数を使用してコードを作成することができます。

#### 즉시 실행함수의 예
#### 即時実行関数の例

```php
$outerVariable = 10;

$result = (function () use ($outerVariable) {
    $innerVariable = 20;
    return $innerVariable + $outerVariable;
})();

var_dump($result); // 30
```

익명 함수를 정의함과 동시에 `(function () {})()`의 방식으로 함수를 변수에 담지 않고 실행하는 방법이다. php에서는 블록 스코프가 없으므로, 블록 스코프 대신에 함수 스코프를 사용해서 스코프의 범위 내에서만 임시적으로 사용할 수 있는 변수를 사용합니다.

匿名関数を定義すると同時に`(function () {})()`のように関数を変数に格納せずに実行する方法です。phpではブロックスコープがないため、ブロックスコープの代わりに関数スコープを使用して、スコープ内でのみ一時的に使用できる変数を使用する文法を利用します。

#### 스코프 중첩을 장려하지 않는 문법
#### スコープの入れ子を推奨しない文法

즉시 실행 함수 사용의 문제는 함수 스코프에 외부의 변수를 전달하기 위해서 `use` 키워드로 함수 밖에서 함수 내부에 사용할 변수를 전달해 주어야 하므로 보일러 플레이트가 많아진다는 점이 있다.

即時実行関数を使用する問題点は、関数スコープに外部の変数を渡すために`use`キーワードを使って、関数外から関数内に変数を渡さなければならないため、ボイラープレートが増える点です。

하지만 스코프를 만들 때 마다 변수를 캡쳐하기 위해서 보일러 플레이트를 많이 사용해야 하므로 많은 익명 함수로 스코프를 만들 때 깊은 중첩은 그 만큼 더 많은 보일러 플레이트를 만들기 때문에 스코프의 중첩을 억제한다.

しかし、スコープを作るたびに変数をキャプチャするために多くのボイラープレートを使用しなければならないため、多くの匿名関数でスコープを作る場合、深い入れ子はその分だけ多くのボイラープレートを生み出すため、スコープの入れ子を抑制します。

일반적으로 스코프의 중첩이 많은 로직은 읽기 어렵고, 메인테인스 하기 어려운 경우가 많기 때문에 깊은 중첩을 장려하지 않게 하는 압력이 있다는 것은 좋은점이다.

一般的に、スコープの入れ子が多いロジックは読みづらく、メンテナンスが難しい場合が多いため、深い入れ子を推奨しない圧力があることは良い点です。

하지만, 일부 케이스에 대해서는 로직을 분리하기 보다는 깊은 중첩이 나은 경우가 있을 수도 있다. 하지만 극소수의 케이스를 위해서 깊은 중첩이란 안티 패턴을 장려할 필요는 없을 것이다. `use` 키워드로 외부 스코프의 변수를 캡쳐하는 것은 보일러 플레이트를 늘리지만, 보일러 플레이트 때문에 중첩을 장려하지 않기 때문에 괜찮은 문법이라 할 수 있다.

しかし、一部のケースでは、ロジックを分割するよりも深い入れ子の方が適している場合もあります。ただし、極少数のケースのために深い入れ子というアンチパターンを推奨する必要はないでしょう。`use`キーワードで外部スコープの変数をキャプチャすることはボイラープレートを増やしますが、ボイラープレートが原因で入れ子を推奨しないため、良い文法だと言えます。

#### 즉시 실행 함수 남발의 코드 스멜 논란
#### 即時実行関数の乱用に関するコードスメルの議論

블록 스코프가 없기 때문에 임시적으로 사용할 변수의 공간을 만들기 위해 즉시 실행 함수의 사용을 남발하는 코드를 만들 수 있는데, 다른 언어의 코드 베이스에서 보기 어려운 코드 스멜이 나는 코드가 될 수 있다는 점이다. 이걸 블록 스코프가 없고 함수 스코프만 있는 언어가 가지는 적합한 코딩 스타일인지, 코드 스멜인지 논란의 소지가 있다.

ブロックスコープがないため、一時的に使用する変数のスペースを作るために即時実行関数の使用を乱用するコードが作成される可能性がありますが、これが他の言語のコードベースでは見かけにくいコードスメルが発生するコードになることがあります。これがブロックスコープがなく関数スコープのみがある言語に適したコーディングスタイルなのか、それともコードスメルなのかについては議論の余地があります。

#### 객체지향으로 스코프 중첩 억제하기
#### オブジェクト指向でスコープの入れ子を抑制する

최근의 자바스크립트는 객체지향 보다는 절차지향과 함수형 프로그래밍을 활용하여 코드를 작성하는 경우가 많다. 그래서 로직의 흐름을 나타내는 코드의 부분을 담당하는 코드를 블록으로 스코프를 구분하여 임시 변수 생성하는 코딩이 좋다.

最近のJavaScriptは、オブジェクト指向よりも手続き型プログラミングや関数型プログラミングを活用してコードを書くことが多いです。そのため、ロジックの流れを表現する部分のコードをブロックでスコープを区別し、一時変数を生成するコーディングが望ましいです。

이벤트와 API 통신 중심의 많은 비동기 로직을 다뤄야 하는 자바스크립트는 함수 중심의 코딩 스타일이 적절한 반면, php는 대부분 동기 코드로 선후 관계가 분명한 코드를 쓰는 것이 권장되므로 객체 중심의 코드 스타일을 채용한다.

イベントやAPI通信中心の多くの非同期ロジックを扱うJavaScriptは、関数中心のコーディングスタイルが適している一方で、phpはほとんどが同期コードで、前後関係が明確なコードを書くことが推奨されているため、オブジェクト中心のコードスタイルを採用します。

php는 객체지향 기법을 장려하는 언어로 로직의 큰 흐름에서 부분을 담당하는 코드는 메소드로 분리해서 코드를 작성하는 스타일이 권장되므로 객체 지향을 잘 활용한다면 함수 스코프를 남발하는 코드의 작성은 억제되므로 익명 함수의 남발을 줄일 수 있다.

phpはオブジェクト指向の技法を推奨する言語であり、ロジックの大きな流れの中で一部分を担当するコードはメソッドに分けてコードを書くスタイルが推奨されているため、オブジェクト指向をうまく活用すれば関数スコープの乱用を抑制でき、匿名関数の乱用を減らすことができます。

함수의 중첩은 외부 스코프의 변수를 캡쳐 할 수 있는 반면, 메소드로 나누면, 변수를 공유하기 위해 멤버 변수로 메소드와 메소드 간의 변수를 공유한다.

関数のネストで外部スコープの変数をキャプチャできますが、メソッドに分割すると、変数を共有するためにメンバ変数を使用してメソッド間で変数を共有することになります。

때때로 멤버 변수가 너무 많아져서 메인테넌스가 어려운 클래스를 만들 수 있는데, 하나의 클래스를 장황하게 작성하기 보다는 여러 클래스로 나누고 조합하는 객체지향의 방식을 생각하는 쪽으로 해결할 수 있다.

しかし、時にはメンバ変数が増えすぎてメンテナンスが難しいクラスになってしまうことがあります。そのような場合は、1つのクラスを冗長に記述するのではなく、複数のクラスに分割し、組み合わせるというオブジェクト指向の考え方で解決できます。

과도한 객체지향은 설계에 많은 시간이 걸릴 수 있고, 코드를 작성하는 양도 많아지기 때문에 적절하게 메소드 사용, 함수 사용, 즉시 실행 함수를 사용하여 상황에 맞게 가성비 있는 코드를 작성하도록 하자.

過度なオブジェクト指向は設計に時間がかかり、コードの量も増えてしまうため、適切にメソッドや関数、即時実行関数を活用し、状況に応じたコスパの良いコードを書くようにしましょう。

## 알아두면 좋은 것들
## 知っておくと良いこと

### 변수 캡쳐
### 変数キャプチャ

`use` 키워드로 함수가 외부의 변수를 캡쳐할 때, 변수에 들어간 값의 종류에 따라, 객체와 같은 레퍼런스 값은 참조로 전달되고, 레퍼런스가 아닌 값은 복사가 된다.

`use`キーワードを使用して関数が外部の変数をキャプチャする際、変数に格納されている値の種類によって挙動が異なります。オブジェクトのような参照型の値は参照として渡され、参照でない値はコピーされます。

```php
$outerVariable = 10;

(function () use ($outerVariable) {
    $innerVariable = 20;
    $outerVariable = $innerVariable + $outerVariable;
    var_dump($outerVariable); // 30
})();

var_dump($outerVariable); // 10
```

`$outerVariable`가 선언될 때의 값은 레퍼런스가 아닌 값이다. 레퍼런스가 아닌 값을 `use`로 캡쳐를 하면 기본적으로 복사가 되어 함수 내로 전달 된다. 함수 내의 `$outerVariable`는 복사된 값이기 때문에 값이 변경 되더라도 함수 밖의 변수와는 다른 값이므로 함수 내의 값 변경이 적용되지 않는다.

`$outerVariable`が宣言された際の値は、参照ではない値です。参照ではない値を`use`でキャプチャすると、基本的にコピーされて関数内に渡されます。そのため、関数内の`$outerVariable`はコピーされた値であり、値が変更されたとしても関数の外側にある変数とは異なる値となるため、関数内での変更は関数外の変数には反映されません。

```php
$outerVariable = 10;

(function () use (&$outerVariable) {
    $innerVariable = 20;
    $outerVariable = $innerVariable + $outerVariable;
    var_dump($outerVariable); // 30
})();

var_dump($outerVariable); // 30
```

`$outerVariable`가 선언될 때의 값은 레퍼런스가 아닌 값이다. 레퍼런스가 아닌 값을 `use`로 캡쳐를 할 때 `&` 참조한다는 표기를 해 주면, 함수 내의 `$outerVariable`는 선언된 값과 동일한 대상을 가리키므로 함수 내부에서 값이 변경되면, 함수 밖에 있던 값도 바뀐다.

`$outerVariable`が宣言される際の値は参照ではない値です。参照ではない値を`use`でキャプチャする際に`&`を付けて参照として指定すると、関数内の`$outerVariable`は宣言された値と同じ対象を指すことになります。そのため、関数内で値が変更されると、関数外の値も変更されます。

### unset을 사용한 임시 변수 관리
### unsetを使った一時変数の管理

때때로, 코드의 전개 과정에서 짧은 단위의 코드에서만 사용되고 더 이상 사용되지 않는 임시 변수를 만들 때는 `unset`을 활용하여 함수 스코프의 변수가 오염되지 않도록 코드를 만드는 것이 좋을 수 있다.

時には、コードの展開過程で短い単位のコード内でのみ使用され、もう使われない一時変数を作成することがあります。この場合、`unset`を活用して関数スコープの変数が汚染されないようにコードを作成することが推奨されることがあります。

함수 스코프의 코드가 짧은 경우에는 `unset`을 굳이 사용하지 않아도 되지만, 하나의 스코프에서 코드가 길어질 경우에는 `unset`으로 사용이 끝난 변수를 제거하여 변수 공간이 오염되지 않는 전략을 사용할 수 있다.

関数スコープのコードが短い場合は、`unset`を使用しなくても問題ありませんが、1つのスコープでコードが長くなる場合は、`unset`で使用が終わった変数を削除し、変数空間が汚染されないようにする戦略を取ることができます。

하지만 블록이 없기 때문에 선언된 변수가 언제 `unset`이 되는지 확인해야하는 문제가 있으므로, 한 눈에 알아볼 수 있을 정도의 몇 줄 정도의 짧은 코드에 한해서만 선언된 코드와 함께 값의 할당을 해제한다는 것을 알 수 있는 방식으로 쓰는 것이 좋다. '매우 긴 로직 + 몇 줄 정도의 짧은 임시 변수를 사용한 코드'에서만 `unset`을 통한 변수의 할당 해제가 적합한 코딩 스타일이다. 그 이외의 임시 변수의 선언 후, 이 변수를 사용하는 코드의 길이가 길어질 경우 `unset` 보다는 함수 스코프를 사용하도록 하자.

ただし、ブロックがないため、宣言された変数がいつ`unset`されるのかを確認する必要があります。そのため、一目でわかる程度の数行の短いコードにおいてのみ、宣言されたコードと一緒に値の割り当てを解除することを分かる方式で使うのが良いです。「非常に長いロジック + 数行程度の短い一時変数を使用したコード」の場合にのみ、`unset`による変数の割り当て解除が適切なコーディングスタイルです。このケース以外の場合、一時変数の宣言後、一時変数を使用するコードが長くなる場合は、`unset`より、関数スコープを使用しましょう。

`unset`을 남발하는 것은 CPU의 리소스 소모를 증가시키므로 좋은 코딩 스타일은 아니다. 하지만, `unset`으로 더 이상 변수가 정의되지 않게 되는 경우, 코드를 추가하는 입장에서 해당 변수를 사용하려고 해도 더 이상 정의되지 않아 사용할 수 없는 임시 변수라서 사용할 수 없게 되었구나를 확실하게 알게 해 준다.

`unset`を乱用することは、CPUのリソース消費を増加させるため、良いコーディングスタイルとは言えません。しかし、`unset`で変数がもう定義されなくなる場合、コードを追加する立場から、その変数を使用しようとしても、もう定義されていないため、使用できない一時変数であることが確実にわかります。

### 스코프와 변수 섀도잉 (Variable Shadowing)
### スコープと変数シャドウイング（Variable Shadowing）

변수 섀도잉이란? 스코프 밖의 변수를 스코프 안에서 별도의 캡쳐 구문 없이 사용할 수 있도록 스코프 밖의 변수와 동일한 이름의 변수를 스코프 안에서 선언해서, 해당 이름의 변수를 접근할 때 하위 스코프에서 선언된 변수에만 접근할 수 있게 하고 상위 스코프의 변수에는 접근할 수 없도록 하는 것이다.

変数シャドウイングとは、スコープ外の変数をスコープ内で特別なキャプチャ構文なしで使用できるように、スコープ外の変数と同じ名前の変数をスコープ内で宣言し、その名前の変数にアクセスする際に下位スコープで宣言された変数のみにアクセスでき、上位スコープの変数にはアクセスできないようにすることです。

스코프의 중첩이 깊어지면, 특정 변수가 상위 스코프의 어디에서 가져온 것인지 하위 스코프의 어디에서 섀도잉이 되었는지 파악해야 하는 문제가 생긴다. 변수명이 같기 때문에 어디서 선언된 변수인지 알아야 변수를 사용할 때 잘못된 사용을 방지할 수 있다. 자바스크립트에서 변수 선언 키워드로 `const`가 존재하는 것은 변수 섀도잉을 방지하기 위함이다.

スコープの入れ子が深くなると、特定の変数が上位スコープのどこから持ってきたものか、下位スコープのどこでシャドウイングされたのかを把握しなければならない問題が生じます。変数名が同じであるため、どこで宣言された変数なのかを知っていないと、変数を使用する際に誤った使用を防ぐことができません。JavaScriptにおいて変数宣言キーワード`const`が存在するのは、変数シャドウイングを防ぐためです。

php에서 함수 스코프는 `use` 키워드를 사용해서 함수 스코프 밖의 변수를 함수 내부로 가져와야 하고, `use` 문으로 어떤 이름의 변수명을 캡쳐하는지 알 수 있기 때문에 함수 내부에서 선언한 변수를 `use` 키워드로 가져온 것과 동일하게 선언할 가능성이 적다. 자바스크립트가 의도하지 않았는데 변수 섀도잉이 일어나는 것을 방지하기 위해 `const`를 도입한 것과 달리 php의 스코프는 의도하지 않은 섀도잉이 일어나지 않기 때문에 `const`와 같은 선언 키워드가 필수적으로 요구되지 않는다.

phpでは、関数スコープは`use`キーワードを使って関数スコープ外の変数を関数内部に持ち込む必要があり、`use`文でどの名前の変数をキャプチャするのかが分かるため、関数内部で宣言した変数を`use`キーワードで持ってきたものと同じように宣言する可能性は低いです。JavaScriptが意図しない変数シャドウイングを防ぐために`const`を導入したのに対して、phpのスコープは意図しないシャドウイングが発生しないため、`const`のような宣言キーワードは必須ではありません。

php에서 화살표 함수 `fn($param) => $param + $captured`는 `use` 키워드 없이 외부의 변수를 캡쳐할 수 있는데, 화살표 함수는 `=>` 뒤에 바로 반환 값이 위치해야 하기 때문에 화살표 안에서 새롭게 선언되는 변수는 화살표 함수의 파라메터이다. 변수의 선언과 동시에 사용하는 것을 바로 알 수 있으므로, 상위 스코프의 변수를 덮어 씌우더라도 바로 사용되는 임시 변수이기 때문에 변수 섀도잉이 일어나더라도 로직에 큰 영향을 끼치지 않는다.

phpでは、矢印関数`fn($param) => $param + $captured`は`use`キーワードなしで外部の変数をキャプチャできますが、矢印関数は`=>`の後にすぐに返り値が位置する必要があるため、矢印内で新たに宣言される変数は矢印関数のパラメータとなります。変数の宣言と同時に使用されることがすぐに分かるため、上位スコープの変数を上書きしてもすぐに使用される一時変数であるため、変数シャドーイングが起こってもですロジックに大きな影響を与えることはありません。

## 마지막으로
## さいごに

php 백앤드 개발을 하고 있다면, 자바스크립트를 함께 사용하는 경우가 많다. 그런데 자바스크립트에는 잘 되는데, php에서는 잘 안되는, php에서는 되는데 자바스크립트에서는 잘 안되는 여러가지 특징에 혼란스런 경험이 있을 것이다.

phpバックエンド開発をしている場合、JavaScriptを一緒に使うことが多いです。しかし、JavaScriptではうまくいくことが、phpではうまくいかない、またはその逆のような、phpとJavaScriptの間で異なる特徴に混乱することがあるかもしれません。

특히 자바스크립트는 변수의 선언 키워드 `var`, `const`, `let`가 존재하는데, php에서는 왜 없는지 의문을 느끼는 사람들이 있을 것이다. 블록 스코프, 함수 스코프의 개념과 관련된 좋은 코딩 스타일에 대한 개념을 이해하면, (지역변수에) 변수의 선언 키워드가 없는 php의 코드를 작성하는데 특별한 불편함이 없이 코딩을 잘 할 수 있는 이유를 이해할 수 있다.

特に、JavaScriptには変数の宣言キーワード`var`, `const`, `let`がありますが、phpにはなぜこれらがないのか疑問に思う人もいるでしょう。ブロックスコープや関数スコープの概念と、それに関連した良いコーディングスタイルの理解を深めることで、（ローカル変数に）変数宣言キーワードがないphpコードを特別な不便を感じることなくうまく書ける理由が理解できるでしょう。

### php에 변수 선언 키워드가 없는 이유
### phpに変数宣言キーワードがない理由

- `var`: php에서 변수에 값을 할당하는 것은 `var` 키워드를 사용한 것과 같다.
- `var`: phpで変数に値を代入することは、`var`キーワードを使用するのと同じです。
- `let`: php는 블록 스코프가 없으므로 `let` 대신에 `var`를 사용하면 된다.
- `let`: phpにはブロックスコープがないため、`let`の代わりに`var`を使用すれば問題ありません。
- `const`: 모르는 새에 변수 섀도잉이 일어나는 일이 없고, 함수 코드의 길이를 짧게 쓰면 자기도 모르는 새에 변수를 재정의 하는 일이 없기 때문에 무리하게 `const` 키워드를 도입할 필요가 없다.
- `const`: 意図しない変数のシャドーイングが発生することはなく、関数のコードを短く書けば自分でも気づかないうちに変数を再定義してしまうこともないため、無理に`const`キーワードを導入する必要はありません。

## References

- https://externals.io/message/109029
- https://stackoverflow.com/questions/16557218/when-unset-should-really-be-used
