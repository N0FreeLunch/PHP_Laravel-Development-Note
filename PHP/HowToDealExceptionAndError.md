# 예외 및 에러처리

## 초보들의 에러처리 (잘못된 방법)

예외를 잡지 않고 일부러 발생 시켜서 프로세스를 강제로 끝나게 작성한다. (여기서 문제인 것은 예측하지 못한 에러가 아닌 '일부러' 예외를 발생 시킨다는 것)

예외를 잡지 않는다는 것은 별도의 에러 처리 로직을 짜지 않아도 되기 때문에 개발 시간을 단축할 때 사용한다.

예를 들어 DB의 듀플리케이션 예외가 발생하면 특별한 에러 처리를 하지 않고 프레임워크가 처리해 주는 500 스테이터스 코드를 띄우는 것이다.

## 예외나 에러의 스텍

예외는 스텍 트레이스라는 특성을 갖고 있다. 스텍트레이스란 예외가 발생한 코드를 실행한 코드를 기록하는 것이다. 예외가 발생했을 때, 예외를 발생한 코드를 어떤 코드가 실행 했고, 해당 코드는 또 어떤 코드에 의해 실행되었고, 이런 과정의 반복으로 최종적으로 처음에는 무엇을 실행해서 예외 코드까지 실행 되었는지 어떤 코드가 무엇을 실행했는지 확인할 수 있는 기록한 것으로 스텍에 축적되는 단위의 데이터는 함수나 메소드의 호출을 기준으로 한다.

php를 CLI 모드로 실행하면 예외가 발생했을 때 외에 쌓인 스텍을 특별히 예외를 처리하지 않는다면, CLI의 스텍 트레이스에 저장된 기록된 데이터를 로그로 표시해 준다. 라이브러리를 사용하면 로그 파일에 예외의 스텍 트레이스의 기록이 저장된다.

스텍 트레이스를 통해서 어떤 부분에서 문제가 발생했는지 추적할 수 있고, 좀 더 빠르게 문제 해결의 실마리를 얻을 수 있다.

## 예외 처리를 하는 이유

예외는 기본적으로 예외 처리를 하기 위해 사용되어야 한다. 처리되지 않는 예외는 로그를 남기고, 예외가 발생했을 때의 통지를 통해서 해당 에러의 원인을 파악하고 해결을 해 줘야 한다.

예외를 처리하지 않으면, 이는 보고되는 처리를 한다. 예외를 처리하지 않아 보고가 되면 이는 예외는 해결 되어야 할 대상인 것을 알 수 있다. 너무 많은 종류의 예외가 발생하게 되면, 무엇을 해결해야 하는 대상인지 어느 문제에 집중해야 할지 파악하기 어렵기 때문에 처리되지 않는 예외는 최소화 하는 것이 중요하다.

예외가 발생했을 때, 미리 예외 처리를 할 수 있다면, 예외가 처리되지 않아 통지되거나 로그가 남지 않도록 하고, 예상치 못한 부분의 문제가 발생했을 때만 해당 부분의 문제를 해결할 수 있도록 처리되지 않은 예외가 되어야 한다.

## 에러 발생 시 고려 해야 하는 유형

- 예상 가능한 에러
- 예방 가능한 에러
- 에러가 발생하면 실행을 중단해야 하는 에러
- 에러가 발생해도 처리를 계속 해야 하는 에러
- 무시해도 괜찮은 에러

### 예상 가능한 에러

- 예상 가능한 에러가면 에러가 발생하지 않도록 미리 예방하는 코드를 짠다. 왜냐하면 예상 되지 않는 것만 로그를 남기기 위해서 예상 가능한 에러는 로그를 남기지 않도록 처리 해 주는 것이다.
- 예상 가능하지만 미리 방지하기 어려운 에러가면 에러가 발생해도 시스템의 작동이 이뤄질 수 있도록 에러 로직을 짠다.

### 예방 가능한 에러

- 고객은 500 스테이터스를 받는다. 이유를 모른 채 서비스의 기능을 사용하지 못한다.
- 500 스테이터스 에러 로그를 기록하지 않는다면 고객이 무슨 기능을 사용하다가 문제가 발생했는지 파악할 수 없다.
- 특별한 안내 메시지 없이 기능을 사용할 수 없다는 것은 서비스 운영에 치명적이기 때문에 500에러가 발생하지 않도록 미리미리 에러를 방지하기 위한 가이드라인을 고객에게 제공하는 UI/UX를 만드는 것이 중요하다.

### 에러가 발생하면 처리를 중단해야 하는 에러
- 에러를 예상하지 못한 경우에 사용하는 에러이다.
- 이 경우 프레임워크 또는 언어 레벨에서 실행이 이뤄지지 않도록 멈추게 된다. 프레임워크를 사용하는 경우 특별한 설정을 하지 않아도 자동으로 에러 로그를 남겨준다. (라라벨의 경우 storage/logs 경로에 에퍼 로그를 기록하는 파일이 남는다.)
-  이와 같은 에러를 확인했다면 에러가 생기지 않도록 코드를 개선해서 서비스에서 미리 대처한 에러에 대한 로그가 생기지 않도록 하자.

### 에러가 발생해도 처리를 계속 해야 하는 에러
- 에러 발생을 예방할 수 있는 코드를 짤 수 없는 경우가 있을 수 있다. 그리고 에러가 발생해도 로직 처리가 끝까지 이뤄지도록 만들 필요가 있는 경우가 있다.
- 이 경우 에러가 발생할 가능성이 있는 코드를 try ~ catch 문으로 감싼 후 에러 로그를 남기고 후속 처리를 계속 진행하는 방식으로 코드를 짤 수 있다.
- 또는 예측 가능한 특정 유형의 에러라면 해당 유형의 에러에 대한 로그를 남지기 않고 후속 처리를 진행하는 방식을 사용할 수 있다.
- 하지만 가능한 한 이 경우를 피하고 예방 가능한 에러를 대응하는 방식으로 만드는 것이 좋다.

### 무시해도 괜찮은 에러
- 예를 들어 데이터베이스의 varchar의 글자 수가 255를 사용할 때, 벨리데이터 처리를 하지 않아서 255자 이상의 데이터가 들어 오는 경우 사내 관리 화면이라면 에러 발생시 굳이 코드를 개선하지 않고 '255자 이상 입력하면 안 되요'라고 이용 사원에게 통지하는 방식으로 대응할 수 있는 것.
- 하지만 사용자입장에서는 이런 에러에 의해서 실행이 안 되고 원하는 동작이 되지 않으므로 서비스 이용 경험이 하락한다.
- 무시해도 괞찮은 에러는 없다. 하지만 개발을 하다보면 개발 시간 및 일정 등을 고려해야 하기 때문에 가끔 발생하고 서비스 경험에 큰 지장이 없는 에러라면 무시할 수도 있다. (거의 로그가 생기지 않기 때문)

## 예치기 못한 에러가 발생했을 때 대응 방안
- 예기치 않은 에러는 기본적으로 프레임워크가 에러를 기록해 준다.
- UI/UX 미비로 잘못된 값이 들어와 에러가 발생했을 때를 대비해서 에러가 발생했다면 에러 로그를 기록해야 한다.
- 예기치 않은 에러는 에러 로그를 확인하고 에러가 발생하지 않도록 UI/UX에서 대응을 하고, 벨리데이터 등으로 왜 처리가 안 되는지 알리는 등의 작업을 하는 것이 필요하다.

## 에러 로그를 남길 때 중요한 것.
- 에러가 나지 않도록 처리하는 것이 아니라, 왜 어떤 경우에 에러가 났는지 알 수 있도록 필요한 에러는 남기는 것이 중요하다.


## 에러 처리 로직을 어떻게 짜면 될까?
CASE 1
```
try {
    에러 발생 가능성이 있는 코드
} catch(e) {
    예외를 기록하는 코드
    예외가 발생했을 때 고객에게 보여주는 코드 (500 스테이터스에러)
}
```

CASE2
```
에러의 발생을 예방하기 위한 여러가지 로직이 들어간 코드
try {
    예상치 못하게 에러가 발생할 가능성이 있는 코드
} catch(e) {
    예외를 기록하는 코드
    예외가 발생했을 때 고객에게 보여주는 코드 (500 스테이터스)
}
```
- CASE1으로 짜는 것이 아니라 CASE2로 짜는 것이 중요하다.

## 에러 로깅을 통한 서비스 장애 해결
- 고객에게 500 스테이터스 화면을 보여 줬다면 고객이 이를 알려주지 않더라도 500 에러를 해결할 수 있도록 만들어 줘야 한다.
- 고객이 안 알려 줬는데 처리가 되는지 안 되는지 확인하기 위해서 에러 로그를 남겨서 확인한다.
- 에러 로그를 주기적으로 확인하거나 에러 통지 기능을 만들어 에러 문제를 해결한다.
- 에러 통지를 만들 때, 너무 많은 알람이 오지 않도록 중복 에러를 배제하는 등의 처리가 필요하다.
- 보통 에러 통지는 센트리 같은 서비스를 사용하거나 렉 통지와 같은 방식을 주로 사용한다.

---

## 사용자 정의 에러
### 커스텀 에러 클래스를 사용하는 이유
- 에러 종류에 대한 필터링을 위해 사용하는 방법
```
try{
    ...
} catch(CustomExceptionA $e) {
    CustomExceptionA에 관한 에러를 처리하는 로직
} catch(CustomExceptionB $e) {
    CustomExceptionB에 관한 에러를 처리하는 로직
}
```
- try 안에서 여러가지 에러가 발생할 수 있지만 그 중에서 각 종류의 에러만 뽑아서 처리하고 싶을 때 사용한다.
- 각각의 에러는 각각의 로직에서 처리하면 되지 않는냐고 할 수 있다. 예를 들어 CustomExceptionA에 관한 에러 처리는 A에 관련된 로직이 처리되는 쪽에서 정의하고, CustomExceptionB에 관한 에러 처리는 B에 관련한 로직이 처리되는 쪽에서 정의 하는 방식이다.
- 위와 같은 코드는 에러 처리를 모아서 하고자 할 때 사용하거나 하나의 단위의 로직을 에러별로 나누기 어려워 로직 단위에서 여러 에러가 섞일 수 밖에 없는 코드를 짤 때 사용한다.

### 커스텀 에러를 사용하는 이유
- 함수의 인자로 'a'와 'b'라는 문자열만 받고 싶은 경우
```
function(string $test) {
    if(!($test === 'a' || $test === 'b')) {
        return throw exception("인자로 'a'와 'b'만 허용함")
    }
    ...
}
```
- 문법적인 강제 기능을 하게 하기 위함이다.





