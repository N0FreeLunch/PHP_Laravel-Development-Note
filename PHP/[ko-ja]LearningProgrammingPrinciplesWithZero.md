## 0으로 배우는 프로그래밍 원리 (부제: 초기값으로 null인가 빈 값인가?)
## ゼロからまなぶプログラミング原理 (副題: 初期値はnullか空の値か？)

## 도입
## はじめに
- 클래스의 멤버 변수에 타입힌트를 사용하지 않았던 과거의 php에서는 멤버 변수에 아무런 직접적인 초기화 값을 넣어주지 않을 경우에 디폴트로 null을 초기값이 된다. 이런 경향으로 인하여 변수의 초기값을 빈 값이 아닌 null으로 세팅하는 경우가 많았다.
- クラスのメンバー変数にタイプヒントを使用しなかった過去のphpには、メンバー変数に直接初期化値を入れない限り、デフォルトでnullが初期値になりました。この傾向から、変数の初期値を空の値ではなくnullに設定するケースが多かったです。
```php
class DefaultMember { public $variable; }
var_dump((new DefaultMember)->variable); // Null
```
- 타입힌트가 나오기 전의 과거 php에서 많은 경우 변수는 단순히 값을 저장하기 위한 용도로 사용되었다. 변수를 선언하기에 앞서 변수를 어떻게 사용할지에 대한 의도를 가지고 만들어지기 만들어져야 하지만, 타입에 대한 의식 없이 무언가를 만드는데 필요했기 때문에 변수를 사용했기 때문에 변수에 아무렇게나 값을 넣었고, 의도없이 변수를 선언했기 때문에 null을 초기값으로 사용하는 경우도 많았다. 이런 예전의 관습 때문에 현재까지도 null을 초기값으로 사용하는 경우도 있다.
- タイプヒントが導入される以前の過去のphpでは、多くの場合、変数は単に値を保存するために使用されました。変数を宣言する前に、変数をどのように使用するかについての意図を考えて作成されるべきですが、タイプに対する意識なしに何かを作成する必要があるから変数には適当な値が入って、意図せずに変数が宣言されたので多くの場合初期値としてnullを使用するケースが多かったです。このような昔の慣行で、現在でもnullを初期値として使用するケースがあります。
- php에서 타입힌트가 등장하고 변수에 null을 사용하기 위해서 `?T` 또는 `null | T` 등의 nullable 타입을 정의하면서 변수를 선언할 때 null으로 초기화 해야할까라는 고민했던 사람들이 많아졌을 것이라고 생각한다. 이번 주제는 이에 대한 답을 찾기 위한 목적으로 작성하였다. 많은 php 개발자들에게 도움이 되는 지식이 되길 바란다.
- phpでタイプヒントが登場し、変数にnullを使用するために`?T`や`null | T`など(Tはあるタイプ)のnullable型を定義して変数を宣言する際、nullで初期化すべきかどうかについて悩んでいた人々が多かったと思います。今回のトピックは、これに対する答えを見つけるための目的で書かれました。多くのphp開発者に役立つ知識になることを願っています。

### 변수의 초기값에 null을 사용하자는 주장
### 変数の初期値にnullを使用すべきだという主張
- 변수의 초기값에 빈 값을 사용하는 경우 비할당된 값의 타입이 할당된 타입과 일치한다. 예를 들어 `$var = 0`을 초기값으로 할당된 값은 `$var = 10`으로 값을 할당하는 것이다. null이 초기값인 것과 달리 타입이 동일하다. null을 초기값으로 사용하는 경우 할당된 값은 타입이 다르다. 예를 들어 매개변수의 타입힌트로 int를 지정했을 때 null을 전달 받으면 타입 불일치로 인해서 에러를 발생시킨다. null을 초기값으로 사용할 경우 타입 불일치로 에러가 발생하므로, 함수나 메소드의 메개변수로 변수에 값이 할당되지 않은 값을 전달할 때 에러를 통해서 값이 할당되었는지 할당되지 않았는지 확인하기 쉽다는 장점이 있다.
- 変数の初期値として空の値を使用する場合、未割り当ての値の型が割り当てられた型と一致します。たとえば、`$var = 0`を初期値として割り当てたから同じタイプである`$var = 10`という値を割り当てることです。nullが初期値の場合とは異なり、空の値は割り当てられた値の型と同じ型です。一方、nullを初期値として使用する場合、割り当てられた値は異なる型です。たとえば、引数のタイプヒントでintを指定した場合、nullを渡すと型不一致のためエラーが発生します。nullを初期値として使用すると、型不一致によりエラーが発生するため、関数やメソッドのパラメーターとして、変数に値が割り当てられていない値を渡すときに、値が割り当てられたかどうかをエラーで確認しやすいという利点があります。

### null 사용보다 빈 값을 사용하는 것이 좋은 이유
### nullを使用するよりも空の値を使用する理由
- `변수 === null` 또는 `is_null(변수)`을 사용하는 것이나, `변수 === 0` `변수 === ''` `변수 === []`이나 어차피 할당과 비할당을 구분하기 위한 분기는 똑같이 처리해야 하기 때문에 빈 값을 할당하는 것이 로직의 분기 복잡성을 줄여주지 않는다고 생각할 수 있다.
- `変数 === null`または`is_null(変数)`を使用することと、`変数 === 0` `変数 === ''` `変数 === []`を使用することはどうせ割り当てと未割り当てを区分するための分岐は同じ処理をすると思われます。空の値を割り当てることはロジックの分岐の複雑さを減らしてくれないと考えられます。
- 하지만 빈 값인 경우 if문의 사용을 줄이는 스타일의 코딩을 통해서 로직의 분기를 줄일 수 있다. 이를 이해하기 위해 먼저 숫자 0에 대한 예를 생각해 보자.
- ただし、空の値の場合、if文の使用を減らすスタイルのコーディングを通じてロジックの分岐を減らすことができます。これを理解するために、まず数0の例を考えてみましょう。

### 숫자 0
### 数字 0
#### 0에 대한 수 n의 연산
#### 0に対する数nの演算
- 0에 어떤 값(n)을 더했을 때, 결과는 n이 된다.
- 0にどんな値(n)を加えた場合、結果はnになる。
- 0에 어떤 값(n)을 뺐을 때, 결과는 n이 된다.
- 0にどんな値(n)を引いた場合、結果はnになる。
- 0에 어떤 값(n)을 곱했을 때, 결과는 0이 된다.
- 0にどんな値(n)を掛けた場合、結果は0になる。
- 0애 어떤 값(n)을 나누었을 때, 결과는 0이 된다.
- 0をどんな値(n)で割った場合、結果は0になる。
- 0에 대한 곱셈과 나눗셈을 생각해 보자. **0에 어떤 값을 연산 했을 때, 그 결과는 0과 어떤 값(n)과 연산은 존재하지 않았던 것과 다름없다.**
- 0に対する乗算と除算を考えてみましょう。**0にどんな値を演算した場合、その結果は0と、どんな値(n)との演算は存在しなかったも同然です。**

#### n에 대한 수 0의 연산
- 어떤 값 n에 0을 더했을 때 결과는 n이 된다.
- どんな値「n」に「0」を加えた場合、結果は「n」になる。
- 어떤 값「n」에 「0」을 뺐을 때 결과는 「n」이 된다.
- どんな値(n)から0を引いた場合、結果はnになる。
- 어떤 값「n」에 「0」을 곱했을 때 결과는 「0」이 된다.
- どんな値「n」を「0」で掛けた場合、結果は「0」になる。
- 어던 값「n」에 0을 나누었을 때 결과는 무한대가 된다.
- どんな値「n」を「0」で割った場合、結果は無限大になる。
- 어떤 값「n」에 대한 덧셈과 뺄셈을 생각해 보자. **n에 0을 연산 했을 때, 그 결과는 n과 0의 연산은 존재하지 않았던 것과 다름없다.**
- どんな値「n」に対する加算と減算を考えてみましょう。**nに「0」を演算した場合、その結果は「n」と「0」の演算は存在しなかったも同然です。**

### 함수로 표현하기
### 関数で表現する
- 이런 0의 특성을 수학에서의 함수로 표현 해 보자. `f(0, n) = 0` 또는 `g(0, n) = n`가 된다. 두 대상의 연산의 결과가 하나의 대상으로 되는 값이라는 것을 알 수 있다.
- このような0の特性を数学の関数で表してみましょう。`f(0, n) = 0`または`g(0, n) = n`となります。2つの対象の演算の結果が1つの対象になる値であることがわかります。

### 처리 전후의 상태가 동일함
### 処理の前後の状態が同じ
- 일반적으로 프로그래밍 언어에서 상태라는 것은 변수가 갖고 있다. 어떤 처리를 하기 전의 여러 변수에 들어 있는 값과, 어떤 처리를 한 후의 변수들이 동일한 값을 가지고 있다면, 이는 동일한 상태를 가진 것과 같다.
- 一般的に、プログラミング言語での状態とは、変数が持っている値を指します。ある処理をする前の変数に入っている値と、ある処理をした後の変数が同じ値を持っている場合、それは同じ状態を持つことと同じです。
- 숫자 0은 여러 연산에 대해서 처리 전후의 값이 동일한 특성을 가진다. 어떤 값 x에 대해서 연산 f의 처리가 x가 되는 것. `f(x)=x`라는 방정식을 만족하는 해를 수학에서는 고정값(fixed point)이라고 부른다. 고정값의 성질을 프로그래밍에서 생각해 보자.
- 数字の0は、色んなの演算に対して処理前後の値が同じ特性を持ちます。ある値「x」に対して演算「f」の処理が「x」になるもの、つまり`f(x)=x`という方程式を満たす解を数学では不動点(fixed point)と呼びます。不動点の性質をプログラミングで考えてみましょう。
- 앞서 0은 수학적으로 여러 연산에 대해 `f(0, n) = 0` 또는 `g(0, n) = n`으로 표현 된다고 하였다. 이 때 `f(0, n) = 0`은 `f'(n) = 0` 또는 `f"(0) = 0`으로 표현 할 수 있을 것이다. `g(0, n) = n`도 `g'(n) = n` 또는 `g"(0) = n`으로 표현 될 것이다. 곧, `f(0, n) = 0`의 관계를 가지고 있다면 `f'(n) = 0`은 `f"(0) = 0`으로 표현될 것이고, `g(0, n) = n`의 관계를 가지고 있다면 `g'(n) = n`은 `g"(0) = n`으로 표현될 것이다. 이는 결국 `f(x)=x`의 꼴로 고정값의 형태로 표현된다.
- 先ほど、「0」は数学的にいくつかの演算に対して `f(0, n) = 0` または `g(0, n) = n`と表現されると述べました。 この場合、`f(0, n) = 0`は `f'(n) = 0`または `f"(0) = 0`と表現できます。 `g(0, n) = n`も `g'(n) = n`または `g"(0) = n`と表現されます。つまり、`f(0, n) = 0`の関係である場合、`f'(n) = 0`は `f"(0) = 0`と表現され、`g(0, n) = n`の関係を持っている場合、`g'(n) = n`は `g"(0) = n`と表現されます。これは結局、`f(x)=x`の形で不動点の形で表されます。

### 빈 값
### 空の値
- 빈 값도 0의 예시 처럼 아무런 영향을 주지 않는 값으로 사용하는 코드를 만들 수 있다. 빈 값에 대한 로직의 처리 전후의 상태의 다름이 없다면, 알고리즘은 실제로 실행되었지만 마치 실행되지 않은 것과 동일한 상태를 갖는다.
- 空の値も、0の場合のように何の影響も与えない値として使用するコードを作成することができます。空の値に対するロジックの処理前後の状態の違いがない場合、アルゴリズムは実際に実行されるにもかかわらず、まるで実行されていないかのような状態を持ちます。
- 값 또는 변수 x,y에 대해 알고리즘 f가 있다고 하자. `f(x,y) = x`의 관계에서 x를 변수로 y를 값으로 두자. 그럼 `f'(x) = x`을 만족하는 `f'`라는 함수를 만들 수 있을 것이다. 알고리즘 `f'`는 알고리즘의 실행 전후의 결과가 동일하기 때문에 로직상 실행되지 않는 것과 동일하다. 물론 프로그램이 실행되면서 리소스를 소비하지만 실행 전후의 상태는 동일하다.
- 値または変数「x、y」についてのアルゴリズム「f」があると仮定しましょう。`f(x, y) = x`の関係で、「x」を変数とし、「y」を値としてみましょう。すると、`f'(x) = x`を満たす関数`f'`を作成できます。アルゴリズム`f'`は、実行前後の結果が同じであるため、ロジック的には実行されないのと同じです。もちろんプログラムは実行されますが、実行前後の状態は同じです。
- 변수의 초기값이 null일때, `if(is_null(x)) { f'(x) }`의 코드가 실행되면 「x」가 「null」이므로 if문을 통과하지 못한다. 따라서 `f'(x)`는 실행되지 않지만, if문의 코드는 진행된다. 초기값을 null으로 했을 때, 변수가 할당되었는지를 확인하는 것과, 초기값으로 알고리즘에 고정값을 사용했을 때 if문 없이 `f'(x)`를 실행했을 때 그 결과가 「x」가 되는 것의 코드 실행 전후의 상태는 if문이 실행되지 않든, `f'(x)`가 실행되든 동일하다.
- 変数の初期値がnullの場合、`if(is_null(x)) { f'(x) }`のコードが実行されると、「x」がnullであるため、if文を通過できません。したがって、`f'(x)`は実行されませんが、if文のコードは進行します。初期値をnullに設定した場合、変数が割り当てられたかどうかを確認することと、初期値としてアルゴリズムに不動点を使用した場合、if文なしで`f'(x)`を実行した場合の結果が「x」になることのコードの実行前後の状態は、if文が実行されなくても`f'(x)`が実行されても同じです。
- 프로그래밍에서 빈 값은 많은 경우 수학에서의 고정값의 역할을 하며, 빈값을 사용할 때 처리 전후의 상태가 동일하다는 특성을 이용해서 if문의 사용을 줄이는 코딩을 할 수 있다.
- プログラミングにおいて、空の値は多くの場合、数学での不動点の役割を果たし、空の値を使用するとき、処理前後の状態が同じであるという特性を利用して、if文の使用を減らすコーディングができます。

### 빈 값을 사용한 분기 줄이기의 예시
### 空の値を利用して分岐を減らす例

#### 문자열 결합 연산자 닷(.)
#### 文字列結合演算子ドット（.）
- dot(.)은 문자열을 결합하는 연산이다. 임의의 문자열에 대해서 빈 문자열을 dot(.)으로 결합하면 그 결과는 이전의 문자열과 동일하다. 빈 문자열의 `.` 연산을 통한 연결은 처리 전후의 결과가 동일한 결과를 얻는다.
- ドット（.）は文字列を結合する演算です。任意の文字列に対して空の文字列をドット（.）で結合すると、その結果は以前の文字列と同じです。空の文字列の`.`演算による結合は、処理前後の結果が同じ結果を得ます。
```php
$var = "";
echo "hello".$var;
```
- `"hello".$var`을 하나의 함수로 바라보자. 그럼 `f("hello", $var) = "hello"`의 꼴으로 알고리즘 f의 고정값으로 `$var`가 빈 문자열이 되어야 한다.
- `"hello".$var`を一つの関数と見なしましょう。すると、`f("hello", $var) = "hello"`の形で、アルゴリズムfの不動点として`$var`は空文字列になる必要があります。

```php
$var = null;
if(is_null($var)) {
    echo "hello";
} else {
    echo "hello".$var;
}
```
- 변수의 초기값으로 null을 주든, 빈 문자열을 주든 출력되는 결과는 `"hello"`으로 동일하다. 하지만 빈 문자열을 사용하는 것을 통해서 if문의 사용을 줄일 수 있다는 것을 알 수 있다.
- 変数の初期値としてnullを与えるか、空文字列を与えるかに関係なく、出力結果はいずれも`"hello"`と同じです。しかし、空文字列を使用することでif文の使用を減らすことができることがわかります。

#### 문자열 대체 함수
#### 文字列置換関数
```php
$search = "";
$subject = "subject";
echo str_replace($search, "_", $subject);
```
- `str_replace`에서 `$search` 변수에 해당하는 문자열 값을 찾아서 `_`으로 바꾸는 코드를 실행한다고 하자.
- `str_replace`関数で、変数`$search`に対応する文字列を見つけて`_`に置き換えるコードを実行するとします。
- `$search`가 빈 문자열인 경우 대체할 대상을 아무것도 찾지 않으므로 대체할 대상이 없어서 위의 결과는 `"subject"`가 그대로 나온다.
- `$search`が空の文字列の場合、置換対象を見つけることができないため、置換対象がなく、結果は`"subject"`のままです。
- 위의 코드의 `str_replace($search, "_", $subject)` 부분은 `"_"`와 `$subject`가 정해진 값이기 때문에 `$search`에 대해서만 생각해 보자. `f("subject", $search) = "subject"`의 꼴으로 표현할 수 있다. 이 방정식의 고정값은 `$search`가 빈 문자열인 경우이다.
- 上記のコードの `str_replace($search, "_", $subject)` 部分は、`"_"`と`$subject`が決められた値なので、`$search`について考えることができます。`f("subject", $search) = "subject"`という形で表現できます。この方程式の不動点は、`$search`が空の文字列の場合です。
```php
$search = null;
$subject = "subject";
if(is_null($search)) {
    echo $subject;
} else {
    echo str_replace($search, "*", $subject);
}
```
- 만약 `$search`에 빈 값이 아닌 `null`을 할당했다면, 위와 같이 분기 처리가 늘어날 것이다.
- もし`$search`に空の値ではなく`null`を割り当てた場合、上記のように分岐処理が増えるでしょう。

#### 스프레드 연산자
#### スプレッド演算子
```php
$oneToFive = [1, 2, 3, 4, 5];
var_dump([10, 11, 12, ...$oneToFive]);
```
- `[10, 11, 12, ...$oneToFive]`은 `[10, 11, 12]` 배열 안에 스프레드 연산자 형태의 배열을 포함될 때 `$oneToFive` 배열 안의 원소들이 `[10, 11, 12]`의 배열에 포함되어 `[10, 11, 12, 1, 2, 3, 4, 5]`라는 결과값을 갖는다.
- `[10, 11, 12, ...$oneToFive]`は、`[10, 11, 12]`の配列内にスプレッド演算子形式の配列が含まれている場合、`$oneToFive`配列の要素が`[10, 11, 12]`の配列に含まれ、結果は`[10, 11, 12, 1, 2, 3, 4, 5]`となります。
```php
$arr = [];
var_dump([10, 11, 12, ...$arr]);
```
- 빈 배열을 스프레드 연산자로 배열에 포함하면, `[10, 11, 12]`으로 아무 원소도 추가되지 않은 결과가 나온다.
- 空の配列をスプレッド演算子で配列に含めると、何も要素が追加されずに`[10, 11, 12]`の結果が得られます。
- 위의 코드는 다음과 같은 의사코드로 바꿀 수 있다. `f([10, 11, 12], $arr) = [10, 11, 12]` 이 방정식을 만족하는 고정값은 `$arr`가 빈 배열이 될 경우이다.
- 上記のコードは、次の擬似コードに置き換えることができます。`f([10, 11, 12], $arr) = [10, 11, 12]` この方程式を満たす不動点は、`$arr`が空の配列になった場合です。
```php
$arr = null;
if(is_null($arr)) {
    var_dump([10, 11, 12]);
} else {
    var_dump([10, 11, 12, ...$arr]);
}
```
- 만약 `$arr`에 빈 값이 아닌 `null`을 할당했다면, 위와 같이 분기 처리가 늘어날 것이다. 변수의 초기값으로 빈 배열을 사용하는 것을 통해서 if문의 사용을 줄일 수 있다.
- もし `$arr` に空ではなく `null` を割り当てた場合、上記と同様に分岐処理が増えるでしょう。変数の初期値として空の配列を使用することで、if文の使用を減らすことができます。

#### 배열 함수 (array_walk)
#### 配列関数 (array_walk)
```
array_walk(array|object &$array, callable $callback, mixed $arg = null): bool
```
- 배열 그 자체를 변경하고자 하는 경우 `&$array`으로 `&` 참조 기호를 사용하며, 배열 안에 든 값만 이용하고 싶다면 `$array`으로 참조 기호 없이 사용한다.
- 配列そのものを変更したい場合は、`&$array`のように`&`参照記号を使用し、配列内の値のみを使用したい場合は`$array`のように参照記号を使用しません。

```php
$arr = [];
array_walk($arr, function (mixed $e) {
    $e = gettype($e);
});
```
- 이 함수는 반환값을 갖는 함수가 아니다. 원본 값 그 자체를 변화 시키거나 원본 값을 활용한 다른 값을 만드는 것인데, 주어진 배열이 빈 배열 `[]`인 경우 주어진 콜백함수를 실행하지 않는다. 곧 결과값이 원본 그대로이다. 따라서 빈 배열은 `[]`은 `array_walk` 내장 함수의 실행에 대해 실행해도 실행하지 않아도 결과값은 동일하다.
- この関数は戻り値がない関数です。元の値そのものを変更したり、元の値を利用して他の値を生成するものであり、与えられた配列が空の配列 `[]` の場合、与えられたコールバック関数を実行しません。そのため、結果は元のままです。したがって、空の配列 `[]` は `array_walk` 組み込み関数の実行を行っても、行わなくても結果は同じです。
- 위 코드는 다음과 같은 의사코드로 바꿀 수 있다. `f($arr) = []` 이를 만족하는 고정값은 `$arr`의 값이 `[]`이 될 경우이다.
- 上記のコードは、次のような擬似コードに変換できます。`f($arr) = []` この方程式を満たす不動点は、`$arr`の値が`[]`になった場合です。
```php
$arr = null;
if(is_array($arr)) {
    array_walk($arr, function mixed ($e) {
        $e = gettype($e);
    });
}
```
- 만약 빈 배열이 아닌 null을 초기값으로 사용했다면 if문을 추가해야 한다.
- もし空の配列ではなくnullを初期値として使用した場合、if文を追加する必要があります。

#### 배열 함수 (array_map)
#### 配列関数 (array_map)
```
array_map(?callable $callback, array $array, array ...$arrays): array
```
- 배열을 받아 콜백함수에 정의된 방식을 통해서 배열의 각 원소를 변경하고 새로운 배열을 만드는 함수이다.
- 配列を受け取り、コールバック関数で定義された方法に従って、配列の各要素を変更し、新しい配列を作成する関数です。
```php
$arr = [];
$typeList = array_map(function (mixed $e) {
    return gettype($e);
}, $arr);
```
- 빈 배열이 주어질 경우 `array_map`은 각각의 원소에 대해 콜백함수를 적용해야 하는데 원소가 없으므로 콜백함수를 적용하지 않고 원소가 없는 빈 배열을 반환한다.
- 空の配列が与えられた場合、`array_map`は各要素に対してコールバック関数を適用する必要がありますが、要素がないため、コールバック関数を適用せずに要素がない空の配列を返します。
- 위 코드는 다음과 같은 의사코드로 바꿀 수 있다. `f($arr) = []` 이를 만족하는 고정값은 `$arr`의 값이 `[]`이 될 경우이다.
- 上記のコードは、次の擬似コードで表現できます：`f($arr) = []` この方程式を満たす不動点は、`$arr`の値が`[]`になった場合です。
```php
$arr = null;
$typeList = [];
if(is_array($arr)) {
    $typeList = [];
} else {
    $typeList = array_map(function (mixed $e) {
        return gettype($e);
    }, $arr);
};
```
- 만약 빈 배열이 아닌 null을 초기값으로 사용했다면 if문을 추가해야 했다.
- もし空の配列ではなくnullを初期値として使用した場合、if文を追加する必要がありました。

### 고정값이 존재하는 알고리즘
### 不動点が存在するアルゴリズム
- 모든 코드에 대해서 빈 값의 초기값이 알고리즘의 실행에서 고정값의 역할을 하지는 않는다. 코드(알고리즘)에 대해 사용하는 변수에 대해 고정값을 만드는 로직을 만들어 줘야 한다. 알고리즘/코드 f와 빈값 a에 대해 (a는 x의 원소)라고 할 때 f(x) = x를 만족하는 a값을 빈 값으로 만들어 줘야 한다. 코드를 만들 때 의도적으로 빈 값이 고정값이 되는 코드를 만드는 것이다. 그러나 빈 값을 고정값으로 만들기 위한 코드를 만드는 것은 번거로운 일이다. 모든 코드를 이렇게 만들라는 것이 아닌 고정값을 만드는 관점이 유용하다는 정도로만 파악해 두자.
- すべてのコードにおいて、空の初期値はアルゴリズムの実行において不動点の役割をしません。コード(アルゴリズム)で使用する変数に対して不動点を生成するロジックを作成する必要があります。アルゴリズム・コード「f」と空の値「a」について 「a」は「x」の要素)とした場合、f(x) = x を満たす「a」値を空の値に作る必要があります。コードを作成する際には、意図的に空の値が不動点となるようなコードを作成することが重要です。ただし、空の値を不動点にするためのコードを作成するのは手間がかかります。すべてのコードをこのように作成する必要はなく、不動点を生成する観点が有用であると認識しておくだけで十分です。

### php에서 빈 값의 유용성
### phpで空の値の有用性
- 굳이 고정값을 빈값으로 만들어내는 코드를 만들지 않더라도 여러 문법과 php의 많은 내장함수는 빈 값이 전달되었을 때 빈 값을 고정값으로 활용하는 기능이 많다. 이를 통해서 if문으로 초기값을 체크하는 로직을 아주 많이 줄일 수 있다.
- あえて不動点を空の値にするコードを作らなくても、様々な文法やphpの多くの組み込み関数は空の値が伝達された時に空の値を不動点として活用する機能が多いです。 これにより、if文で初期値をチェックするロジックを大幅に減らすことができます。
- 하지만 어떤 기능을 담당하는 코드가 복잡하거나 길어질수록 빈 값을 고정값으로 활용하는 코드인지 파악하기 어려운 경우가 있다. 이런 경우에는 내부의 구현을 확인하기 보다는 if문을 사용해서 코드를 실행하지 않도록 코딩하는 편이 더 나을 때도 있다.
- しかし、特定の機能を担当するコードが複雑または長くなると、空の値を不動点として活用しているかどうかを把握するのが難しい場合があります。このような場合、内部の実装を確認する代わりに、if文を使用してコードを実行しないようにコーディングする方が良い場合もあります。

### null과 빈값에 대해 다시 생각하기
### nullや空の値について再考する
#### null
- null을 초기값으로 사용하면, 타입힌트의 제약을 받는 코드에 값을 할당하게 될 때 에러를 통해서 값이 할당되었는지 할당되지 않았는지 확인하기 쉽다는 장점이 있다.
- nullを初期値として使用すると、タイプヒントの制約を受けるコードに値を割り当てる際に、エラーを通じて値が割り当てられたかどうかを簡単に確認できる利点があります。
- null을 초기값으로 사용한다면 비할당은 빈값이 아닌 모두 null으로 일관성을 맞춰야 혼란을 줄일 수 있다. null을 초기값으로 사용하는 스타일은 빈 값이 있을 경우 빈 값이 비할당이 아닌 할당으로 봐야 한다. 예를 들어 '지불 금액'이라는 변수가 있다고 하자. null은 지불 금액이 설정되지 않은 것이며, 0은 공짜라서 0원을 내도 된다는 의미를 가진다. 이 때 0은 유효한 값이다. '구매 수량'이라는 변수가 있다고 하자. null은 구매하지 않은 상태이다. 그러나 0도 구매하지 않은 상태이다. 그럼 구매하지 않을 상태로 0을 쓸 것인지 null을 쓸 것인지 모호하게 된다.
- nullを初期値として使用する場合、未割り当ての状態は空の値ではなくすべてnullで統一して、混乱を減らすことが良いです。nullを初期値として使用するスタイルでは、空の値がある場合、空の値が未割り当てではなく割り当てであると見なす必要があります。例えば、「支払金額」という変数があるとします。nullは支払金額が設定されていないことを意味し、0は無料であるため、0円を支払っても構わないという意味になります。この場合、0は有効な値です。「購入数量」という変数があるとします。nullは購入していない状態を意味します。しかし、0も購入していない状態です。したがって、購入しない状態で0を使用するか、nullを使用するかは曖昧になります。
- 구매하지 않은 상태로 변수가 가질 수 있는 값이 두 가지 0과 null이 될 수 있는 경우, `if(!is_null($var) && $var !== 0)`로 할당된 상태인 경우에만 if문 내부의 코드를 실행하는 조건문의 코드가 늘어나게 되며, 긴 조건문을 사용하고 싶지 않다면 `empty`를 사용하게 되는데 `empty`는 변수의 타입을 드러내지 않기 때문에 개인적으로 선호하지 않는 코딩 스타일이다. (php는 강타입 언어가 아니기 때문에 변수에 IDE가 변수의 타입을 추론하지 못하는 경우가 대다수 이므로 코드에 타입의 정보를 기술하는 코딩 스타일이 좋다고 생각한다.)
- 購入していない状態で変数が持つことができる値が0とnullの2つの場合、`if(!is_null($var) && $var !== 0)`という条件式で変数が割り当てられた状態のみ条件式内のコードが実行されるのは条件式が長くなり、ます。長い条件式を避けたい場合は、emptyを使用しますが、emptyは変数の型を示さないため、個人的に好ましくないコーディングスタイルです。(phpは強い型付け言語ではないため、ほとんどの場合、IDEが変数の型を推論できないことがあり、コードに型情報を記述するコーディングスタイルが良いと思います。)
- 따라서 null을 초기값으로 할당하는 경우에는 null이 가지는 의미와 빈 값이 가지는 의미가 중복되는 경우가 생기지 않도록 의미의 중복이 일어나는 경우에는 빈 값을 사용하지 않고 null만 사용하는 코딩스타일을 만드는 것이 좋다. 문제는 이로 인해서 코드의 길이가 늘어나는 것인데 예를 들어 구매 수량은 0이나 null이나 비할당의 의미를 가지므로 비할당을 하나의 값으로만 사용하기 위해 0이 되었을 때 이 값을 null으로 바꿔주게 되면 로직의 분기가 추가된다.
- したがって、nullを初期値として割り当てる場合、nullが持つ意味と空の値が持つ意味が重複しないようにするため、意味の重複が発生する場合には空の値を使用せず、nullのみを使用するコーディングスタイルを採用することが望ましいです。問題は、これによりコードの長さが増加することです。例えば、購入数量は0またはnullは未割り当ての意味なので、未割り当てを一つの値として使用するために、0になった場合にそれをnullに変更すると、ロジックに分岐が追加されます。

#### 빈 값
#### 空の値
- 빈 값을 비할당으로 사용하면, 많은 php의 기능을 사용할 때 if문 없는 코드를 만들어 낼 수 있다. 코드의 분기를 줄일 수 있다는 장점이 있다.
- 空の値を未割り当てとして使用すると、多くのPHP機能を使用する際、if文がないコードを生成することができます。コードの分岐を減らすという利点があります。
- 위에서 null을 비할당으로 사용할 때, 구매수량이 0이 되었을 때 null으로 바꿔주는 것은 아무래도 직관적이지 않아 보인다. 그렇다고 null과 0을 병행하게 되면 if문의 체크 조건이 늘어나거나 empty를 사용하게 되어 변수의 타입을 알기 어렵다는 문제점이 생긴다.
- 上記のように、nullを未割り当てとして使用する場合、購入数量が0になった場合、nullに変更することは直感的ではないようです。しかし、nullと0を併用すると、if文の条件が増える問題があり、またはemptyを使用すると変数の型がわかりにくくなるという問題が生じます。
- 비할당 값으로 빈 값을 사용하게 되면 null을 고려하지 않아도 되므로 빈 값인지 아닌지 확인하는 if 문이 하나만 확인하면 되므로 `if($var !== 0)`와 같이 간결해 진다. 또한 구매수량이 n이었다가 0이 되는 경우와 같은 할당 상태였다가 비할당 상태로 변환하는 부분에도 null으로 변환할 필요 없이 빈 값을 할당하면 되므로 직관적으로 만족스럽다.
- 未割り当ての値として空の値を使用すると、nullを考慮する必要がなくなるため、空の値かどうかを確認するif文を一つだけ確認すれば良いです。`if($var !== 0)`のように簡潔になります。また、購入数量がnであった場合から0になる場合など、割り当ての状態から未割り当ての状態に変換する部分でも、nullに変換する必要はなく、空の値を割り当てるだけで十分なので直感的に満足できます。

### 정적 타입 언어와의 비교
### 静的型言語との比較
- 다양한 타입을 변수에 허용하는 동적 타이핑 언어와 달리 정적 타입의 언어에서는 하나의 변수는 하나의 타입을 사용한다. 빈 값으로 할당과 비할당을 구분하기도 하며, 해당 변수에서 사용 빈도 없거나 적은 특정한 값(sentinel value)을 이용해서 할당과 비할당을 구분한다. php에서는 다른 언어와의 유사성을 위해서라도 비할당 값을 null 보다는 빈 값으로 사용하는 것이 좋다.
- 動的型付け言語が複数の型を変数に許容するのに対し、静的型付け言語では一つの変数に一つの型が使用されます。また、空の値と未割り当てを区別する場合もあり、その変数で使用頻度が低いか、まったく使用されない特定の値(sentinel value)を使用して割り当てと未割り当てを区別します。PHPでは、他の言語との類似性を考慮しても、未割り当ての値をnullではなく空の値として使用することが好ましいです。

### 내장 함수의 null 인자 제한
- '내장 함수의 null 비허용 인자에 null을 전달하는 것을 권장하지 않음' [Deprecate passing null to non-nullable arguments of internal functions](https://wiki.php.net/rfc/deprecate_null_to_scalar_internal_arg)라는 RFC를 보면 내장함수의 인자에 null 타입을 명시적으로 전달하는 사양이 아니라면 null 값을 인자로 사용할 수 없게 바뀐다고 한다.
- 「組み込み関数のnullを許容しない引数にnullを渡すことは推奨されません」[Deprecate passing null to non-nullable arguments of internal functions](https://wiki.php.net/rfc/deprecate_null_to_scalar_internal_arg)というRFCを見ると、組み込み関数の引数にnullタイプを明示的に渡す仕様でなければ、null値を引数として使用できなくなると述べられています。
- 지금까지는 null이 허용되지 않는 매개변수에 null이 전달된 경우 빈 값으로 암묵적인 형변환이 되어 사용되었다. php8에서 php 내장함수에 null을 전달하면 에러 또는 경고(Warning)를 발생시키고, php9에서는 에러가 발생한다. 이후 부터는 내장 함수에 비할당 된 값을 전달하기 전에 null인지 확인하는 코드를 사용해야 한다.
- これまで、nullが許容されないパラメーターにnullが渡された場合、空の値に暗黙的な型変換が行われて使用されていました。php8では、phpの組み込み関数にnullを渡すとエラーまたは警告が発生し、php9ではエラーが発生します。その後は、組み込み関数に未割り当ての値を渡す前に、nullかどうかを確認するコードを使用する必要があります。
- 하지만, 초기값을 빈 값으로 하는 경우에는 if문으로 null인지 확인할 필요가 없고, 앞서 설명한 많은 내장함수 기능에 대해 빈 값은 고정값으로 동작하기 때문에 비할당인 경우 실행하지 않는 별도의 if문을 사용할 필요도 없다. 앞으로의 php의 변화에 맞추어 초기값을 null으로 사용하는 것 보다는 기본적으로 빈 값을 초기값으로 사용하되, 빈 값이 유요한 할당값이 되는 경우 null을 초기값으로 사용하는 방식을 사용하면 많은 이점을 누릴 수 있다.
- しかし、初期値を空の値にする場合、nullかどうかをif文で確認する必要がなく、先述の多くの組み込み関数の機能に対して空の値が不動点として動作するため、未割り当ての場合には実行しない別個のif文を使用する必要もありません。今後のPHPの変化に合わせて、初期値としてnullを使用するよりも、基本的に空の値を初期値として使用し、空の値が有効な割り当て値となる場合にのみnullを初期値として使用する方法を採用すると、多くの利点を享受できます。

### 결론
### 結論
- null을 비할당으로 사용하는 경우 타입힌트를 통해서 null이 허용되지 않는 코드에 null이 전달되었을 때 타입 불일치 에러가 발생하여 할당의 여부를 손쉽게 확인할 수 있다는 장점이 있지만, 여러 모호한 상황과 분기 처리등의 복잡성이 생겨나기 때문에 무조건 null을 비할당으로 사용하는 것 보다는 빈 값을 비할당으로 사용하고 빈 값이 유효한 변수인 경우 null을 비할당으로 사용하도록 하자.
- nullを未割り当てとして使用する場合、タイプヒントを介してnullが許容されていないコードにnullが渡された場合、型不一致エラーが発生し、割り当ての有無を簡単に確認できる利点があります。しかし、いくつかの曖昧な状況や分岐処理などの複雑さが発生するため、必ずしもnullを未割り当てとして使用するよりも、空の値を未割り当てとして使用し、空の値が有効な変数の場合にのみnullを未割り当てとして使用する方が良いでしょう。
