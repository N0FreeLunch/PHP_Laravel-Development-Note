## 0으로 배우는 프로그래밍 원리 (부제: 초기값으로 null인가 빈 값인가?)
## ゼロからまなぶプログラミング原理 (副題: 初期値はnullか空の値か？)

## 도입
## はじめに

### 변수의 초기값으로 빈 값을 사용할 것인가? null을 사용할 것인가?
### 変数の初期値として空の値を使用するか、ヌルを使用するか？
- 변수의 초기값을 설정하는데 null이 좋을지 빈 값이 좋을지에 대해 생각을 해 보자.
- 変数の初期値を与える時、nullが良いのか空の値が良いのかについて考えてみましょう。

### 변수의 초기값에 null을 사용하자는 주장
### 変数の初期値にnullを使用すべきだという主張
- 변수의 초기값에 빈 값을 사용하는 경우 비할당된 값의 타입이 할당된 타입과 일치한다. 예를 들어 `$var = 0`을 초기값으로 할당된 값은 `$var = 10`으로 값을 할당할 수 있다.. null이 초기값인 것과 달리 타입이 동일하다. null을 초기값으로 사용하는 경우 할당된 값은 타입이 다르다. 예를 들어 매개변수의 타입힌트로 int를 지정했을 때 null을 전달 받으면 타입 불일치로 인해서 에러를 발생시킨다. null을 초기값으로 사용할 경우 타입 불일치로 에러가 발생하므로, 함수나 메소드의 메개변수로 변수에 값이 할당되지 않은 값을 전달할 때 에러를 통해서 값이 할당되었는지 할당되지 않았는지 확인하기 쉽다는 장점이 있다.
- 変数の初期値として空の値を使用する場合、未割り当ての値の型が割り当てられた型と一致します。たとえば、`$var = 0`を初期値として割り当てたから`$var = 10`と値を割り当てるのができます。nullが初期値の場合とは異なり、空の値は型が同じです。一方、nullを初期値として使用する場合、割り当てられた値は異なる型です。たとえば、引数のタイプヒントでintを指定した場合、nullを渡すと型不一致のためエラーが発生します。nullを初期値として使用すると、型不一致によりエラーが発生するため、関数やメソッドのパラメーターとして、変数に値が割り当てられていない値を渡すときに、値が割り当てられたかどうかをエラーで確認しやすいという利点があります。


### null 사용보다 빈 값을 사용하는 것이 좋은 이유
### nullを使用するよりも空の値を使用する理由
- `변수 === null` 또는 `is_null(변수)`을 사용하는 것이나, `변수 === 0` `변수 === ''` `변수 === []`이나 어차피 할당과 비할당을 구분하기 위한 분기는 똑같이 처리해야 하기 때문에 빈 값을 할당하는 것이 로직의 분기 복잡성을 줄여주지 않는다고 생각할 수 있다.
- `変数 === null`または`is_null(変数)`を使用することと、`変数 === 0` `変数 === ''` `変数 === []`を使用することはどうせ割り当てと未割り当てを区分するための分岐は同じ処理をすると思われます。空の値を割り当てることはロジックの分岐の複雑さを減らしてくれないと考えることができる。
- 하지만 빈 값인 경우 처리의 전후 상태의 변화가 없는 스타일의 코딩을 통해서 로직의 분기를 줄일 수 있다. 이를 이해하기 위해 먼저 숫자 0에 대한 예를 생각해 보자.
- ただし、空の値の場合、処理の前後の状態の変化がないスタイルのコーディングを通じてロジックの分岐を減らすことができます。これを理解するために、まず数0の例を考えてみましょう。

### 숫자 0
### 数字 0
#### 0에 대한 수 n의 연산
#### 0に対する数nの演算
- 0에 어떤 값(n)을 더했을 때, 결과는 n이 된다.
- 0にどんな値(n)を加えた場合、結果はnになる。
- 0에 어떤 값(n)을 뺐을 때, 결과는 n이 된다.
- 0にどんな値(n)を引いた場合、結果はnになる。
- 0에 어떤 값(n)을 곱했을 때, 결과는 0이 된다.
- 0にどんな値(n)を掛けた場合、結果は0になる。
- 0애 어떤 값(n)을 나누었을 때, 결과는 0이 된다.
- 0をどんな値(n)で割った場合、結果は0になる。
- 0에 대한 곱셈과 나눗셈을 생각해 보자. **0에 어떤 값을 연산 했을 때, 그 결과는 0과 어떤 값(n)과 연산은 존재하지 않았던 것과 다름없다.**
- 0に対する乗算と除算を考えてみましょう。**0にどんな値を演算した場合、その結果は0と、どんな値(n)との演算は存在しなかったも同然です。**

#### n에 대한 수 0의 연산
- 어떤 값(n)애 0을 더했을 때 결과는 n이 된다.
- どんな値(n)に0を加えた場合、結果はnになる。
- 어떤 값(n)애 0을 뺐을 때 결과는 n이 된다.
- どんな値(n)から0を引いた場合、結果はnになる。
- 어떤 값(n)에 0을 곱했을 때 결과는 0이 된다.
- どんな値(n)を0で掛けた場合、結果は0になる。
- 어던 값(n)에 0을 나누었을 때 결과는 무한대가 된다.
- どんな値(n)を0で割った場合、結果は無限大になる。
- 어떤 값(n)에 대한 덧셈과 뺄셈을 생각해 보자. **n에 0을 연산 했을 때, 그 결과는 n과 0의 연산은 존재하지 않았던 것과 다름없다.**
- どんな値(n)に対する加算と減算を考えてみましょう。**nに0を演算した場合、その結果はnと0の演算は存在しなかったも同然です。**

### 함수로 표현하기
- 이런 0의 특성을 수학에서의 함수로 표현 해 보자. `f(0, n) = 0` 또는 `g(0, n) = n`가 된다. 두 대상의 연산의 결과가 하나의 대상으로 되는 값이라는 것을 알 수 있다.

### 처리 전후의 상태가 동일함
### 処理の前後の状態が同じ
- 일반적으로 프로그래밍 언어에서 상태라는 것은 변수가 갖고 있다. 어떤 처리를 하기 전의 여러 변수에 들어 있는 값과, 어떤 처리를 한 후의 변수들이 동일한 값을 가지고 있다면, 이는 동일한 상태를 가진 것과 같다.
- 一般的に、プログラミング言語での状態とは、変数が持っている値を指します。ある処理をする前の変数に入っている値と、ある処理をした後の変数が同じ値を持っている場合、それは同じ状態を持つことと同じです。
- 숫자 0은 여러 연산에 대해서 처리 전후의 값이 동일한 특성을 가진다. 어떤 값 x에 대해서 연산 f의 처리가 x가 되는 것. `f(x)=x`라는 방정식을 만족하는 해를 수학에서는 고정값(fixed point)이라고 부른다. 고정값의 성질을 프로그래밍에서 생각해 보자.
- 数字の0は、色んなの演算に対して処理前後の値が同じ特性を持ちます。ある値xに対して演算fの処理がxになるもの、つまり`f(x)=x`という方程式を満たす解を数学では不動点(fixed point)と呼びます。不動点の性質をプログラミングで考えてみましょう。
- 앞서 0은 수학적으로 여러 연산에 대해 `f(0, n) = 0` 또는 `g(0, n) = n`으로 표현 된다고 하였다. 이 때 `f(0, n) = 0`은 `f'(n) = 0` 또는 `f"(0) = 0`으로 표현 할 수 있을 것이다. `g(0, n) = n`도 `g'(n) = n` 또는 `g"(0) = n`으로 표현 될 것이다. 곧, `f(0, n) = 0`의 관계를 가지고 있다면 `f'(n) = 0`은 `f"(0) = 0`으로 표현될 것이고, `g(0, n) = n`의 관계를 가지고 있다면 `g'(n) = n`은 `g"(0) = n`으로 표현될 것이다. 이는 결국 `f(x)=x`의 꼴로 고정값의 형태로 표현된다.


### 빈 값
### 空の値
- 빈 값도 0의 예시 처럼 아무런 영향을 주지 않는 값으로 사용하는 코드를 만들 수 있다. 빈 값에 대한 로직의 처리 전후의 상태의 다름이 없다면, 알고리즘은 실제로 실행되었지만 마치 실행되지 않은 것과 동일한 상태를 갖는다.
- 空の値も、0の場合のように何の影響も与えない値として使用するコードを作成することができます。空の値に対するロジックの処理前後の状態の違いがない場合、アルゴリズムは実際に実行されているにもかかわらず、まるで実行されていないかのような状態を持ちます。
- 값 또는 변수 x,y에 대해 알고리즘 f가 있다고 하자. `f(x,y) = x`의 관계에서 x를 변수로 y를 값으로 두자. 그럼 `f'(x) = x`을 만족하는 `f'`라는 함수를 만들 수 있을 것이다. 알고리즘 `f'`는 알고리즘의 실행 전후의 결과가 동일하기 때문에 로직상 실행되지 않는 것과 동일하다. 물론 프로그램이 실행되면서 리소스를 소비하지만 실행 전후의 상태는 동일하다.
- 値または変数x、yについてのアルゴリズムfがあると仮定しましょう。`f(x, y) = x`の関係で、xを変数とし、yを値としてみましょう。すると、`f'(x) = x`を満たす関数`f'`を作成できます。アルゴリズム`f'`は、実行前後の結果が同じであるため、ロジック的には実行されないのと同じです。もちろんプログラムは実行されますが、実行前後の状態は同じです。
- 변수의 초기값이 null일때, `if(is_null(x)) { f'(x) }`의 코드가 실행되면 x가 null이므로 if문을 통과하지 못한다. 따라서 `f'(x)`는 실행되지 않지만, if문의 코드는 진행된다. 초기값을 null으로 했을 때, 변수가 할당되었는지를 확인하는 것과, 초기값으로 알고리즘에 고정값을 사용했을 때 if문 없이 `f'(x)`를 실행했을 때 그 결과가 x가 되는 것의 코드 실행 전후의 상태는 if문이 실행되지 않든, `f'(x)`가 실행되든 동일하다.
- 変数の初期値がnullの場合、`if(is_null(x)) { f'(x) }`のコードが実行されると、xがnullであるため、if文を通過できません。したがって、`f'(x)`は実行されませんが、if文のコードは進行します。初期値をnullに設定した場合、変数が割り当てられたかどうかを確認することと、初期値としてアルゴリズムに固定値を使用した場合、if文なしで`f'(x)`を実行した場合の結果がxになることのコードの実行前後の状態は、if文が実行されなくても`f'(x)`が実行されても同じです。
- 프로그래밍에서 빈 값은 많은 경우 수학에서의 고정값의 역할을 하며, 빈값을 사용할 때 처리 전후의 상태가 동일하다는 특성을 이용해서 if문의 사용을 줄이는 코딩을 할 수 있다.
- プログラミングにおいて、空の値は多くの場合、数学での固定値の役割を果たし、空の値を使用するとき、処理前後の状態が同じであるという特性を利用して、if文の使用を減らすコーディングができます。

### 빈 값을 사용한 분기 줄이기의 예시

#### 문자열 결합 연산자 닷(.)
- dot(.)은 문자열을 결합하는 연산이다. 임의의 문자열에 대해서 빈 문자열을 dot(.)으로 결합하면 그 결과는 이전의 문자열과 동일하다. 빈 문자열의 `.` 연산을 통한 연결은 처리 전후의 결과가 동일한 결과를 얻는다.
```php
$var = "";
echo "hello".$var;
```
- `"hello".$var`을 하나의 함수로 바라보자. 그럼 `f("hello", $var) = "hello"`의 꼴으로 알고리즘 f의 고정값으로 `$var`가 빈 문자열이 되어야 한다.

```php
$var = null;
if(is_null($var)) {
    echo "hello";
} else {
    echo "hello".$var;
}
```
- 변수의 초기값으로 null을 주든, 빈 문자열을 주든 출력되는 결과는 `"hello"`으로 동일하다. 하지만 빈 문자열을 사용하는 것을 통해서 if문의 사용을 줄일 수 있다는 것을 알 수 있다.

#### 문자열 대체 함수
```php
$search = "";
$subject = "subject";
echo str_replace($search, "*", $subject);
```
- `str_replace`에서 `$search` 변수에 해당하는 문자열 값을 찾아서 `*`으로 바꾸는 코드를 실행한다고 하자.
- `$search`가 빈 문자열인 경우 대체할 대상을 아무것도 찾지 않으므로 대체할 대상이 없어서 위의 결과는 `"subject"`가 그대로 나온다.
- 위의 코드의 `echo str_replace($search, "*", $subject)` 부분은 `"*"`와 `$subject`가 고정값이기 때문에 `$search`에 대해서만 생각해 보자. `f("subject", $search) = "subject"`의 꼴으로 표현할 수 있다. 이 방정식의 고정값은 `$search`가 빈 문자열인 경우이다.
```php
$search = null;
$subject = "subject";
if(is_null($search)) {
    echo $subject;
} else {
    echo str_replace($search, "*", $subject);
}
```
- 만약 `$search`에 빈 값이 아닌 `null`을 할당했다면, 위와 같이 분기 처리가 늘어날 것이다.

#### 스프레드 연산자
```php
$oneToFive = [1, 2, 3, 4, 5];
var_dump([10, 11, 12, ...$oneToFive]);
```
- `[10, 11, 12, ...$oneToFive]`은 `[10, 11, 12]` 배열 안에 스프레드 연산자 형태의 배열을 포함될 때 `$oneToFive` 배열 안의 원소들이 `[10, 11, 12]`의 배열에 포함되어 `[10, 11, 12, 1, 2, 3, 4, 5]`라는 결과값을 갖는다.
```php
$arr = [];
var_dump([10, 11, 12, ...$arr]);
```
- 빈 배열을 스프레드 연산자로 포함하면, `[10, 11, 12]`으로 아무 원소도 추가되지 않은 결과가 나온다.
- 위의 코드는 다음과 같은 의사코드로 바꿀 수 있다. `f([10, 11, 12], $arr) = [10, 11, 12]` 이 방정식을 만족하는 고정값은 `$arr`가 빈 배열이 될 경우가 된다.
```php
$arr = null;
if(is_null($arr)) {
    var_dump([10, 11, 12]);
} else {
    var_dump([10, 11, 12, ...$arr]);
}
```
- 만약 `$arr`에 빈 값이 아닌 `null`을 할당했다면, 위와 같이 분기 처리가 늘어날 것이다. 변수의 초기값으로 빈 배열을 사용하는 것을 통해서 if문의 사용을 줄일 수 있다.

#### 배열 함수 (array_walk)
```
array_walk(array|object &$array, callable $callback, mixed $arg = null): bool
```
- 배열 그 자체를 변경하고자 하는 경우 `&$array`으로 `&` 참조 기호를 사용하며, 배열 안에 든 값만 이용하고 싶다면 `$array`으로 참조 기호 없이 사용한다.
```php
$arr = [];
array_walk($arr, function (mixed $e) {
    $e = gettype($e);
});
```
- 이 함수는 반환값을 갖는 함수가 아니다. 원본 값 그 자체를 변화 시키거나 원본 값을 활용한 다른 값을 만드는 것인데, 주어진 배열이 빈 배열 `[]`인 경우 주어진 콜백함수를 실행하지 않는다. 곧 결과값이 원본 그대로이다. 따라서 빈 배열은 `[]`은 `array_walk` 내장 함수의 실행에 대해 실행 전후의 상태가 동일하다.
```php
$arr = null;
if(!is_null($arr)) {
    array_walk($arr, function mixed ($e) {
        $e = gettype($e);
    });
}
```
- 만약 빈 배열이 아닌 null을 초기값으로 사용했다면 if문을 추가해야 했다.

#### 배열 함수 (array_map)
```
array_map(?callable $callback, array $array, array ...$arrays): array
```
- 배열을 받아 콜백함수에 정의된 방식을 통해서 배열의 각 원소를 변경하고 새로운 배열을 만드는 함수이다.
```php
$arr = [];
array_map(function (mixed $e) {
    return gettype($e);
}, $arr);
```
- 빈 배열이 주어질 경우 `array_map`은 각각의 원소에 대해 콜백함수를 적용해야 하는데 원소가 없으므로 콜백함수를 적용하지 않고 원소가 없는 빈 배열을 반환한다. `array_map`은 빈 배열에 대해 실행 전후의 상태가 동일하다.
```php
$arr = null;
if(!is_null($arr)) {
    array_map(function (mixed $e) {
        return gettype($e);
    });
}, $arr);
```

### 고정값이 존재하는 알고리즘
- 모든 코드에 대해서 변수의 초기값이 빈 값의 실행 전후의 변수의 상태가 변화하는 것은 아니다. 사용자가 고정값을 만드는 로직을 만들어 줘야 한다. 알고리즘/코드 f와 빈값 a에 대해 (a는 x의 원소)라고 할 때 f(x) = x를 만족하는 a값을 빈 값으로 만들어 줘야 한다. 코드를 만들 때 빈 값을 고정값으로 사용할 수 있는 코드를 만드는 것이다. 그러나 빈 값을 고정값으로 만들기 위한 코드를 만드는 것은 번거로운 일이다. 모든 코드를 이렇게 만들라는 것은 이런 관점을 갖는 것이 유용하다는 정도로만 파악해 두자.

### php에서 빈 값의 유용성
- 굳이 고정값을 빈값으로 만들어내는 코드를 만들지 않더라도 여러 문법과 php의 많은 내장함수는 빈 값이 전달되었을 때 실행 전후의 상태를 동일하게 만들어 주는 경우가 많다. 이를 통해서 if문으로 초기값을 체크하는 로직을 아주 많이 줄일 수 있다.

### null과 빈값에 대해 다시 생각하기
#### null
- null을 초기값으로 사용하면, 타입힌트의 제약을 받는 코드에 값을 할당하게 될 때 에러를 통해서 값이 할당되었는지 되지 않았는지 확인하기 쉽다는 장점이 있다.
- null을 초기값으로 사용한다면 비할당은 빈값이 아닌 모두 null으로 일관성을 맞춰야 혼란을 줄일 수 있다. null을 초기값으로 사용하는 스타일은 빈 값이 있을 경우 빈 값이 비할당이 아닌 할당으로 봐야 한다. 예를 들어 '지불 금액'이라는 변수가 있다고 하자. null은 지불 금액이 설정되지 않은 것이며, 0은 공짜라서 0원을 내도 된다는 의미를 가진다. 이 때 0은 유효한 값이다. '구매 수량'이라는 변수가 있다고 하자. null은 구매하지 않은 상태이다. 그러나 0도 구매하지 않은 상태이다. 그럼 구매하지 않을 상태로 0을 쓸 것인지 null을 쓸 것인지 모호하게 된다.
- 구매하지 않은 상태로 변수가 가질 수 있는 값이 두 가지 0과 null의 값을 가지면 `if(!is_null($var) && $var !== 0)`로 할당된 상태인 경우에만 실행하고자 하는 if문의 코드가 늘어나게 되며, 그렇지 않으면 `empty`를 사용하게 되는데 `empty`는 변수의 타입을 드러내지 않기 때문에 개인적으로 선호하지 않는 코딩 스타일이다.
- 따라서 null을 초기값으로 할당하는 경우에는 null이 가지는 의미와 빈 값이 가지는 의미가 중복되는 경우가 생기지 않도록 의미의 중복이 일어나는 경우에는 빈 값을 사용하지 않는 코딩스타일을 만드는 것이 좋다. 하지만 구매 수량이 0이 되었을 때 이 값을 null으로 바꿔줘야 한다는 것은 로직의 분기를 추가한다.

#### 빈 값
- 빈 값을 비할당으로 사용하면, 많은 php의 기능을 사용할 때 if문 없는 코드를 만들어 낼 수 있다. 코드의 분기를 줄일 수 있다는 장점이 있다.
- 위에서 null을 비할당으로 사용할 때, 구매수량이 0이 되었을 때 null으로 바꿔주는 것은 아무래도 직관적이지 않아 보인다. 그렇다고 null과 0을 병행하게 되면 if문의 체크 조건이 늘어나거나 empty를 사용하게 되어 변수의 타입을 알기 어렵다는 문제점이 생긴다.
- 비할당 값으로 빈 값을 사용하게 되면 null을 고려하지 않아도 되므로 빈 값인지 아닌지 확인하는 if 문이 하나만 확인하면 되므로 `if($var !== 0)`와 같이 간단해 진다. 또한 구매수량이 n이었다가 0이 되는 경우와 같은 할당 상태였다가 비할당 상태로 변환하는 부분에도 null으로 변환할 필요 없이 빈 값을 할당하면 되므로 직관적으로 만족스럽다.

### 정적 타입 언어와의 비교
- 다양한 타입을 변수에 허용하는 동적 타이핑 언어와 달리 정적 타입의 언어에서는 하나의 변수는 하나의 타입을 가진다. 빈 값으로 할당과 비할당을 구분하거나 해당 변수에서 사용 빈도 없거나 적은 특정한 값을 이용해서 할당과 비할당을 구분한다. 다른 언어와의 유사성을 위해서라도 비할당 값을 null 보다는 빈 값으로 사용하는 것이 좋다.

### 빈 값이 null인 경우
- 지불 금액과 같이 0이 지불할 금액 없이 공짜라는 의미를 갖는 경우 0은 유효한 의미를 가지고 있으며 할당되지 않은 경우와는 구분된다. 이런 경우에는 비할당을 나타내는 값을 null으로 한다.

### 내장 함수의 null 인자 제한
- [Deprecate passing null to non-nullable arguments of internal functions](https://wiki.php.net/rfc/deprecate_null_to_scalar_internal_arg)라는 RFC를 보면 php9에서는 내장함수에서 null 타입을 명시적으로 전달하는 사양이 아니라면 null 값을 전달할 수 없게 바뀐다고 한다.
- 지금까지는 null이 허용되지 않는 매개변수에 null이 전달된 경우 빈 값으로 내부적으로 형변환되어 사용되었다고 한다. php8에서 php 내장함수에 null을 전달하면 에러 또는 경고(Warning)를 발생시키고, php9에서는 에러가 발생한다. 이후 부터는 내장 함수에 비할당 된 값을 전달하기 전에 null인지 확인하는 코드를 사용해야 한다.
- 하지만, 초기값을 빈 값으로 하는 경우에는 if문으로 null인지 확인할 필요가 없고, 앞서 설명한 많은 내장함수 기능에 대해 빈 값은 고정값으로 동작하기 때문에 비할당인 경우 실행하지 않는 별도의 if문을 사용할 필요도 없다. 앞으로의 php의 변화에 맞추어 초기값을 null으로 사용하는 것 보다는 기본적으로 빈 값을 초기값으로 사용하되, 빈 값이 유요한 할당값이 되는 경우 null을 초기값으로 사용하는 방식을 사용하면 많은 이점을 누릴 수 있다.

### 결론
- null을 비할당으로 사용하는 경우 타입힌트를 통해서 null이 허용되지 않는 코드에 null이 전달되었을 때 타입 불일치 에러가 발생하여 할당의 여부를 손쉽게 확인할 수 있다는 장점이 있지만, 여러 모호한 상황과 분기 처리등의 복잡성이 생겨나기 때문에 무조건 Null을 비할당으로 사용하는 것 보다는 빈 값을 비할당으로 사용하고 빈 값이 유효한 변수인 경우 null을 비할당으로 사용하도록 하자.
