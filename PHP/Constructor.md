## 생성자

### 생성자는 메소드이다. 메소드는 함수이다.
- 인자의 전달이 누락되어 있다면 디폴트 값으로 전달한다.

### 함수/메소드의 특징
#### 장점
- 옵셔널 파라메터를 설정하기 좋다.

#### 단점
- 함수에 인자를 전달할 때는 파라메터의 순서대로 인자를 전달해야 한다. n번째의 인자를 설정하기 위해서 n-1 번째까지의 인자를 모두 설정해야 한다. php8 부터는 named parameter라는 개념이 도입되어 파라메터 이름을 지정하여 원하는 인자를 함수에 전달할 수 있다. 함수의 파라메터의 이름을 달아서 전달한다는 것은 함수 인자의 이름에 의존하는 코드를 만들어 낸다.

### 클래스
- 클래스는 퍼블릭 멤버가 존재한다. 퍼블릭 멤버는 클래스를 다루기 위한 인터페이스를 제공한다.
- 클래스의 생성자는 객체를 받기 위해서 반드시 전달 받아야 하는 옵션이고, 세터는 옵션에 해당한다.

### 생성자
- 만약에 클래스가 의존하는 필수적인 외부 값이 많아지면, 생성자에 전달하는 인자의 크기가 커지고 객체를 하나 생성하는데도 많은 의존하는 값을 전달해 주어야 한다. 이를 해결하기 위한 방법으로 생성자의 주입을 프레임워크에 맞기는 제어의 역전 IOC(Inversion of Control)을 사용하게 된다. IOC를 사용하게 되면 생성자 할당에 대한 권한을 프레임워크에게 빼앗기게 되고 프레임워크가 정할 수 없는 의존값을 생성자를 통해서 객체에 전달할 수 없는 문제가 있다. 프레임워크가 정할 수 없는 의존값이란 세션이나 리퀘스트의 정보로 어떤 처리를 해야 할지 판단할 수 없는 경우로, 프로그래머가 아니라면 판단할 수 없는 의존값을 객체에 주입하기 위해서 세터를 통해서 필수 옵션을 전달해 주어야 한다. 이런 경우가 있기 때문에 생성자만이 항상 필수 의존값을 주입하는 수단이 되기는 어렵다.
- 생성자를 통해서 의존성을 주입하는 것을 이전에는 좋아하지 않았는데, 생성자라는 메소드의 인자로 의존값들을 전달해야 했기 때문이다. 함수의 인자는 어떤 인자를 어떤 순서로 입력해야 하는지 알아야 했기 때문에 객체에 생성자가 어떤 값을 할당 받는지 매번 확인을 해야하기 때문이다. php8 이후에는 명명된 매개변수(named parameter)를 사용하여 생성자의 인자를 할당하는 것이 가능해서 좀 더 편리해졌다. 하지만 생성자로 주입해야 하는 대상이 많아지게 되면 누락되는 대상을 찾기 어려워지므로 파라메터의 순서대로 생성자의 인자를 전달하는 편이 좋다. 생성자를 주입할 때는 특정한 규칙에 따라서 주입하는 것이 좋은데 기본적으로는 알파벳 사전 순대로 나열하자.
- 생성자에는 옵션에 해당하는 값을 인자로 받지 않도록 한다. 생성자는 객체 생성에 필수적인 값을 받아 가능한 생성자가 받는 인자의 수를 줄여 주입되는 인자 수를 최소화해야 한다. 옵션에 해당하는 의존값은 생성자의 인자로 전달받지 않고 생성자에서 디폴트로 멤버에 할당을 하고, 옵션의 조정이 필요하다면 세터를 통해서 값을 받도록 한다.

#### 생성자 인터페이스
- 일반적으로 문법적인 인터페이스는 객체가 가진 행위에 대한 것만 정의하기 때문에 인터페이스로 생성자를 정의하지는 않는다. 객체의 사용방법을 정하는 것이 인터페이스인데 인터페이스의 정의 대상이 아니라는 것은 외부의 사용법이 아닌 내부의 구현을 확인해야 하는 것이다. 생성자는 내부 구현을 확인해야 하는 대상이므로 생성자에 필수 의존값들을 전달해야 하는 방식을 좋게 생각하지는 않는다.
> Although they are supported, including constructors in interfaces is strongly discouraged. Doing so significantly reduces the flexibility of the object implementing the interface. Additionally, constructors are not enforced by inheritance rules, which can cause inconsistent and unexpected behavior. <sup>[링크](https://www.php.net/manual/en/language.oop5.interfaces.php)</sup>
- 정적 언어에서는 인터페이스에 생성자를 포함할 수 없으며, 생성자를 포함하는 기능을 만들 때는 추상 클래스를 만들라고 제안을 한다. 그에 반해 php는 인터페이스에서 생성자를 제한할 수 있는데, 인터페이스로 생성자를 제한한 경우 생성자의 형태가 고정되어 있기 때문에 상속할 때 생성자의 변경이나 확장을 할 수 없어서 필수값이 더 추가될 필요성이 있는 경우 생성자를 통해서 필수적인 의존 값을 추가로 받지 못하게 된다는 문제점이 발생한다.
- 이런 제약 사항을 잘 이해하고 있다면, 인터페이스를 구현(implement) 할 때 인터페이스가 생성자를 제한하고 있다면 생성자의 확장이 불가능하다는 것을 인지하고 코드를 작성해야 한다.

### Builder pattern
- 객체의 상태를 setter로 주입하게 되면, 객체의 특정 상태가 설정되지 않아 버그 또는 에러가 발생할 수 있다. builder 패턴이란 이름이 붙은 이유는 미리 객체의 상태를 만들어(building) 객체를 사용할 때 메소드를 자유롭게 사용하기 위함이다. Builder 객체를 통해서 미리 객체의 상태를 만들고, Builder 객체를 다른 객체를 생성할 때 생성자로 주입하여, 객체의 어떤 메소드를 사용하더라도 이미 상태가 주입되어 있어 빠진 상태로 인한 메소드 사용의 에러가 발생하지 않도록 한다.
- 도메인 로직을 담당하는 클래스에 setter을 직접 정의하는 대신, 빌더 객체를 만들어 객체의 생성과 동시에 미리 상태가 만들어진 빌더를 생성자에 주입하여 도메인 객체를 setter 주입 없이 사용하도록 한다. 도메인 계층의 클래스를 보면, setter나 getter 없이 간략한 서술만을 메소드명으로 만드는 경우가 많은데, 이는 빌더 패턴을 이용해서 미리 상태를 주입하여 정해진 상태 기반에서 어떤 다른 동작(메소드의 실행)을 하더라도 객체에 누락된 상태가 없으므로 상태의 누락으로 인한 에러가 발생하지 않도록 하게 하기 위함이다.

### 꼭 생성자로 필수 값을 세팅해야 할까?
- 객체를 만들 때 빌더 패턴을 이용하는 것을 당연시 생각하는 사람들이 있다. 객체를 생성할 때는 빌더를 이용해서 상태를 미리 준비한 후에 누락된 상태가 없는 상태에서 객체를 사용해야만 올바른 방식이라고 주장하는 것이다. 게임의 경우를 예로 들면, 유저의 이벤트에 따라 객체의 메소드를 사용해서 다양한 상태가 변경이 될 것이다. 이때, 유저에 의해 호출되는 메소드의 실행에서 뭔가 문제가 발생하면 안 된다. 이런 때는 미리 객체의 상태를 생성해서 누락되는 데이터가 없도록 세팅하는 것은 중요하다. 하지만 웹 프로그래밍의 경우, 도메인 객체는 컨트롤러에 의해 호출된다. 이 때 컨트롤러에 의해서 객체의 메소드는 컨트롤러의 로직에 따라 특정한 순서에 의해 메소드를 실행할 수 있기 때문에 순서를 잘 지킨다면 객체의 상태 누락 없이 실행하는 컨트롤을 할 수 있다. 따라서 객체의 메소드 실행 순서를 지킬 수 있도록 객체의 메소드명을 만드는 것으로 빌더 패턴을 사용하지 않아 발생하는 런타임의 에러 문제를 회피할 수 있다.
- 프레임워크에서는 생성자 주입을 통해서 객체의 생성자를 직접 할당하는 권한을 빼앗기는 상황이 발생한다. 클라이언트로 부터 전송되는 데이터에 의해서 객체의 상태를 미리 모두 구비할 수 있다면 문제가 없겠지만, 도메인 로직은 다양한 컨트롤러에서 재활용되므로 활용되는 곳곳마다 약간 다른 상태의 세팅이 필요하게 된다. 이런 값은 IOC에 의해서 주입될 수 없는 값인데 만약 IOC를 통해서 주입하려고 한다면, 객체가 사용되는 곳곳마다 주입되는 생성자 값을 다르게 서비스 컨테이너를 통해서 주입을 해 줘야 한다. 아무리 객체의 상태를 미리 생성자를 통해 구비한다는 것이 올바른 사용법이라지만, 세터를 통해서 객체에 직접 상태를 주입하는 것 대신에 조금씩 다른 상태를 주입하기 위해 IOC에서 다양한 쓰임에 맞게 생성자 할당이 되도록 모든 케이스를 생성하는 것은 사용하려는 객체 뿐만 아닌 IOC의 할당 방식도 고려해야 하므로 좋은 방식이 아니라는 생각이 든다. 표준적인 객체지향 사용 방식에서는 조금 벗어나더라도 IOC에 의한 생성자 주입으로 모든 상태를 세팅하려고 하기 보다는, 객체의 세터를 통해서 필요한 값을 세팅하고, 세터를 통해 받아야 하지만 받지 못한 값이 있다면 에러를 발생시키는 방식을 사용하는 편이 나은 스타일이라는 생각이 든다.
