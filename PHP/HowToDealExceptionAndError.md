# 예외 및 에러처리

## 예외 또는 에러가 발생한 상황

코드를 짤 때 다양한 문제를 직면한다. 문법이 잘못되어서 실행 중에 에러가 발생할 수도 있고, 라이브러리를 사용했는데, 라이브러리에서 에러를 발생 시킬 수도 있다.

데이터 베이스의 테이블의 컬럼을 유니크로 만들었다고 하자. 유니크 컬럼에 동일한 컬럼값을 가진 레코드가 insert 되면, DB의 듀플리케이션 예외가 발생한다.

### 초보자들이 흔히 하는 실수

모든 구문을 try ... catch 문으로 감싸 에러가 발생하면, 이를 잡아서 에러 페이지를 방법을 사용한다.

또는 예외를 잡지 않고 일부러 발생 시켜서 프로세스를 강제로 끝나게 작성한다.

### 예외나 에러를 잡아 로그로 남기기

에러가 발생했으니 로그를 남긴다? 물론 좋은 방법이다. 에러 로그를 기록해 주는 무언가가 없다면, 에러를 캐치해서 수동으로 에러를 남기는 방편도 사용할 수 있다. 하지만, 예외나 에러를 포착해서 이를 자동으로 로그에 남길 수 있도록 설정을 해 주는 편이 좋다.

### 올바른 처리 방법

데이터베이스에 동일한 값이 전달되지 않도록 코드를 짜 줘야 할 필요가 있다. 왜, 컬럼값이 중복되는 데이터가 생성되려 했는지 원인을 찾아 해당 문제가 일어나지 않도록 해야 한다.

데이터베이스에 값을 넣을 때 해당 데이터가 중복 되는지 확인을 한 후 데이터를 전달할 필요가 있다.

만약 렌덤으로 생성되는 값을 데이터베이스에 넣을 때는 어떻게 할까? 거의 대부분은 키의 중복이 일어나지 않을 것이다. 하지만 1건의 처리라도 시스템상 생성되어야 하는 데이터가 생성되지 않으면 곤란한 문제가 발생할 수 있기 때문에 쿼리를 두 번 날리더라도 한 번은 확인하고, 한 번은 생성하는 방식으로 만드는 편이 좋다.

## 예외나 에러의 스텍

예외는 스텍 트레이스라는 특성을 갖고 있다. 스텍트레이스란 예외가 발생한 코드를 실행한 코드를 기록하는 것이다. 예외가 발생했을 때, 예외를 발생한 코드를 어떤 코드가 실행 했고, 해당 코드는 또 어떤 코드에 의해 실행되었고, 이런 과정의 반복으로 최종적으로 처음에는 무엇을 실행해서 예외 코드까지 실행 되었는지 어떤 코드가 무엇을 실행했는지 확인할 수 있는 기록한 것으로 스텍에 축적되는 단위의 데이터는 함수나 메소드의 호출을 기준으로 한다.

공통적으로 사용되는 코드에서 문제가 발생했을 때 어떤 경로로 해당 코드가 실행 되었을 때 문제가 발생했는지 확인하기 위해서는 에러 또는 예외의 스텍 트레이스의 기록을 확인해야 어떤 원인에 의해 발생한 문제인지 알기 쉽다.

php를 CLI 모드로 실행하면 예외가 발생했을 때 외에 쌓인 스텍을 특별히 예외를 처리하지 않는다면, CLI의 스텍 트레이스에 저장된 기록된 데이터를 로그로 표시해 준다. 라이브러리를 사용하면 로그 파일에 예외의 스텍 트레이스의 기록이 저장된다.

## 예외 처리를 하는 이유

코드에 예외를 던진다는 것은, 로직을 전개하다가 해당 맥락에서는 처리하기가 적절하지 않거나, 데이터베이스와 같은 외부 API를 사용했을 때, API에서 발생할 수 있는 케이스가 너무 많아서 예외를 처리할 수 없을 때 해당 문제에 대한 충분한 처리 로직을 작성하지 못할 때, 예외를 던지도록 코드를 짤 수 있다.

예외는 기본적으로 예외 처리를 하기 위해 사용되어야 한다. 예외를 발생시키는 코드를 사용했다면, 해당 코드를 반드시 catch로 잡아서 처리를 해 줘야 한다. 

예외가 처리되지 않으면, 프로그램이 멈추게 된다. 프로그램이 멈추지 않도록 하기 위해서 개발자는 예외가 발생하지 않도록 처리를 하거나 예외를 잡아서 그에 맞는 처리를 해 줘야 한다.

예외가 발생하면 스텍 트레이스가 생성되고, 스텍 트레이스는 로그 또는 터미널에 나타난다. 이는 어느 지점에서 문제가 발생했는지를 개발자에게 알려 주는데, 개발자는 이를 통해서 어떤 경로로 코드를 실행했을 때 예외가 발생했는지 파악할 수 있다.

개발자는 문제가 발생한 코드가 실행되는 경로를 확인하고, 해당 문제가 발생하지 않도록 코드를 짜거나, try ... catch 구문을 통해서 예외를 잡아 처리한다.

## 에러 발생 시 고려 해야 하는 유형

- 예상 가능한 예외 또는 에러
- 예측할 수 없는 예외 또는 에러
- 예외 또는 에러가 발생하면 실행을 중단해야 하는 경우
- 예외 또는 에러가 발생해도 처리를 계속 해야 하는 경우
- 무시해도 괜찮은 에러

### 예상 가능한 예외 또는 에러

예상 가능한 예외 또는 에러는 할 수 있다면 생기지 않도록 미리 예방하는 코드를 짜는 것이 좋다. 예외/에러와 관련 된 부분은 보통 로그 또는 통지로 스텍 트레이스의 기록과 함께 제공되어 개발자에게 왜 이런 문제가 발생했는지 알려 주는 역할을 하는데, 해결해야 할 문제가 아닌데 예외/에러가 발생했다면 해결 해야 할 문제가 무엇인지 해결하지 말아야 할 문제가 무엇인지 파악하기 어려울 수 있다. 예상되지 않는 것만 로그를 남기기 위해서 예상 가능한 예외/에러는 로그를 남기지 않도록 처리 해 주는 것이 좋다.

예상 가능하지만 미리 방지하기 어려운 예외/에러라면 예외/에러가 발생해도 시스템의 작동이 이뤄질 수 있도록 try ... catch를 사용해서 처리를 하거나, 개발 환경과 프로덕션 서버와 같이 서로 데이터가 달라 어떤 조건에서 생기는 문제인지 알기 어려운 경우, 일부러 예외/에러를 발생시켜 스텍트레이스를 남겨 문제를 추적할 수 있도록 하는 방법이 존재한다.

### 예측할 수 없는 예외 또는 에러

예상 가능한 예외/에러는 가능한 발생하지 않도록 짠다. 하지만 그럼에도 생각지도 못한 실행 흐름에서 발생하는 예외/에러가 존재할 수도 있다. 이런 문제를 해결하기 위해서 모든 코드에 try ... catch 문을 도배하는 경우도 있는데 이는 좋지 못하다.

예외/에러가 발생했을 때, 예외는 기본적으로 처리 되어야 하고, 에러는 이 문제를 해결하여 에러가 발생하지 않게 되어야 한다. try ... catch를 사용했을 때 에러의 스텍 트레이스를 보고하는 기능을 사용하고, 다음 로직을 처리할 수 있는 방법을 사용할 수 있지만, 기본적으로 생각하지 못한 전개의 로직은 가능한 동작되지 않도록 하고, 해당 로직이 전개되기에 앞서 필요한 정보들을 수집할 수 있다면 수집하도록 코드를 만드는 것이 좋다.

하지만, 예상이나 예측할 수 없이 생긴 예외/에러인데 해당 문제를 재현하기 위한 데이터를 수집하는 코드를 짤 수 있을리가 없다. 기본적으로는 예외/에러가 발생해서 프로그램이 멈췄을 때 발생하는 예외/에러를 기록할 수 있는 시스템을 만드는 것이 좋다. 그리고 해당 예외/에러가 개발자에게 통지되어 가능한 빨리 해결하는 코드를 적용할 수 있도록 한다.

#### 예측할 수 없는 에러 대처하기

이런 예측할 수 없는 예외/에러가 발생하는 경우, 고객은 500 스테이터스 에러를 받는다. 이유를 모른 채 서비스의 기능을 사용하지 못하는 것이다. 특별한 안내 메시지 없이 기능을 사용할 수 없다는 것은 서비스 운영에 치명적이기 때문에 500에러가 발생하지 않도록 미리미리 에러를 방지하기 위한 가이드라인을 고객에게 제공하는 UI/UX를 만드는 것이 중요하다.

### 에러 또는 에러가 발생하면 실행을 중단해야 하는 경우

기본적으로 미리 설계되지 않은 경우에 대해서는 동작하지 않도록 코드를 짜는 것이 옳다. 미리 설계되지 않은 동작을 했을 때 발생하는 예외 또는 에러는 예상하지 못한 경우에 해당하며, 예상하지 못한 코드가 동작이 되면 의도하지 않은 결과를 만들어 낸다. 프로그래밍 로직은 의도한 바에 맞게 동작하도록 만들어져야 하는데, 의도하지 않은 로직이 실행되게 되면 치명적인 결과를 초래할 수 있다.

의도하지 않은 로직의 동작을 방지하기 위해서, 의도하지 않은 값이 전달되지 않도록 각종 문법이나 벨리데이션 로직들을 활용하여 의도한 동작 이외의 동작이 일어나지 않도록 한다. 의도하지 않은 동작이 일어날 경우 에러/또는 예외가 발생하게 하여 스텍트레이스와 함께 프로그램 또는 웹이라면 리퀘스트를 종료하도록 만들어 줘야 한다.

또한 실행이 멈췄을 때는 처리 중간까지의 결과를 롤백 할 수 있어야 한다. 이를 위해서 데이터베이스의 수정 변경과 같이, 상태를 수정 및 변경하는 로직의 경우 한 곳에 모아 트렌젝션이 되도록 코드를 만들어야 한다. 여러 로직을 한 곳에 묶어서 처리를 하므로 트렌젝션을 사용하도록 한다. 보통은 서비스가 여러 도메인 로직을 연결해 하나의 플로우를 만들어 처리하기 때문에 서비스 단에서 트렌젝션이 이뤄진다.

실행이 중단되어 예외/에러가 발생했다면 해당 코드의 문제를 통보 받을 수 있는 시스템을 구축하고, 빠르게 개선해서 문제를 해결하도록 하자.

### 예외 또는 에러가 발생해도 처리를 계속 해야 하는 에러

예외 또는 에러가 발생했을 때, 발생했음에도 불구하고 처리를 계속 해야 할 때가 있다. 어떤 로직을 처리하는 도중에 어떤 문제가 발생하더라도 반드시 최종 처리까지 이르러야 하는 경우이다. 이 경우, 메인 로직이 존재하고, 부수적인 로직은 처리 되지 않더라도 비즈니스에 특별한 문제가 없을 때 사용할 수 있다.

메인 로직과 부수적인 로직은 하나의 트렌젝션으로 감싸면 안 되며, 별도의 트렌젝션을 가져서 부수적인 로직의 실패로 메인 로직의 처리에 영향을 주지 않도록 만든다. 부수적인 로직의 실패가 발생할 때 예외/에러를 가 발생해도 작업이 종료되지 않도록 try ... catch 문으로 에러를 잡고, 이 에러에 대한 로그를 통지 받을 수 있도록 스텍트레이스를 포함한 에러를 통지 받을 수 있도록 처리를 한다.

이는 예외/또는 에러가 일어날 가능성이 있는 로직에 적용해야 하며, 어떤 일이 일어날지 알 수 있어서 미리 로직을 충분히 구비하여 예방을 할 수 있는 경우는 예외/에러가 발생하지 않도록 코드를 짜도록 한다.

### 무시해도 괜찮은 에러

무시해도 괞찮은 에러는 없다. 하지만 개발을 하다보면 개발 시간 및 일정 등을 고려해야 하기 때문에 가끔 발생하고 서비스 경험에 큰 지장이 없는 에러라면 무시할 수도 있다.

예를 들어 데이터베이스의 varchar의 글자 수가 255를 사용할 때, 벨리데이터 처리를 하지 않아서 255자 이상의 데이터가 들어 오는 경우 사내 관리 화면이라면 에러 발생시 굳이 코드를 개선하지 않고 '255자 이상 입력하면 안 되요'라고 화면의 입력 항목 하단에 메시지를 적어주면 된다. 그리고 255자까지 입력할 일이 아주 드물고 발생하지 않는 입력 항목에 대해서만 가능하다. 

사용자입장에서는 이런 에러에 의해서 실행이 안 되고 원하는 동작이 되지 않으므로 서비스 이용 경험이 하락하기 때문에 안 되었을 때 왜 안 되는지를 알려주고 (255자 이하로 입력과 같은) 올바른 방법으로 서비스를 이용할 수 있도록 한다.

## 예치기 못한 에러가 발생했을 때 대응 방안
- 예기치 않은 에러는 기본적으로 프레임워크가 에러를 기록해 준다.
- UI/UX 미비로 잘못된 값이 들어와 에러가 발생했을 때를 대비해서 에러가 발생했다면 에러 로그를 기록해야 한다.
- 예기치 않은 에러는 에러 로그를 확인하고 에러가 발생하지 않도록 UI/UX에서 대응을 하고, 벨리데이터 등으로 왜 처리가 안 되는지 알리는 등의 작업을 하는 것이 필요하다.

## 에러 로그를 남길 때 중요한 것.
- 에러가 나지 않도록 처리하는 것이 아니라, 왜 어떤 경우에 에러가 났는지 알 수 있도록 필요한 에러는 남기는 것이 중요하다.


## 에러 처리 로직을 어떻게 짜면 될까?
CASE 1
```
try {
    에러 발생 가능성이 있는 코드
} catch(e) {
    예외를 기록하는 코드
    예외가 발생했을 때 고객에게 보여주는 코드 (500 스테이터스에러)
}
```

CASE2
```
에러의 발생을 예방하기 위한 여러가지 로직이 들어간 코드
try {
    예상치 못하게 에러가 발생할 가능성이 있는 코드
} catch(e) {
    예외를 기록하는 코드
    예외가 발생했을 때 고객에게 보여주는 코드 (500 스테이터스)
}
```
- CASE1으로 짜는 것이 아니라 CASE2로 짜는 것이 중요하다.

## 에러 로깅을 통한 서비스 장애 해결
- 고객에게 500 스테이터스 화면을 보여 줬다면 고객이 이를 알려주지 않더라도 500 에러를 해결할 수 있도록 만들어 줘야 한다.
- 고객이 안 알려 줬는데 처리가 되는지 안 되는지 확인하기 위해서 에러 로그를 남겨서 확인한다.
- 에러 로그를 주기적으로 확인하거나 에러 통지 기능을 만들어 에러 문제를 해결한다.
- 에러 통지를 만들 때, 너무 많은 알람이 오지 않도록 중복 에러를 배제하는 등의 처리가 필요하다.
- 보통 에러 통지는 센트리 같은 서비스를 사용하거나 렉 통지와 같은 방식을 주로 사용한다.

---

## 사용자 정의 에러
### 커스텀 에러 클래스를 사용하는 이유
- 에러 종류에 대한 필터링을 위해 사용하는 방법
```
try{
    ...
} catch(CustomExceptionA $e) {
    CustomExceptionA에 관한 에러를 처리하는 로직
} catch(CustomExceptionB $e) {
    CustomExceptionB에 관한 에러를 처리하는 로직
}
```
- try 안에서 여러가지 에러가 발생할 수 있지만 그 중에서 각 종류의 에러만 뽑아서 처리하고 싶을 때 사용한다.
- 각각의 에러는 각각의 로직에서 처리하면 되지 않는냐고 할 수 있다. 예를 들어 CustomExceptionA에 관한 에러 처리는 A에 관련된 로직이 처리되는 쪽에서 정의하고, CustomExceptionB에 관한 에러 처리는 B에 관련한 로직이 처리되는 쪽에서 정의 하는 방식이다.
- 위와 같은 코드는 에러 처리를 모아서 하고자 할 때 사용하거나 하나의 단위의 로직을 에러별로 나누기 어려워 로직 단위에서 여러 에러가 섞일 수 밖에 없는 코드를 짤 때 사용한다.

### 커스텀 에러를 사용하는 이유
- 함수의 인자로 'a'와 'b'라는 문자열만 받고 싶은 경우
```
function(string $test) {
    if(!($test === 'a' || $test === 'b')) {
        return throw exception("인자로 'a'와 'b'만 허용함")
    }
    ...
}
```
- 문법적인 강제 기능을 하게 하기 위함이다.





