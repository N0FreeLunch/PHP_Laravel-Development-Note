## php에서 배열의 특징
- php에서는 배열이란 하나의 타입에 `[1,2,3,4,5]`와 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]`의 두 가지 방식을 사용할 수 있다. 첫 번째는 인덱싱 배열이고 두 번째는 연관 배열이라고 부른다.
- 정적 언어에서는 인덱싱 배열은 키가 존재하지 않는 대상이다. 메모리의 어떤 위치에 데이터를 일정 바이트 간격으로 순차적으로 읽게 된다. 이런 방식으로 접근을 하기 때문에 배열의 각각의 인덱스에 해당하는 값에 접근할 때 빠른 속도를 보여준다.
- php에서의 배열은 연관 배열과 같은데 이는 `[1,2,3,4,5]`은 `[0 => 1, 1 => 2, 2 => 3, 3=> 4, 4 => 5]`와 동일하기 때문이다. 인덱싱 배열로 만들어도 어차피 php에서는 모두 연관배열로 처리한다.
- php의 배열은 인덱싱 배열이나 연관 배열이나 처리 방식의 동일함으로 인해서 동일한 타입으로 만들어져 있다.

### 기능의 스펙 문제
- 함수나 클래스는 사용상의 스펙을 만드는 작업이다. 하지만 매개변수에 배열을 사용하게 되면, 배열 안의 어떤 값을 이용해야 할지 해당 코드만 보고서는 알 수 없다는 단점이 있다. 함수나 클래스 등 어떤 캡슐화 된 어떤 기능을 사용하기 위해서는 어떤 값을 전달해야 할지를 알아야 한다. 하지만, 배열 타입힌트만를 가진 대상을 받을 때는 배열으로 받을 수 있는 형태의 다양성으로 인해서 어떤 값을 받아야 할지 애매한 경우가 많다.
- 복잡한 소프트웨어를 만들 수록 각 단위 기능의 테스트 가능성은 중요하다. 일반적으로 테스트가 가능하다는 것은 마치 순수함수와 같이 인풋에 대해 아웃풋을 가질 수 있어서 따로 떼어 내었을 때 인풋을 넣었을 때 아웃풋의 결과를 확인할 수 있는 것을 의미한다. 테스트 할 수 있는 기능은 어떤 역할을 할지 예상하기 쉽고 예상대로 동작하는지에 대한 테스트 코드를 작성하기 쉽다는 장점이 있다. 하지만 배열을 인풋으로 받을 때 배열의 어떤 형태를 인풋으로 받아야 할지 알 수 없기 때문에 동작이 잘 이뤄지는 것인지 모호한 경우가 생길 수 있다.
- 테스트하기 쉬운 코드가 되기 위해서는 특정 기능만을 따로 떼어 냈을 때 어떤 인풋을 넣어 주어야 아웃풋을 확인할 수 있는지 넣어주는 값을 정해야 하는데, 배열의 경우 구조의 형태가 다양해서 어떤 값을 넣어 주어야 할지 생각하기 어려운 경우가 많다. 결국 스펙만을 보고서는 어떤 입력에 어떤 결과값을 갖는지 추측하기 어려운 경우가 많이 발생할 수 있고, 내부 구현을 꼭 확인헤야 하는 코드를 만들 가능성이 있다.
- 어떤 기능이 어떤 동작을 하는지 불분명하기 때문에 인풋에 대한 아웃풋이 명확한 스펙을 갖고 있다면 테스트 코드를 만들기 쉽고 이를 통해서 해당 기능이 어떻게 동작하는지 확인할 수 있다. 하지만 배열을 매개변수로 사용하게 되면, 어떤 구조의 배열을 전달해야 결과값을 확인할 수 있을지 기능의 스펙만을 보고는 알 수 없기 때문에 테스트 할 수 있는 코드가 될 수 없다.
- 전달된 배열을 내부에서 어떻게 처리를 할지 어떤 값을 전달해야 해당 기능의 스펙에 맞는 동작을 만들어 낼 수 있을지를 확인하기 위해서 내부의 코드의 처리 과정을 확인해야 한다는 것이다. 프로그래밍에서 추상화는 내부의 로직을 확인하지 않더라도 어떤 기능을 가졌는지 추론할 수 있도록 만드는 것인데 php의 배열을 사용하게 되면 함수나 메소드 스펙만 봐서는 어떤 배열의 값을 전달해야 할지 알 수 없게 되는 문제점이 생긴다.

### 문자열 매개변수의 문제
- 문자열 매개변수의 예를 생각 해 보자. 일반적인 코딩 스타일에서 문자열 그대로에 대해 어떤 일반적인 처리를 하는 것이 아니라, 어떤 식별자로 문자열을 사용하는 코딩 스타일을 좋게 여기지 않는 경우가 많다. 타입에 의해 제한되는 방식과 달리 문자열 매개 변수는 문자열에 오기가 발생한 경우 런타임에 에러를 감지하지 못할 수도 있고, IDE가 코딩의 실수를 알려주지 않는 경우도 있다. 컴파일 언어의 경우에도 컴파일 타임의 타입 체크를 사용해서 코딩의 실수를 줄이기 위해서 문자열 매개변수를 사용하는 것을 권장하지 않는 코딩 프렉티스가 존재한다.
- 무조건 문자열 매개변수를 사용하지 말라는 것은 아니다. 일반적인 문자열에 대한 처리를 하는 경우에는 문자열을 매개변수로 전달하는 것은 괜찮다. 하지만, 함수 내부에서 특정한 문자열에 대해서만 처리를 달리하는 분기가 존재하는 경우 함수는 특정 문자열에 의존적인 처리를 가진다. 이런 경우 문자열은 어떤 상태를 구분하는 식별자의 역할을 하는데 이를 문자열로 처리하면 실수를 유발할 가능성을 높인다.
- 식별자의 용도로 문자열을 사용하기 보다는 enum을 사용하거나 커스텀 클래스를 만들어 `new CutstomTeyp(문자열)`의 생성자로 문자열을 전달하고 `__invoke` 매직 메소드를 통해서 벨리데이션 된 문자열을 사용하는 방법을 사용하는 것을 추천한다. 문자열은 너무 다양한 값이 들어 올 수 있기 때문에 식별자로 문자열을 사용할 경우에는 런타임이나 IDE 등의 툴을 이용한 코딩의 실수를 방지하는 기능이 동작하지 않을 가능성이 높기 때문에 버그를 만들어 낼 가능성을 높인다. 이러한 스타일을 제약할 수 있도록 enum이나 커스텀 class를 만들어 타입힌트로 이들 타입을 사용하는 것을 추천한다.
- enum의 경우는 `enum Gender: string { case Man = 'man'; case Woman = 'woman'; }` `$canPregnant = function(Gender $gender): bool { ... }`의 예를 생각해 보자. 문자열 파라메터로 `'man'` `'woman'`을 전달하도록 만들면 `$canPregnant = function(string $gender): bool { ... }`의 `string $gender` 파라메터로 `'man'` `'woman'`을 전달해야 할지, `'m'` `'w'`을 전달해야 할지, `'male'` `'femail'`을 전달해야 할지, `'m'`, `'f'`를 전달해야 할지 함수의 내부 구현을 확인하지 않으면 알 수가 없다. 이에 반해 enum을 사용하면 함수가 어떤 파라메터를 사용하는지 명확한 스펙을 알 수 있다.
- 또한 문자열이 너무 다양한 값을 가지기 때문에 어떤 기능의 스펙을 정하기 위해서 enum이나 커스텀 class를 만들어 타입힌트로 사용하는 것과 마찬가지로 배열 또한 단위 기능의 스펙상의 제약을 걸기 위해 타입힌트를 사용하는 방법을 생각하는 편이 좋다.

### 일반적인 배열 처리
- php의 배열도 문자열과 마찬가지 문제를 갖는다. 배열로 가질 수 있는 구조가 다양하기 때문에 어떤 구조의 배열을 전달해야 할지 알 수 없다는 문제가 있다. 문자열이 식별자로 사용될 경우 어떤 문자열이 기능 내부의 특별한 처리 케이스를 갖는지 확인해야 하듯이 배열도 어떤 구조의 배열을 전달해야 사용하려는 기능에서 원하는 결과를 얻을 수 있는지는 내부 구현을 확인하지 않고는 알 수 없는 문제가 발생한다.
- 배열을 매개변수로 사용하는 기능이 있다면 배열의 구조에 관계 없이, 모든 배열의 구성에 대해 동작하는 스펙을 만드는 것이 좋다. 특정 배열의 구조에 의존하는 것이 아닌 배열의 모든 데이터를 순회하는 방식의 처리를 하는 기능으로 만든다. 또한 특정한 키에 의존하는 기능 또는 특정한 키에 대한 특수한 처리를 한다면 어떤 키에 어떤 처리를 하는지 알 수 없기 때문에 내부의 코드 동작의 특수 처리를 하는 부분을 확인하지 않는 이상 기능의 동작의 결과를 추측하기 어렵게 된다.
- 만약 배열의 특정한 키나 특정한 값에 대한 처리를 하는 것이라면 특정한 키를 지정하여 처리할 수 있도록 `$needle`과 같은 매개 변수를 갖는 함수를 만들어 처리하도록 하며, 기능의 스펙(함수의 이름, 파라메터, 반환값 등)으로 내부의 특수한 처리를 언급할 수 없는 처리는 만들지 않는 편이 좋다.

### 특수한 배열 형태의 의존하는 경우

#### 자바스크립트에서 특수한 배열 형태를 처리하는 방법
- 자바스크립트에서 배열은 자바스크립트의 배열은 인덱스 키만 가지고 벨류가 매핑된 형태이며, 다양한 키를 갖는 문법은 오브젝트이어야 한다. php의 연관배열은 자바스크립트의 배열과 오브젝트 둘 다의 표현을 갖고 있다.
- 자바스크립트에서는 비구조화 할당 패턴 (Destructuring Assignment Pattern)이라는 개념이 존재한다.
```js
const fn = ({a, b, c, d}) => console.log(a, b, c, d);
fn({a: 1, b: 2, c: 3, d: 4});
```
- 자바스크립트 함수의 파라메터로 오브젝트 형태에서 값만 빠진 `{a, b, c, d}`와 같은 파라메터의 코드를 쓰면 `fn({a: 1, b: 2, c: 3, d: 4})`는 a가 1, b가 2, c가 3, d가 4의 값을 가지며, `fn({a: 1, b: 2, c: 3})`은  a가 1, b가 2, c가 3, d가 undefined의 값을 갖는다. `fn({a: 1, b: 2, e: 3})`의 경우는  a가 1, b가 2, c가 undefined, d가 undefined의 값을 갖는다.
- 자바스크립트는 비구조화 할당 패턴을 통해서 특수한 형태의 오브젝트에 의존하는 사양의 기능을 만들 수 있다.





