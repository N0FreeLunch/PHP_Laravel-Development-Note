## php에서 배열의 특징
- php에서는 배열이란 하나의 타입에 `[1,2,3,4,5]`와 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5]`의 두 가지 방식을 사용할 수 있다. 첫 번째는 인덱싱 배열이고 두 번째는 연관 배열이라고 부른다.
- 정적 언어에서는 인덱싱 배열은 키가 존재하지 않는 대상이다. 메모리의 어떤 위치에 데이터를 일정 바이트 간격으로 순차적으로 읽게 된다. 이런 방식으로 접근을 하기 때문에 배열의 각각의 인덱스에 해당하는 값에 접근할 때 빠른 속도를 보여준다.
- php에서의 배열은 연관 배열과 같은데 이는 `[1,2,3,4,5]`은 `[0 => 1, 1 => 2, 2 => 3, 3=> 4, 4 => 5]`와 동일하기 때문이다. 인덱싱 배열로 만들어도 어차피 php에서는 모두 연관배열로 처리한다.
- php의 배열은 인덱싱 배열이나 연관 배열이나 처리 방식의 동일함으로 인해서 동일한 타입으로 만들어져 있다.

### 기능의 스펙 문제
- 함수나 클래스는 사용상의 스펙을 만드는 작업이다. 함수의 이름, 파라메터, 타입을 모두 포함하여 기능의 인터페이스를 나타내는 용어를 함수의 '서명'이라고 부른다. 함수의 서명으로 매개변수로 배열을 사용하게 되면, 배열 안의 어떤 값을 이용해야 할지 서명만 보고서는 알 수 없으며 내부의 구현을 확인해야 한다는 단점이 있다. 함수나 클래스 등 캡슐화 된 서명만을 통해 가능한 해당 서명이 어떤 기능을 나타내는지 알 수 있어야 하며 배열을 전달한다면 어떤 구조의 배열을 받아야 할지 알아야 한다. 하지만, 배열 타입힌트만를 가진 대상을 받을 때는 배열으로 받을 수 있는 형태의 다양성으로 인해서 어떤 값을 받아야 할지 모호한 경우가 많다.
- 복잡한 소프트웨어를 만들 수록 각 단위 기능의 테스트 가능성은 중요하다. 일반적으로 테스트가 가능하다는 것은 마치 순수함수와 같이 인풋에 대해 아웃풋을 가질 수 있어서 따로 떼어 내었을 때 인풋을 넣었을 때 아웃풋의 결과를 확인할 수 있는 것을 의미한다. 테스트 할 수 있는 기능은 어떤 역할을 할지 예상하기 쉽고 예상대로 동작하는지에 대한 테스트 코드를 작성하기 쉽다는 장점이 있다. 하지만 배열을 인풋으로 받을 때 배열의 어떤 형태를 인풋으로 받아야 할지 알 수 없기 때문에 동작이 잘 이뤄지는 것인지 모호한 경우가 생길 수 있다.
- 테스트하기 쉬운 코드가 되기 위해서는 함수나 클래스의 서명만으로 어떤 인풋을 넣었을 때 아웃풋이 어떤 형태의 아웃풋을 받는지 확인할 수 있어야 한다. 배열의 경우 구조의 형태가 다양해서 어떤 값을 넣어 주어야 할지 생각하기 어려운 경우가 많다. 결국 배열을 인자로 받는 경우 어떤 입력에 어떤 결과값을 갖는지 추측하기 어려운 경우가 많이 발생할 수 있고, 내부 구현을 꼭 확인헤야 하는 코드를 만들 가능성이 있다.
- 어떤 기능이 어떤 동작을 하는지 불분명하기 때문에 인풋에 대한 아웃풋이 명확한 스펙을 갖고 있다면 테스트 코드를 만들기 쉽고 이를 통해서 해당 기능이 어떻게 동작하는지 확인할 수 있다. 하지만 배열을 매개변수로 사용하게 되면, 어떤 구조의 배열을 전달해야 결과값을 확인할 수 있을지 기능의 스펙만을 보고는 알 수 없기 때문에 테스트하기 어려운 코드가 된다.
- 전달된 배열을 내부에서 어떻게 처리를 할지 어떤 값을 전달해야 해당 기능의 스펙에 맞는 동작을 만들어 낼 수 있을지를 확인하기 위해서 서명만 보고서는 충분하지 못하며 내부의 코드의 처리 과정을 확인해야 한다면 값의 변화의 양상을 코드 중간 중간 확인하는 디버깅을 더 많이 요구하게 되므로 관리하기 어려운 코드가 된다. 프로그래밍에서 추상화는 내부의 로직을 확인하지 않더라도 어떤 기능을 가졌는지 추론할 수 있도록 만드는 것인데 php의 배열을 파라메터로 받으면 함수나 메소드 스펙만 봐서는 어떤 배열의 형태와 값을 전달해야 할지 알 수 없게 되는 문제점이 생긴다.

### 문자열 매개변수의 문제
- 문자열 매개변수의 예를 생각 해 보자. 일반적인 코딩 스타일에서 문자열 그대로에 대해 어떤 일반적인 처리를 하는 것이 아니라, 어떤 식별자로 문자열을 사용하는 코딩 스타일을 좋게 여기지 않는 경우가 많다. 타입에 의해 제한되는 방식과 달리 문자열 매개 변수는 문자열에 오기가 발생한 경우 런타임에 에러를 감지하지 못할 수도 있고, IDE가 코딩의 실수를 알려주지 않는 경우도 있다. 컴파일 언어의 경우에도 컴파일 타임의 타입 체크를 사용해서 코딩의 실수를 줄이기 위해서 문자열 매개변수를 사용하는 것을 권장하지 않는 코딩 프렉티스가 존재한다.
- 무조건 문자열 매개변수를 사용하지 말라는 것은 아니다. 일반적인 문자열에 대한 처리를 하는 경우에는 문자열을 매개변수로 전달하는 것은 괜찮다. 하지만, 함수 내부에서 특정한 문자열에 대해서만 처리를 달리하는 분기가 존재하는 경우 함수는 특정 문자열에 의존적인 처리를 가진다. 이런 경우 문자열은 어떤 상태를 구분하는 식별자의 역할을 하는데 이를 문자열로 처리하면 실수를 유발할 가능성을 높인다.
- 식별자의 용도로 문자열을 사용하기 보다는 enum을 사용하거나 커스텀 클래스를 만들어 `new CutstomTeyp(문자열)`의 생성자로 문자열을 전달하고 `__invoke` 매직 메소드를 통해서 벨리데이션 된 문자열을 사용하는 방법을 사용하는 것을 추천한다. 문자열은 너무 다양한 값이 들어 올 수 있기 때문에 식별자로 문자열을 사용할 경우에는 런타임이나 IDE 등의 툴을 이용한 코딩의 실수를 방지하는 기능이 동작하지 않을 가능성이 높기 때문에 버그를 만들어 낼 가능성을 높인다. 이러한 스타일을 제약할 수 있도록 enum이나 커스텀 class를 만들어 타입힌트로 이들 타입을 사용하는 것을 추천한다.
- enum의 경우는 `enum Gender: string { case Man = 'man'; case Woman = 'woman'; }` `$canPregnant = function(Gender $gender): bool { ... }`의 예를 생각해 보자. 문자열 파라메터로 `'man'` `'woman'`을 전달하도록 만들면 `$canPregnant = function(string $gender): bool { ... }`의 `string $gender` 파라메터로 `'man'` `'woman'`을 전달해야 할지, `'m'` `'w'`을 전달해야 할지, `'male'` `'femail'`을 전달해야 할지, `'m'`, `'f'`를 전달해야 할지 함수의 내부 구현을 확인하지 않으면 알 수가 없다. 이에 반해 enum을 사용하면 함수가 어떤 파라메터를 사용하는지 명확한 스펙을 알 수 있다.
- 또한 문자열이 너무 다양한 값을 가지기 때문에 어떤 기능의 스펙을 정하기 위해서 enum이나 커스텀 class를 만들어 타입힌트로 사용하는 것과 마찬가지로 배열 또한 단위 기능의 스펙상의 제약을 걸기 위해 타입힌트를 사용하는 방법을 생각하는 편이 좋다.

### 일반적인 배열 처리
- php의 배열도 문자열과 마찬가지 문제를 갖는다. 배열로 가질 수 있는 구조가 다양하기 때문에 어떤 구조의 배열을 전달해야 할지 알 수 없다는 문제가 있다. 문자열이 식별자로 사용될 경우 어떤 문자열이 기능 내부의 특별한 처리 케이스를 갖는지 확인해야 하듯이 배열도 어떤 구조의 배열을 전달해야 사용하려는 기능에서 원하는 결과를 얻을 수 있는지는 내부 구현을 확인하지 않고는 알 수 없는 문제가 발생한다.
- 배열을 매개변수로 사용하는 기능이 있다면 배열의 구조에 관계 없이, 모든 배열의 구성에 대해 동작하는 스펙을 만드는 것이 좋다. 특정 배열의 구조에 의존하는 것이 아닌 배열의 모든 데이터를 순회하는 방식의 처리를 하는 기능으로 만든다. 또한 특정한 키에 의존하는 기능 또는 특정한 키에 대한 특수한 처리를 한다면 어떤 키에 어떤 처리를 하는지 알 수 없기 때문에 내부의 코드 동작의 특수 처리를 하는 부분을 확인하지 않는 이상 기능의 동작의 결과를 추측하기 어렵게 된다.
- 만약 배열의 특정한 키나 특정한 값에 대한 처리를 하는 것이라면 특정한 키를 지정하여 처리할 수 있도록 `$needle`과 같은 매개 변수를 갖는 함수를 만들어 처리하도록 하며, 기능의 스펙(함수의 이름, 파라메터, 반환값 등)으로 내부의 특수한 처리를 언급할 수 없는 처리는 만들지 않는 편이 좋다.

### 특수한 배열 형태의 의존하는 경우

#### 자바스크립트에서 특수한 배열 형태를 처리하는 방법
- 자바스크립트에서 배열은 자바스크립트의 배열은 인덱스 키만 가지고 벨류가 매핑된 형태이며, 다양한 키를 갖는 문법은 오브젝트이어야 한다. php의 연관배열은 자바스크립트의 배열과 오브젝트 둘 다의 표현을 갖고 있다.
- 자바스크립트에서는 비구조화 할당 패턴 (Destructuring Assignment Pattern)이라는 개념이 존재한다.
```js
const fn = ({a, b, c, d}) => console.log(a, b, c, d);
fn({a: 1, b: 2, c: 3, d: 4});
```
- 자바스크립트 함수의 파라메터로 오브젝트 형태에서 값만 빠진 `{a, b, c, d}`와 같은 파라메터의 코드를 쓰면 `fn({a: 1, b: 2, c: 3, d: 4})`는 a가 1, b가 2, c가 3, d가 4의 값을 가지며, `fn({a: 1, b: 2, c: 3})`은  a가 1, b가 2, c가 3, d가 undefined의 값을 갖는다. `fn({a: 1, b: 2, e: 3})`의 경우는  a가 1, b가 2, c가 undefined, d가 undefined의 값을 갖는다.
- 자바스크립트는 비구조화 할당 패턴을 통해서 특수한 형태의 오브젝트에 의존하는 사양의 기능을 만들 수 있다.

#### php에서 특수한 배열 형태를 처리하는 방법
```php
$fn = function (array $arr) {
    foreach($arr as $e) {
    	var_dump($e);
    }	
};

$fn(['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]);
```
- 자바스크립트의 비구조화 할당 패턴의 파라메터와 같이 특수한 형태의 배열을 받을 수는 없다. 따라서 특수한 구조의 배열을 받고 싶다면, 배열을 사용하지 않고 받고자 하는 대상을 모두 파라메터로 지정하는 방법을 사용한다.

```php
$fn = function (int $a, int $b, int $c, int $d) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
    var_dump($d);
};

$fn(...['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], ...['d' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], d: 4);
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => 3, 'd' => 4]);
echo "=========================================".PHP_EOL;
$fn(...['a' => 1, 'b' => 2], ...['c' => 3], 4); // Fatal error: Cannot use positional argument after argument unpacking
```
- 배열 `['a' => 1, 'b' => 2, 'c' => 3, 'd' => 4]`을 스프레드 문법 `...`을 사용해서 함수의 인자로 할당하면 함수의 파라메터에 배열의 원소들이 매핑 되는 것을 볼 수 있다. 하지만 자바스크립트와 같이 일부는 오브젝트의 형태로, 일부는 그냥 파라메터로 받는 것은 안 된다. 인자를 전달할 때 파라메터의 이름을 지정하는 방식을 사용한 것으로 일부 인자를 파라메터 이름을 지정해서 전달을 하는 방식을 사용했다면 뒤따르는 나머지 인자도 파라메터의 이름을 지정해서 전달하는 방식으로 사용해 주어야 한다. 인자를 전달할 때 파라메터의 이름을 지정하는 방법은 연관 배열의 키를 파라메터의 이름으로 지정한 배열을 전달하거나, '파라메터명: 전달할_인자'의 방식으로 전달하는 방법이 있다. 둘 다 이름을 지정하여 전달하는 방식으로 인자를 나열할 때의 콤마(,)를 사용하여 혼용할 수 있다. 파라메터명을 지정한 인자 할당 방식을 공식 용어로 '명명된 인자'(named arguments)라고 부른다.
- 함수의 인자를 지정할 때 파라메터명을 지정하는 방식을 통해서 특수한 구조를 갖는 배열을 전달할 수 있다는 것을 알 수 있다. 하지만 다차원 배열을 모두 구조화하지는 못한다는 단점이 있고, 파라메터명이 지정된 것과 지정되지 않은 인자 전달 방식을 혼용하기 위해서는 `$fn(1, 2, ...['c' => 3, 'd' => 4])`와 같이 파라메터명이 지정되지 않은 인자 전달 방식을 먼저 나열한 다음 파라메터명이 지정된 인자 할당 방식을 뒤에 배치해야 하므로 인자의 순서에 제한이 있다는 단점이 있다. 또한 어느 파라메터부터 어느 파라메터까지가 배열을 스프레드 문법 `...`으로 전달해야 하는 대상인지 알 수 없다는 문제가 있다.
```php
$fn = function (int $a, int $b) {
    return function (int $c , int $d) use ($a, $b) {
        var_dump($a);
        var_dump($b);
        var_dump($c);
        var_dump($d);
    };
};

$fn(1, 2)(...['c' => 3, 'd' => 4]);
```
- 위와 같이 배열을 받을 대상과 그렇지 않을 대상을 구분하기 위해서 클로저를 사용해서 일반 값을 받을 대상과 배열 값을 받을 대상을 구분감 있게 분리하는 것도 방법이지만 문법이 너무 복잡해진다는 단점이 존재한다.
```php
$fn = function (int $a, int $b, /* < arr */int $c, int $d /* arr > */) {
    var_dump($a);
    var_dump($b);
    var_dump($c);
    var_dump($d);
};
```
- 위와 같이 주석을 사용하여, 배열이 전달되는 부분을 표기하는 방법이 존재한다. 다음과 같이 개행을 넣어 구분감을 주는 방법도 존재한다.
```php
$fn = function (
        int $a, int $b, # each
        int $c, int $d, # arr group
    ) {
        var_dump($a);
        var_dump($b);
        var_dump($c);
        var_dump($d);
    };
```
- php에서 함수의 인자로 특수한 형태의 연관 배열을 전달하고 싶다면 함수의 파라메터로 배열 타입의 파라메터를 만들지 않고, 전달되는 배열을 구성하는 파라메터를 나열하는 방식으로 파라메터를 정의하도록 하자.

#### 인덱싱 된 배열(indexed array)을 받는 방법
- 인데싱 된 배열은 파이썬과 같은 언어에서 리스트라고 부른다. 배열의 원소로 키가 없는 배열을 의미한다. php에서는 키가 없는 배열의 경우 키가 없는 대상의 앞선 원소 부터 0부터 정수의 키가 부여된다. 예를 들어 `['a', 'key' => 'b', 'c']`라고 하면, 'a'에는 0의 키가 부여되고, 'c'에는 1의 키가 부여된다.
- 키-벨류 쌍을 가지는 연관 배열과 달리 인덱스 된 배열은 가변 함수 문법([RFC: Syntax for variadic functions](https://wiki.php.net/rfc/variadics))의 가변 파라메터(variadic parameter)를 이용해서 배열을 받을 수 있다. 가변 인자(variadic arguments)를 받는 배열은 받을 수 있는 인자의 갯수가 제한이 없다는 의미의 문법이다. 파라메터에 '...변수'의 문법을 사용하여 가변 인자를 받는 파라메터를 만들 수 있다.
```php
$fn = function (int $a, int $b, int ...$c) {
    var_dump($a);
    var_dump($b);
    foreach($c as $key => $value) {
    	echo 'key: ';
        var_dump($key);
        echo 'value: ';
        var_dump($value);
    }
};

$fn(1, 2, 3);
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5);
echo "=========================================".PHP_EOL;
$fn(1, 2, 3, 4, 5, 6, 7);
echo "=========================================".PHP_EOL;
$fn(1, 2, ...[3,4,5]);
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => 3]);
echo "=========================================".PHP_EOL;
$fn(1, 2, ...['c' => [3, 4, 5]]); // Argument #3 must be of type int, array given
```
- 파라메터를 `...$c`으로 설정한 것 덕분에 `$fn(1, 2, 3)`, `$fn(1, 2, 3, 4, 5)`, `$fn(1, 2, 3, 4, 5, 6, 7)`으로 인자의 갯수를 늘려도 계속 인자를 받을 수 있다.
- `...$c`에 타입을 붙일 수 있는데 그럼 가변 인자로 받을 모든 대상은 지정한 타입이 되어야 한다. 마치 인덱싱된 배열의 원소의 타입을 (php에는 존재하지 않지만) 제네릭 문법을 사용하여 타입을 제한할 수 있듯이 가변 파라메터에 타입을 붙이면 제네릭을 붙인 것과 같이 받는 대상의 파라메터를 제한할 수 있다.
- 가변 파라메터는 파라메터를 나열할 때 가장 마지막에 위치해야 한다. 가변 파라메터는 파라메터를 계속해서 받을 수 있기 때문에, 가변 파라메터 뒤에 정의된 파라메터의 인자를 받을 수 없다.
```php
$fn = function($a, ...$b, $c) {
    var_dump($a);
    var_dump($b);
    foreach($c as $key => $value) {
    	echo 'key: ';
        var_dump($key);
        echo 'value: ';
        var_dump($value);
    }
};

$fn(1, ...[2, 3, 4], 5); // Fatal error: Only the last parameter can be variadic
```
- 가변 파라메터는 인자의 수를 제한하지 않는다는 의미를 기본적으로 갖지만, 가변 파라메터에 배열을 스프레드 문법 `...`을 사용해서 `$fn(1, 2, ...[3,4,5])`와 같이 할당하는 방법을 통해서 리스트 형식의 배열을 받는다는 의미를 부여할 수 있다. `$fn(1, 2, ...[3, 'key' => 4, 5]);`와 같이 배열에 키가 지정된 값을 보내면 키와 일치하는 대상을 파라메터에서 찾는다. 가변 파라메터는 파라메터의 마지막에 위치하기 때문에 `$fn(1, 2, )`와 같이 가변 파라메터 이외의 인자는 미리 다 넣은 상태에서 마지막에 가변 인자를 할당한다. 이 경우 `...['c' => '3']`로 값을 전달할 수는 있지만, `...['c' => '3', 4, 5]` 파라메터 명을 지정하여 전달하는 방식 뒤에 파라메터를 지정하지 않은 방식의 전달을 하고 있으므로 문법적으로 불가능하며, `...[3, 4, 'c' => 5]`는 전달 가능하다. `$fn(1, 2, ...['c' => [3, 4, 5]])`으로 파라메터명을 지정해서 가변 인자를 보낼 수도 있는데, `$c`의 타입을 int으로 한 경우 array가 전달되어 타입에러가 발생한다. 가변 파라메터에 배열이 아닌 타입을 지정하는 것을 통해서 파라메터명으로 배열을 할당할 수 없기 때문에 스프레드 문법으로 '...배열'으로 리스트를 전달하는 의미의 배열이 된다.
- 가변 파라메터를 통해서 인자를 갯수 제한 없이 받을 수도 있지만, 리스트 형태의 배열을 받을 수 있다. 그리고 리스트 형태의 배열의 원소의 타입도 지정가능한 문법을 활용할 수 있다. 하지만 가변으로도 인자를 받을 수 있기 때문에 의미가 조금 모호한 단점은 존재한다.

### phpdoc을 사용하기
- phpdoc에는 array shape라는 기능이 있다. 이는 주석을 통해서 배열의 형태를 나타내는 것으로, 파라메터로 배열을 사용할 때 어떤 형태의 배열을 받는지 알 수 있게 해 준다.

### array shape
- [array-shapes](https://phpstan.org/writing-php-code/phpdoc-types#array-shapes)의 문서는 phpstan이란 정적 분석을 사용할 때 정적분석에 의한 추론으로 올바른 값이 들어갔는지 확인할 수 있는 기능을 제공한다. [phpstorm IDE의 array-shape 지원](https://blog.jetbrains.com/phpstorm/2022/02/phpstorm-2022-1-eap-3/)으로 phpdoc의 array-shapes 구문을 사용할 때, 코드에서 지정한 값의 타입 및 접근 방식 등의 추론을 통한 자동 완성이 강화되었다.
```php
/**
 * @param $arr array{c: int, d: int}
 */
$fn = function (int $a, int $b, array $arr) {
    var_dump($a);
    var_dump($b);
    var_dump($arr['c']);
    var_dump($arr['d']);
};
```
- 위와 같은 코드를 작성하게 되면, IDE에 의해서 `$arr[|]` (|는 문자열 입력 커서의 위치)정도만 입력해도 `$arr['c']`, `$arr['d']`에 대한 자동완성이 보여지게 된다. 이런 방식을 통해서 배열에 어떤 값이 들어가 있는지 알 수 있게 해 준다는 것이다.
- 하지만 이러한 지원은 어디까지나 주석으로 코드의 변경에 따라 주석이 업데이트 되지 않는 경우가 많으므로 개인적으로 선호하지 않는 스타일이며, 배열의 구조를 표기하지 못하는 것이 마음에 들지 않기 때문에 어쩔 수 없이 쓰는 방편일 뿐이다.
```php
/**
 * @param $arr array<int, string>
 */
$fn = function (int $a, int $b, array $arr) {
    var_dump($a);
    var_dump($b);
    var_dump($arr[0]);
    var_dump($arr[1]);
};

$fn(1, 2, ['c', 'd']);
```
- 제네릭을 사용해서 위와 같이 표기할 수도 있다. php에서 인덱싱 된 배열의 키는 수이므로 제네릭 표시 `<int, string>`의 첫 번째 타입은 키의 타입으로 인덱스를 의미하므로 int를 두 번째 타입으로 키에 대응하는 벨류의 타입으로 `<int, string>`을 할당해 주었다.

### DTO 사용하기
- DTO란 Data Transfer Object의 약자이다. 데이터 전송 객체는 데이터를 전달할 때의 규격을 정한다.
- php에서는 클래스를 통해서 타입을 만들 수 있다. 클래스를 하나 만들어 파라메터로 클래스 타입을 지정하고, 해당 클래스로 만든 오브젝트를 인자로 전달하는 것을 통해 전달 받는 인자의 스펙을 명확하게 할 수 있다.
```php
class Dto
{
    public function __construct(
        public int $c,
        public int $d,
    ) {
    }
}

$fn = function($a, $b, Dto $cdObj) {
    var_dump($a);
    var_dump($b);
    var_dump($cdObj->c);
    var_dump($cdObj->d);
};

$fn(1, 2, new Dto(3, 4));
```
- 문제는 타입힌트를 사용하기 위해서 클래스를 사용해야 한다는 것인데, 함수에 인자를 전달하기 위해서 인자를 생성하는 부분에서 객체를 생성하기 위해서 클래스 코드가 존재해야 하며, 함수의 파라메터를 타입힌트로 쓰기 위해서 클래스 코드가 존재해야 한다. php에서 함수 또는 메소드를 여러 파일에서 네임스페이스를 통해서 사용하려고 한다면 인자를 전달 할 때 DTO 클래스를 통해서 객체를 만들어야 하므로 DTO 파일도 불러 쓸 수 있는 형태가 되어야 한다. 따라서 DTO 클래스를 별도의 파일로 분리해야 하므로 파일의 배치 폴더 구조 클래스 코드 네임스페이스 등 보일러 플레이트가 많아진다는 단점이 생긴다.

## Reference
- https://www.php.net/manual/en/functions.arguments.php
