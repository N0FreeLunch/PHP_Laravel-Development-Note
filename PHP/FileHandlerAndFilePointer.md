## 파일 헨들러와 파일 포인터

### 디스크의 동작

컴퓨터는 데이터를 0과 1로 저장을 한다. 0과 1의 상태를 1비트로 표현을 하고, 1비트의 상태가 8개가 모이면 1바이트가 된다. 하드웨어는 연속된 이진 상태 저장 공간을 가지고 있다. 연속된 저장 공간을 가진다는 것은, 어떤 데이터를 찾을 때 인덱스 번호를 통한 접근을 할 수 있어 빠르게 데이터에 접근할 수 있다는 것을 의미한다. 컴퓨터가 데이터를 다룰 때는 가능한 빠른 것이 좋기 때문에 가능한 연속된 저장 공간을 갖도록 설계를 한다.

디스크에 저장된 파일은 빈번히 저장되고 삭제되고 변경된다. 일부 데이터가 지워진 자리에 새로운 파일을 저장할 때 파일의 크기가 커서 저장될 수 없다면, 파일의 데이터를 분할해서 이곳 저곳에 저장해야 한다. 그래서 모든 저장 공간을 연속적으로 만들지 않고, 일정 단위로 연속된 저장 공간을 만들다. 이를 블록이라고 하는데 큰 파일의 경우 여러 블록에 데이터를 나눠 저장을 한다.

컴퓨터는 하드웨어에 기록된 데이터를 읽거나 쓰는 경우 블록이란 단위로 데이터를 읽고 쓴다. 아무리 작은 데이터를 취득할 때에도 한 단위의 블록을 읽어야 한다. 디스크에 대한 접근은 파일시스템에서 관리를 하는데, 파일 시스템은 하나의 블록의 데이터를 읽기 위해서 블록의 크기 이상의 메모리 공간을 최소한 사용해야 한다. 블록은 데이터를 읽고 쓰기 위한 단위의 개념으로 하나의 블록은 일반적으로 연속된 저장 공간을 가지지만 하드웨어의 설계에 따라 반드시 연속적인 저장공간만을 가지는 것만은 아니다.

### 파일 데이터의 변경

어떤 파일의 데이터가 변경되었다고 가정해 보자. 해당 파일의 용량이 크다면 여러 블록에 걸쳐 데이터가 저장될 것이고, 파일의 용량이 작다면 하나의 블록 안에 다른 파일의 데이터들과 함께 저장될 수 있다. 예를 들어 `ABCDEFG`라는 데이터가 있고, 하나의 블록이 4개의 문자를 저장한다고 가정하자. 이 경우 `ABCD`와 `EFGH`가 두 개의 블록에 저장된다. 그런데 `ABCD123EFGH`으로 123이란 데이터가 추가 되었다고 하자. 그러면 `ABCD` `123E` `FGH_`으로 분할하여 각각의 블록에 저장을 할 것이다. (\_는 빈 저장공간이라고 하자.) 데이터의 추가 및 제거로 인하여 각각의 블록에 저장되는 데이터 세트가 달라진다는 것을 알 수 있다. 하지만 블록을 새로 쓰는 것은 효율적이지 못하고 쓰기 작업은 하드웨어의 수명을 단축시키므로 `ABCD` `123_` `EFGH`와 같이 기존의 블록은 그대로 두고 추가 되는 데이터만 따로 새 블럭에 추가한다. 이 때 하드웨어의 연속된 저장 공간에 데이터가 저장된 것은 아니지만 논리적으로 연결된 데이터로 만들어진다.

데이터를 삭제하는 경우에는 `ABCD` `123_` `EFGH`에서 A,B,1,2를 삭제하면 삭제된 데이터는 빈 공간으로 남게되며 `__CD` `__3_` `EFGH`가 된다. 데이터를 삭제할 때는 기존의 데이터는 그대로 두고 삭제할 저장 공간의 데이터만 지우는 방식으로 동작한다. 하드웨어에서의 데이터는 불연속적이게 되지만, 논리적으로는 연속된 공간으로 만들 수 있기 때문에 효율적인 데이터 저장을 위해 빈 공간으로 남겨준다.

SSD가 보편화 되기 전 하드디스크를 조각모음하는 경우가 있었다. 읽고 쓰는 작업이 많아지면 하드웨어에 저장된 데이터가 불연속적이게 되어 논리적으로 데이터를 연결하는데 컴퓨팅 리소스를 많이 소비하므로 조작 모음을 통해 데이터를 물리적으로 연속적되게 저장해 리소스 소비량을 줄이고 빠르게 동작하도록 만들 수 있었다. SSD의 경우에는 데이터가 조각화 되더라도 연속적인 경우와 큰 차이 없는 속도이므로 조각 모음을 할 필요성이 없어졌다.

## File handler

### 파일 헨들러란?

파일 헨들러는 파일에 기록된 데이터를 바이트 단위로 읽고 쓸 수 있는 기능을 제공한다. 파일 헨들러를 사용하여 파일의 모든 데이터를 메모리에 올려 놓지 않고 파일의 내용을 읽기, 쓰기를 할 수 있다.

파일의 모든 내용을 메모리에 미리 적재하지 않기 위해 파일 핸들러는 파일 포인터라는 위치 추적기를 사용한다. 파일 포인터는 파일 내에서 현재 읽기 또는 쓰기 작업을 하기 위한 지점을 가리킨다.

### 왜 파일 헨들러를 사용하는가?

파일이란 바이트 단위의 크기를 가질 때도 있고, 킬로 바이트 단위의 크기를 가질 때도 있고, 메가 바이트 단위의 크기를 가질 때도 있다. 때로는 기가 바이트 단위의 단일 파일도 있고 더 큰 용량의 파일도 존재한다. 이런 단일 파일을 프로그래밍으로 내용을 변경하고자 할 때 모든 파일의 내용을 메모리에 올리려면 파일의 용량 이상의 메모리 사용량이 요구된다.

어떤 프로그램이 어떤 파일을 처리할 때 전달되는 파일의 용량은 항상 일정한 것은 아니다. 파일에 대해 동일한 처리를 수행하는 프로그램이라도 유저가 원하는 파일 크기에 따라 작은 용량을 처리할 때도, 큰 용량을 처리할 때도 있다. 프로그램이 사용하는 메모리는 가능한 일정한 한계선을 두고 만드는 것이 좋으며, 무한정 메모리를 소모하게 되면 컴퓨터가 사용할 수 있는 하드웨어 메모리 리소스를 초과하거나 OS에 할당된 메모리 리소스를 초과하여 프로그램이 의도치 않게 종료되는 크레시 현상이 발생할 수 있다.

프로그램이 크레시로 인해 강제 종료되면, 애플리케이션을 다시 기동해야 할 뿐만 아니라, 처리하고 있던 작업이 손실되며, 처리 문제가 발생했을 때 예외처리를 비롯한 각종 후속처리가 이뤄지지 않으므로 복구하기 어렵거나 불가능한 여러 문제가 발생할 수 있다. 따라서 크레시로 인한 종료 현상을 최대한 막기 위해서 애플리케이션의 메모리 관리를 잘 해 줘야 한다.

파일 헨들러를 사용하면 파일의 특정 지점까지의 데이터를 메모리에 올리고 프로그래밍을 통해서 메모리에 올린 데이터를 처리할 수 있다. 처리가 끝나면 파일을 최종적으로 읽은 지점부터 특정 지점까지의 데이터를 메모리에 올리는 작업을 반복하여, 파일 전체의 데이터가 아닌 적당한 크기 만큼의 데이터를 메모리에 올려서 처리하기 때문에 메모리 사용량이 절약된다. 파일 헨들러를 이용하여 메모리 사용량을 줄일 수 있는 로직을 만들 수 있어 애플리케이션에서 파일 처리로 인한 메모리 문제를 예방할 수 있다.

### 웹 애플리케이션에서 파일 처리

웹 애플리케이션은 수 많은 리퀘스트를 처리하는 프로그램이다. 웹 애플리케이션 서버는 여러 리퀘스트를 동시에 처리하는데, 만약 여러 유저가 업로드한 파일을 동시에 처리하게 되거나, 유저가 큰 용량의 파일을 업로드 하게 되면 하나의 리퀘스트를 처리하는데 많은 메모리를 사용하게 되고 이런 현상이 여러 리퀘스트에 동시에 일어나게 되면, 하드웨어나 OS에서 가용 가능한 메모리 자원을 다 소비하여 크레시가 발생할 수 있다.

많은 리퀘스트의 처리가 동시에 일어나는 웹 애플리케이션의 메모리 사용량은 동시에 일어나는 모든 리퀘스트가 사용할 수 있는 총 메모리 사용량에 상한선을 두고, 메모리 사용량이 정해진 상한선을 초과하지 않도록 관리해야 웹 애플리케이션의 크레시를 방지할 수 있다.

처리할 파일의 용량의 상한선이 정해지지 않았는데 파일에서 많은 양의 데이터를 취득해서 메모리에 올리게 되면 메모리 크레시가 발생하므로 파일 헨들러를 사용해서 파일 데이터를 처리할 때는 파일 데이터를 분할해서 메모리에 올려 처리해야 한다. 하지만 분할해서 처리를 하게 되면 그만큼 처리 시간이 늘어나게 된다.

php의 경우 처리하는 시간이 길어지면 하나의 리퀘스트 프로세스를 계속 점유하므로, 하나의 프로세스가 갖는 CPU 및 메모리 자원을 동시에 처리할 수 있는 리퀘스트의 수가 감소하게 된다. php 서버에서 동시에 처리할 수 있는 프로세스의 수는 서버 설정에 의해 제한되어 있기 때문에, 리퀘스트가 처리되지 않으면 가용할 수 있는 프로세스의 수가 줄어들면서 서버의 이용이 어렵게 되는 경우가 있다. 따라서 시간이 오래 걸릴 가능성이 있는 파일 처리는 가능한 웹 애플리케이션 서버가 아닌 큐 시스템 또는 배치 시스템을 이용하여 처리하는 편이 낫다.

## File pointer란?

책을 읽는데 전에 읽었던 페이지가 어딘지 쉽게 확인하기 위해서 책갈피를 사용한다. 파일 포인터는 책갈피의 역할을 하며 파일을 읽을 때 어느 지점까지 읽고 있는지를 표기하기 위해 사용한다.

기본적으로 컴퓨터가 데이터를 읽는 기본 단위는 바이트 단위이다. 메모리에서 바이트 단위로 데이터를 읽어서 비트 데이터를 읽고, 비트 단위의 데이터를 변경하면 바이트 단위로 다시 변수에 할당하는 작업을 한다.

컴퓨터의 읽기 단위가 바이트 단위이므로 파일 포인터는 바이트와 바이트 사이에 위치하는 책갈피 개념으로 생각하면 편하다. 바이트와 바이트 사이에 어디까지 읽었는지 표시하는 위치 정보를 다루는 기능을 파일 포인터로 여기면 된다. 좀 더 정확하게는 바이트와 바이트 사이가 아닌 파일 포인터는 파일의 시작점 부터 몇 번째 바이트에 있는지에 인덱스 값으로 처리하고 있는 지점의 위치 정보를 저장하는 것이다.

파일 헨들러가 제공하는 데이터의 위치를 파악하는 파일 포인터를 통해서 컴퓨터는 하드웨어의 특정 지점의 데이터를 읽거나, 쓰거나, 변경하는 명령을 내릴 수 있다.

기본적으로 하나의 파일 핸들러가 컨트롤하는 파일 포인터는 하나인데, 이는 하드웨어에 있는 데이터를 한꺼번에 읽지 않고 하드웨어에서 직접 가져오기 때문이다. 데이터가 다른 요인에 의해 변경이 되면 파일의 시작점 부터 N 번째 글자까지의 글자가 줄어들거나 늘어날 수 있으므로, N번째 다음 부터의 글자를 처리할 때 원하는 대상의 내용이 아닐 수 있다. 데이터가 부정확하게 다뤄질 수 있기 때문에 기본적으로 하나의 파일은 하나의 헨들러가 점유하며, 하나의 헨들러는 하나의 파일 포인터를 갖도록 한다.

물론 하나의 파일에 여러 파일 헨들러를 동시에 사용할 수 있지만, 이 경우 데이터의 변경에 따라 파일 포인터가 가리키는 값이 달라질 수 있으므로 다루기 까다로워진다.

### 동시적 변경 시의 파일 포인터

`ABCDEFGH`라는 글자가 적혀 있다고 하자. 하나의 헨들러의 파일 포인터 P1이 D와 E 사이에 위치한다고 하자. `123`이란 글자를 추가 하면 P1 파일 포인터 위치에서 `123`의 데이터가 추가된다. 물리적으로는 서로 다른 블록으로 데이터가 추가되더라도 논리적으로 연결이 되기 때문에 `ABCD123EFGH`와 같이 연속된 데이터로 다루게 된다. 다른 파일 포인터 P2가 F와 G 사이에 위치했다고 하자. 이때 파일의 시작 지점에서 인덱스는 6이다. P2 파일 포인터는 인덱스 값 6을 가리키고 있으므로 `123`이란 데이터의 추가로 인해 `ABCD123EFGH`에서는 `2`와 `3` 사이에 파일 포인터가 위치하게 된다. P1 포인터를 컨트롤 하는 파일 헨들러가 `ABCD`의 다음 데이터인 `EFGH` 취득하려고 하는데, 데이터의 변경으로 인해서 `ABCD12` 다음의 데이터인 `EFGH`를 취득하게 되는 것이다. 하나의 파일 데이터를 여러 파일 헨들러로 동시에 변경하게 되면, 파일 포인터가 저장하는 인덱스는 동일하지만 P2 파일 포인터가 F와 G 사이에 위치했지만 `2`와 `3` 사이에 위치되는 것과 같이 상대적인 관계가 변경되기 때문에 파일을 다룰 때 의도한 바와 다른 동작을 하게 된다.

### 파일 조작 모드

파일을 조작할 수 있는 모드는 읽기 모드 (r: read), 쓰기 모드 (w: write), 추가 모드 (a: add), 배타적 생성 모드 (x: exclusive)로 나뉘어져 있다.

읽기 모드(r)는 저장되어 있는 파일을 읽기 위한 용도로 사용되며, 쓰기 모드(w)는 이미 존재하는 파일의 데이터를 지우고 새롭게 데이터를 생성하거나 새로운 파일을 만들기 위한 용도로 사용되며, 추가 모드(a)는 기본 파일의 끝에 데이터를 추가하기 위한 용도로 사용된다. 배타적 생성 모드는 쓰기 모드가 기존 파일을 덮어 쓰는 반면, 기존 파일이 존재할 때는 파일을 생성하지 않고 실패하는 모드이다.

파일 헨들러를 이용하는 것은 파일을 데이터의 일부만 메모리에 올리기 위한 용도로 사용된다. 따라서 데이터를 읽거나 추가하거나 변경을 하기 위해서는 파일 포인터 지점에서 새롭게 데이터를 읽거나 변경하거나 추가하는 작업을 해야 한다. 파일 헨들러를 통해서 파일을 조작할 때 하나의 파일을 여러 파일 헨들러가 조작을 하는 경우 파일의 파일의 시작점에서 동일한 인덱스의 위치라고 하더라도 데이터 간의 상대적인 위치는 달라질 수 있다. 그래서 파일의 데이터를 변경할 때는 다른 헨들러의 파일 포인터가 의도와는 다른 데이터를 건드리는 경우가 생기므로 읽거나 쓸 수 없도록 락을 건다.

하나의 파일 조작 모드를 사용해서 파일을 조작하는 경우 다른 모드로 파일을 열 수 없도록 한다. 이는 파일 데이터에서 파일 포인터의 상대적 위치가 달리지는 문제를 방지하기 위함이다.

쓰기 모드(r)가 존재하는데 왜 추가 모드(a)가 있을까? 추가 모드는 파일의 마지막에 데이터를 추가하는 것으로 기존의 데이터 중간에 데이터를 추가하거나 변경하지는 못한다. 파일을 여는 모드는 권한과 관련이 있는데, 파일을 수정하거나 변경하지는 못하더라도 로그와 같이 어떤 무언가를 계속 남겨야 하는 권한이 필요할 수 있다. 이 때 사용하는 것이 추가 모드(a)이다.

#### + 모드

각각의 파일 조작 모드 읽기(r), 쓰기(w), 추가(a) 모드가 존재한다. 각각의 모드에 + 옵션을 추가하여 r+, w+, a+ 모드를 만들 수 있는데 다음과 같이 동작한다.

읽기 모드에서 플러스 (r+) : 존재하는 파일의 데이터를 읽고 수정할 수 있는 용도로 사용된다. 이 모드는 파일의 크기 변경 여부에 따라 동작이 다르다. 파일 크기가 변하지 않은 경우, 기존 블록 구조를 변경하지 않고 이미 할당된 블록 내에서 데이터를 덮어쓰거나 수정할 수 있다. 수정된 데이터는 데이터를 꺼낸 블록과 동일한 블록 위치에 덮어 씌워진다. 반면, 데이터의 크기가 변경되는 경우, 파일 시스템은 필요한 경우 새로운 블록을 할당하거나 기존 블록에 이어서 데이터를 저장할 수 있다. (이는 이해를 위한 개념으로 디스크 하드웨어는 다양한 기술을 도입하고 있으므로 실제 동작과는 정확히 일치하지 않을 수도 있다.)

쓰기 모드에서 플러스 (w+) : 존재하는 파일의 데이터를 읽을 필요가 없는 경우 사용한다. 이미 존재하는 파일에 대해 w나 w+으로 파일을 열면 기존 파일의 길이를 0으로 만들기 때문에 파일의 데이터는 삭제된다. 파일을 연 시점에 파일의 크기가 0이 되기 때문에 쓰기 작업 중간에 오류가 발생해도 이전 파일 데이터가 복원되지 않는다. 쓰기 모드(w)는 데이터를 쓰기만 할 뿐, 쓰기 작업을 하면서 새롭게 추가한 데이터를 읽을 수는 없는 반면, w+의 경우에는 데이터를 쓰면서 추가한 데이터를 읽을 수 있는 기능을 제공한다. w+는 파일을 열기 이전 데이터를 읽을 수는 없으며, 파일을 열고 나서 추가한 데이터만 읽을 수 있다는 점에 주의하자.

추가 모드에서 플러스 (a+) : 존재하는 파일의 끝에 데이터를 추가하는 a 모드에 + 옵션을 붙이면 파일 내용을 읽을 수 있는 기능을 제공한다. 파일의 쓰기는 파일의 끝 부분에서만 이뤄지지만 읽기가 가능한 + 모드는 파일의 마지막 부분 뿐만 아니라 다른 위치의 데이터로 읽을 수 있다. 읽기를 위한 파일 포인터는 파일 내에서 자유롭게 이동할 수 있지만, 파일의 쓰기는 파일 포인터에 관계 없이 끝에만 위치하여 데이터가 추가 된다. (기본적으로 파일 포인터는 하나이지만 a+ 모드에서는 파일 포인터가 끝에 고정되어 있으므로 읽기를 위해 읽기 전용의 별도의 포인터 개념이 사용된다.)

#### 생성 모드

php에서 파일 조작으로는 읽기, 쓰기, 추가, 배타적 생성 모드 이외에 생성 모드 (c: create)라는 특별한 모드를 사용할 수 있다.

php의 fopen 함수에서만 사용할 수 있는 생성 모드(c)는 쓰기 모드(w)와 비슷하지만 쓰기 모드가 기존 파일의 데이터를 모두 지우고 새로 파일을 쓰는 것과 달리, 데이터를 지우지 않고, 필요한 경우 데이터를 어느 지점부터 지울 것인지를 정할 수 있는 기능을 제공한다. 파일의 시작부터 지정한 파일 포인터의 위치까지 기존 파일의 데이터를 사용하고 그 이후 부터 파일의 데이터를 쓸 수 있는 기능을 제공한다.

지정한 인덱스의 바이트까지만 기존 데이터를 사용하고 그 이후로는 w 모드와 같이 데이터를 새로 쓰기 위한 용도로 사용할 수 있다. 파일을 열어서 지정한 위치의 바이트까지 파일 포인터를 이동시킨 후, `ftruncate` 함수를 사용해 파일을 잘라 지정한 만큼의 파일 길이 만큼을 기존이 파일 데이터를 사용하고, 해당 파일 포인터 지점 이후에는 쓰기 모드(w)와 동일하게 동작한다. c 모드는 파일을 열 때 파일 잠금이 되지 않으므로 `ftruncate` 함수로 파일을 자르기 전에 파일 잠금을 해서 외부 헨들러에 의한 파일 조작이 일어나지 않게 해야한다.

생성 모드에서 플러스 (c+) : c로 w와 같이 파일을 쓰던지, c+로 w+와 같이 파일을 쓰고 데이터를 읽을 수 있는 기능을 제공한다.

## Byte에 대해 더 이해하기

컴퓨터에 저장되는 데이터의 단위는 바이트단위로 되어 있다. 컴퓨터 아키텍처에서 메모리 또는 디스크에서 인식 가능한 주소를 지정할 수 있는 최소 단위가 바이트이다. 파일 포인터가 바이트단위인 이유도 하드웨어의 인식가능한 주소의 단위가 바이트이기 때문이다.

비트 단위로 접근하려면 바이트 단위로 데이터를 읽어 변수에 저장한 후, 이를 조작해야 한다. 하드웨어가 바이트 단위를 기본 처리 단위로 사용하기 때문에, 이에 맞춰 비트 단위의 파일 포인터 이동을 하도록 만들어지지 않고 바이트 단위의 파일 포인터 이동을 하도록 만들어졌다. 소프트웨어의 데이터 취득 단위와 하드웨어의 데이터 취득 단위가 다르게 되면 비효율적인 변환 비용이 발생하게 된다.

파일의 기본 단위를 8 비트인 바이트단위로 나눠야 한다는 절대적인 이유는 없지만 숫자, 영문, 일부 특수기호, 제어문자를 구분하기 위한 단위로서 8비트를 표준으로 정의하였다. 컴퓨터의 역사에서 초기 문자를 정의할 때 ASCII 코드를 사용했다. ASCII 코드는 7비트로도 숫자, 영문, 일부 특수기호, 제어문자를 표시하였으며, 이진수인 컴퓨터가 표기할 수 있는 3자리 수가(2^3) 8비트이므로 8비트를 사용하여 문자를 표기하기 시작하였다. 초창기에는 7비트로 ASCII 코드를 정의했지만, ASCII 코드도 8비트로 표기하기 시작했다. 초기 개인용 컴퓨터가 보급되기 시작한 시점에서 8비트 단위로 데이터를 처리를 하였기 때문에 8비트를 1바이트로 사용하는 것이 표준이 되었다.

너무 많은 비트를 1 바이트로 지정하면 하나의 문자가 차지하는 용량이 커지고 너무 적은 비트를 1 바이트로 지정하면 원하는 문자를 표현하는데 여러 비트를 사용하거나 가변 바이트를 사용하게 되어 용량을 많이 차지하게 된다. 개인용 컴퓨터가 보급될 시점에 적절한 타협점으로 8비트를 데이터 처리의 가장 기본 단위로 만든 것이다.

8비트를 하나의 문자열로 다루는 인코딩 방식은 ASCII 코드 뿐만 아니라 EBCDIC 코드가 있다. 숫자, 영문, 일부 특수기호, 제어문자와 다국어 지원 문자로 255개의 문자를 채울 수 있도록 만들어졌다. 일본어의 경우 EBCDIC 포멧을 이용할 때 반각 가나를 추가해서 사용하고 있다. 일본 은행의 통장을 보면 반각가나로 이뤄져 있는데 EBCDIC 인코딩을 사용할 때의 형식을 계속 지금까지 이어서 사용하고 있기 때문이다. 코볼을 쓰는 오래된 금융 시스템을 개선하기 어려운 요인으로 아직까지도 통장 명의는 반각가나로 이뤄져 있는 것으로 보인다.

## 1바이트를 초과하는 문자의 등장

많은 나라에서 컴퓨터를 이용함에 따라 다국어를 지원할 필요성이 생겼다. 8비트만으로는 표현할 수 없는 문자수를 가진 나라들이 생겨서 하나의 문자를 표현하는데 여러 바이트를 사용하여 하나의 문자를 나타내는 문자열 인코딩 방식이 도입되었다. 2바이트를 사용하여 문자를 표현하는 방식 및 문자에 따라 1바이트가 될 때도 있고 2바이트가 될 수도 있는 가변 바이트를 사용하는 방식의 인코딩 방식도 있으며, 유니코드를 포함하는 문자 집합의 경우 최대 4바이트까지 사용한다.

## 프로그래밍에서 파일을 처리하는 방법

- 파일 전체를 한 번에 읽는다.
- 파일을 열어서 조금씩 읽어들인다. 

## 파일을 나눠서 읽어야 하는 경우

파일 전체를 한 번에 읽어서 메모리에 파일 내용을 적재해야 하는데 '파일 데이터를 변수에 담아 메모리에 올릴 때 필요한 메모리 사이즈' + '코드를 처리할 때 사용하는 추가 메모리'가 php 프로세스에서 허용하는 메모리 보다 커질 수 있다. 물론 php의 메모리 사이즈 및 하드웨어의 메모리 사이즈 및 가상메모리 사이즈 등을 늘릴 수 있지만 파일의 용량은 일반적으로 한없이 늘어나는 경우를 고려해야 하기 때문에 제한된 메모리 내에서 동작하는 코드를 작성해야 이후 시스템의 확장에 대응할 수 있다. 파일 사이즈가 어느 용량 이하로 정해져 있다면 파일을 한 번에 읽는 방식을 사용해도 괜찮다.

## 헨들러를 사용하여 데이터를 나누어 읽을 때

파일 헨들러를 사용한다는 것은 파일의 전체 내용을 메모리에 적재하는 것이 아니라, 파일 포인터를 이용하여 필요한 기준 지점에서 지정한 양만큼의 바이트를 읽고 삭제하거나 기준 지점에 새로운 바이트를 추가하는 방식을 사용할 수 있다.

파일 전체를 메모리에 적재하는 것이 아니라 필요한만큼 쪼개어 메모리에 올리는 방식으로 처리할 수 있기 때문에 대용량의 파일을 처리할 때 유용한 방법이다.

## php에서 전체 파일 읽기

#### [`file_get_contents`](https://www.php.net/manual/en/function.file-put-contents.php)

지정한 파일 전체 컨텐츠를 읽어서 php의 변수에 저장할 수 있다. 파일의 데이터가 큰 경우 php 프로세스에 인가된 메모리 한도를 초과할 수 있기 때문에 파일의 크기가 제한되어 있다는 전제 하에서만 사용하도록 한다.

## php에서 파일 헨들러 사용하기

읽어야 할 파일의 사이즈를 정확히 알기 어렵거나, 파일의 사이즈가 큰 경우 데이터를 분할 처리하는 용도로 사용한다.

#### [`fopen()`](https://www.php.net/manual/en/function.fopen.php)

파일을 열고 파일 헨들러를 반환 받는다.

#### [`fread()`](https://www.php.net/manual/en/function.fread.php)

파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 갯수의 연속된 바이트를 읽는다. 연속된 바이트를 읽다가 읽을 수 없는 지점이 나오면 읽은 부분까지의 바이트를 반환한다. 이때 파일 포인터는 읽은 바이트만큼 이동한다.

#### [`fget()`](https://www.php.net/manual/en/function.fgets.php)

파일헨들러가 가지고 있는 파일 포인터 위치에서 파일의 개행 문자 또는 EOF가 나타날 때까지 바이트를 읽고 반환한다. 지정한 갯수의 연속된 바이트를 읽을 수 있으나 개행 또는 파일 끝을 나타내는 부분이 나오기 전까지의 바이트만 읽는다. 이때 파일포인터는 읽은 바이트만큼 이동한다.

하나의 행이 갖는 데이터의 크기가 클 수 있기 때문에, 각각의 행 데이터의 크기가 다룰 수 있는 사이즈라는 전제 하에서 사용해야 한다. 다루기 위한 파일의 행 크기는 미리 벨리데이션 처리를 하여 일정 사이즈 이하로 제한하는 편이 좋다.

#### [`fwrite()`](https://www.php.net/manual/en/function.fwrite.php)

파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 바이트를 주입한다. 이때 파일포인터는 추가한 바이트만큼 이동한다.

#### [`fclose()`](https://www.php.net/manual/en/function.pclose.php)

함수를 사용하여 파일 헨들러를 닫는다. 파일 헨들러를 닫게 되면 OS가 관리하고 있는 파일락이 해제 되면서 이 헨들러가 아닌 다른 작업으로 파일 변경을 할 수 있게 만들어 준다.

## 파일 포인터의 이동

- 파일헨들러가 제공하는 파일 포인터를 통해서 파일의 어느 바이트를 읽을 것인지 어느 지점에 바이트를 추가할지를 정한다.
- 물리적 하드웨어가 하나의 바이트를 쓰거나 읽으면 그 다음 포인터에 위치하게 된다. 소트프웨어의 포인터는 가상의 포인터이지만 물리적 하드웨어가 가지는 포인터와 움직임을 동일하게 하여 파일 포인터의 조작에 따른 하드웨어의 움직임을 자연스럽고 직관적으로 만들기 때문에 바이트 읽기와 쓰기 이후에는 파일 포인터가 그 뒤로 이동하는 것을 따른다. 하지만 최근의 플래시 메모리 하드웨어의 경우 하드웨어의 파일 포인터의 의미를 많이 퇴색하게 만든 부분도 있다.
- php에서 제공하는 파일시스템의 바이트 읽기 및 추가를 하는 함수는 연속적인 바이트를 읽어야 하기 때문에 하나의 바이트를 읽으면 파일 포인터를 읽은 포인터 다음으로 이동시킨다. 1 바이트 작업 후 그 뒤의 포인터로 이동해야지 연속적인 바이트 작업의 로직이 단순해진다. php에서 제공하는 연속적인 바이트를 추가하는 함수도 1 바이트를 이동하는 기능을 합쳐 놓은 단순한 형태이기 때문에 연속적인 바이트를 추가한 후 그 뒤로 파일 포인터를 이동시키는 특성을 가지고 있다.
- 바이트를 읽거나 추가를 해도 파일 포인터가 이동하지 않도록 만들 수도 있더. 그러나 php의 함수는 파일 포인터에 대한 가장 직접적인 접근방식을 사용기 때문에 파일을 읽고 쓰게 되면 파일 포인터는 읽고 쓰기한 다음 바이트에 위치한다. 파일을 읽고 쓰기 한 다음 원래 위치로 포인터를 되돌리고 싶다면 [`fseek()`](https://www.php.net/manual/en/function.fseek.php) 함수를 사용하여 이동한 포인터 위치 만큼 되돌아 가 주면 된다.

### loop와 파일 포인터

```php
$handle = fopen("http://www.example.com/", "rb");
if (FALSE === $handle) {
    exit("Failed to open stream to URL");
}

$contents = '';

while (!feof($handle)) {
    $contents .= fread($handle, 8192);
}
fclose($handle);
```
- `feof`는 헨들러의 포인터가 파일 끝에 도달했는지를 확인한다. `!feof($handle)` 헨들러의 포인터가 파일 끝에 도달하지 않았기 때문에 파일의 마지막 부분에 포인터가 도착할 때까지 루프를 돈다.
- 루프가 돌아갈 때마다 `fread($handle, 8192)` 8192 바이트의 문자를 읽고 파일 헨들러의 파일 포인터를 읽은 문자 다음으로 둔다. `fread` 함수로 바이트를 읽을 때 마다 파일 포인터가 읽은 다음에 위치하기 때문에 루프가 돌아가면서 `fread` 함수를 사용하는 것만으로 파일의 전체 데이터를 얻어낼 수 있다.

```php
$fp = @fopen("/tmp/inputfile.txt", "r");
if ($fp) {
    while (($buffer = fgets($fp, 4096)) !== false) {
        echo $buffer;
    }
    if (!feof($fp)) {
        echo "Error: unexpected fgets() fail\n";
    }
    fclose($fp);
}
```
- `($buffer = fgets($fp, 4096)) !== false`에서 `$buffer = fgets($fp, 4096)`가 반환하는 값은 `$buffer`에 담고 있는 `fgets($fp, 4096)` 값이다. `$buffer`와 `false`가 `!==`으로 비교가 된다.
- `fgets($fp, 4096)`를 사용하는 것만으로도 파일 포인터가 이동하게 된다. 이외의 따로 파일 포인터를 옮기는 과정 없이도 파일을 읽게 된다.

## 인코딩

- 파일을 읽을 때는 바이트 단위로 읽는다고 읽는데 문자열 인코딩은 때로는 한 바이트가 아닌 여러 바이트가 하나의 문자를 가리키는 경우가 있다. 또한 언어에 따라 바이트가 나타내는 값(비트 값)과 언어 문자 사이의 매핑은 인코딩 방식에 따라 다를 수 있다.
- php에서 바이트를 읽은 결과를 나타내는 `fget()`, `fread()` 등의 함수로 바이트를 읽은 결과는 특별한 지시가 없는 한 어떤 문자열로 보여지는 상태는 아니다. echo 등을 통해서 이 데이터의 문자열을 확인하려고 한다면 php는 single byte set으로 문자열을 보여주며, 이 때 사용하는 single byte set은 ISO-8859-1, US-ASCII 을 사용한다. php의 default 변환 문자는 ISO-8859-1 방식이므로 `À	Á	Â	Ã	Ä	Å	Æ	Ç	È	É	Ê	Ë	Ì	Í	Î	Ï   D   Ð 	Ñ	Ò	Ó	Ô	Õ	Ö	×	Ø	Ù	Ú	Û	Ü	Ý	Þ	à	á	â	ã	ä	å	æ	ç	è	é	ê	ë	ì	í	î	ï ð	ñ	ò	ó	ô	õ	ö	÷	ø	ù	ú	û	ü	ý	þ	ÿ`와 같은 문자를 보여준다.
- UTF-8, SJIS, ECU-KR 등의 멀티 바이트 인코딩의 문자열이 들어 있던 파일이라면 이 바이트 데이터의 문자열을 제대로 나타내기 위해서는 멀티 바이트 데이터를 적절하게 묶어 주는 인코딩을 사용하여 원하는 문자열로 출력해야 한다.

## References
- https://stackoverflow.com/questions/5249279/file-get-contents-php-fatal-error-allowed-memory-exhausted
- https://en.wikipedia.org/wiki/Byte
- https://www.php.net/manual/en/xml.encoding.php
