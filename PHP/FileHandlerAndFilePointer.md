## File handler
- 파일 헨들러는 파일의 바이트 정보를 읽기 및 추가를 할 수 있는 기능을 제공한다.
- 파일 헨들러를 사용하여 파일을 읽는 것은 파일의 모든 정보를 메모리에 올려 놓지 않고 파일의 내용을 읽기, 쓰기를 할 수 있는 기능이다.
- 메모리에 파일 정보를 미리 적재하지 않기 위해서 파일 헨들러는 파일에 파일 포인터를 위치시킨다. 그런데 포인터가 위치한 파일이 이동하거나 파일의 데이터가 변경되면 파일 포인터의 동작에 문제가 생긴다. 위치한 파일 포인터에서 파일 내의 다른 포인터로 이동할 수도 없으며 파일의 잘못된 조작이 일어날 수도 있다. 따라서 파일에 포인터를 위치시키기 위해서는 파일헨들러가 파일을 점유해야 한다.
- OS는 파일 헨들러에게 파일을 점유할 수 있는 기능을 제공한다. OS가 제공하는 파일 점유 기능을 이용하면 파일 헨들러가 작동하고 있는 동안 OS는 외부 조작으로 인해 파일을 이동시키거나 파일 정보를 수정한다거나 하지 못하게 한다.

## File pointer
- 데이터를 바이트 단위로 나눴을 때 각각의 바이트와 바이트 사이에 위치하는 위치정보이다.
- 하나의 파일 헨들러가 컨트롤하는 파일 포인터는 하나이다. 
- 파일헨들러의 파일 포인터가 위치하는 지점에 바이트 정보의 추가를 할 수 있다.
- 파일헨들러의 파일 포인터가 위치하는 지점에서 n번째 바이트 정보까지 읽을 수 있다.

## Byte
- 컴퓨터에 저장되는 데이터의 단위는 바이트단위로 되어 있다. 컴퓨터 아키텍처에서 메모리 또는 디스크에서 인식 가능한 주소를 지정할 수 있는 최소 단위가 바이트이다. 파일 포인터가 바이트단위인 이유도 하드웨어의 인식가능한 주소의 단위가 바이트이기 때문이다. 
- 비트단위로 접근하기 위해서는 바이트 단위로 데이터를 읽어내어 최소단위가 바이트인 변수에 저장을 해서 문자를 하나씩 읽어야 한다. 그러니까 하드웨어 단위에서 비트 단위의 포인터 이동은 불가능하다.
- 파일의 기본 단위를 바이트단위로 나눠야 한다는 절대적인 이유는 없지만 숫자, 영문, 일부 특수기호, 제어문자를 구분하기 위한 단위로서 8비트를 표준으로 정의하였다. ASCII 코드를 보면 7비트로도 숫자, 영문, 일부 특수기호, 제어문자를 표시할 수 있지만 다국어의 추가 문자를 지원하기 위해 8비트를 사용하기 시작하였다.
- 8비트 문자를 사용할 때 초기 개인용 컴퓨터가 보급되기 시작하였고 이 컴퓨터가 8비트 단위로 데이터를 처리를 하였기 때문에 8비트를 1바이트로 사용하는 것이 표준이 되었다.
- 너무 많은 비트를 1 바이트로 지정하면 하나의 문자가 차지하는 용량이 커지고 너무 적은 비트를 1 바이트로 지정하면 원하는 문자를 표현하는데 여러 비트를 사용하거나 가변 바이트를 사용하게 되어 용량을 많이 차지하게 된다.
- 8비트를 하나의 문자열로 다루는 초기 인코딩 방식은 EBCDIC 코드이다. 숫자, 영문, 일부 특수기호, 제어문자와 다국어 지원 문자로 255개의 문자를 채울 수 있도록 만들어졌다. 일본어의 경우 EBCDIC 포멧을 이용할 때 반각 가나를 추가해서 사용하고 있다. 일본 은행의 통장을 보면 반각가나로 이뤄져 있는데 EBCDIC에서 쓰던 형식을 계속 따라서 사용하고 있는 것. 코볼을 쓰는 오래된 시스템도 EBCDIC 형식을 처리하는데 사용하고 있을 것으로 보임.

## 문자열
- 많은 나라에서 컴퓨터를 이용함에 따라 다국어를 지원할 필요성이 생겼다. 8비트만으로는 표현할 수 없는 문자수를 가진 나라들이 생겨서 하나의 문자를 표현하는데 여러 바이트를 사용하여 하나의 문자를 나타내는 문자열 인코딩 방식이 도입되었다.
- 2바이트를 사용하여 문자를 표현하는 방식 및 문자에 따라 1바이트가 될 때도 있고 2바이트가 될 수도 있는 가변 바이트를 사용하는 방식의 인코딩 방식이 있다.

## php에서 파일을 읽는 방법
- 파일 전체를 한 번에 읽는다.
- 파일을 열어서 조금씩 읽어들인다. 

## 파일을 나눠서 일어야 하는 경우
- 파일 전체를 한 번에 읽어서 메모리에 파일 내용을 적재해야 하는데 '파일 데이터를 php의 변수에 담아 메모리에 올릴 때 필요한 메모리 사이즈' + '코드를 처리할 때 사용하는 추가 메모리'가 php 프로세스에서 허용하는 메모리 보다 커질 수 있다. 물론 php의 메모리 사이즈 및 하드웨어의 메모리 사이즈 및 가상메모리 사이즈 등을 늘릴 수 있지만 파일의 용량은 일반적으로 한없이 늘어나는 경우를 고려해야 하기 때문에 제한된 메모리 내에서 동작하는 코드를 작성해야 이후 시스템의 확장에 대응할 수 있다.
- 파일 사이즈가 어느 용량 이하로 정해져 있다면 파일을 한 번에 읽는 방식을 사용해도 괜찮다.

## 헨들러를 사용하여 데이터를 나누어 읽을 때
- 파일 헨들러를 사용한다는 것은 파일의 전체 내용을 메모리에 적재하는 것이 아니라, 파일 포인터를 이용하여 필요한 양만큼의 바이트를 읽거나 바이트와 바이트 사이에 새로운 바이트를 추가할 때 사용한다.
- 파일 전체를 메모리에 적재하는 것이 아니라 필요한만큼 쪼개어 메모리에 올리는 방식으로 처리할 수 있기 때문에 대용량의 파일을 처리할 때 유용한 방법이다.

## php에서 전체 파일 읽기
- [`file_get_contents`](https://www.php.net/manual/en/function.file-put-contents.php) 함수를 사용하여 지정한 파일 전체 컨텐츠를 읽어서 php의 변수에 저장할 수 있다.

## php에서 파일 헨들러 사용하기
- [`fopen()`](https://www.php.net/manual/en/function.fopen.php) 함수를 사용하여 파일을 열고 파일 헨들러를 반환 받는다.
- [`fread()`](https://www.php.net/manual/en/function.fread.php) 파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 갯수의 연속된 바이트를 읽는다. 연속된 바이트를 읽다가 읽을 수 없는 지점이 나오면 읽은 부분까지의 바이트를 반환한다. 이때 파일포인터는 읽은 바이트만큼 이동한다.
- [`fget()`](https://www.php.net/manual/en/function.fgets.php) 파일헨들러가 가지고 있는 파일 포인터 위치에서 파일의 개행 문자 또는 EOF가 나타날 때까지 바이트를 읽고 반환한다. 지정한 갯수의 연속된 바이트를 읽을 수 있으나 개행 또는 파일 끝을 나타내는 부분이 나오기 전까지의 바이트만 읽는다. 이때 파일포인터는 읽은 바이트만큼 이동한다.
- [`fwrite()`](https://www.php.net/manual/en/function.fwrite.php) 파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 바이트를 주입한다. 이때 파일포인터는 추가한 바이트만큼 이동한다.
- [`fclose()`](https://www.php.net/manual/en/function.pclose.php) 함수를 사용하여 파일 헨들러를 닫는다. 파일 헨들러를 닫게 되면 OS가 관리하고 있는 파일락이 해제 되면서 이 헨들러가 아닌 다른 작업으로 파일 변경을 할 수 있게 만들어 준다.

## 파일 포인터의 이동
- 파일헨들러가 제공하는 파일 포인터를 통해서 파일의 어느 바이트를 읽을 것인지 어느 지점에 바이트를 추가할지를 정한다.
- php에서 제공하는 파일시스템의 바이트 읽기 및 추가를 하는 함수는 연속적인 바이트를 읽어야 하기 때문에 하나의 바이트를 읽으면 파일 포인터를 읽은 포인터 다음으로 이동시킨다. 또한 연속덕린 바이트를 추가하기 때문에 하나의 바이트를 추가하면 추가한 바이트 뒤에 포인터를 위치시킨다.
- 바이트를 읽거나 추가를 해도 파일 포인터가 이동하지 않도록 만들 수도 있더. 그러나 php의 함수는 파일 포인터에 대한 가장 직접적인 접근방식을 사용기 때문에 파일을 읽고 쓰게 되면 파일 포인터는 읽고 쓰기한 다음 바이트에 위치한다. 파일을 읽고 쓰기 한 다음 원래 위치로 포인터를 되돌리고 싶다면 [`fseek()`](https://www.php.net/manual/en/function.fseek.php) 함수를 사용하여 이동한 포인터 위치 만큼 되돌아 가 주면 된다.

### loop와 파일 포인터

## 인코딩
- 파일을 읽을 때는 바이트 단위로 읽는다고 읽는데 문자열 인코딩은 때로는 한 바이트가 아닌 여러 바이트가 하나의 문자를 가리키는 경우가 있다. 또한 언어에 따라 바이트가 나타내는 값(비트 값)과 언어 문자 사이의 매핑은 인코딩 방식에 따라 다를 수 있다.
- php에서 바이트를 읽은 결과를 나타내는 `fget()`, `fread()` 등의 함수로 바이트를 읽은 결과는 php의 기본 인코딩인 UTF-8 방식으로 해석된다. 하지만 파일의 인코딩이 UTF-8이 아닐 경우 이상한 문자를 저장하는 경우가 생긴다.

## Reference
- https://stackoverflow.com/questions/5249279/file-get-contents-php-fatal-error-allowed-memory-exhausted
- https://en.wikipedia.org/wiki/Byte
