## File handler

### 파일 헨들러란?

파일 헨들러는 파일에 기록된 데이터를 바이트 단위로 읽고 쓸 수 있는 기능을 제공한다. 파일 헨들러를 사용하여 파일의 모든 데이터를 메모리에 올려 놓지 않고 파일의 내용을 읽기, 쓰기를 할 수 있다.

파일의 모든 내용을 메모리에 미리 적재하지 않기 위해 파일 핸들러는 파일 포인터라는 위치 추적기를 사용한다. 파일 포인터는 파일 내에서 현재 읽기 또는 쓰기 작업을 하기 위한 지점을 가리킨다.

### 왜 파일 헨들러를 사용하는가?

파일이란 바이트 단위의 크기를 가질 때도 있고, 킬로 바이트 단위의 크기를 가질 때도 있고, 메가 바이트 단위의 크기를 가질 때도 있다. 때로는 기가 바이트 단위의 단일 파일도 있고 더 큰 용량의 파일도 존재한다. 이런 단일 파일을 프로그래밍으로 내용을 변경하고자 할 때 모든 파일의 내용을 메모리에 올리려면 파일의 용량 이상의 메모리 사용량이 요구된다.

어떤 프로그램이 어떤 파일을 처리할 때 전달되는 파일의 용량은 항상 일정한 것은 아니다. 파일에 대해 동일한 처리를 수행하는 프로그램이라도 유저가 원하는 파일 크기에 따라 작은 용량을 처리할 때도, 큰 용량을 처리할 때도 있다. 프로그램이 사용하는 메모리는 가능한 일정한 한계선을 두고 만드는 것이 좋으며, 무한정 메모리를 소모하게 되면 컴퓨터가 사용할 수 있는 하드웨어 메모리 리소스를 초과하거나 OS에 할당된 메모리 리소스를 초과하여 프로그램이 의도치 않게 종료되는 크레시 현상이 발생할 수 있다.

프로그램이 크레시로 인해 강제 종료되면, 애플리케이션을 다시 기동해야 할 뿐만 아니라, 처리하고 있던 작업이 손실되며, 처리 문제가 발생했을 때 예외처리를 비롯한 각종 후속처리가 이뤄지지 않으므로 복구하기 어렵거나 불가능한 여러 문제가 발생할 수 있다. 따라서 크레시로 인한 종료 현상을 최대한 막기 위해서 애플리케이션의 메모리 관리를 잘 해 줘야 한다.

파일 헨들러를 사용하면 파일의 특정 지점까지의 데이터를 메모리에 올리고 프로그래밍을 통해서 메모리에 올린 데이터를 처리할 수 있다. 처리가 끝나면 파일을 최종적으로 읽은 지점부터 특정 지점까지의 데이터를 메모리에 올리는 작업을 반복하여, 파일 전체의 데이터가 아닌 적당한 크기 만큼의 데이터를 메모리에 올려서 처리하기 때문에 메모리 사용량이 절약된다. 파일 헨들러를 이용하여 메모리 사용량을 줄일 수 있는 로직을 만들 수 있어 애플리케이션에서 파일 처리로 인한 메모리 문제를 예방할 수 있다.

### 웹 애플리케이션에서 파일 처리

웹 애플리케이션은 수 많은 리퀘스트를 처리하는 프로그램이다. 웹 애플리케이션 서버는 여러 리퀘스트를 동시에 처리하는데, 만약 여러 유저가 업로드한 파일을 동시에 처리하게 되거나, 유저가 큰 용량의 파일을 업로드 하게 되면 하나의 리퀘스트를 처리하는데 많은 메모리를 사용하게 되고 이런 현상이 여러 리퀘스트에 동시에 일어나게 되면, 하드웨어나 OS에서 가용 가능한 메모리 자원을 다 소비하여 크레시가 발생할 수 있다.

많은 리퀘스트의 처리가 동시에 일어나는 웹 애플리케이션의 메모리 사용량은 동시에 일어나는 모든 리퀘스트가 사용할 수 있는 총 메모리 사용량에 상한선을 두고, 메모리 사용량이 정해진 상한선을 초과하지 않도록 관리해야 웹 애플리케이션의 크레시를 방지할 수 있다.

처리할 파일의 용량의 상한선이 정해지지 않았는데 파일에서 많은 양의 데이터를 취득해서 메모리에 올리게 되면 메모리 크레시가 발생하므로 파일 헨들러를 사용해서 파일 데이터를 처리할 때는 파일 데이터를 분할해서 메모리에 올려 처리해야 한다. 하지만 분할해서 처리를 하게 되면 그만큼 처리 시간이 늘어나게 된다.

php의 경우 처리하는 시간이 길어지면 하나의 리퀘스트 프로세스를 계속 점유하므로, 하나의 프로세스가 갖는 CPU 및 메모리 자원을 동시에 처리할 수 있는 리퀘스트의 수가 감소하게 된다. php 서버에서 동시에 처리할 수 있는 프로세스의 수는 서버 설정에 의해 제한되어 있기 때문에, 리퀘스트가 처리되지 않으면 가용할 수 있는 프로세스의 수가 줄어들면서 서버의 이용이 어렵게 되는 경우가 있다. 따라서 시간이 오래 걸릴 가능성이 있는 파일 처리는 가능한 웹 애플리케이션 서버가 아닌 큐 시스템 또는 배치 시스템을 이용하여 처리하는 편이 낫다.

## File pointer란?

책을 읽는데 전에 읽었던 페이지가 어딘지 쉽게 확인하기 위해서 책갈피를 사용한다. 파일 포인터는 책갈피의 역할을 하며 파일을 읽을 때 어느 지점까지 읽고 있는지를 표기하기 위해 사용한다.

기본적으로 컴퓨터가 데이터를 읽는 기본 단위는 바이트 단위이다. 바이트 단위로 데이터를 읽어서 비트 데이터를 읽고, 비트 단위의 데이터를 변경하면 바이트 단위로 다시 쓰기 작업을 한다.

컴퓨터의 읽기 단위가 바이트 단위이므로 책갈피는 바이트와 바이트 사이에 위치하는 개념으로 생각하면 편하다. 바이트와 바이트 사이에 어디까지 읽었는지 표시하는 위치 정보를 다루는 기능을 파일 포인터로 여기면 된다. 좀 더 정확하게는 바이트와 바이트 사이가 아닌 파일 포인터는 파일의 시작점 부터 몇 번째 바이트에 있는지에 인덱스 값으로 처리하고 있는 지점의 위치 정보를 저장하는 것이다.

파일 헨들러가 제공하는 데이터의 위치를 파악하는 파일 포인터를 통해서 컴퓨터는 하드웨어의 특정 지점의 데이터를 읽거나, 쓰거나, 변경하는 명령을 내릴 수 있다.

기본적으로 하나의 파일 핸들러가 컨트롤하는 파일 포인터는 하나인데, 이는 하드웨어에 있는 데이터를 한꺼번에 읽지 않고 하드웨어에서 직접 가져오기 때문이다. 데이터가 다른 요인에 의해 변경이 되면 파일의 시작점 부터 N 번째 글자까지의 글자가 줄어들거나 늘어날 수 있으므로, N번째 다음 부터의 글자를 처리할 때 원하는 대상의 내용이 아닐 수 있다. 데이터가 부정확하게 다뤄질 수 있기 때문에 기본적으로 하나의 파일은 하나의 헨들러가 점유하며, 하나의 헨들러는 하나의 파일 포인터를 갖도록 한다.

물론 하나의 파일에 여러 파일 헨들러를 동시에 사용할 수 있지만, 이 경우 데이터의 변경에 따라 파일 포인터가 가리키는 값이 달라질 수 있으므로 다루기 까다로워진다.

## Byte에 대해 더 이해하기

컴퓨터에 저장되는 데이터의 단위는 바이트단위로 되어 있다. 컴퓨터 아키텍처에서 메모리 또는 디스크에서 인식 가능한 주소를 지정할 수 있는 최소 단위가 바이트이다. 파일 포인터가 바이트단위인 이유도 하드웨어의 인식가능한 주소의 단위가 바이트이기 때문이다.

비트 단위로 접근하려면 바이트 단위로 데이터를 읽어 변수에 저장한 후, 이를 조작해야 한다. 하드웨어가 바이트 단위를 기본 처리 단위로 사용하기 때문에, 이에 맞춰 비트 단위의 파일 포인터 이동을 하도록 만들어지지 않고 바이트 단위의 파일 포인터 이동을 하도록 만들어졌다. 소프트웨어의 데이터 취득 단위와 하드웨어의 데이터 취득 단위가 다르게 되면 비효율적인 변환 비용이 발생하게 된다.

파일의 기본 단위를 8 비트인 바이트단위로 나눠야 한다는 절대적인 이유는 없지만 숫자, 영문, 일부 특수기호, 제어문자를 구분하기 위한 단위로서 8비트를 표준으로 정의하였다. 컴퓨터의 역사에서 초기 문자를 정의할 때 ASCII 코드를 사용했다. ASCII 코드는 7비트로도 숫자, 영문, 일부 특수기호, 제어문자를 표시하였으며, 이진수인 컴퓨터가 표기할 수 있는 3자리 수가(2^3) 8비트이므로 8비트를 사용하여 문자를 표기하기 시작하였다. 초창기에는 7비트로 ASCII 코드를 정의했지만, ASCII 코드도 8비트로 표기하기 시작했다. 초기 개인용 컴퓨터가 보급되기 시작한 시점에서 8비트 단위로 데이터를 처리를 하였기 때문에 8비트를 1바이트로 사용하는 것이 표준이 되었다.

너무 많은 비트를 1 바이트로 지정하면 하나의 문자가 차지하는 용량이 커지고 너무 적은 비트를 1 바이트로 지정하면 원하는 문자를 표현하는데 여러 비트를 사용하거나 가변 바이트를 사용하게 되어 용량을 많이 차지하게 된다. 개인용 컴퓨터가 보급될 시점에 적절한 타협점으로 8비트를 데이터 처리의 가장 기본 단위로 만든 것이다.

8비트를 하나의 문자열로 다루는 인코딩 방식은 ASCII 코드 뿐만 아니라 EBCDIC 코드가 있다. 숫자, 영문, 일부 특수기호, 제어문자와 다국어 지원 문자로 255개의 문자를 채울 수 있도록 만들어졌다. 일본어의 경우 EBCDIC 포멧을 이용할 때 반각 가나를 추가해서 사용하고 있다. 일본 은행의 통장을 보면 반각가나로 이뤄져 있는데 EBCDIC 인코딩을 사용할 때의 형식을 계속 지금까지 이어서 사용하고 있기 때문이다. 코볼을 쓰는 오래된 금융 시스템을 개선하기 어려운 요인으로 아직까지도 통장 명의는 반각가나로 이뤄져 있는 것으로 보인다.

## 1바이트를 초과하는 문자의 등장

많은 나라에서 컴퓨터를 이용함에 따라 다국어를 지원할 필요성이 생겼다. 8비트만으로는 표현할 수 없는 문자수를 가진 나라들이 생겨서 하나의 문자를 표현하는데 여러 바이트를 사용하여 하나의 문자를 나타내는 문자열 인코딩 방식이 도입되었다. 2바이트를 사용하여 문자를 표현하는 방식 및 문자에 따라 1바이트가 될 때도 있고 2바이트가 될 수도 있는 가변 바이트를 사용하는 방식의 인코딩 방식도 있으며, 유니코드를 포함하는 문자 집합의 경우 최대 4바이트까지 사용한다.

## 프로그래밍에서 파일을 처리하는 방법

- 파일 전체를 한 번에 읽는다.
- 파일을 열어서 조금씩 읽어들인다. 

## 파일을 나눠서 읽어야 하는 경우

파일 전체를 한 번에 읽어서 메모리에 파일 내용을 적재해야 하는데 '파일 데이터를 변수에 담아 메모리에 올릴 때 필요한 메모리 사이즈' + '코드를 처리할 때 사용하는 추가 메모리'가 php 프로세스에서 허용하는 메모리 보다 커질 수 있다. 물론 php의 메모리 사이즈 및 하드웨어의 메모리 사이즈 및 가상메모리 사이즈 등을 늘릴 수 있지만 파일의 용량은 일반적으로 한없이 늘어나는 경우를 고려해야 하기 때문에 제한된 메모리 내에서 동작하는 코드를 작성해야 이후 시스템의 확장에 대응할 수 있다. 파일 사이즈가 어느 용량 이하로 정해져 있다면 파일을 한 번에 읽는 방식을 사용해도 괜찮다.

## 헨들러를 사용하여 데이터를 나누어 읽을 때

파일 헨들러를 사용한다는 것은 파일의 전체 내용을 메모리에 적재하는 것이 아니라, 파일 포인터를 이용하여 필요한 기준 지점에서 지정한 양만큼의 바이트를 읽고 삭제하거나 기준 지점에 새로운 바이트를 추가하는 방식을 사용할 수 있다.

파일 전체를 메모리에 적재하는 것이 아니라 필요한만큼 쪼개어 메모리에 올리는 방식으로 처리할 수 있기 때문에 대용량의 파일을 처리할 때 유용한 방법이다.

## php에서 전체 파일 읽기

- [`file_get_contents`](https://www.php.net/manual/en/function.file-put-contents.php) 함수를 사용하여 지정한 파일 전체 컨텐츠를 읽어서 php의 변수에 저장할 수 있다.

## php에서 파일 헨들러 사용하기

- [`fopen()`](https://www.php.net/manual/en/function.fopen.php) 함수를 사용하여 파일을 열고 파일 헨들러를 반환 받는다.
- [`fread()`](https://www.php.net/manual/en/function.fread.php) 파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 갯수의 연속된 바이트를 읽는다. 연속된 바이트를 읽다가 읽을 수 없는 지점이 나오면 읽은 부분까지의 바이트를 반환한다. 이때 파일포인터는 읽은 바이트만큼 이동한다.
- [`fget()`](https://www.php.net/manual/en/function.fgets.php) 파일헨들러가 가지고 있는 파일 포인터 위치에서 파일의 개행 문자 또는 EOF가 나타날 때까지 바이트를 읽고 반환한다. 지정한 갯수의 연속된 바이트를 읽을 수 있으나 개행 또는 파일 끝을 나타내는 부분이 나오기 전까지의 바이트만 읽는다. 이때 파일포인터는 읽은 바이트만큼 이동한다.
- [`fwrite()`](https://www.php.net/manual/en/function.fwrite.php) 파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 바이트를 주입한다. 이때 파일포인터는 추가한 바이트만큼 이동한다.
- [`fclose()`](https://www.php.net/manual/en/function.pclose.php) 함수를 사용하여 파일 헨들러를 닫는다. 파일 헨들러를 닫게 되면 OS가 관리하고 있는 파일락이 해제 되면서 이 헨들러가 아닌 다른 작업으로 파일 변경을 할 수 있게 만들어 준다.

## 파일 포인터의 이동

- 파일헨들러가 제공하는 파일 포인터를 통해서 파일의 어느 바이트를 읽을 것인지 어느 지점에 바이트를 추가할지를 정한다.
- 물리적 하드웨어가 하나의 바이트를 쓰거나 읽으면 그 다음 포인터에 위치하게 된다. 소트프웨어의 포인터는 가상의 포인터이지만 물리적 하드웨어가 가지는 포인터와 움직임을 동일하게 하여 파일 포인터의 조작에 따른 하드웨어의 움직임을 자연스럽고 직관적으로 만들기 때문에 바이트 읽기와 쓰기 이후에는 파일 포인터가 그 뒤로 이동하는 것을 따른다. 하지만 최근의 플래시 메모리 하드웨어의 경우 하드웨어의 파일 포인터의 의미를 많이 퇴색하게 만든 부분도 있다.
- php에서 제공하는 파일시스템의 바이트 읽기 및 추가를 하는 함수는 연속적인 바이트를 읽어야 하기 때문에 하나의 바이트를 읽으면 파일 포인터를 읽은 포인터 다음으로 이동시킨다. 1 바이트 작업 후 그 뒤의 포인터로 이동해야지 연속적인 바이트 작업의 로직이 단순해진다. php에서 제공하는 연속적인 바이트를 추가하는 함수도 1 바이트를 이동하는 기능을 합쳐 놓은 단순한 형태이기 때문에 연속적인 바이트를 추가한 후 그 뒤로 파일 포인터를 이동시키는 특성을 가지고 있다.
- 바이트를 읽거나 추가를 해도 파일 포인터가 이동하지 않도록 만들 수도 있더. 그러나 php의 함수는 파일 포인터에 대한 가장 직접적인 접근방식을 사용기 때문에 파일을 읽고 쓰게 되면 파일 포인터는 읽고 쓰기한 다음 바이트에 위치한다. 파일을 읽고 쓰기 한 다음 원래 위치로 포인터를 되돌리고 싶다면 [`fseek()`](https://www.php.net/manual/en/function.fseek.php) 함수를 사용하여 이동한 포인터 위치 만큼 되돌아 가 주면 된다.

### loop와 파일 포인터

```php
$handle = fopen("http://www.example.com/", "rb");
if (FALSE === $handle) {
    exit("Failed to open stream to URL");
}

$contents = '';

while (!feof($handle)) {
    $contents .= fread($handle, 8192);
}
fclose($handle);
```
- `feof`는 헨들러의 포인터가 파일 끝에 도달했는지를 확인한다. `!feof($handle)` 헨들러의 포인터가 파일 끝에 도달하지 않았기 때문에 파일의 마지막 부분에 포인터가 도착할 때까지 루프를 돈다.
- 루프가 돌아갈 때마다 `fread($handle, 8192)` 8192 바이트의 문자를 읽고 파일 헨들러의 파일 포인터를 읽은 문자 다음으로 둔다. `fread` 함수로 바이트를 읽을 때 마다 파일 포인터가 읽은 다음에 위치하기 때문에 루프가 돌아가면서 `fread` 함수를 사용하는 것만으로 파일의 전체 데이터를 얻어낼 수 있다.

```
$fp = @fopen("/tmp/inputfile.txt", "r");
if ($fp) {
    while (($buffer = fgets($fp, 4096)) !== false) {
        echo $buffer;
    }
    if (!feof($fp)) {
        echo "Error: unexpected fgets() fail\n";
    }
    fclose($fp);
}
```
- `($buffer = fgets($fp, 4096)) !== false`에서 `$buffer = fgets($fp, 4096)`가 반환하는 값은 `$buffer`에 담고 있는 `fgets($fp, 4096)` 값이다. `$buffer`와 `false`가 `!==`으로 비교가 된다.
- `fgets($fp, 4096)`를 사용하는 것만으로도 파일 포인터가 이동하게 된다. 이외의 따로 파일 포인터를 옮기는 과정 없이도 파일을 읽게 된다.

## 인코딩

- 파일을 읽을 때는 바이트 단위로 읽는다고 읽는데 문자열 인코딩은 때로는 한 바이트가 아닌 여러 바이트가 하나의 문자를 가리키는 경우가 있다. 또한 언어에 따라 바이트가 나타내는 값(비트 값)과 언어 문자 사이의 매핑은 인코딩 방식에 따라 다를 수 있다.
- php에서 바이트를 읽은 결과를 나타내는 `fget()`, `fread()` 등의 함수로 바이트를 읽은 결과는 특별한 지시가 없는 한 어떤 문자열로 보여지는 상태는 아니다. echo 등을 통해서 이 데이터의 문자열을 확인하려고 한다면 php는 single byte set으로 문자열을 보여주며, 이 때 사용하는 single byte set은 ISO-8859-1, US-ASCII 을 사용한다. php의 default 변환 문자는 ISO-8859-1 방식이므로 `À	Á	Â	Ã	Ä	Å	Æ	Ç	È	É	Ê	Ë	Ì	Í	Î	Ï   D   Ð 	Ñ	Ò	Ó	Ô	Õ	Ö	×	Ø	Ù	Ú	Û	Ü	Ý	Þ	à	á	â	ã	ä	å	æ	ç	è	é	ê	ë	ì	í	î	ï ð	ñ	ò	ó	ô	õ	ö	÷	ø	ù	ú	û	ü	ý	þ	ÿ`와 같은 문자를 보여준다.
- UTF-8, SJIS, ECU-KR 등의 멀티 바이트 인코딩의 문자열이 들어 있던 파일이라면 이 바이트 데이터의 문자열을 제대로 나타내기 위해서는 멀티 바이트 데이터를 적절하게 묶어 주는 인코딩을 사용하여 원하는 문자열로 출력해야 한다.



## Reference
- https://stackoverflow.com/questions/5249279/file-get-contents-php-fatal-error-allowed-memory-exhausted
- https://en.wikipedia.org/wiki/Byte
- https://www.php.net/manual/en/xml.encoding.php
