# php의 배열함수

## php 배열함수의 단점
- 대부분의 인기 있는 언어에서 배열에 관한 체이닝 함수는 필수적인 추세이다.
- 하지만 php에서는 기본적으로 제공되는 배열함수는 체이닝을 할 수 없다.
- php의 배열함수는 자바스크립트의 예와 같이 `[1,2,3,4,5].filter(e => e>=3).map(e => e+1)` 이렇게 체이닝을 하는 방법을 사용할 수가 없다.

### pipe 연산자 RFC 거부
```
[1,2,3,4,5]
|> fn($x) => array_filter(fn($x) => $x >= 3, $x),
|> fn($x) => array_map(fn($x) => $x+1, $x),
|> fn($x) => array_map(fn($x) => $x+1, $x)
```
- 이런식으로 파이프 연산자를 도입해서 array_function의 체이닝을 할 수 있는 방식도 도입 되지 않았다.
- 파이프 연산자를 도입하면 그나마 쉽게 만들 수 있지만, 만약 도입한다고 해도 php의 기본 배열함수는 함수로 한 번 레핑을 해야 사용할 수 있는 단점이 있다.

### 꼭 체이닝을 하고 싶다면?
```
array_reduce(
    [
        fn($x) => array_filter(fn($x) => $x >= 3, $x),
        fn($x) => array_map(fn($x) => $x+1, $x),
        fn($x) => array_map(fn($x) => $x+1, $x)
    ]
, fn($x, $y) => $y($x), [1,2,3,4,5]);
```
- 이렇게 좀 불편하게 체이닝을 할 수는 있지만, 보일러 플레이트가 많은 단점이 존재한다.
- 이렇게 사용하는 것은 코드가 길어지고 여러모로 불편한 점을 야기한다.


### 지연평가 사용 불가
- 지연 평가란 f(x)의 결과를 y라고 할 때 이 결과에 g(y)와 같이 g함수를 사용해서 결과 값을 얻는 것이다. 하지만 연산한 결과에 연산한 결과에 연산한 결과를 넣는 것 보다 함수를 한꺼번에 묶어서 연산을 하는 방법이 있다. f·g 를 만들고 f·g(x)로 실행하여 결과 값을 얻는 것이다. 함수를 묶어서 실행할 수 있기 때문에 함수의 조합으로 하나의 도메인 로직 모듈 또는 기능의 단위를 묶어서 사용할 수 있어서 지연평가는 함수형 프로그래밍에서 아주 중요한 역할을 한다.
- 지연평가를 사용하기 위해서는 커링 가능한 함수를 만들어야 한다. 왜냐하면 일부 인자를 넣고 인자가 다 찰때까지 실행되는 것이 아니라 함수 자체로 존재해야 하기 때문이다.
- php의 기본 배열함수에 적용하기 위해서는 기존 함수를 변경할 수 있어야 하는데, 디폴트 배열함수는 변경 시도 자체가 불가능하기 때문에 사용할 수 없으며 지연평가를 위한 커링 함수를 만들기 위해서는 기본 배열함수를 레핑 할 수 있어야 한다.


## Reference
- https://www.php.net/manual/en/ref.array.php
