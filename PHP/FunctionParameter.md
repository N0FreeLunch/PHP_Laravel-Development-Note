# 파라메터로 클로저를 사용하는 더 나은 방법
# パラメーターとしてクロージャを使用するより良い方法

# 들어가며
# はじめに

php에서 Closure를 함수 인자로 받을 때는 `Closure` 타입힌트를 사용한다. 함수 내로 전달된 함수를 사용하려면 매개변수로 어떤 값을 전달 받고, 반환 값으로 어떤 타입을 반환하는지 알아야 하는데, `Closure` 매개변수만으로는 함수의 스펙 정보가 부족하다.

phpでClosureを関数の引数として受け取る際、`Closure`型ヒントを使用します。関数内部に伝われた関数を使うようとしたら、引数としてどんな値を渡し、戻り値としてどの型を返すのかを知っておく必要があります。しかし、`Closure`型の引数だけでは、関数の仕様に関する情報が十分ではありません。

이 글은 php의 리플렉션을 통한 런타임 검사를 통해 함수의 인자로 전달된 `Closure`의 매개변수 타입과 반환 타입을 확인하는 기능을 제안하고, 클로저의 매개변수와 반환 값의 타입 정보를 추가하여 클로저를 다룰 때의 불편함을 줄이는 방법을 알아본다. 또한 클로저를 사용할 때 신중해야 하는 이유와 대안도 함께 살펴보자.

そこで本稿では、phpのリフレクション(reflection)を使ったランタイム(runtime)検査を利用して、関数の引数として渡された`Closure`のパラメータ型や戻り値の型を確認する方法を提案します。これにより、クロージャを扱う際の不便さを軽減する方法、さらに、クロージャを使うときに注意すべき点や、場合によっては代替手段を検討したほうがよい理由も紹介します。

## php Closure의 특징
## php Closureの特徴

이 부분은 이 글의 목적을 이해하는데 중요한 부분은 아니므로 [Closure의 문제](#closure_problem)으로 건너뛰어도 괜찮다.

この部分は本稿の目的を理解する上で必須ではありません。そのため、必要に応じて読み飛ばし、[Closureの問題点](#closureの問題点)に進んでいただいて構いません。

### 시놉시스
### シノプシス

다음은 [PHP 공식 문서](https://www.php.net/manual/en/class.closure.php#closure.synopsis)의 `Closure`에 대한 시놉시스(synopsis: 요약, 개요)이다.

次は、[PHP公式マニュアル]((https://www.php.net/manual/ja/class.closure.php#closure.synopsis))にある`Closure`のシノプシス（synopsis: 概要）です。

```
final class Closure {
    /* Methods */
    private __construct()
    public static bind(Closure $closure, ?object $newThis, object|string|null $newScope = "static"): ?Closure
    public bindTo(?object $newThis, object|string|null $newScope = "static"): ?Closure
    public call(object $newThis, mixed ...$args): mixed
    public static fromCallable(callable $callback): Closure
}
```

위 시그니처의 특성을 이해하면 왜 클로저의 매개변수와 반환 타입을 지정하는 방식을 생각할 수 없는지 생각해 볼 수 있다. 우선 Closure의 특성을 알아보자.

上記のシグネチャの特性を理解すると、なぜクロージャの引数や戻り値の型を指定する方法を考えにくいのかが分かります。まずは、`Closure`の特性について見ていきます。

### 상속 불가능
### 継承不可

final class이므로 상속 불가능하며 기존 메소드를 오버라이딩해서 변경하거나 메소드를 추가할 수 없다. 주어진 클래스의 사양의 변경 없이 그대로 사용해야 한다.

final classであるため、継承はできません。既存のメソッドをオーバーライド(overriding)して変更したり、新しいメソッドを追加したりすることもできません。与えられたクラスの仕様をそのまま使用するしかないです。


### 객체 생성 불가
### オブジェクトの生成不可

`private __construct`는 객체 외부에서 `new` 키워드를 통한 객체 생성을 차단한다. `new`로 새로운 객체가 생성될 때는 `public`인 생성자 함수를 호출하면서 새로운 객체를 만드는데, 생성자 함수가 `private`이므로 접근을 차단하기 때문에 객체 생성을 할 수 없게 만든다.

`private __construct` は、オブジェクトの外部から `new` キーワードを使ったオブジェクト生成を防ぎます。通常、`new` によって新しいオブジェクトを作る際には `public` なコンストラクタが呼び出されますが、コンストラクタが `private` であるためアクセスが遮断され、オブジェクトを生成できなくなっています。

`private`라서 객체 내부에서는 생성자 함수에 접근할 수 있어서 `new Self`와 같은 코드로 객체를 생성하는 메소드를 만들 수는 있지만, final로 상속 불가능한 클래스이므로 각종 메소드를 추가 설정할 수 없다. 

`private` であるため、オブジェクト内部ではコンストラクタにアクセスでき、`new Self` のようなコードでオブジェクトを生成するメソッドを作ることは可能です。しかし、`final` クラスであり継承できないため、任意のメソッドを追加することはできません。

`Closure::method`의 방식으로는 객체를 생성할 수 없고, 익명함수를 생성하는 문법(`function ($param) { /* code */}`, `fn($param) => $return; `)으로만 클로저 객체를 생성할 수 있다.

そのため、`Closure::method` のような方法ではオブジェクトを生成できず、無名関数を生成する構文（`function ($param) { /* code */ } や fn($param) => $return;`）を使うことのみクロージャオブジェクトを生成できます。

### 바인딩이란?
### バインディングとは？

익명함수는 Closure 클래스의 호출 가능한 메소드를 정의하는 것과 같다. 그래서 익명함수의 함수 블록안에 `$this`는 `Closure` 객체를 가리킨다. 이때 객체를 바인딩하는 것을 통해서 익명 함수 블록 내의 `$this`에 다른 객체를 지정하여 접근할 수 있다.

無名関数は、`Closure`クラスの呼び出し可能なメソッドを定義することと同じです。そのため、無名関数の関数ブロック内での`$this`は`Closure`オブジェクトを指します。このとき、オブジェクトをバインドすることで、無名関数ブロック内の`$this`に他のオブジェクトを指定してアクセスできます。

### 익명함수 복사하기
### 無名関数をコピーする

```php
public static bind(Closure $closure, ?object $newThis, object|string|null $newScope = "static"): ?Closure
```

`$newFn = Closure::bind($fn, $obj)`으로 익명함수 `$fn`을 복사하면서, 필요에 따라 바인딩할 오브젝트를 지정하여 복사된 익명함수에 바인딩할 수 있다.

`$newFn = Closure::bind($fn, $obj)`のようにして、無名関数`$fn`をコピーしつつ、必要に応じてバインドするオブジェクトを指定し、コピーされた無名関数にバインドすることができます。

오브젝트를 바인딩하여 `$this`으로 바인딩한 오브젝트에 엑세스를 할 수 있지만, 클래스 내부의 코드에 정의되지 않은 경우 클래스가 객체화 되는 순간 퍼블릭 멤버에만 접근할 수 있게 된다. 복사된 익명함수는 이미 생성된 오브젝트를 바인딩하는 것이므로 바인딩한 대상의 프라이빗 또는 퍼블릭 멤버에 엑세스 할 수 없다. 비공개 멤버에도 접근하기 위해서는 인스턴스화 되어 더 이상 비공개 멤버에 접근할 수 없는 대상이 아닌, 인스턴스화 하기 전의 주형 정보가 있어야 접근할 수 있다.

オブジェクトをバインドすることで`$this`を通じてバインドされたオブジェクトにアクセスできますが、クラス内部のコードとして定義されていない場合、クラスがインスタンス化された時点でアクセスできるのはパブリックメンバーに限られます。コピーされた無名関数は、すでに生成済みのオブジェクトにバインドされるため、バインド対象のプライベートメンバーやプロテクテッドメンバーにはアクセスできず、パブリックメンバーのみが参照可能となります。プライベートメンバーにアクセスするには、インスタンス化されていない、まだアクセス可能な鋳型(クラス)情報が必要です。

리플렉션을 통해서 오브젝트의 클래스 정보를 얻어 오브젝트의 비공개 멤버에 접근하는 방식을 택할 수도 있지만, 주형 정보 직접 사용하는 것으로 리플렉션에 리소스를 소비하지 않을 수 있다.

リフレクションを使ってオブジェクトのクラス情報を取得し、プライベートメンバーにアクセスする方法もありますが、鋳型(クラス)情報を直接使用することで、リフレクションにリソースを消費させずに済みます。

`$newScope`는 복사되는 익명함수에 주형 정보를 바인딩한다. 기본적으로는 `'static'`이란 문자열로 되어 있는데, 클로저 멤버에서 `static::`의 코드로 접근할 수 있게 한다. 만약 클래스 A를 문자열로 전달하여 바인딩하면, `A::`의 코드를 익명 함수 블록 내의 코드에서 사용할 수 있고, `self::`의 self는 A가 되는 식이다.

`$newScope`はコピーされる無名関数にプロトタイプ情報をバインドします。デフォルトでは`'static'`という文字列になっており、クロージャメンバー内で`static::`のコードとしてアクセスできるようになります。もしクラスAを文字列として伝えてバインドすると、無名関数ブロック内で`A::`のコードを使うことができ、`self::`のselfはAを指すことになります。

### 익명 함수에 바인딩 대상을 전달하며 실행하기

### 無名関数にバインド対象を渡して実行する

```php
public call(object $newThis, mixed ...$args): mixed
```

메소드 선언부는 바인딩 할 객체를 받고, 클로저를 실행할 때 필요한 인자를 받는 형태로 구성되어 있다.

メソッド宣言は、バインドするオブジェクトを受け取り、クロージャを実行する際に必要な引数を受け取る形になっています。

정적 메소드가 아닌데 그 이유는 `$fn->call()`의 방식으로 익명함수에 (익명 함수를 객체로 두고) 직접 `->call()`으로 실행하기 때문이다.

このメソッドが静的メソッドでない理由は、`$fn->call()`のように、無名関数をオブジェクトとして扱い、直接`->call()`で実行するためです。

### 콜러블 함수를 클로저로 만들기
### コーラブル関数をクロージャに変換する

```php
public static fromCallable(callable $callback): Closure
```

부분은 callable 타입의 호출할 수 있는 타입을 받아서 Closure 타입의 함수를 생성할 수 있다는 것을 드러낸다.

この部分は、`callable`型の呼び出し可能なものを受け取り、`Closure`型の関数を生成できることを示しています。

참고로 `callable` 타입힌트에 `Closure` 타입을 전달할 수 있다. 그러나 `Closure`는 `callable`의 서브타입은 아니라고 한다.

なお、`callable`型ヒントに`Closure`型を渡すことができます。しかし、`Closure`は`callable`のサブタイプではないと言われています。<sup>[[1]](#endnote_1)</sup>

<a name="closure_problem"></a>
## Closure의 문제
## Closureの問題点

### 매개 변수 및 반환 타입의 정의 불가
### 引数および戻り値の型を定義できない

매개 변수로 함수를 받을 때 특정 타입의 매개변수를 갖는 함수의 타입을 정의 할 수 없다.

引数として関数を受け取る場合、特定の型の引数を持つ関数の型を定義することができません。

함수를 인자로 전달할 수 있는 고차함수의 특성이 php에 있음에도 불구하고, php에서 함수형 프로그래밍이 적절하지 않는 의견이 있는 것은 매개변수로 받을 함수의 타입을 지정할 수 없다는 점 때문이다.

PHP には関数を引数として渡せる高階関数の特性がありますが、それにもかかわらず PHP が関数型プログラミングに適さないとされる理由のひとつは、引数として受け取る関数の型を指定できない点にあります。

php는 정적분석을 하기 쉬운 방향으로 진화하고 있는데, 클로저의 매개변수와 반환 타입을 지정할 수 없어 정적 분석이 되지 않는다면 함수형 특성을 사용할 수 있음에도 불구하고 권장하기는 어렵다.

phpは静的解析が行いやすい方向へと進化しています。しかし、クロージャの引数および戻り値の型を指定できないため、静的解析の対象とすることができません。そのため、本来であれば関数型の特性を活用できる場面であっても、クロージャの利用を積極的に推奨するのは難しいと言えます。

### Closure 클래스 상속 불가
### Closure クラスの継承不可

php에서 Closure는 언어에 내장된 클래스이다. 만약 이 클래스를 상속해서 새로운 클래스를 만들 수 있다면, 함수의 파라메터로 함수를 받을 때, Closure를 상속 받아 재정의한 서브 클래스를 받게하여, 특수한 시그니처의 Closure 타입을 받는다는 생각을 할 수 있다.

PHPにおける`Closure`は言語に組み込まれたクラスです。このクラスを継承して新しいクラスを作成できれば、関数のパラメータとして関数を受け取る際に、`Closure`を継承して再定義したサブクラスを受け取り、特定のシグネチャを持つ`Closure`型を扱うという考え方が可能です。

하지만 php에서 Closure 클래스는 final 클래스이므로 상속해서 별도의 클래스를 만들 수 없기 때문에 별도의 시그니처를 정의할 수 없기 때문에 Closure 파라메터가 어떤 매개 변수를 타입을 받아야 하고 어떤 반환 타입을 반환하는지 별도의 주석이나 문서 없이는 알 수 없다는 문제가 있다.

しかし、PHPでClosureクラスはfinalクラスであるため、継承して別のクラスを作ることができません。そのため、別のシグネチャを定義することもできず、`Closure`パラメータがどの型の引数を受け取り、どの型の戻り値を返すかを、特別なコメントや文書なしに把握することはできないという問題があります。

## 클로저의 타입을 확인하지 못하여 발생하는 문제
## クロージャの型を確認できないことで生じる問題

```php
declare(strict_types=1);

function calculate(Closure $operation, $transArg1, $transArg2): int {
    /*************
     * some code *
     *************/
    echo 'debug';
    /*************
     * some code *
     *************/
    return $operation($transArg1, $transArg2); // Fatal error: Uncaught TypeError: {closure}(): Argument #2 ($y) must be of type int, string given
}

$result = calculate(fn(int $x, int $y) => $x + $y, 3, '5');
echo $result; // 8
```

`$operation` 함수는 두 인자 `$x`, `$y`를 받아서 연산한 결과를 반환하는 함수이다. 그런데 `calculate` 함수에 전달할 때 `$operation` 함수에 인자가 전달되는 것이 아니라, `calculate`에 모든 인자가 전달된 이후 `$operation($transArg1, $transArg2)` 코드가 실행이 될 때, `$operation($transArg1, $transArg2)` 부분에서 `$operation` 함수에 인자가 전달된다. `echo 'debug';` 부분이 잘 출력 된다는 것은 여기까지는 에러가 발생하지 않았다는 의미이다. 그 이후 `$operation` 함수를 실행하는 코드에서 첫 번째 인자로 int 타입과 두 번째 인자로 string 타입의 값이 전달되는데, 두 번째 인자는 int 타입이 전달되어야 하는데 string 타입이 전달 되므로 에러가 발생한다.

`$operation`関数は、2つの引数`$x`と`$y`を受け取り、計算結果を返す関数です。しかし、`calculate`関数に渡す際、`$operation`関数に直接引数が渡されるのではなく、`calculate`にすべての引数が渡された後に`$operation($transArg1, $transArg2)`が実行されるときになってから`$operation`関数に引数が渡されます。`echo 'debug';`が正しく表示されることは、ここまではエラーが発生していないことを意味します。その後、`$operation`関数を実行するコードでは、1つ目の引数に`int`型、2つ目の引数に`string`型の値が渡されます。しかし、2つ目の引数には`int`型が渡されるべきところに`string`型が渡されるため、エラーが発生します。

문제는 `calculate` 함수의 매개변수인 `Closure $operation`에 인자가 전달될 때 타입 검증이 되지 않는다는 점이다. 전달된 클로저의 실행 타이밍에 타입에러가 발생하기 때문에 클로저에 잘못된 타입이 전달되었는지 빠르게 파악하지 못한다. 함수의 로직이 길어지면 클로저의 타입 문제인지 모르고 아닌 다른 원인을 찾느라 시간을 허비할 수도 있고, 클로저의 스펙을 알지 못하여 전달되는 클로저의 스펙을 확인학기 위한 코드 추적을 해야하는 등의 수고가 든다.

問題は、`calculate`関数のパラメータである`Closure $operation`に引数が渡される際に、型チェックが行われない点です。渡されたクロージャは、実行されるタイミングで型エラーが発生するため、クロージャに誤った型が渡されたかどうかをすぐに確認できません。関数のロジックが長くなると、クロージャの型の問題かどうか分からず、他の原因を探すために時間を浪費することもあります。また、クロージャの仕様を知らないため、渡されたクロージャの仕様を確認するためにコードを追跡する必要があり、手間がかかります。

여기서는 `calculate` 함수에 클로저를 전달할 때, `$operation` 클로저는 함수는 인자를 2개를 받아야 하고 첫 번째 인자와 두 번째 인자는 int 타입이며, `calculate`의 2번째, 3번째 인자가 `$operation` 함수의 인자로 전달될 값을 받는다는 사양을 알아야 하는데, 클로저 파라메터의 정보가 없다는 문제가 있다.

ここで、`calculate`関数にクロージャを渡す場合、`$operation`クロージャは2つの引数を受け取り、1つ目と2つ目の引数は`int`型であること、そして`calculate`の2番目と3番目の引数が`$operation`関数に渡される値であることを仕様として把握しておく必要があります。しかし、クロージャのパラメータ情報がないという問題があります。

이러한 문제 해결하기 위해 클로저를 사용한다면 클로저의 시그니처를 표시해 주어야 한다. 하지만, php가 제공하는 문법으로는 클로저의 사양을 표기할 수 없기 때문에 [phpdoc을 이용한 표기](https://phpstan.org/writing-php-code/phpdoc-types#callables)나, 런타임 리플렉션을 통한 타입 체커를 사용해야 한다.

このような問題を解決するためには、クロージャを使用する場合、そのシグネチャを明示する必要があります。しかし、PHPが提供する文法ではクロージャの仕様を明示することができないため、[phpdocを使った表記](https://phpstan.org/writing-php-code/phpdoc-types#callables)や、ランタイムリフレクションを利用した型チェッカーを使用する必要があります。

### 함수명을 이용한 시그니처 추측의 한계
### 関数名からシグネチャを推測することの限界

위와 같은 `calculate` 함수를 함수형 프로그래밍에서는 `apply`라는 이름의 함수로 구현을 하는데, 함수형 프로그래밍에서 사용하는 함수 이름을 사용하여 함수를 정의할 줄 아는 사람도, 그 함수형 프로그래밍에서 자주 사용되는 함수 이름을 통해서 함수의 역할과 사용법을 알아낼 수 있는 사람도 드물기 때문에 함수 파라메터의 스펙을 최대한 제공하는 것이 좋다.

上記のような`calculate`関数は、関数型プログラミングでは`apply`という名前の関数として実装されます。しかし、関数型プログラミングで使用される関数名を活用して関数を定義できる人も、関数型プログラミングでよく使われる関数名から関数の役割や使い方を憶える覚え出す人も少ないです。そのため、関数のパラメータの仕様をできるだけ明示することが望ましいです。

```php
declare(strict_types=1);

function apply(Closure $operation, mixed ...$transArgs): int {
    return $operation(...$transArgs);
}

$result = apply(fn(int $x, int $y) => $x + $y, 3, 5);
echo $result; // 8
```

↑ apply 함수의 예

↑ apply 関数の例です。

## 정적 분석을 통한 타입 확인
## 静的解析による型確認

php 문법으로는 타입 추론을 할 수 없는 Closure의 사양 때문에, docblock으로 호출가능한 함수의 타입을 지정할 수 있다.

PHPの文法だけでは型推論ができないClosureの仕様のため、docblockを使って呼び出し可能な関数の型を指定することができます。

```php
/**
 * @param Closure(int, int): int $operation
 */
function calculate(Closure $operation, int $trasArg1, int $transArg2): int {
    return $operation($trasArg1, $transArg2);
}

$result = calculate(fn($x, $y) => $x + $y, 3, 5);
echo $result; // 8
```

위와 같이 파라메터로 전달되는 함수의 타입을 지정해서 정적 분석으로 잘못된 타입을 지정할 수 있다. 이는 강력한 정적검사 툴에 의해서는 타입 불일치가 지적이 되지만, IDE에서는 버그로 또는 미지원으로 지적되지 않는 케이스도 있다. 게다가 런타임의 동작에서 잘못되었는지 알려주지 않는 문제가 있으므로 런타임 시점에 전달 받은 함수의 파라메터 타입과 인자의 수가 의도한 형태의 함수인지 확인하는 코드를 추가하는 편이 좋다.

このようにして、パラメータとして渡される関数の型を指定することで、静的解析によって誤った型の指定を検出できます。強力な静的解析ツールでは型の不一致が指摘されますが、IDE上ではバグまたは導入されない機能のため指摘されない場合もあります。さらに、ランタイムで動作中に誤りが分からない問題もあるため、ランタイム時に渡された関数のパラメータの型や引数の数が意図した形の関数であるかどうかを確認するコードを追加することが望ましいです。

## 런타임 타입 확인
## ランタイムでの型確認

컴파일을 하는 정적 타입 언어와 달리 동적 타입 언어인 php는 정적 분석으로 코드의 무결성을 보장하기 힘들다. phpstan과 같은 정적 분석 툴을 최고 레벨로 두어 개발할 수 있지만 이런 개발 방식은 특별한 php 코딩 스타일을 요구하므로 초기 설정 부터 엄격한 타이핑의 코드를 작성할 수 있는 환경 세팅을 해 줘야 한다. 그렇지 않다면 정적 분석 레벨을 높이기 위해 많은 코드 스타일 변경 리펙토링을 요구한다. 또한 엄격한 정적 분석이 되도록 phpdoc을 써 줘야 하기 때문에 많은 보일러플레이트가 필요하고, 경우에 따라 일부 docblock 구문이 IDE의 코드 검사에서 이뤄지지 않는 경우도 있기 때문에, 일반적인 코딩 스타일에서 정적 분석과 런타임 타임 검사를 적절히 조합하는 방식으로 코드를 작성하여 IDE의 정적 분석에 맞는 코드로 실수를 줄이고, 런타임으로 실행할 때 한 번 더 코드를 체크하는 과정을 거치는 편이 좋다.

コンパイルを行う静的型言語と異なり、動的型言語であるPHPでは、静的解析だけでコードの完全性を保証することは難しいです。PHPStanなどの静的解析ツールを最高レベルに設定して開発することも可能ですが、この開発方法では特別なPHPコーディングスタイルが要求されるため、初期設定の段階から厳格な型付けのコードを書ける環境を整える必要があります。そうでない場合、静的解析レベルを上げるために多くのコードスタイル変更やリファクタリングが求められます。また、厳密な静的解析を行うためにはphpdocの記述が必要で、多くのボイラープレートが発生します。場合によっては、一部のdocblock構文がIDEのコードチェックで反映されないこともあります。そのため、一般的なコーディングスタイルの中で、静的解析とランタイムでの型確認を適切に組み合わせる方法でコードを作成し、IDEの静的解析によるミスを減らし、ランタイム実行時にもう一度コードをチェックするプロセスを踏むことが望ましいです。

docblock으로 함수의 파라메터로 함수를 받을 때 함수의 타입 정보를 기술할 수 있었다면, 추가적으로 php의 불완전한 타입검사의 한계를 보완하기 위해 런타임으로 타입을 검증하는 과정을 넣어준다. 전달된 클로저가 어떤 타입을 받는지 런타임 시점에 알기 위해서는 리플렉션을 사용해야 한다. php에서는 [클로저의 정보를 확인할 수 있는 리플렉션 클래스](https://www.php.net/manual/en/class.reflectionfunction.php)가 제공되며 이를 통해서 클로저가 가진 인자의 타입정보, 반환 타입정보를 알 수 있다.

もしdocblockで関数のパラメータとして渡される関数の型情報を記述できる場合、さらにPHPの不完全な型検査の限界を補うために、ランタイムで型を検証する段階を追加します。渡されたクロージャがどの型を受け取るかをランタイム時点で確認するためには、リフレクションを使用する必要があります。PHPでは[クロージャの情報を取得できるリフレクションクラス](https://www.php.net/manual/ja/class.reflectionfunction.php)が提供されており、これを通じてクロージャが持つ引数の型情報や戻り値の型情報を確認することができます。

### 예
### 例

```php
function check0Target1String2IntParamStringReturn(Closure $fn): bool {
    $ref = new ReflectionFunction($fn);
    $params = $ref->getParameters();
    if (count($params) !== 3) return false;
    $param0TypeName = $params[0]->getType()->getName();
    if ($param0TypeName !== Target::class || is_subclass_of($param0TypeName, Target::class)) return false;
    if ($params[1]->getType()->getName() !== 'string') return false;
    if ($params[2]->getType()->getName() !== 'int') return false;
    if ($ref->getReturnType()->getName() !== 'string') return false; 
    return true;
}

$repeatPropertyValue = fn(Target $target, string $property, int $terationNumber): string => $target->{$property} * $terationNumber;

assert(check0Target1String2IntParamStringReturn($repeatPropertyValue));

class Target
{
    public readonly string $value;
}
```

`$ref = new ReflectionFunction($fn);`: 익명 함수 `$fn`의 리플렉션 정보를 취득한다.

`$ref = new ReflectionFunction($fn);`;：無名関数`$fn`のリフレクション情報を取得します。

`$params = $ref->getParameters();`: 각각의 파라메터 정보를 인덱싱된 배열로 반환한다.

`$params = $ref->getParameters();`：それぞれのパラメータ情報をインデックス付き配列として返します。

`if (count($params) !== 3) return false;`: 파라메터가 3개인지 확인한다. `$ref->getNumberOfParameters()`를 사용할 수도 있다.

`if (count($params) !== 3) return false;`：パラメータが3つであるかを確認します。`$ref->getNumberOfParameters()`を使用することも可能です。

리플랙션 클래스의 인스턴스의 `getType()`를 사용하면 [ReflectionType](https://www.php.net/manual/en/class.reflectiontype.php) 클래스의 객체를 반환한다. `getName` 메소드로 타입의 이름을 확인할 수 있다.

リフレクションクラスのインスタンスで`getType()`を使用すると、[ReflectionType](https://www.php.net/manual/ja/class.reflectiontype.php)クラスのオブジェクトが返されます。`getName`メソッドで型名を確認することができます。

`if ($param0TypeName !== Target::class || is_subclass_of($param2TypeName, Target::class)) return false;`: 첫 번째 파라메터가 `Target` 클래스인지 확인한다. 타입 체크를 할 때는 서브 타입인 경우도 허용되는 타입으로 고려해야 하므로 전달된 대상의 타입이 서브타입인지도 확인한다.

`if ($param0TypeName !== Target::class || is_subclass_of($param2TypeName, Target::class)) return false;`：最初のパラメータが`Target`クラスかどうかを確認します。型チェックではサブタイプも許容する型として考慮する必要があるため、渡された対象がサブタイプかどうかも確認します。

`if ($params[1]->getType()->getName() !== 'string') return false;`: 두 번째 파라메터가 문자열 타입인지 확인한다.

`if ($params[1]->getType()->getName() !== 'string') return false;`：2番目のパラメータが文字列型かどうかを確認します。

`if ($params[2]->getType()->getName() !== 'int') return false;`: 세 번째 파라메터가 정수 타입인지 확인한다.

`if ($params[2]->getType()->getName() !== 'int') return false;`：3番目のパラメータが整数型かどうかを確認します。

#### 참고 : 서브타입 체크 방식
#### 参考：サブタイプのチェック方法

```php
class ParentClass {}
class ChildClass extends ParentClass {}
var_dump(is_subclass_of(ChildClass::class, ParentClass::class));
```

`assert(checkStringIntParamStringReturn($repeat));`로 런타임 타입 검사에 활용한다.

`assert(checkStringIntParamStringReturn($repeat));`のように、ランタイムでの型チェックに活用します。

## 재사용할 수 있는 코드로 만들기
## 再利用可能なコードにする

파라메터 하나씩 검증할 수 있는 기능을 만들면 재사용할 수 있다.

パラメータを1つずつ検証できる機能を作ることで、再利用可能なコードにすることができます。

```php
function checkClosureParam(Closure $fn, string|int $keyNameOrIdx, string ...$types): bool {
    $ref = new ReflectionFunction($fn);
    $params = $ref->getParameters();
    if (is_numeric($keyNameOrIdx)) {
    	$paramIdx = $keyNameOrIdx;
    } else {
        $paramIdx = array_search($keyNameOrIdx, array_map(fn($e) => $e->getName(), $params));
    }
    $targetParam = $params[$paramIdx] ?? null;
    if (is_null($targetParam)) return false;
    $paramTypeName = $targetParam->getType()?->getName() ?? '';
    return in_array($paramTypeName, $types, true) || (array_reduce($types, fn($acc, $type) => $acc || is_subclass_of($paramTypeName, $type), false));
}

function checkClosureReturn(Closure $fn, string ...$types): bool {
    $ref = new ReflectionFunction($fn);
    $returnTypeObj = $ref->getReturnType();
    $returnTypeName = $returnTypeObj->getName() ?? '';
    return in_array($returnTypeName, $types, true) || (array_reduce($types, fn($acc, $type) => $acc || is_subclass_of($returnTypeName, $type), false));
}

$repeatPropertyValue = fn(ChildClass $target, string $property, int $terationNumber, $option): string => $target->{$property} * $terationNumber;

assert(checkClosureParam($repeatPropertyValue, 'target', ParentClass::class));
assert(checkClosureParam($repeatPropertyValue, 0, ParentClass::class));
assert(checkClosureParam($repeatPropertyValue, 'property', 'string'));
assert(checkClosureParam($repeatPropertyValue, 1, 'string'));
assert(checkClosureParam($repeatPropertyValue, 'terationNumber', 'int'));
assert(checkClosureParam($repeatPropertyValue, 2, 'int'));
assert(checkClosureParam($repeatPropertyValue, 'option', ''));
assert(checkClosureParam($repeatPropertyValue, 3, ''));
assert(checkClosureReturn($repeatPropertyValue, 'string'));

class ParentClass {}
class ChildClass extends ParentClass {}
```

런타임 타입 검사를 위해 `checkClosureParam`라는 파라메터의 타입을 검사하는 기능과 `checkClosureReturn`라는 리턴 타입을 검사하는 기능을 만들었다. 유니온 타입을 체크할 수 있도록 가변 파라메터로 복수의 타입을 지정할 수 있도록 만들어 주었다. 또한 타입힌트가 없는 경우도 허용할지 말지를 정할 수 있도록 빈 문자열('')로 타입힌트가 없는 경우 통과할 수 있도록 만들었다. 또한 리스코프 치환이 가능하도록 `is_subclass_of`으로 타입 체크를 하였다. 이후 한 번 만든 함수를 여러 파일에서 재사용할 수 있도록 `use function checkClosureParam`, `use function checkClosureReturn`으로 불러와서 클로저의 타입을 확인하자. 

ランタイム型チェックのために、パラメータの型を検証する機能として`checkClosureParam`、戻り値の型を検証する機能として`checkClosureReturn`を作成しました。ユニオン型をチェックできるよう、可変パラメータで複数の型を指定できるようにしています。また、型ヒントがない場合も許容するかどうかを指定できるよう、空文字列（’’）で型ヒントがない場合に通過できるようにしました。さらに、リスコフの置換原則に対応するため、`is_subclass_of`を用いて型チェックを行っています。その後、一度作成した関数は複数のファイルで再利用できるよう、`use function checkClosureParam`、`use function checkClosureReturn`で呼び出し、クロージャの型を確認します。

하지만 이 방식은 타입을 하나씩 검사하는 방식이므로 제네릭(타입 파라메터)를 만드는 방식은 사용할 수 없다는 한계가 있다. 제네릭에 관한 정보는 이 방법이 아닌 docblock 제네릭이나, 유니온 타입, 타입 단언 등을 사용하여 보완하자.

ただし、この方法は型を1つずつチェックする方式であるため、ジェネリクス（型パラメータ）を利用する方法は使えないという制限があります。ジェネリクスに関する情報は、この方法ではなく、`docblock`のジェネリクスやユニオン型、型アサーションなどを用いて補完する必要があります。

런타임 확인을 위한 리플렉션은 리소스가 드는 작업이므로 프로덕션 환경에서는 동작하지 않는 `assert` 함수로 로컬 또는 테스트 환경에서의 실행을 확인할 때 사용하면 적절하다.

ランタイムでの確認のためのリフレクションはリソースを消費する作業なので、プロダクション環境では動作させず、`assert`関数を使ってローカルやテスト環境での実行確認に使用するのが適切です。

## 클로저의 대안 찾기
## クロージャの代替案

### 클로저의 문제
### クロージャの問題点

라라벨의 각종 메소드는 익명함수 파라메터를 사용하는 코드가 많은데, 이는 겉으로 보기에는 코드에 우아함을 더하지만, 전달해야 하는 함수의 사양을 php 언어 수준에서 확인할 수 없기 때문에 이를 보조하는 공식 문서등의 자료가 필수적이다. 잘 정의된 문서, 충분한 주석 설명이 갖춰지지 않는다면, php의 함수 파라메터는 어떤 인자 타입과 어떤 반환 타입을 가져야 하는지 모르기 때문에 재사용하기에 좋지 않은 코드가 된다.

Laravelの各種メソッドでは、無名関数をパラメータとして使うコードが多く見られます。表面上はコードを優雅に見せることができますが、渡すべき関数の仕様をPHP言語レベルで確認できないため、公式ドキュメントなどの補助資料が必須です。十分に定義されたドキュメントやコメントがない場合、PHPの関数パラメータがどの型の引数を受け取り、どの型の戻り値を返すか分からず、再利用に適さないコードになってしまいます。

### 클로저를 활용하려면
### クロージャを活用するには

#### 일반적이거나 직관적인 함수명 또는 문서화하기
#### 一般的または直感的な関数名、あるいはドキュメント化

클로저를 잘 활용하기 위해서는 프로그래밍 세계에서 일반적으로 자주 쓰이는 함수명을 통해서 어떤 사양의 클로저를 받는지 알 수 있는 형태 예를 들어 `map`과 같은 컬렉션의 메소드를 사용하거나, 추가적인 사양 문서나 주석으로 어떤 클로저를 전달해야 하는지 사용법을 잘 기술하는 것이 중요하다.

クロージャを適切に活用するためには、プログラミングで一般的に使われる関数名を通じて、どの仕様のクロージャを受け取るか分かる形式にすることが重要です。例えば、`map`のようなコレクションメソッドを使用したり、追加の仕様書やコメントで、どのクロージャを渡すべきかを明示することが大切です。

예를 들어 라라벨의 컬렉션은 배열 또는 컬렉션 자료구조의 순회하는 원소 각각에 적용되는 인수로 전달되는 익명함수를 사용한다. 이 때 익명함수는 컬렉션의 원소의 타입을 받기 때문에 기본적으로는 특정한 타입에 얽매여있지 않다. 익명함수는 사용될 때, 특정 타입에 의존적인 기능을 갖기 보다는 타입에 의존적이지 않게 만들어, A 타입을 함수의 인자로 전달하면 A 타입을 받고, B 타입을 함수의 인자로 반환하면 체인된 컬렉션 메소드의 익명함수에 B 타입이 전달되는 처음 컬렉션 메소드에 전달되는 타입을 알면, 체인된 다음 컬렉션 메소드에 전달되는 타입도 알 수 있는 직관적으로 이해할 수 있는 메소드가 많다. 또한 직관적으로 알 수 없는 경우 각 메소드의 설명이 라라벨 문서에 잘 기술되어 있으므로 참고하면 된다.

Laravelのコレクションでは、配列やコレクションの各要素に適用される引数で伝えられる無名関数を使用します。この場合、無名関数はコレクションの要素の型を受け取るため、基本的に特定の型に縛られません。無名関数は、特定の型に依存する機能を持つのではなく、型に依存しないように作ることが望ましいです。たとえば、A型を関数の引数として渡すとA型を受け取り、B型を返すとチェーンされたコレクションメソッドにB型が渡される、といった直感的に理解できる設計のメソッドがあります。直感的に理解できない場合でも、各メソッドの説明がLaravelドキュメントに記載されているため参考すれば問題ないです。

#### 인자 사용되는 클로저가 필요한가?

#### 引数としてクロージャが本当に必要か？

익명함수는 설계된 코드에 변화를 주기 위해 자주 쓰인다. 하지만 지나치게 자유로운 로직을 허용해 설계 의도를 흐릴 수 있다. 객체나 함수에서 미리 설계된 구체적인 로직이 있고 제공될 값의 범위가 정해진 경우, 굳이 익명함수를 사용할 필요가 없으며 오히려 익명 함수로 전달할 수 있는 로직의 자유도로 인해 객체나 함수가 익명 함수를 통해 지나치게 다양한 양상 갖게 되어 코드의 원래 설계 목적, 도메인적인 제약사항을 초과하거나 무시하는 동작을 만들어 낼 수 있다.

無名関数は設計したコードを柔軟に変更するために使われることが多いです。しかし、自由すぎるロジックを許すと設計意図が曖昧になる可能性があります。オブジェクトや関数に事前に設計された具体的なロジックがあり、提供される値の範囲が決まっている場合、無名関数を使う必要はなく、むしろ無名関数によるロジックの自由度によって、オブジェクトや関数の動作が意図以上に多様化し、コードの本来の設計目的やドメイン制約を超えたり無視する動作が生まれる可能性があります。

도메인에서 쓰이는 범위로 기능을 제한하는 것으로 해당 코드의 의미와 목적을 분명하게 만들 수 있는 장점이 있는데, 익명 함수가 남발되면서 만들어진 목적과 의미를 훼손하는 코드가 생성될 수 있다. 익명함수를 써야 한다면, 함수 내로 받은 익명함수의 로직이 어느정도 제한되어야 하고 익명 함수를 인자로 전달 받음에도 불구하고 자유도를 제한할 수 있는 정도로 쓰이는 편이 바람직하다.

ドメインで使用される範囲に機能を制限することで、そのコードの意味や目的を明確にできます。しかし無名関数が乱用されると、作成された目的や意味が損なわれるコードが生まれることがあります。無名関数を使う際、関数内に受け取った無名関数のロジックがある程度制限されていることが望ましいです。無名関数を引数として受け取る場合でも、自由度を制限できる範囲で使用する方が適切です。

보통 함수의 파라메터로 함수를 받는 것은 함수형 프로그래밍에서 사용한다. 순수 함수라면 함수를 전달하더라도 동작의 예측이 쉬울 수 있지만, 순수함수가 아니라 객체내에서 전달 받은 함수에 외부 변수나, 객체를 바인딩하는 코드가 있다면 객체나 변수의 상태를 변경할 수 있기 때문에 어떤 동작을 할지 예측하기 어려워진다. 또한 전달 받은 함수를 객체에서 어떤 목적으로 이용할 것인지를 알 수 있도록 객체의 사양(인터페이스, 퍼블릭 메소드)을 드러내야 하는데 이를 드러내기 쉽지 않은 경우가 있어서 함수를 파라메터로 사용하는 코드를 남발하는 것은 좋지 않다.

関数のパラメータとして関数を受け取るのは通常、関数型プログラミングで使われます。純粋関数であれば関数を渡しても動作の予測は容易ですが、純粋関数でなく、オブジェクト内で渡された関数に外部変数やオブジェクトをバインドする場合、オブジェクトや変数の状態を変更できるため、動作の予測が難しくなります。また、渡された関数をオブジェクトでどのように利用するかを明確にするため、オブジェクトの仕様（インターフェース、パブリックメソッド）を示す必要がありますが、示すのが難しい場合もあるため、関数をパラメータとして渡すコードを乱用するのは好ましくありません。

### 클로저의 대안
### クロージャの代替案

#### 메소드 사용하기
#### メソッドを使う

클래스 내부에서 파라메터로 클로저를 사용해서 인자로 함수를 전달하기 보다는, 함수 블록 안의 메소드를 호출하는 코드를 작성하는 편이 좋다. 메소드는 매개변수의 타입과 반환 타입을 시그니처로 나타낼 수 있기 때문에 정적 분석이 가능한 코드를 만들 수 있다. 

クラス内部でパラメーターとしてクロージャを使い、引数として関数を渡すよりも、関数ブロック内でメソッドを呼び出すコードを記述する方が望ましいです。メソッドの場合、パラメーターの型や返り値の型をシグネチャで明示できるため、静的解析が可能なコードになります。

익명함수를 파라메터로 사용하면 좋은 경우는 함수의 시그니처를 나타내지 않아도 사용법을 알아채기 쉬운 코드나 간단한 코드이거나, 함수 외부의 변수를 캡쳐해서 사용할 수 있고, 해당 맥락에서만 사용하는 코드를 작성할 때이다. 이런 이점을 누릴 수 없다면 메소드를 만들어 정적 분석이 가능한 코드로 만드는 편이 좋다.

無名関数をパラメーターとして使用するのが適しているのは、関数のシグネチャを示さなくても使い方がすぐに分かるコードや、シンプルなコードの場合、または関数外部の変数をキャプチャして利用できる場合、特定のコンテキストだけで使うコードを記述する場合です。これらの利点が得られない場合には、メソッドを作成して静的解析が可能なコードにする方が良いでしょう。

인스턴스 메소드는 `$this`를 자주 사용하게 되어 객체의 상태 관리가 복잡하게 되고 어려워질 수 있으므로, 정적 메소드를 사용하고, 특별한 상황이 아닌 한 정적 메소드는 정적 멤버의 상태 공유가 없는 순수 함수처럼 정의하여 사용하여 함수를 사용하면 어떤 일이 일어날지 예측하기 쉽게 만들자.

インスタンスメソッドは`$this`を多用することになり、オブジェクトの状態管理が複雑になることがあります。そのため、静的メソッドを使用し、特別な理由がない限り、静的メソッドは静的メンバーの状態共有がない純粋関数として定義すると、関数の動作を予測しやすくなります。

#### 디자인 패턴을 활용하기
#### デザインパターンを活用する

디자인 패턴을 통해 미리 만들어둔 특정 사양의 객체로 교체 할 수 있게 만들거나, 설정할 수 있는 옵션을 미리 구비하여 필요에 따라 설정된 대상을 주입하여 교체할 수 있도록 코드를 만들 수 있는 각종 패턴을 만드는 방법을 배우도록 한다. 함수 파라메터를 대체할 수 있는 OOP의 디자인 패턴으로는 전략 패턴, 상태 패턴, 템플릿 메소드 패턴 등이 있다. (각각의 세부 설명은 디자인 패턴과 관련된 내용이므로 여기서는 생략한다.)

デザインパターンを使うことで、事前に作成された特定仕様のオブジェクトに置き換えたり、設定可能なオプションを用意して必要に応じて注入できるようにコードを作る方法を学びます。関数パラメータを代替できるOOPのデザインパターンには、戦略パターン、状態パターン、テンプレートメソッドパターンなどがあります（詳細な説明はデザインパターン関連の資料に譲ります）。

- 전략 패턴 : 런타임에 교체 가능한 여러 개의 알고리즘(전략)을 캡슐화하고, 이를 인터페이스로 추상화하여 선택적으로 사용할 수 있도록 하는 패턴.
- 戦略パターン：ランタイムで差し替え可能な複数のアルゴリズム（戦略）をカプセル化し、インターフェースで抽象化して選択的に利用できるようにするパターン。
- 상태 패턴 : 객체의 상태를 별도의 클래스로 분리하고, 상태 변경에 따라 객체의 동작이 다르게 수행되도록 하는 패턴.
- 状態パターン：オブジェクトの状態を別クラスとして分離し、状態変更に応じてオブジェクトの動作を変更するパターン。
- 템플릿 메소드 패턴 : 상위 클래스에서 알고리즘의 기본 흐름을 정의하고, 일부 세부 구현을 하위 클래스에서 정의하도록 하는 패턴.
- テンプレートメソッドパターン：上位クラスでアルゴリズムの基本フローを定義し、一部の詳細実装を下位クラスで定義するパターン。

#### 클래스도 대체하기
#### クラスを代替として使う

클래스를 객체화하고, 클래스 자체를 함수처럼 호출해 사용할 수 있도록 `__invoke`를 사용하여 매개변수의 타입과 반환 타입을 정의하는 것이 가능하다. 클로저 대신에 별도의 클래스를 타입으로 한 객체를 전달하는 방법도 사용할 수 있다.

クラスをオブジェクト化し、`__invoke`を使用してクラス自体を関数のように呼び出せるようにすれば、パラメータ型と戻り値型を定義可能です。クロージャの代わりに、特定の型のオブジェクトを渡す方法もあります。

또는 Value Object를 정의해서 클로저 대신 사용하는 방법도 좋은 방법이다. Value Object는 도메인의 제약이 담긴 값을 담는 용도 뿐만 아니라, 도메인의 제약사항을 표현하는 로직을 담은 클래스를 만드는 방식으로 클로저를 대체한다.

また、ValueObjectを定義してクロージャの代わりに使う方法も有効です。ValueObjectは、ドメイン制約を持つ値を保持するだけでなく、ドメイン制約を表現するロジックを含むクラスを使う方式でクロージャを代替します。

# 마지막으로
# 最後に

Closure를 매개변수로 사용하기에 앞서, 꼭 사용해야 할까? 대체하는 방법을 생각해 보고 불가피하다면 런타임 검사하는 방법을 고민해 보면 도움이 될 것이다.

クロージャをパラメーターとして使用する前に、本当に使う必要があるかどうかを考えてみましょう。代替できる方法がないか検討し、どうしても必要な場合は、ランタイムで検証する方法を考えると役立ちます。

---
<a name="endnote_1">[1]</a> https://externals.io/message/125943
