# 명명된 인자를 사용할 때 여기까지 생각하고 있나요?
# 「名付け引数」を使うとき、ここまで考えていますか？

명명된 인자란 인자를 전달할 때 파라메터 이름을 전달하여, 함수의 파라메터가 정의된 순서에 관계 없이 인자를 전달할 수 있도록 하는 문법이다.

名前付き引数とは、引数を渡す際にパラメータ名を指定することで、関数のパラメータが定義された順番に関係なく引数を渡すことができる構文です。

php 8 부터 명명된 인자를 사용할 수 있게 되었다.

PHP8から名前付き引数が使用可能になりました。

# 도입
# 導入

명명된 인자는 코드의 가독성을 높이지만, 파라메터의 이름을 나열해야 하기 때문에 타이핑이 귀찮은 단점이 있다. 명명된 인자의 좋은 점과 나쁜 점을 생각해 보는 것으로 좀 더 상황에 맞는 적절한 코드를 작성하는 방법을 알아 보자.

名前付き引数はコードの可読性を高めますが、パラメータ名を列挙する必要があるため、タイピングが面倒という欠点もあります。名前付き引数の利点と欠点を考えることで、状況に応じた適切なコードの書き方を学んでいきましょう。

# 본론
# 本論

## 예제 코드
## 例のコード

```php
$fn = function ($a, $b, $c) {};
$fn(c:1, a:2, b:3);
```

라는 함수가 있다면 파라메터의 순서대로 인자를 전달하는 것이 아니라, 파라메터명을 사용하여 파라메터의 순서와 인자의 순서를 다르게 전달할 수 있는 기능이다.

という関数がある場合、パラメータの順番に従って引数を渡すのではなく、パラメータ名を指定することで、パラメータの順序と引数の順序を異なる形で渡すことができる機能です。

## php 함수 파라메터의 특징
## PHPで関数パラメータの特徴

명명된 인자의 사용에 대해 생각하기 전에 php 함수의 파라메터 특징을 좀 더 생각해 보자.

名前付き引数の使用について考える前に、PHPの関数パラメータの特徴についてもう少し考えてみましょう。

### 가변인자의 문제
### 可変引数の問題

php에서 데이터 세트를 함수나 메소드에 전달하고 싶을 때는 배열 타입의 파라메터를 사용한다. 하지만, 배열 파라메터의 경우, 배열 내부의 데이터 구조를 알 수 없기 때문에 dockbloc generic이나 array shape 등의 주석을 추가하는 편이 좋다.

PHPでは、データセットを関数やメソッドに渡したい場合、配列型のパラメータを使うことが一般的です。しかし、配列パラメータの場合、配列内部のデータ構造が分かりにくいため、dockbloc genericやarray shapeなどのドックブロックアノテーションを追加するのが望ましいです。

개인적으로 dockbloc은 보일러 플레이트가 있다보니, 여러 배열을 전달하거나 대량의 데이터를 함수에 전달하는 것이 아니라면, 약간의 성능 저하가 있더라도 가변 파라메터를 사용하는 코딩 스타일을 선호한다.

個人的には、ドックブロックはボイラープレートが多くなりがちなので、複数の配列を渡したり、大量のデータを関数に渡すようなケースでなければ、多少のパフォーマンス低下があっても可変パラメータを使うコーディングスタイルを好みます。

가변 파라메터를 사용하면, `fn(...['a', 'b', 'c'])`으로 가변 파라메터에 배열로 인자를 전달할 수도 있고, `fn('a', 'b', 'c')` 그저 나열하는 방법으로 파라메터를 전달할 수 있으며, 문법적인 간략함과 더불어 런타임 타입체크를 활용할 수 있다.

可変パラメータを使えば、 `fn(...['a', 'b', 'c'])`のように配列を展開して渡すことも、`fn('a', 'b', 'c')`のように単純に列挙して渡すこともでき、構文的に簡潔でありながら、実行時の型チェックも活用できます。

가변 파라메터는 동일한 타입의 데이터로 이뤄진 데이터 세트를 전달할 때 간단한 장점이 있지만, 함수를 정의할 때, 파라메터의 가장 마지막에 위치해야 하고, 하나의 함수 당 하나의 가변 인자만 사용할 수 있다는 단점이 있다.

可変パラメータは、同じ型のデータで構成されたデータセットを渡す場合に便利ですが、関数を定義する際にはパラメータの最後に書く必要があり、1つの関数につき1つの可変引数しか使えないという制約があります。

### 디폴트 값을 가진 파라메터의 위치 문제
### デフォルト値を持つパラメータの位置の問題

```php
function ($param1, $paramWithDefault = 100, ...$variadicParams);
```

위의 코드는 가능하지만, 다음 두 코드는 불가능하다.

上記のコードは可能ですが、次の2つのコードは不可能です。

```php
function ($paramWithDefault = 100, $param1, ...$variadicParams);
```

```php
function (...$variadicParams, $paramWithDefault = 100, $param1);
```

왜냐하면, 파라메터에 디폴트 값이 있는 경우, 디폴트 값이 없는 파라메터가 디폴트 값이 부여된 파라메터 다음에 위치할 수 없다는 룰이 있기 때문이다.

その理由は、パラメータにデフォルト値が設定されている場合、デフォルト値のないパラメータをその後に配置することはできないというルールがあるためです。

## 언제 명명된 인자를 사용하면 좋을까?
## どんなときに名前付き引数を使うと良いか？

1. 함수를 사용할 때 인자의 전달 순서를 파라메터의 순서와 다르게 하고 싶을 때 사용한다.
1. 関数を使用する際に、引数の渡す順番をパラメータの定義順と異なる形にしたいときに使います。

2. 코드를 읽을 때 파라메터 명을 표시하여 함수가 정의된 부분을 확인하지 않고도 어떤 인자들이 전달되는지 표기하고 싶을 때 사용한다.
2. コードを読む際にパラメータ名を明示することで、関数の定義部分を確認しなくてもどんな引数が渡されているかを分かりやすくしたいときに使います。

3. 디폴트 값이 부여된 파라메터의 인자 전달을 생략하고 싶을 때 사용한다.
3. デフォルト値が設定されているパラメータの引数の指定を省略したいときに使います。

### 항상 명명된 인자를 사용하는 것이 좋지 않을 이유
### 常に名前付き引数を使うべきではない理由

```php
function getUserById(int $id): User {}
```

위의 함수 시그니처의 경우, 함수 명에 `byId`가 있어 id를 전달하는 것을 직관적으로 알 수 있는데, 굳이 추가 정보인 명명된 인자를 사용할 필요는 없다.

上記の関数シグネチャの場合、関数名に byId が含まれているため、id を渡すことが直感的に分かります。そのため、わざわざ追加情報である名前付き引数を使う必要はありません。

```php
function biggerThan(int $a, int $b): bool {}
```

위의 함수 시그니처의 경우, `A is bigger than B`의 구문을 떠올리기 때문에, 첫 번째 인자가 두 번째 인자 보다 큰지를 판별하는 함수라고 생각할 수 있다. 만약 두 번째 인자 보다 첫 번째 인자가 큰지를 판별하는 함수였다면 함수를 상식적으로 만들라는 조언을 해 줄 수 있을 것이다.

上記の関数シグネチャの場合、英語の「A is bigger than B」という構文を思い起こさせるため、第一引数が第二引数より大きいかを判定する関数であることが分かります。もし逆に、第二引数より第一引数が大きいかを判定するのではなく、第一引数が第二引数より大きいかを確認する関数でなければ、直感的に分かりやすい関数にするようアドバイスするでしょう。


```php
function subtract(int $a, int $b): int {}
```

위의 함수 시그니처의 경우, 첫 번째 인자에서 두 번째 인자를 빼는 함수라고 생각할 수 있다. 만약 두 번째 인자에서 첫 번째 인자를 빼는 함수였다면 함수를 상식적으로 만들라는 코드리뷰를 할 것이다.

上記の関数シグネチャの場合、第一引数から第二引数を引く関数だと理解できます。もし逆に、第二引数から第一引数を引く関数であったなら、直感的にわかりやすい関数にするようコードレビューで指摘するでしょう。

#### 알 수 있는 것
#### 分かること

이렇듯 명명된 파라메터 없이도 함수의 이름만으로 역할을 하는지 알 수 있기 때문에 굳이 정보를 추가하는 명명된 인자를 사용할 필요는 없다.

このように、関数名だけでもその役割が明確に分かる場合には、わざわざ追加情報として名前付き引数を使う必要はありません。

## 명명된 인자를 사용해야 할 때
## 名前付き引数を使うべき場合

다음과 같은 시그니처가 있다고 하자.

次のようなシグネチャがあるとします。

```php
function isUpdatedBy(int $userId, bool $excluded = false) {}
```

`isUpdatedBy`를 사용할 때는 `isUpdatedBy(userId: $id)` 또는 `isUpdatedBy(userId: $id, excluded: true)`으로 사용할 수 있다. `excluded`파라메터는 디폴트 값이 있으므로 생략하는 편이 좋다.

`isUpdatedBy` を使用する場合、`isUpdatedBy(userId: $id)` または `isUpdatedBy(userId: $id, excluded: true)` のように呼び出すことができます。`excluded`パラメータにはデフォルト値が設定されているため、省略するのが望ましいです。


```php
enum StatusEnum
{
    case Active;
    case Deleted;
    case Stopped;
}

function isInStatus(bool $excluded = false, ...$statuses) {}
```

`isInStatus`를 사용할 때는 `isInStatus(statuses: [StatusEnum::Deleted])`, `isInStatus(statuses: [StatusEnum::Deleted], excluded: true)`으로 사용할 수 있다.

`isInStatus`を使用する場合、`isInStatus(statuses: [StatusEnum::Deleted])`、`isInStatus(statuses: [StatusEnum::Deleted], excluded: true)`のように使用できます。

메소드를 설계 할 때, 유사한 그룹의 클래스라면 excluded와 같은 공통의 메소드의 정의 위치는 일관되게 만들고 싶을 것이다.

メソッドを設計する際、類似グループのクラスであれば、`excluded`のような共通のメソッドの定義位置は一貫性を持たせたいと思うでしょう。

문제는 `isUpdatedBy`의 경우에는 바로 다음에 `id`가 위치하고, 마지막에 `excluded`가 나오는 것이 자연스럽고, `isInStatus`의 경우도 `statuses`가 먼저 나오고, `excluded`가 마지막에 나오는 것이 자연스럽다. 하지만, 명명된 인자로 인해서 파라메터의 위치상으로는 `excluded`가 마지막에 위치하지 못한다.

問題は、`isUpdatedBy`の場合は`id`が直後に来て、`excluded`が最後に来ると直感的に分かりやすく、`isInStatus`でも同様に、`statuses`が先に来て`excluded`が最後に来るのが自然です。しかし、名前付き引数の存在により、パラメータの位置として`excluded`を最後に置けないことがあります。

이렇게 동일하게 `bool $excluded = false`를 정의하는데, 어떤 경우는 두 번째 파라메터가 되고, 어떤 경우는 첫 번째 파라메터로 정의되어야 하는 경우, 사용할 때 명명된 인자로 사용하면 일관된 방식으로 사용할 수 있다.

このように、どちらも bool $excluded = false を共通して定義する場合でも、あるケースでは第2引数、別のケースでは第1引数にしなければならないことがあります。そのような場合、使用時に名前付き引数を使うことで、呼び出し方を一貫させることができます。

#### 만약 명명된 인자가 없다면
#### 名前付き引数がない場合

명명된 인자가 없다면, `isInStatus(false, ...[StatusEnum::Deleted, StatusEnum::Stopped])`으로 사용해야 한다. `excluded`는 기본 `false`라서 생략하고 싶은데, 파라메터가 정의된 순서대로 적어야 하기 때문에 `statuses`를 인자로 전달하기 위해서 생략하지 못하기 때문에 코드가 우아해지지 못한 문제가 있다.

名前付き引数がないと、`isInStatus(false, ...[StatusEnum::Deleted, StatusEnum::Stopped])`のように使用しなければなりません。`excluded`はデフォルトで`false`なので省略したいところですが、名前付き引数がないと、パラメータ定義の順序通りに引数を渡す必要があるため、`statuses`を渡すためには`excluded`を省略できず、コードが洗練されなくなるという問題があります。

명명된 인자를 사용하면 `excluded` 인자를 뒤로 배치하여 디폴트 값이 부여된 파라메터에 대한 인자 전달을 생략할 수 있다는 장점이 있다. 또한 전달하려는 인자의 의미를 분명히 하여, 함수의 정의된 파라메터를 직접 읽지 않고서도 어떤 의미의 인자를 전달하는지 알 수 있다.

名前付き引数を使えば、`excluded`引数を後ろに配置することで、デフォルト値が設定されたパラメータへの引数の指定を省略できるという利点があります。さらに、渡そうとしている引数の意味を明確にすることで、関数のパラメータ定義を直接見なくても、どのような意味の引数を渡しているのかを把握することができます。

디폴트 값이 붙은 파라메터는 생략할 수 있으므로 다음과 같이 전달하려는 인자를 생략하여 불필요한 정보를 제거한 코드를 만들 수 있다.

デフォルト値の付いたパラメータは省略可能なので、次のように渡す必要のある引数だけを記述し、不要な情報を取り除いたコードを書くことができます。

```php
isInStatus(statuses: ...[StatusEnum::Deleted, StatusEnum::Stopped], excluded: false);
```

```php
isInStatus(statuses: ...[StatusEnum::Deleted, StatusEnum::Stopped]);
```

## 명명된 인자의 문제
## 名前付き引数の問題点

명명된 인자를 사용하는 쪽에서는 함수의 파라메터를 쓰기 때문에, 함수 파라메터명이 달라지게 되면, 해당 함수를 사용하는 모든 코드를 바꿔야 한다는 문제점이 있다.

名前付き引数を使用する場合、関数のパラメータ名を明示的に指定することになるため、関数のパラメータ名が変更されると、その関数を使用しているすべてのコードを修正しなければならないという問題があります。

그러므로 모든 함수에 명명된 인자를 사용하기 보다는 함수명으로 어떤 인자를 전달해야 하는지 알 수 있는 경우는 굳이 사용하지 않는 편이 좋으며, 함수명으로 전달하려는 파라메터가 무엇인지 몇 번째 인자로 전달해야 하는지 알기 어려운 경우에는 명명된 인자를 사용하는 편이 좋다.

そのため、すべての関数で名前付き引数を使うのではなく、関数名からどのような引数を渡せばよいかが明確に分かる場合には、無理に使用しない方がよいでしょう。
逆に、関数名だけではどのパラメータを何番目に渡すべきかが分かりにくい場合には、名前付き引数を使うのが適しています。

## 인간의 언어처럼 표현하기
## 人間の言語のように表現する

명명된 인자를 사용하면, 함수의 인자에서 디폴트 값이 있는 것을 생략할 수 있고, `isUpdatedBy` 처럼 영문법상 `id`가 먼저 나오고, `excluded`가 나중에 나오는 것이 자연스러운데, 인자의 전달 순서를 적절히 바꿀 수 있어, 인간의 언어와 같은 인식 구조의 표현이 가능하다는 장점이 있다.

名前付き引数を使うことで、関数の引数のうちデフォルト値が設定されているものを省略でき、`isUpdatedBy`のように英語の文法上では`id`が先に来て`excluded`が後に来る方が自然な場合でも、引数の渡す順序を適切に入れ替えることができるため、人間の言語のような認知構造に沿った表現が可能になるという利点があります。

## 싱글 엑션 클래스와 비교
## シングルアクションクラスとの比較

명명된 인자가 없던 시절에는, 코드를 읽을 때 함수 정의를 직접 확인하거나, 전달할 파라메터 값을 의미 있는 변수에 담아 전달하는 방식을 사용했다. 또 다른 방법으로는, 필요한 값을 setter로 설정한 후, action 메소드 하나를 통해 객체를 함수 대신 사용하는 패턴도 있었다.

名前付き引数がなかった時代には、コードを読む際に関数の定義を直接確認したり、渡すパラメータの値を意味のある変数に代入してから渡す方法が使われていました。また別の方法としては、必要な値を`setter`で設定し、`action`メソッドひとつでオブジェクトを関数の代わりに使うパターンもありました。

하나의 엑션을 가진 다양한 클래스를 정의할 수 있지만, 대표적인 예로 빌드 패턴을 들 수 있다.

1つのアクションを持つさまざまなクラスを定義することができますが、代表的な例としてはビルダーパターンが挙げられます。

```php
class UserBuilder {
    private $name;
    private $age;
    private Gender $gender;

    public function setName(string $name): self {
        $this->name = $name;
        return $this;
    }

    public function setAge(int $age): self {
        $this->age = $age;
        return $this;
    }

    public function setGender(Gender $gender) {
        $this->age = $gender;
        return $this;
    }

    public function build(): User {
        return $this;
    }
}

(new UserBuilder)->setName('yamada')->setAge(30)->setGender(Gender::Male)->build();
```

위와 같이 action은 build 메소드 하나이며 필요한 값은 setter를 통해서 받았다.

上記のように、actionはbuildメソッドひとつだけで、必要な値はsetterを通じて受け取っていました。

# 마지막으로
# 最後に

php에 명명된 인자가 없던 시절에는, 싱글 엑션 클래스 또는 인자를 파라메터의 의미의 변수에 담아서 전달했지만, php에 명명된 인자가 생기고 나서는 좀 더 간단하게 가독성 좋은 함수 인자 전달 방식을 사용할 수 있게 되었다.

PHPに名前付き引数がなかった時代には、シングルアクションクラスを使ったり、引数をパラメータの意味を持つ変数に代入してから渡すなどの方法が用いられていました。しかし、PHPに名前付き引数が導入されてからは、より簡潔で可読性の高い引数の渡し方ができるようになりました。

명된 인자를 사용하면 인자의 순서를 달리 전달할 수 있어, 인간 언어에 맞는 순서로 코드를 작성할 수 있기 때문에 코드를 읽을 때 글을 읽는 듯한 편안함을 준다. 필요에 따라 적극 사용하는 것으로 가독성을 높일 수 있다.

名前付き引数を使えば、引数の順番を変えて渡すことができ、人間の言語に近い順序でコードを書くことができるため、コードを読む際に文章を読むような自然さと心地よさを与えてくれます。必要に応じて積極的に活用することで、コードの可読性を向上させることができます。
