# 엔지니어라면 알아야 할 파일 조작의 기초
# エンジニアなら知っておくべきファイル操作の基礎

## 들어가며
## はじめに

프로그래밍에서 자주 사용되지만, 그 누구도 자세히 알려 주지 않는 내용 중 하나가 파일 조작이다. 이에 관한 자료나 설명을 찾기 어려운 경우가 많다. 학교에서 CS 지식을 배운다고 해도, 파일 조작과 같은 실무에서 필요한 지식은 배우지 않거나 개략적인 부분만 다룬다.

プログラミングで頻りに使われるにもかかわらず、誰も詳しく教えてくれない内容の一つがファイル操作です。これに関する資料や説明は見つかりにくいです。学校でCSの知識を学ぶとしても、ファイル操作のような実務で必要な知識は学ばないか、概要だけにとどまることが多いです。

이로 인해 파일과 관련된 문제를 다룰 때 데이터를 파일을 통째로 읽어 처리하거나, 파일 핸들러를 통해 파일을 처리하더라도 피상적인 이해와 예제 코드 패턴을 따라 코드를 작성하는 경우가 많다.

そのため、ファイルに関する問題に対処する際には、データをファイル全体で読み取って処理したり、ファイルハンドラーを使っても表面的な理解とサンプルコードのパターンに従ってコードを書いてしまうことがよくあります。

이 기사는 파일 조작을 이해하는 데 필요한 기초적인 CS 지식을 습득하기 위한 목적으로 작성되었다. 이를 통해 파일 헨들러를 좀 더 적절하게 다룰 수 있으리라 기대한다.

本記事はファイル操作を理解するために必要な基本的なCS知識を習得するために作成されました。これを通じてファイルハンドラーをより適切に扱えるようになることを期待します。

:warning: 본 기사는 파일 핸들러를 이해하는 데 필요한 지식에 초점을 맞추고 있으며, OS의 파일 시스템과 디스크의 하드웨어적인 처리에 대한 설명은 필자의 지식 부족으로 실제와 다를 수 있다는 점을 미리 밝힌다.

:warning: 本記事はファイルハンドラーの理解に必要な知識に焦点を当てており、OSのファイルシステムやディスクのハードウェア的な処理に関する説明については筆者の知識不足により、実際と異なる点がある可能性があることを予めご了承ください。

## 본론
## 本論

### 디스크의 동작
### ディスクの動作

컴퓨터는 데이터를 0과 1로 저장을 한다. 0과 1의 상태를 1비트로 표현을 하고, 1비트의 상태가 8개가 모이면 1바이트가 된다. 하드웨어 디스크는 연속된 이진 상태 저장 공간을 가지고 있다. 연속된 저장 공간을 가진다는 것은, 어떤 데이터를 찾을 때 인덱스 번호를 통한 접근을 할 수 있어 빠르게 데이터에 접근할 수 있다는 것을 의미한다. 컴퓨터가 데이터를 다룰 때는 가능한 빠른 것이 좋기 때문에 가능한 연속된 저장 공간을 갖도록 설계를 한다.

コンピュータはデータを0と1で保存します。0と1の状態を1ビットで表現し、1ビットの状態が8つ集まると1バイトになります。ハードウェアディスクは連続した2進状態の保存空間を持っています。連続した保存空間を持つということは、データを探す際にインデックス番号でアクセスできて、迅速にデータへアクセスできます。コンピュータがデータを扱うときには、できるだけ速い方が望ましいため、可能な限り連続した保存空間を持つように設計されています。

컴퓨터는 하드웨어에 기록된 데이터를 읽거나 쓰는 경우 블록이란 단위로 데이터를 읽고 쓴다. 아무리 작은 데이터를 취득할 때에도 한 단위의 블록을 읽어야 한다. 디스크에 대한 접근은 파일시스템에서 관리를 하는데, 파일 시스템은 하나의 블록의 데이터를 읽기 위해서 최소한 블록의 크기 이상의 메모리 공간을 사용해야 한다. 블록은 데이터를 읽고 쓰기 위한 최소 단위의 개념이다.

コンピュータがハードウェアに記録されたデータを読み書きする場合、ブロックという単位でデータを読み書きします。たとえ小さなデータを取得する場合でも、1単位のブロックを読み込まなければなりません。ディスクへのアクセスはファイルシステムで管理され、ファイルシステムは1つのブロックのデータを読み込むために、少なくともブロックのサイズ以上のメモリ空間を使用する必要があります。ブロックはデータの読み書きの最小単位の概念です。

디스크에 저장된 파일은 빈번히 저장되고 삭제되고 변경된다. 일부 데이터가 지워진 영역 만큼의 공간에 새로운 데이터를 저장할 때 데이터의 크기가 커서 저장될 수 없다면, 파일의 데이터를 분할해서 이곳 저곳에 저장해야 한다. 하드웨어는 블록 단위로 데이터를 저장하므로 기존 블록에 저장할 공간이 부족하다면 새로운 블록에 데이터를 저장하거나 기존 블록과 새로운 블록에 데이터를 분할해서 저장을 한다. 블록이란 저장 단위로 인해 하드웨어는 모든 저장 공간을 연속적으로 만들지 않고, 어떤 단위의 연속된 저장 공간을 가진다.

ディスクに保存されたファイルは頻繁に保存、削除、変更が行われます。一部のデータが削除された領域の空きスペースに新しいデータを保存する際、データのサイズが大きすぎて保存できない場合は、ファイルのデータを分割して別々の場所に保存する必要があります。ハードウェアはブロック単位でデータを保存するため、既存のブロックに保存スペースが不足している場合、新しいブロックにデータを保存するか、既存のブロックと新しいブロックにデータを分割して保存します。ブロックとは保存単位のことであり、このためハードウェアはすべての保存スペースを連続的に構成せず、一定単位の連続した保存スペースを持つようになっています。

:bulb: 하드웨어의 설계는 다양한 기술을 사용하고 있으므로 하나의 블록이라도 반드시 연속적인 저장 공간만을 가지는 것만은 아니며, SSD와 같은 저장소는 1 비트 단위의 데이터 저장이 아닌 셀 단위의 데이터 저장을 하므로 1~4비트 데이터를 한 단위로 저장하는 등의 기술을 사용한다.

:bulb: ハードウェアの設計はさまざまな技術を使用しているため、1つのブロックであっても必ずしも連続した保存空間のみを持つわけではありません。SSDのようなストレージは、1ビット単位ではなくセル単位でデータを保存し、1〜4ビットのデータを1単位として保存するなどの技術が使用されています。

### 파일 데이터의 변경
### ファイルデータの変更

어떤 파일의 데이터가 변경되었다고 가정해 보자. 해당 파일의 용량이 크다면 여러 블록에 걸쳐 데이터가 저장될 것이고, 파일의 용량이 작다면 하나의 블록 안에 다른 파일의 데이터들과 함께 저장될 수 있다. 예를 들어 `ABCDEFG`라는 데이터가 있고, 하나의 블록이 4개의 문자를 저장한다고 가정하자. 이 경우 `ABCD`와 `EFGH`가 두 개의 블록에 저장된다. 그런데 `ABCD123EFGH`으로 123이란 데이터가 추가 되었다고 하자. 그러면 `ABCD` `123E` `FGH_`으로 분할하여 각각의 블록에 저장을 할 것이다. (\_는 빈 저장공간이라고 하자.) 데이터의 추가 및 제거로 인하여 각각의 블록에 저장되는 데이터 세트가 달라진다. 

あるファイルのデータが変更されたと仮定しましょう。そのファイルの容量が大きい場合、複数のブロックにわたってデータが保存され、ファイルの容量が小さい場合は1つのブロック内に他のファイルのデータと一緒に保存されることがあります。例えば、`ABCDEFG`というデータがあり、1つのブロックが4文字を保存すると仮定すると、`ABCD`と`EFGH`が2つのブロックに保存されます。ここで`ABCD123EFGH`のように123というデータが追加された場合、`ABCD` `123E` `FGH_`と分割され、それぞれのブロックに保存されます（\_は空の保存領域とします）。データの追加や削除によって各ブロックに保存されるデータセットが異なることがわかります。

기존 블록을 지우고 다시 쓰는 것 보다는 새로운 블록에 데이터를 추가하는 것이 좋은데, 일정한 영역에 반복해서 쓰면 하드웨어의 수명을 단축시키므로 전체 디스크 영여글 골고루 활용하는 것이 좋고, 블록의 일부 데이터를 변경 했을 때 동일 블록 내의 다른 데이터가 있다면 다른 데이터에 끼치는 영향도 고려해야 하기 때문에, 하나의 블록을 다시 쓰기 보다는 블록에 할당하는 것이 리소스 소모량이 적고, 덮어 쓰지 않아 기존의 블록이 남겨져 있기 때문에 문제가 생겼을 때 (파일 시스템이) 데이터의 데이터의 리커버리를 할 수 있는 가능성이 높아지는 등의 이유 때문이다. 그래서 `ABCD` `123_` `EFGH`와 같이 기존의 블록(`ABCD`, `EFGH`)은 그대로 두고 추가되는 데이터만 따로 새 블럭(`123_`)에 추가한다. 이 때 하드웨어의 연속된 저장 공간에 데이터가 저장된 것은 아니지만 논리적으로 연결된 데이터로 만들어진다.

既存のブロックを削除して再書き込みするよりも、新しいブロックにデータを追加する方が望ましい理由はいくつかあります。特定の領域に繰り返し書き込むとハードウェアの寿命が短くなるため、ディスク全体の領域を均等に活用することが重要です。また、ブロック内の一部のデータを変更する際、同じブロック内にある他のデータに影響を与える可能性も考慮する必要があります。そのため、1つのブロックを再書き込みするよりも、新しいブロックを割り当てる方がリソース消費量が少なく効率的です。さらに、上書きを行わず既存のブロックをそのまま残すことで、問題が発生した場合にファイルシステムがデータを復旧できる可能性が高まるといった利点もあります。このため、ブロックを新たに書き換えるのは効率が悪く、書き込み作業はハードウェアの寿命を縮めるため、`ABCD` `123_` `EFGH`のように既存のブロック（`ABCD`と`EFGH`）はそのままにして、追加されるデータのみ新しいブロック（`123_`）に保存します。このとき、ハードウェア上では連続した保存空間にデータが保存されていないものの、論理的には連結されたデータとして扱われます。

데이터를 삭제하는 경우에는 `ABCD` `123_` `EFGH`에서 A,B,1,2를 삭제하면 삭제된 데이터는 빈 공간으로 남게되며 `__CD` `__3_` `EFGH`가 된다. 데이터를 삭제할 때는 기존의 데이터는 그대로 두고 삭제할 저장 공간의 데이터만 지우는 방식으로 동작한다. 하드웨어에서의 데이터는 불연속적이게 되지만, 논리적으로는 연속된 공간으로 만들 수 있기 때문에 효율적인 데이터 저장을 위해 빈 공간으로 남겨준다.

データを削除する場合、`ABCD` `123_` `EFGH`からA、B、1、2を削除すると、削除されたデータは空白のまま残り、`__CD` `__3_` `EFGH`となります。データを削除する際には、既存のデータをそのままにして、削除対象の保存空間のデータのみを消去する方式で動作します。ハードウェア上ではデータが不連続になりますが、論理的には連続した空間として扱えるため、効率的なデータ保存のために空白として残しておきます。

:bulb: SSD가 보편화 되기 전 하드디스크를 조각모음하는 경우가 있었다. 읽고 쓰는 작업이 많아지면 하드웨어에 저장된 데이터가 불연속적이게 되어 논리적으로 데이터를 연결하는데 컴퓨팅 리소스를 많이 소비하므로 조작 모음을 통해 데이터를 물리적으로 연속적되게 저장해 논리적인 연결 작업에 드는 리소스 소비량을 줄이고 빠르게 동작하도록 만들 수 있었다. SSD의 경우에는 데이터가 조각화 되더라도 하드디스크처럼 속도 저하가 거의 발생하지 않기 때문에 조각 모음이 필요하지 않게 되었다. 오히려 SSD는 하나의 셀의 쓰기 횟수에 한계치가 있어서 잦은 조각 모음은 셀의 수명을 단축시킨다.

:bulb: SSDが普及する前はハードディスクでデフラグを行うことがありました。読み書きの操作が増えるとハードウェアに保存されたデータが不連続となり、論理的にデータを連結する際にコンピュータリソースを多く消費するため、デフラグを行ってデータを物理的に連続した状態に保存し、論理的な接続作業にかかるリソース消費を抑えつつ高速に動作させることができました。しかし、SSDの場合、データが断片化されてもハードディスクのように速度低下がほとんど発生しないため、デフラグが不要になりました。むしろSSDはセルごとの書き込み回数に限界があるため、頻繁なデフラグはセルの寿命を短縮します。

### File handler

#### 파일 헨들러란?
#### ファイルハンドラとは？

파일 헨들러는 파일에 기록된 데이터를 바이트 단위로 읽고 쓸 수 있는 기능을 제공한다. 파일 헨들러를 사용하여 파일의 모든 데이터를 메모리에 올려 놓지 않고 파일의 내용을 읽기, 쓰기를 할 수 있다.

ファイルハンドラは、ファイルに記録されたデータをバイト単位で読み書きする機能を提供します。ファイルハンドラを使用すると、ファイル全体のデータをメモリにロードすることなく、ファイル内容の読み書きが可能です。

파일의 모든 내용을 메모리에 미리 적재하지 않기 위해 파일 핸들러는 파일 포인터라는 위치 추적기를 사용한다. 파일 포인터는 파일 내에서 현재 읽기 또는 쓰기 작업을 하기 위한 지점을 가리킨다.

ファイルの全内容をメモリに事前にロードしないために、ファイルハンドラはファイルポインタという位置追跡機能を使用します。ファイルポインタは、ファイル内で現在読み取りまたは書き込みを行うための位置を指します。

#### 왜 파일 헨들러를 사용하는가?
#### なぜファイルハンドラを使用するのか？

파일이란 바이트 단위의 크기를 가질 때도 있고, 킬로 바이트 단위의 크기를 가질 때도 있고, 메가 바이트 단위의 크기를 가질 때도 있다. 때로는 기가 바이트 단위의 단일 파일도 있고 더 큰 용량의 파일도 존재한다. 이런 단일 파일을 프로그래밍으로 내용을 변경하고자 할 때 모든 파일의 내용을 메모리에 올리려면 파일의 용량 이상의 메모리 사용량이 요구된다.

ファイルは、バイト単位のサイズの場合もあれば、KB、MB、さらにはGBやそれ以上の大容量の単一ファイルの場合もあります。このような大きなファイルをプログラムで内容を変更したいときに、ファイル全体をメモリにロードしようとすると、ファイルのサイズ以上のメモリ使用量が要求されます。

어떤 프로그램이 어떤 파일을 처리할 때 전달되는 파일의 용량은 항상 일정한 것은 아니다. 파일에 대해 동일한 처리를 수행하는 프로그램이라도 유저가 업로드하는 파일 크기에 따라 작은 용량을 처리할 때도, 큰 용량을 처리할 때도 있다. 프로그램이 사용하는 메모리는 가능한 일정한 한계선을 두고 만드는 것이 좋으며, 무한정 메모리를 소모하게 되면 컴퓨터가 사용할 수 있는 하드웨어 메모리 리소스를 초과하거나 OS에 할당된 메모리 리소스를 초과하여 프로그램이 의도치 않게 종료되는 크레시 현상이 발생할 수 있다.

あるプログラムがファイルを処理する際に、渡されるファイルの容量は常に一定ではありません。同じ処理を行うプログラムでも、ユーザーがアップロードするファイルサイズに応じて、小さなファイルを処理することもあれば、大きなファイルを処理することもあります。プログラムが使用するメモリは、可能な限り一定の限界を設けて設計することが望ましく、無制限にメモリを消費すると、コンピュータが利用できるハードウェアメモリリソースやOSに割り当てられたメモリリソースを超えてしまい、プログラムが予期せず終了するクラッシュが発生することがあります。

프로그램이 크레시로 인해 강제 종료되면, 애플리케이션을 다시 기동해야 할 뿐만 아니라, 처리하고 있던 작업이 손실되며, 처리 문제가 발생했을 때 예외처리를 비롯한 각종 후속처리가 이뤄지지 않으므로 복구하기 어렵거나 불가능한 여러 문제가 발생할 수 있다. 따라서 크레시로 인한 종료 현상을 최대한 줄이기 위해서 애플리케이션의 메모리 관리를 잘 해 줘야 한다.

プログラムがクラッシュによって強制終了されると、アプリケーションを再起動するだけでなく、処理中だった作業が失われ、エラーが発生した際の例外処理などの後続処理が行われず、復旧が困難または不可能なさまざまな問題が発生する可能性があります。そのため、クラッシュによる終了をできる限り防ぐために、アプリケーションのメモリ管理を適切に行う必要があります。

파일 헨들러를 사용하면 파일 데이터의 특정 지점까지의 데이터를 메모리에 올리고 프로그래밍을 통해서 메모리에 올린 데이터를 처리할 수 있다. 처리가 끝나면 파일을 최종적으로 읽은 지점부터 특정 지점까지의 데이터를 메모리에 올리는 작업을 반복하여, 파일 전체의 데이터가 아닌 적당한 크기 만큼의 데이터를 메모리에 올려서 처리하기 때문에 메모리 사용량이 절약된다. 파일 헨들러를 이용하여 메모리 사용량을 줄일 수 있는 로직을 만들 수 있어 애플리케이션에서 파일 처리로 인한 메모리 문제를 예방할 수 있다.

ファイルハンドラを使用すると、ファイルデータの特定の位置までのデータをメモリに読み込んでプログラムで処理が可能です。処理が終わったら、次の特定の位置までのデータをメモリに読み込む作業を繰り返すことで、ファイル全体のデータではなく適度なサイズのデータのみをメモリに読み込んで処理するため、メモリ使用量を節約できます。ファイルハンドラを利用してメモリ使用量を抑えるロジックを作成することで、アプリケーションでのファイル処理に伴うメモリ問題を予防することが可能です。

### 웹 애플리케이션에서 파일 처리
### ウェブアプリケーションでのファイル処理

웹 애플리케이션은 수 많은 리퀘스트를 처리하는 프로그램이다. 웹 애플리케이션 서버는 여러 리퀘스트를 동시에 처리하는데, 만약 여러 유저가 업로드한 파일을 동시에 처리하게 되거나, 유저가 큰 용량의 파일을 업로드 하게 되면 하나의 리퀘스트를 처리하는데 많은 메모리를 사용하게 되고 이런 현상이 여러 리퀘스트에 동시에 일어나게 되면, 하드웨어나 OS에서 가용 가능한 메모리 자원을 다 소비하여 크레시가 발생할 수 있다.

ウェブアプリケーションは、多数のリクエストを処理するプログラムです。ウェブアプリケーションサーバーは複数のリクエストを同時に処理しますが、もし複数のユーザーがアップロードしたファイルを同時に処理する場合や、ユーザーが大容量のファイルをアップロードした場合、1つのリクエストを処理するのに多くのメモリを使用することになります。このような現象が複数のリクエストで同時に発生すると、ハードウェアやOSで利用可能なメモリリソースをすべて消費し、クラッシュが発生する場合があります。

많은 리퀘스트의 처리가 동시에 일어나는 웹 애플리케이션의 메모리는 동시에 일어나는 모든 리퀘스트가 사용할 수 있는 총 메모리 사용량에 상한선을 두고, 메모리 사용량이 정해진 상한선을 초과하지 않도록 관리해야 웹 애플리케이션의 크레시를 방지할 수 있다.

多数のリクエストが同時に処理されるウェブアプリケーションのメモリは、すべてのリクエストが使用する総メモリ使用量に上限を設け、メモリ使用量が定められた上限を超えないよう管理することで、ウェブアプリケーションのクラッシュを防止できます。

처리할 파일의 용량의 상한선이 정해지지 않았는데 파일에서 많은 양의 데이터를 취득해서 메모리에 올리게 되면 메모리 부족으로 인한 크레시가 발생하므로 파일 헨들러를 사용해서 파일 데이터를 처리할 때는 파일 데이터를 분할해서 메모리에 올려 처리해야 한다. 하지만 분할해서 처리를 하게 되면 그만큼 처리 시간이 늘어나게 된다.

処理するファイルの容量に上限が設定されていない場合、大量のデータをファイルから取得してメモリに読み込むと、メモリ不足によるクラッシュが発生するため、ファイルハンドラを使用してファイルデータを処理する際は、データを分割してメモリに読み込み処理する必要があります。ただし、分割して処理するとその分処理時間が長くなります。

php의 경우 처리하는 시간이 길어지면 하나의 리퀘스트 프로세스를 계속 점유하므로, 하나의 프로세스가 갖는 CPU 및 메모리 자원을 동시에 처리할 수 있는 리퀘스트의 수가 감소하게 된다. php 서버에서 동시에 처리할 수 있는 프로세스의 수는 서버 설정에 의해 제한되어 있기 때문에, 리퀘스트가 처리되지 않으면 가용할 수 있는 프로세스의 수가 줄어들면서 서버의 이용이 어렵게 되는 경우가 있다. 따라서 시간이 오래 걸릴 가능성이 있는 파일 처리는 가능한 웹 애플리케이션 서버가 아닌 큐 시스템 또는 배치 시스템을 이용하여 처리하는 편이 낫다.

phpの場合、処理時間が長くなると1つのリクエストプロセスがリソースを占有し続けるため、1つのプロセスが持つCPUおよびメモリリソースによって同時に処理できるリクエストの数が減少します。phpサーバーで同時に処理できるプロセス数はサーバー設定によって制限されているため、リクエストが処理されないと利用可能なプロセス数が減少し、サーバーの利用が難しくなる場合があります。そのため、時間がかかる可能性のあるファイル処理は、できるだけウェブアプリケーションサーバーではなく、キューシステムやバッチシステムを利用して処理するほうが望ましいです。

### File pointer란?
### ファイルポインタとは？

책을 읽는데 전에 읽었던 페이지가 어딘지 쉽게 확인하기 위해서 책갈피를 사용한다. 파일 포인터는 책갈피의 역할을 하며 파일을 읽을 때 어느 지점까지 읽고 있는지를 표기하기 위해 사용한다.

本を読む際、以前読んだページがどこかを簡単に確認するためにしおりを使います。ファイルポインタはしおりの役割を果たし、ファイルを読み込む際にどこまで読み進めているかを示すために使用されます。

기본적으로 컴퓨터가 데이터를 읽는 기본 단위는 바이트 단위이다. 메모리에서 바이트 단위로 데이터를 읽어서 비트 데이터를 읽고, 비트 단위의 데이터를 변경하면 바이트 단위로 다시 변수에 할당하는 작업을 한다.

基本的にコンピュータがデータを読み取る基本単位はバイト単位です。メモリからバイト単位でデータを読み込み、ビット単位でデータを変更し、再度バイト単位で変数に割り当てる処理を行います。

컴퓨터의 읽기 단위가 바이트 단위이므로 파일 포인터는 바이트와 바이트 사이에 위치하는 책갈피 개념으로 생각하면 편하다. 바이트와 바이트 사이에 어디까지 읽었는지 표시하는 위치 정보를 다루는 기능을 파일 포인터로 여기면 된다. 좀 더 정확하게는 바이트와 바이트 사이가 아닌 파일 포인터는 파일의 시작점 부터 몇 번째 바이트에 있는지에 인덱스 값으로 처리하고 있는 지점의 위치 정보를 저장하는 것이다.

コンピュータの読み取り単位がバイト単位であるため、ファイルポインタはバイトとバイトの間に位置するしおりのような概念と考えるとわかりやすいです。ファイルポインタは、バイトとバイトの間にどこまで読み込んだかを示す位置情報を扱う機能とみなすことができます。より正確には、ファイルポインタはファイルの開始点から何番目のバイトにあるかを示すインデックス値として、処理している位置の情報を保持しています。

파일 헨들러가 제공하는 데이터의 위치를 파악하는 파일 포인터를 통해서 컴퓨터는 하드웨어의 특정 지점의 데이터를 읽거나, 쓰거나, 변경하는 명령을 내릴 수 있다.

ファイルハンドラが提供するデータの位置を示すファイルポインタを通じて、コンピュータはハードウェアの特定の位置にあるデータを読み取ったり、書き込んだり、変更する命令を出すことができます。

### 동시적 변경 시의 파일 포인터
### 同時変更時のファイルポインタ

기본적으로 하나의 파일 핸들러가 컨트롤하는 파일 포인터는 하나인데, 이는 파일의 데이터를 한꺼번에 읽지 않고 지정한 파일 포인터를 이동시키면서 데이터를 필요한 만큼 가져오는 처리를 하기 위해서이다. 데이터가 다른 요인에 의해 변경이 되면 파일의 시작점 부터 N 번째 글자까지의 글자가 줄어들거나 늘어날 수 있으므로, N번째 다음 부터의 글자를 처리할 때 원하는 대상의 내용이 아닐 수 있다. 데이터가 부정확하게 다뤄질 수 있기 때문에 기본적으로 하나의 파일은 하나의 헨들러가 점유하며, 하나의 헨들러는 하나의 파일 포인터를 갖도록 한다.

基本的に、1つのファイルハンドラが制御するファイルポインタは1つだけです。これは、ファイルデータを一度にすべて読み込むのではなく、指定したファイルポインタを移動させながら必要な分だけデータを取得する処理を行うためです。他の要因によりデータが変更されると、ファイルの開始位置からN番目までの文字が減少したり増加したりするため、N番目以降の文字を処理する際に期待する内容が得られない可能性があります。データが不正確に扱われるリスクがあるため、基本的に1つのファイルは1つのハンドラが占有し、1つのハンドラには1つのファイルポインタが割り当てられます。

하나의 파일에 여러 파일 헨들러를 동시에 사용할 수 있지만, 이 경우 데이터의 변경에 따라 파일 포인터가 가리키는 값이 달라질 수 있으므로 다루기 까다로워진다. 그래서 하나의 파일은 하나의 헨들러가 점유할 수 있도록 락을 걸어 동시 접근에 의한 데이터 손상을 방지한다.

1つのファイルに複数のファイルハンドラを同時に使用することもできますが、この場合、データの変更によってファイルポインタが指す値が変わる可能性があり、扱いが難しくなります。そのため、1つのファイルを1つのハンドラが占有するようにロックをかけて同時アクセスによるデータ破損を防止します。

`ABCDEFGH`라는 글자가 적혀 있다고 하자. 하나의 헨들러의 파일 포인터 P1이 D와 E 사이에 위치하고 다른 파일 포인터 P2가 F와 G 사이에 위치했다고 하자. P1은 파일의 시작 지점에서 인덱스는 4이고, P2의 파일의 시작 지점에서 인덱스는 6이다. `123`이란 글자를 추가 하면 P1 파일 포인터 위치에서 `123`의 데이터가 추가되면서 파일 포인터는 `123`의 뒤인 9번 인덱스에 위치한다. 물리적으로는 서로 다른 블록으로 데이터가 추가되더라도 논리적으로 연결이 되기 때문에 `ABCD123EFGH`와 같이 연속된 데이터로 다루게 된다. P2 파일 포인터는 인덱스 값 6을 가리키고 있으므로 `123`이란 데이터의 추가로 인해 `ABCD123EFGH`에서는 동일한 인덱스가 가리키는 `2`와 `3` 사이에 파일 포인터가 위치하게 된다. P1 포인터를 컨트롤 하는 파일 헨들러가 `ABCD`의 다음 데이터인 `EFGH` 취득하려고 하는데, 데이터의 변경으로 인해서 `ABCD12` 다음의 데이터인 `EFGH`를 취득하게 되는 것이다. 하나의 파일 데이터를 여러 파일 헨들러로 동시에 변경하게 되면, 파일 포인터가 저장하는 인덱스는 동일하지만 P2 파일 포인터가 F와 G 사이에 위치했지만 `2`와 `3` 사이에 위치되는 것과 같이 상대적인 관계가 변경되기 때문에 파일을 다룰 때 의도한 바와 다른 동작을 하게 된다.

「ABCDEFGH」という文字列が記載されているとします。1つのハンドラのファイルポインタP1がDとEの間に位置し、別のファイルポインタP2がFとGの間に位置しているとします。P1のインデックスはファイルの先頭から数えて4であり、P2のインデックスは6です。この状態で「123」というデータを追加すると、P1の位置で「123」が挿入され、P1のファイルポインタは「123」の後ろであるインデックス9に移動します。物理的には異なるブロックにデータが追加されても、論理的には接続されているため、「ABCD123EFGH」のように連続したデータとして扱われます。一方、P2のファイルポインタはインデックス6を指しているため、「123」の追加によって「ABCD123EFGH」というデータ内では同じインデックスが「2」と「3」の間を指すことになり、その位置にファイルポインタが移動します。P1ポインタを制御するファイルハンドラが`ABCD`の次のデータ`EFGH`を取得しようとした場合、データの変更によって`ABCD12`の次のデータである`EFGH`を取得することになります。1つのファイルデータを複数のファイルハンドラで同時に変更すると、ファイルポインタが保持するインデックスは同じですが、P2ファイルポインタがFとGの間に位置しているものの、実際には2と3の間に位置するように相対的な関係が変わるため、ファイルを扱う際に意図とは異なる動作を引き起こす可能性があります。

### 파일 조작 모드
### ファイル操作モード

파일을 조작할 수 있는 모드는 읽기 모드 (r: read), 쓰기 모드 (w: write), 추가 모드 (a: add), 배타적 생성 모드 (x: exclusive)로 나뉘어져 있다.

ファイルの操作モードは、読み込みモード（r: read）、書き込みモード（w: write）、追加モード（a: add）、排他的作成モード（x: exclusive）に分かれています。

읽기 모드(r)는 저장되어 있는 파일을 읽기 위한 용도로 사용되며, 쓰기 모드(w)는 이미 존재하는 파일의 데이터를 지우고 새롭게 데이터를 생성하거나 새로운 파일을 만들기 위한 용도로 사용되며, 추가 모드(a)는 기본 파일의 끝에 데이터를 추가하기 위한 용도로 사용된다. 배타적 생성 모드(x)는 쓰기 모드와 비슷하여 기존 파일을 덮어 쓰지만, 이미 파일이 존재할 때는 파일을 생성하지 않고 실패하는 모드이다.

読み込みモード（r）は既存のファイルを読み込むために使用され、書き込みモード（w）は既存のファイルデータを削除して新たにデータを生成したり、新規ファイルを作成したりするために使用されます。追加モード（a）は、基本的にファイルの末尾にデータを追加するためのモードです。排他的作成モード（x）は、書き込みモードに似ており、既存のファイルを上書きしますが、すでにファイルが存在する場合にはファイルを作成せず、失敗するモードです。

파일 헨들러를 이용하는 것은 파일을 데이터의 일부만 메모리에 올리기 위한 용도로 사용된다. 따라서 데이터를 읽거나 추가하거나 변경을 하기 위해서는 파일 포인터 지점에서 새롭게 데이터를 읽거나 변경하거나 추가하는 작업을 해야 한다. 파일 헨들러를 통해서 파일을 조작할 때 하나의 파일을 여러 파일 헨들러가 조작을 하는 경우 파일의 파일의 시작점에서 동일한 인덱스의 위치라고 하더라도 데이터 간의 상대적인 위치는 달라질 수 있다. 그래서 파일의 데이터를 변경할 때는 다른 헨들러의 파일 포인터가 의도와는 다른 데이터를 건드리는 경우가 생기므로 읽거나 쓸 수 없도록 락을 걸어 주도록 한다.

ファイルハンドラを使用する目的は、ファイルのデータを一部だけメモリにロードするためです。そのため、データを読み取ったり、追加したり、変更するには、ファイルポインタの位置から新たにデータを読み込んだり変更したりする必要があります。ファイルハンドラでファイルを操作する際に1つのファイルを複数のファイルハンドラが操作する場合、同じファイル開始位置のインデックスを指していても、データの相対的な位置が変わることがあります。そのため、ファイルデータを変更する際には他のハンドラのファイルポインタが意図しないデータに影響を及ぼさないように、読み取りや書き込みを行えないようにロックをかけることが一般的です。

하나의 파일 조작 모드를 사용해서 파일을 조작하는 경우 다른 모드로 파일을 열 수 없도록 파일락 설정해야 한다. 이는 파일 데이터에서 파일 포인터의 상대적 위치가 달리지는 문제를 방지하기 위함이다.

1つのファイル操作モードでファイルを操作する場合、他のモードでファイルを開けないようにファイルロック設定が必要です。これはファイルデータ内でファイルポインタの相対位置が変わる問題を防ぐためです。

쓰기 모드(w)가 존재하는데 왜 추가 모드(a)가 있을까? 파일에 데이터를 쓰는 방식에서 차이가 있는데, 쓰기 모드(w)는 파일을 열 때 기존 데이터를 초기화한 후 새로운 데이터를 쓰지만, 추가 모드(a)는 기존 데이터를 유지하고 파일의 끝에만 데이터를 추가하는 용도로 사용된다. 추가 모드(a)는 파일 중간의 데이터를 변경하거나 삽입할 수 없으며, 주로 기존 내용을 보존하면서 새로운 데이터를 기록해야 하는 상황에서 사용된다. 예를 들어, 로그 파일처럼 기존 데이터를 유지한 채 새로운 정보를 계속 추가해야 하는 경우 유용하다. 추가 모드는 파일을 열 때 항상 파일 끝으로 파일 포인터를 이동시키므로, 기존 데이터의 무결성을 보장하면서 새로운 데이터를 추가할 수 있다는 장점이 있다.

書き込みモード（w）が存在するのに、なぜ追記モード（a）があるのでしょうか？ファイルにデータを書き込む方法に違いがあります。書き込みモード（w）は、ファイルを開く際に既存のデータを初期化した後、新しいデータを書き込みます。一方、追記モード（a）は既存のデータを保持し、ファイルの末尾にのみデータを追加するために使用されます。追記モード（a）は、ファイルの中間データを変更または挿入することはできず、主に既存の内容を保持しながら新しいデータを記録する必要がある場合に利用されます。例えば、ログファイルのように既存のデータを残しつつ新しい情報を継続的に追加する必要がある場合に有用です。追記モードはファイルを開く際に常にファイルポインタをファイル末尾に移動させるため、既存データの整合性を保ちながら新しいデータを追加できるという利点があります。

#### + 모드
#### + モード

각각의 파일 조작 모드 읽기(r), 쓰기(w), 추가(a) 모드가 존재한다. 각각의 모드에 + 옵션을 추가하여 r+, w+, a+ 모드를 만들 수 있는데 다음과 같이 동작한다.

各ファイル操作モードである読み取り（r）、書き込み（w）、追加（a）モードには、+オプションを追加して「r+」、「w+」、「a+」モードにすることができます。以下に各モードの動作を示します。

#### 읽기 모드에서 플러스 (r+)

r+ 모드는 기존 파일의 데이터를 읽고 수정할 수 있는 용도로 사용된다. 이 모드는 파일의 r+ 모드로 데이터가 변경 되었을 때, 파일의 시작점에서 어떤 오프셋으로 이동하더라도 예상치 못한 동작이 발생하지 않도록, 가능한 한 디스크 블록의 구조를 변경하지 않는 방향으로 동작한다. 파일 크기가 변경되지 않은 경우, 기존 블록 구조를 유지한 채 이미 할당된 블록 내에서 데이터를 수정할 수 있다. 이때, 수정된 데이터는 원래 데이터를 포함했던 동일한 블록 위치에 덮어 씌워진다. 반면, 데이터 크기가 변경될 경우, 파일 시스템은 필요에 따라 새로운 블록을 할당하거나 기존 블록에 이어 데이터를 저장할 수 있다. (이 설명은 이는 디스크와 파일 시스템의 알고리즘에 따라 다르며, 경우에 따라 기존 블록을 덮어쓰지 않고 새로운 디스크 블록을 재할당하는 방식으로 동작할 수도 있다.)

読み取りモードでのプラス (r+): 「r+」モードは、既存のファイルデータを読み取り、修正するために使用されます。このモードでは、「r+」モードで変更された際、ファイルの開始位置から任意のオフセットに移動した際に予期しない動作が発生しないように、可能な限りディスクブロックの構造を変更しない方向で動作します。ファイルサイズが変更されない場合、既存のブロック構造を維持したまま、すでに割り当てられたブロック内でデータを修正することができます。このとき、修正されたデータは、元のデータが含まれていた同じブロック位置に上書きされます。一方で、データサイズが変更された場合、ファイルシステムは必要に応じて新しいブロックを割り当てるか、既存のブロックに続けてデータを保存することがあります。(この動作は、ディスクおよびファイルシステムのアルゴリズムによって異なり、場合によっては既存のブロックを上書きせず、新しいディスクブロックを再割り当てする方法で動作することもあります。)

#### 쓰기 모드에서 플러스 (w+)

존재하는 파일의 데이터를 읽을 필요가 없는 경우 사용한다. 이미 존재하는 파일에 대해 w나 w+으로 파일을 열면 기존 파일의 길이를 0으로 만들기 때문에 파일의 데이터는 삭제된다. 파일을 연 시점에 파일의 크기가 0이 되기 때문에 쓰기 작업 중간에 오류가 발생해도 이전 파일 데이터가 복원되지 않는다. 쓰기 모드(w)는 데이터를 쓰기만 할 뿐, 쓰기 작업을 하면서 새롭게 추가한 데이터를 읽을 수는 없는 반면, w+의 경우에는 데이터를 쓰면서 추가한 데이터를 읽을 수 있는 기능을 제공한다. w+는 파일을 열기 이전 데이터를 읽을 수는 없으며, 파일을 열고 나서 추가한 데이터만 읽을 수 있다는 점에 주의하자.

書き込みモードでのプラス (w+): 既存のファイルデータを読み取る必要がない場合に使用します。既存のファイルを「w」または「w+」で開くと、既存ファイルの長さが0に設定されるため、ファイル内のデータは削除されます。ファイルを開いた時点でファイルサイズが0になるため、書き込み処理の途中でエラーが発生しても、元のファイルデータは復元されません。書き込みモード(w)はデータの書き込みのみを行い、書き込み中に新たに追加したデータを読み取ることはできませんが、「w+」はデータを書き込みながら、追加したデータを読み取る機能を提供します。ただし、「w+」では、ファイルを開く前のデータを読み取ることはできず、ファイルを開いた後に追加したデータのみを読み取れる点に注意が必要です。

#### 추가 모드에서 플러스 (a+)

존재하는 파일의 끝에 데이터를 추가하는 a 모드에 + 옵션을 붙이면 파일 내용을 읽을 수 있는 기능을 제공한다. 파일의 쓰기는 파일의 끝 부분에서만 이뤄지지만 읽기가 가능한 + 모드는 파일의 마지막 부분 뿐만 아니라 다른 위치의 데이터로 읽을 수 있다. 읽기를 위한 파일 포인터는 파일 내에서 자유롭게 이동할 수 있지만, 파일의 쓰기는 파일 포인터에 관계 없이 끝에만 위치하여 데이터가 추가 된다. (기본적으로 파일 포인터는 하나이지만 a+ 모드에서는 파일 포인터가 끝에 고정되어 있으므로 읽기를 위해 읽기 전용의 별도의 포인터 개념이 사용된다.)

追加モードにプラス (a+)：既存のファイルの末尾にデータを追加する「a」モードに「+」オプションを付けると、ファイル内容を読み込む機能も提供されます。ファイルの書き込みは常に末尾でのみ行われますが、「+」オプションを付けることで、ファイルの最後だけでなく他の場所のデータも読み込むことが可能になります。読み込みのためのファイルポインタはファイル内で自由に移動できますが、書き込みはファイルポインタに関係なく末尾にデータを追加します。（通常、ファイルポインタは1つですが、「a+」モードではファイルポインタが末尾に固定されるため、読み取りには読み取り専用の別のポインタの概念が使用されます。）

#### 생성 모드
#### 作成モード

php에서 파일 조작으로는 읽기, 쓰기, 추가, 배타적 생성 모드 이외에 생성 모드 (c: create)라는 특별한 모드를 사용할 수 있다.

phpでは、ファイル操作に読み込み、書き込み、追加、排他的作成モードに加えて、特別な作成モード（c: create）を利用することができます。

php의 fopen 함수에서만 사용할 수 있는 생성 모드(c)는 쓰기 모드(w)와 비슷하지만 쓰기 모드가 기존 파일의 데이터를 모두 지우고 새로 파일을 쓰는 것과 달리, 데이터를 지우지 않고, 필요한 경우 데이터를 어느 지점부터 지울 것인지를 정할 수 있는 기능을 제공한다. 파일의 시작부터 지정한 파일 포인터의 위치까지 기존 파일의 데이터를 사용하고 그 이후 부터 파일의 데이터를 쓸 수 있는 기능을 제공한다.

phpのfopen関数でのみ使用できる生成モード（c）は、書き込みモード（w）に似ていますが、書き込みモードが既存のファイルデータをすべて削除して新しいファイルを書き込むのに対し、データを削除せず、必要に応じてどの位置からデータを削除するかを指定できる機能を提供します。ファイルの先頭から指定したファイルポインタの位置までは既存のファイルデータを使用し、それ以降から新しいデータを書き込むことができる機能を持っています。

지정한 인덱스의 바이트까지만 기존 데이터를 사용하고 그 이후로는 w 모드와 같이 데이터를 새로 쓰기 위한 용도로 사용할 수 있다. 파일을 열어서 지정한 위치의 바이트까지 파일 포인터를 이동시킨 후, `ftruncate` 함수를 사용해 파일을 잘라 지정한 만큼의 파일 길이 만큼을 기존이 파일 데이터를 사용하고, 해당 파일 포인터 지점 이후에는 쓰기 모드(w)와 동일하게 동작한다. `ftruncate` 함수로 파일을 자르기 전에 실패를 방지하기 위해 파일 잠금을 해서 외부 헨들러에 의한 파일 조작이 일어나지 않게 해야한다.

指定したインデックスのバイトまで既存のデータを保持し、その後は「w」モードのように新しいデータを書き込む用途で利用できます。ファイルを開いて指定の位置までファイルポインタを移動した後、`ftruncate`関数を使用してファイルを切って、指定した長さ分の既存データを利用し、その後は書き込みモード（w）と同様に動作します。`ftruncate`関数でファイルを切り詰める前に、外部ハンドラによるファイル操作を防ぐため、ファイルロックをかける必要があります。

생성 모드에서 플러스 (c+) : c로 w와 같이 파일을 쓰던지, c+로 w+와 같이 파일을 쓰고 데이터를 읽을 수 있는 기능을 제공한다.

作成モードにプラス (c+)：「c」モードで「w」と同様にファイルを書き込むか、「c+」モードで「w+」と同様にファイルを書き込みながらデータを読み込む機能を提供します。

### 파일 잠금
### ファイルロック

파일 헨들러로 파일을 열 때, 자동적으로 락을 걸지 않는다. 따라서 파일을 열고 조작할 때는 파일락을 거는 코드를 추가해 주는 편이 좋다.

ファイルハンドラでファイルを開くとき、自動的にロックはかかりません。そのため、ファイルを開いて操作する際には、ファイルロックをかけるコードを追加することが推奨されます。

#### LOCK_SH (공유 잠금)
#### LOCK_SH（共有ロック）

파일 락을 건 핸들러와 다른 모든 파일 핸들러가 파일을 읽을 수 있지만 쓸 수는 없도록 한다.

ファイルロックをかけたハンドラーと他のすべてのファイルハンドラーが、ファイルを読み取ることはできるが、書き込むことはできないようにします。

#### LOCK_EX (배타적 잠금)
#### LOCK_EX（排他的ロック）

파일 락을 건 핸들러의 파일 조작은 제한이 없다. 하지만 다른 핸들러가 파일을 읽거나 쓸 수 없도록 엑세스를 차단한다.

ファイルロックをかけたハンドラーのファイル操作には制限がありません。しかし、他のハンドラーがファイルを読み取ったり書き込んだりすることはできないようにアクセスを制限します。

#### LOCK_UN (잠금 해제)
#### LOCK_UN（ロックを開放）

파일에 걸린 공유 잠금(LOCK_SH) 또는 배타적 잠금(LOCK_EX)을 해제하기 위해 사용한다. 파일 락을 건 핸들러에서만 락을 해제할 수 있으며, 해제하기 전까지 다른 핸들러의 동작은 제한된다.

ファイルにかけられた共有ロック（LOCK_SH）または排他的ロック（LOCK_EX）を開放するために使用します。ロックをかけたハンドラーのみがロックを開放でき、開放されるまで他のハンドラーの操作は制限されます。

#### LOCK_NB (비차단식 잠금)
#### LOCK_NB（非ブロッキングロック）

기본적으로 파일 락을 걸 때, 다른 헨들러에 의해 파일 락이 걸려 있는 경우, 파일을 락 걸 수 있을 때 까지 대기한 후 다음 코드가 진행된다.

通常、ファイルロックをかけるときに、他のハンドラによってファイルがすでにロックされている場合、ロックをかけられるまで待機し、その後コードが進行します。

LOCK_NB 옵션은 `LOCK_SH | LOCK_NB` 또는 `LOCK_EX | LOCK_NB`의 방식으로 사용되어 이미 락이 걸려 있을 때 대기하지 않고 즉시 실패를 알리도록 한다.

LOCK_NBオプションは `LOCK_SH | LOCK_NB` または`LOCK_EX | LOCK_NB` の形式で使用され、ロックがすでにかかっている場合は待機せず、直ただちに失敗を知らせます。

파일이 잠겨 있어서 현재 헨들러에서 잠금을 걸 수 없다면 `flock($fp, LOCK_SH | LOCK_NB)` `flock($fp, LOCK_EX | LOCK_NB)`는 false를 반환한다.

ファイルがロックされていて現在のハンドラーでロックをかけることができない場合、`flock($fp, LOCK_SH | LOCK_NB)` `flock($fp, LOCK_EX | LOCK_NB)`はfalseを返します。

### Byte에 대해 더 이해하기
### バイトについての理解を深める

컴퓨터에 저장되는 데이터의 단위는 바이트단위로 되어 있다. 컴퓨터 아키텍처에서 메모리 또는 디스크에서 인식 가능한 주소를 지정할 수 있는 최소 단위가 바이트이다. 파일 포인터가 바이트단위인 이유도 하드웨어의 인식가능한 주소의 단위가 바이트이기 때문이다.

コンピュータに保存されるデータの単位はバイト単位になっています。コンピュータアーキテクチャにおいて、メモリやディスクで認識可能なアドレスを指定できる最小の単位がバイトです。ファイルポインタがバイト単位である理由も、ハードウェアの認識可能なアドレス単位がバイトであるためです。

비트 단위로 접근하려면 바이트 단위로 데이터를 읽어 변수에 저장한 후, 이를 조작해야 한다. 하드웨어가 바이트 단위를 기본 처리 단위로 사용하기 때문에, 이에 맞춰 비트 단위의 파일 포인터 이동을 하도록 만들어지지 않고 바이트 단위의 파일 포인터 이동을 하도록 만들어졌다. 소프트웨어의 데이터 취득 단위와 하드웨어의 데이터 취득 단위가 다르게 되면 비효율적인 변환 비용이 발생하게 된다.

ビット単位でアクセスする場合、バイト単位でデータを読み込んで変数に保存した後、それを操作する必要があります。ハードウェアがバイト単位を基本処理単位としているため、ビット単位でファイルポインタを移動することはできず、バイト単位で移動するように設計されています。ソフトウェアのデータ取得単位とハードウェアのデータ取得単位が異なると、非効率な変換コストが発生します。

파일의 기본 단위를 8 비트인 바이트단위로 나눠야 한다는 절대적인 이유는 없지만 숫자, 영문, 일부 특수기호, 제어문자를 구분하기 위한 단위로서 8비트를 표준으로 정의하였다. 컴퓨터의 역사에서 초기 문자를 정의할 때 ASCII 코드를 사용했다. ASCII 코드는 7비트로도 숫자, 영문, 일부 특수기호, 제어문자를 표시하였으며, 이진수인 컴퓨터가 표기할 수 있는 3자리 수가(2^3) 8비트이므로 8비트를 사용하여 문자를 표기하기 시작하였다. 초창기에는 7비트로 ASCII 코드를 정의했지만, ASCII 코드도 8비트로 표기하기 시작했다. 초기 개인용 컴퓨터가 보급되기 시작한 시점에서 8비트 단위로 데이터를 처리를 하였기 때문에 8비트를 1바이트로 사용하는 것이 표준이 되었다.

ファイルの基本単位を8ビットのバイト単位にする絶対的な理由はありませんが、数字、英字、一部の特殊記号、制御文字を区別する単位として8ビットが標準として定義されました。コンピュータの歴史において初期の文字コードとしてASCIIコードが使われました。ASCIIコードは7ビットで数字、英字、一部の特殊記号、制御文字を表していましたが、コンピュータが扱える3桁の2進数（2^3）で8ビットが適当とされ、文字を8ビットで表すようになりました。初期は7ビットでASCIIコードが定義されていましたが、のちに8ビットで表記されるようになりました。初期のパーソナルコンピュータが8ビット単位でデータを処理していたため、8ビットを1バイトとして使用するのが標準になりました。

너무 많은 비트를 1 바이트로 지정하면 하나의 문자가 차지하는 용량이 커지고 너무 적은 비트를 1 바이트로 지정하면 원하는 문자를 표현하는데 여러 비트를 사용하거나 가변 바이트를 사용하게 되어 용량을 많이 차지하게 된다. 개인용 컴퓨터가 보급될 시점에 적절한 타협점으로 8비트를 데이터 처리의 가장 기본 단위로 만든 것이다.

あまりに多くのビットを1バイトに指定すると1文字が占める容量が大きくなり、逆に少ないビットで1バイトを指定すると必要な文字を表現するために複数ビットや可変バイトを使うことになり、容量が増えてしまいます。パーソナルコンピュータが普及し始めた時期に、8ビットがデータ処理の基本単位として適切な妥協点とされました。

8비트를 하나의 문자열로 다루는 인코딩 방식은 ASCII 코드 뿐만 아니라 EBCDIC 코드가 있다. 숫자, 영문, 일부 특수기호, 제어문자와 다국어 지원 문자로 총 255개의 문자를 채울 수 있도록 만들어졌다. 일본어의 경우 EBCDIC 포멧을 이용할 때 반각 가나를 추가해서 사용하고 있다. 일본 은행의 통장을 보면 명의가 반각가나로 이뤄져 있는데 EBCDIC 인코딩을 사용할 때의 형식을 계속 지금까지 이어서 사용하고 있기 때문이다. 코볼을 쓰는 오래된 금융 시스템을 개선하기 어려운 요인으로 아직까지도 통장 명의는 반각가나로 이뤄져 있는 것으로 보인다.

8ビットを1文字の単位とするエンコーディング方式はASCIIコードだけでなく、EBCDICコードもあります。EBCDICは数字、英字、一部の特殊記号、制御文字および多言語サポート文字で総255文字を扱えるように設計されています。日本語の場合、EBCDICフォーマットを利用する際に半角カナが追加され、使用されています。例えば、日本の銀行の通帳では名義が半角カナで名前が記載されていますが、これはEBCDICエンコーディングの形式を現在でも使用し続けているためです。COBOLを使った古い金融システムの改善が難しいこともあり、今でも通帳の名義は半角カナで表記されていると考えられます。

### 1바이트를 초과하는 문자의 등장
### 1バイトを超える文字の登場

많은 나라에서 컴퓨터를 이용함에 따라 다국어를 지원할 필요성이 생겼다. 8비트만으로는 표현할 수 없는 문자수를 가진 나라들이 생겨서 하나의 문자를 표현하는데 여러 바이트를 사용하여 하나의 문자를 나타내는 문자열 인코딩 방식이 도입되었다. 2바이트를 사용하여 문자를 표현하는 방식 및 문자에 따라 1바이트가 될 때도 있고 2바이트가 될 수도 있는 가변 바이트를 사용하는 방식의 인코딩 방식도 있으며, 유니코드를 포함하는 문자 집합의 경우 최대 4바이트까지 사용한다.

多くの国でコンピュータが利用されるようになるにつれて、多言語対応の必要性が生じました。8ビットでは表現できない文字数を持つ国々が現れ、1つの文字を表現するために複数のバイトを使う文字列エンコーディング方式が導入されました。2バイトを使用して文字を表現する方式や、文字によって1バイトになる場合や2バイトになる場合がある可変バイト方式のエンコーディングもあり、ユニコードを含む文字集合の場合、最大4バイトまで使用することがあります。

### 프로그래밍에서 파일을 처리하는 방법
### プログラミングでファイルを処理する方法

- 파일 전체를 한 번에 읽는다.
- ファイル全体を一度に読み込む
- 파일을 열어서 조금씩 읽어들인다.
- ファイルを開いて少しずつ読み込む

#### 파일을 나눠서 읽어야 하는 경우
#### ファイルを分割して読み込む必要がある場合

파일 전체를 한 번에 읽어서 메모리에 파일 내용을 적재해야 하는데 '파일 데이터를 변수에 담아 메모리에 올릴 때 필요한 메모리 사이즈' + '코드를 처리할 때 사용하는 추가 메모리'가 php 프로세스에서 허용하는 메모리 보다 커질 수 있다. 물론 php의 메모리 사이즈 및 하드웨어의 메모리 사이즈 및 가상메모리 사이즈 등을 늘릴 수 있지만 파일의 용량은 일반적으로 한없이 늘어나는 경우를 고려해야 하기 때문에 제한된 메모리 내에서 동작하는 코드를 작성해야 이후 시스템의 확장에 대응할 수 있다. 파일 사이즈가 어느 용량 이하로 정해져 있다면 파일을 한 번에 읽는 방식을 사용해도 괜찮다.

ファイル全体を一度に読み込んでメモリにファイル内容を読み込む際、「ファイルデータを変数に格納するために必要なメモリサイズ」 + 「コード処理時に使用する追加メモリ」がphpプロセスで許可されているメモリより大きくなる可能性があります。もちろん、phpのメモリサイズやハードウェアのメモリサイズ、仮想メモリサイズを増やすことは可能ですが、ファイルの容量は一般的に無限に増える可能性があるため、制限されたメモリ内で動作するコードを書くことで、後のシステム拡張に対応できます。ファイルサイズがある程度小さい場合は、一度にファイルを読み込む方法を使用しても問題ありません。

#### 헨들러를 사용하여 데이터를 나누어 읽을 때
#### ハンドラを使ってデータを分割して読む場合

파일 헨들러를 사용한다는 것은 파일의 전체 내용을 메모리에 적재하는 것이 아니라, 파일 포인터를 이용하여 필요한 기준점에서 지정한 양만큼의 바이트를 읽고 삭제하거나 기준점에 새로운 바이트를 추가하는 방식을 사용할 수 있다.

ファイルハンドラを使用するということは、ファイル全体をメモリに読み込むのではなく、ファイルポインタを利用して必要な基準点から指定された量のバイトを読み取り、削除したり、基準点に新しいバイトを追加する方法を取ることができます。

파일 전체를 메모리에 적재하는 것이 아니라 필요한만큼 쪼개어 메모리에 올리는 방식으로 처리할 수 있기 때문에 대용량의 파일을 처리할 때 유용한 방법이다.

ファイル全体をメモリに読み込むのではなく、必要な分だけ分割してメモリに読み込む方法で処理できるため、大容量のファイルを扱う際に有用な方法です。

### php에서 전체 파일 읽기
### phpでのファイル全体読み込み

#### [`file_get_contents`](https://www.php.net/manual/en/function.file-put-contents.php)
#### [`file_get_contents`](https://www.php.net/manual/ja/function.file-put-contents.php)

지정한 파일 전체 컨텐츠를 읽어서 php의 변수에 저장할 수 있다. 파일의 데이터가 큰 경우 php 프로세스에 인가된 메모리 한도를 초과할 수 있기 때문에 파일의 크기가 제한되어 있다는 전제 하에서만 사용하도록 한다.

指定したファイルの全体のコンテンツを読み込み、PHPの変数に保存できます。ファイルデータが大きい場合、PHPプロセスで許可されているメモリ制限を超える可能性があるため、ファイルのサイズが制限されているという前提でのみ使用します。

### php에서 파일 헨들러 사용하기
### PHPでのファイルハンドラの使用

읽어야 할 파일의 사이즈를 정확히 알기 어렵거나, 파일의 사이즈가 큰 경우 데이터를 분할 처리하는 용도로 사용한다.

読み込むべきファイルのサイズが不明確である場合や、ファイルサイズが大きい場合、データを分割して処理するために使用します。

#### [`fopen()`](https://www.php.net/manual/en/function.fopen.php)
#### [`fopen()`](https://www.php.net/manual/ja/function.fopen.php)

파일을 열고 파일 헨들러를 반환 받는다. 이 파일 헨들러는 stream이라고 부르며 파일 시스템 포인터를 다룰 수 있는 리소스를 반환한다. 파일 포인터 리소스를 반환하지 못하고 실패한 경우에는 false를 반환한다.

ファイルを開き、ファイルハンドラを返します。このファイルハンドラはストリームと呼ばれ、ファイルシステムポインタを扱えるリソースを返します。ファイルポインタリソースを返せずに失敗した場合には、falseを返す。

#### [`fseek()`](https://www.php.net/manual/en/function.fseek.php)
#### [`fseek()`](https://www.php.net/manual/ja/function.fseek.php)

파일 포인터의 위치를 지정한 바이트만큼 이동을 한다. 옵션을 지정할 수 있는데 옵션을 지정하지 않으면 SEEK_SET으로 동작한다.

ファイルポインタの位置を指定したバイト分だけ移動します。オプションを指定しない場合は、SEEK_SETとして動作します。

SEEK_SET: 파일의 시작을 기준으로 지정한 오프셋 만큼의 바이트를 이동한다.

SEEK_SET: ファイルの先頭を基準に指定したオフセット分バイトを移動します。

SEEK_CUR: 현재 파일 포인터의 위치를 기준으로 지정한 오프셋 만큼의 바이트를 이동한다.

SEEK_CUR: 現在のファイルポインタの位置を基準に指定したオフセット分バイトを移動します。

SEEK_END: 파일의 끝을 기준으로 이동 지정한 오프셋 만큼의 바이트를 이동한다. offset 값을 음수로 지정하면 이전 데이터 위치로 이동할 수 있다는 것을 이용한다.

SEEK_END: ファイルの末尾を基準に指定したオフセット分バイトを移動します。offsetを負の値に設定すると、前方に移動できることを利用します。

#### [`fread()`](https://www.php.net/manual/en/function.fread.php)
#### [`fread()`](https://www.php.net/manual/ja/function.fread.php)

파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 갯수의 연속된 바이트를 읽는다. 연속된 바이트를 읽다가 읽을 수 없는 지점이 나오면 읽은 부분까지의 바이트를 반환한다. 이때 파일 포인터는 읽은 바이트만큼 이동한다.

ファイルハンドラが持つファイルポインタ位置から指定された連続したバイト数を読み取ります。連続したバイトが読み取れない場合、読み取った部分までのバイトを返します。この時、ファイルポインタは読み取ったバイト分だけ移動します。

#### [`fget()`](https://www.php.net/manual/en/function.fgets.php)
#### [`fget()`](https://www.php.net/manual/ja/function.fgets.php)

파일헨들러가 가지고 있는 파일 포인터 위치에서 파일의 개행 문자 또는 EOF가 나타날 때까지 바이트를 읽고 반환한다. 지정한 갯수의 연속된 바이트를 읽을 수 있으나 개행 또는 파일 끝을 나타내는 부분이 나오기 전까지의 바이트만 읽는다. 이때 파일포인터는 읽은 바이트만큼 이동한다.

ファイルハンドラが持つファイルポインタ位置から、ファイルの改行文字またはEOFに達するまでバイトを読み取って返します。指定された連続したバイト数を読み取りますが、改行やファイル末尾が現れるまでのバイトのみを読み取ります。この時、ファイルポインタは読み取ったバイト分だけ移動します。

하나의 행이 갖는 데이터의 크기가 클 수 있기 때문에, 각각의 행 데이터의 크기가 다룰 수 있는 사이즈라는 전제 하에서 사용해야 한다. 다루기 위한 파일의 행 크기는 미리 벨리데이션 처리를 하여 일정 사이즈 이하로 제한하는 편이 좋다.

1行のデータサイズが大きい場合があるため、各行データのサイズが扱いやすいサイズである前提で使用する必要があります。処理するファイルの行サイズは、事前に検証処理を行い、一定のサイズ以下に制限するのが望ましいです。

#### [`fwrite()`](https://www.php.net/manual/en/function.fwrite.php)
#### [`fwrite()`](https://www.php.net/manual/ja/function.fwrite.php)

파일헨들러가 가지고 있는 파일 포인터 위치에서 지정한 바이트만큼의 데이터를 변경한다. 파일의 끝 부분이라면 데이터가 추가 되지만, 파일의 끝이 아니라면 기존의 데이터를 새로운 데이터로 교체한다. 이때 파일포인터는 추가한 바이트만큼 이동한다.

ファイルハンドラが持つファイルポインタ位置から、指定したバイト数のデータを変更します。ファイルの末尾であればデータが追加されますが、末尾でない場合は既存のデータが新しいデータに置き換えられます。この時、ファイルポインタは追加したバイト分だけ移動します。

#### [`fclose()`](https://www.php.net/manual/en/function.pclose.php)
#### [`fclose()`](https://www.php.net/manual/ja/function.pclose.php)

파일 헨들러를 닫는다. 파일 헨들러를 닫게 되면 OS가 관리하고 있는 파일락을 별도로 해제하지 않아도 해제되면서 이 헨들러가 아닌 다른 헨들러로 파일을 조작할 수 있게 한다.

ファイルハンドラを閉じます。ファイルハンドラを閉じると、OSが管理しているファイルロックが開放され、他の操作によるファイル変更が可能になります。

파일 데이터를 변경할 때, 잦은 디스크 엑세스를 방지하기 위해 파일 시스템은 `fwrite` 등으로 데이터 변경을 하더라도 바로 디스크에 저장하지 않고 메모리의 버퍼에 저장한다. 만약 디스크에 아직 쓰기가 되지 않은 상태라면, `fclose`를 사용하는 것으로 버퍼의 데이터가 디스크에 완전히 쓰여지게 되어 예기치 않은 문제로 인해 프로세스가 종료 되더라도 데이터가 기록되지 않는 문제를 방지할 수 있다. 또한 파일 헨들러와 관련된 모든 메모리 자원이 해제되어 불필요한 메모리 낭비 및 누수를 방지한다.

ファイルデータを変更する際、頻繁なディスクアクセスを避けるために、ファイルシステムは`fwrite`などでデータ変更を行ってもすぐにディスクに保存せず、メモリのバッファに保存します。もしディスクにまだ書き込まれていない場合、`fclose`を使用することでバッファのデータがディスクに完全に書き込まれ、予期しない問題でプロセスが終了してもデータが記録されない問題を防ぐことができます。また、ファイルハンドラーに関連するすべてのメモリ資源が解放され、不要なメモリの浪費やリークを防止します。

### 파일 포인터의 이동
### ファイルポインタの移動

프로그래밍 언어의 라이브러리에서 제공하는 파일 스트림의 바이트 데이터 읽기 및 추가를 하는 함수를 사용하면 파일 포인터가 바이트 데이터를 읽은 만큼 다음 지점으로 이동한다. 'abcdef'에서 b와c 지점 사이의 파일 포인터에서 `fread` 또는 `fwrite`를 사용해서 2 바이트를 읽거나 변경한다면, 파일 포인터는 읽고 변경한 후 d와 e 지점에 위치하게 된다. 이 때문에 바이트를 읽고 쓰는 작업 이후 별도로 파일 포인터를 이동시킬 필요가 없어서 좀 더 편하게 데이터를 다룰 수 있다.

プログラミング言語のライブラリが提供するファイルストリームでバイトデータの読み取りや追加を行う関数を使用すると、ファイルポインタは読み取ったバイトデータ分だけ次の位置へと移動します。たとえば「abcdef」のうち、bとcの間のファイルポインタ位置から`fread`や`fwrite`で2バイトを読み取ったり変更したりした場合、ファイルポインタは読み取りや変更後、dとeの位置に移動します。このため、バイトの読み取りや書き込み操作の後にファイルポインタを別途移動させる必要がなく、より便利にデータを扱うことができます。

### 파일 스트림을 다루는 예제
### ファイルストリームを扱う例

다음에서 소개하는 예제는 php 공식문서에서 가져왔다.

以下の例は、php公式ドキュメントから引用したものです。

#### loop와 파일 포인터
#### ループとファイルポインタ

```php
$handle = fopen("http://www.example.com/", "rb");
if (FALSE === $handle) {
    exit("Failed to open stream to URL");
}

$contents = '';

while (!feof($handle)) {
    $contents .= fread($handle, 8192);
}
fclose($handle);
```

`if (FALSE === $handle)`는 `fopen` 함수가 파일을 열지 못한 경우 false를 반환하여 파일 처리가 불가능함을 나타낸다.

`if (FALSE === $handle)`は、`fopen`関数がファイルを開けなかった場合にfalseを返し、ファイル処理が不可能であることを示します。

`feof`는 헨들러의 포인터가 파일 끝에 도달했는지를 확인한다. `!feof($handle)` 헨들러의 포인터가 파일 끝에 도달하지 않았기 때문에 파일의 마지막 부분에 포인터가 도착할 때까지 루프를 돈다.

`feof`は、ハンドラのポインタがファイルの終端に達しているかを確認します。`!feof($handle)`がtrueである限り、ポインタがファイルの終端に達していないため、ファイルの最後までループを繰り返します。

루프가 돌아갈 때마다 `fread($handle, 8192)` 8192 바이트의 문자를 읽고 파일 헨들러의 파일 포인터를 읽은 문자 다음으로 둔다. `fread` 함수로 바이트를 읽을 때 마다 파일 포인터가 읽은 다음에 위치하기 때문에 루프가 돌아가면서 `fread` 함수를 사용하는 것만으로 파일의 전체 데이터를 얻어낼 수 있다.

ループが回るたびにfread($handle, 8192)で8192バイト分の文字を読み取り、ファイルハンドラのポインタを次の位置に進めます。freadでバイトを読み取るたびにポインタが自動的に進むため、ループ内でfreadを使用するだけでファイル全体のデータを取得できます。

#### 한 줄씩 읽기
#### 一行ずつ読み込み

```php
$fp = @fopen("/tmp/inputfile.txt", "r");
if ($fp) {
    while (($buffer = fgets($fp, 4096)) !== false) {
        echo $buffer;
    }
    if (!feof($fp)) {
        echo "Error: unexpected fgets() fail\n";
    }
    fclose($fp);
}
```

`fopen`는 지정한 경로의 파일을 찾을 수 없을 때 경고(warning)를 발생시킨다. 함수 앞에 @를 붙여 주면 에러나 경고를 출력하지 않도록 할 수 있다. 파일 스트림을 반환하는데 실패하면 false를 반환하는 `fopen` 함수의 반환 값은 변함 없다.

`fopen`は、指定した経路のファイルが見つからないときに警告(warning)を発生させます。関数の前に@を付けると、エラーや警告を出力しないようにすることができます。ファイルストリームの返還に失敗すると、falseを返還する`fopen`関数の返還値は変わりません。

`($buffer = fgets($fp, 4096)) !== false`에서 `$buffer = fgets($fp, 4096)`가 반환하는 값은 `$buffer`에 담고 있는 `fgets($fp, 4096)` 값이다. `$buffer`와 `false`가 `!==`으로 비교가 된다.

`($buffer = fgets($fp, 4096)) !== false`では、`$buffer = fgets($fp, 4096)`が返す値が`$buffer`に格納され、`$buffer`と`false`が`!==`で比較されます。

`fgets($fp, 4096)`를 사용하는 것만으로도 파일 포인터가 이동하게 된다. 이외의 따로 파일 포인터를 옮기는 과정 없이도 파일을 읽게 된다.

`fgets($fp, 4096)`を使用するだけでファイルポインタが進むため、追加でポインタを移動する処理を行わなくてもファイルを読み取ることができます。

각 행에서 정상적으로 데이터를 취득할 수 있었다면, `fgets($fp, 4096)` 값은 false가 되지 않을 것이고, 더 이상 읽은 행이 없다면 `fgets($fp, 4096)`는 `false`를 반환하고 `while` 문의 반복은 종료된다.

各行で正常にデータを取得できた場合、`fgets($fp, 4096)`の値はfalseにはならず、もしそれ以上読み込む行がない場合、`fgets($fp, 4096)`はfalseを返し、`while`文の繰り返しは終了します。

더 이상 읽을 행이 없는데, `!feof($fp)`으로 파일의 마지막에 도달하지 않았다면 `fgets($fp, 4096)`가 `false`가 된 이유가 행의 마지막에 도착한 이유가 아닌 다른 이유로 실패 했다는 의미가 되며, 이는 각 행의 데이터를 읽을 때 어디에서 실패했다는 것을 의미한다. 파일의 마지막에 도착했다면 `fclose($fp)`로 파일 헨들러를 종료한다.

これ以上読み込む行がないのに、`!feof($fp)`でファイルの最後に到達していない場合、`fgets($fp, 4096)`がfalseになった理由は行の最後に到達したことではなく、他の理由で失敗したことを意味します。これは各行のデータを読み込む際にどこで失敗したのかを示しています。ファイルの最後に到達した場合は、`fclose($fp)`でファイルハンドラを終了します。

### 효율적인 데이터 취득 방법
### 効率的なデータ取得方法

#### 캐시
#### キャッシュ

하드웨어는 블록 보다 더 작은 데이터를 읽어도 최소한 블록 단위 만큼의 데이터를 취득한다. 어차피 최소 단위로 블록 단위의 데이터를 취득한다면 블록 단위 보다 작은 데이터를 여러 번 읽는 것 보다 한 번에 블록 단위로 데이터를 읽으면 하드웨어에 엑세스하는 횟수가 적어지므로 효율적이라고 생각할 것이다. 하지만 파일 시스템은 한 번 읽은 데이터를 캐시해 두기 때문에 최소한 블록 단위의 데이터를 캐시한다. 블록 데이터의 크기 보다 작은 데이터를 취득하더라도 동일한 블록 내의 데이터라면 파일 시스템에 캐시된 데이터에 접근하기 때문에 한 번에 블록 단위의 데이터를 읽든, 작은 데이터를 여러번 읽든 하드웨어 저장소에 대한 추가적인 접근을 하지 않으므로 큰 속도 저하는 없다.

ハードウェアは、ブロックより小さいデータを読み取る場合でも、最低限ブロック単位のデータを取得します。どうせ最小単位でブロック単位のデータを取得するのであれば、複数回に分けて小さいデータを読み取るよりも、一度にブロック単位でデータを読み取る方が、ハードウェアへのアクセス回数が少なくなり効率的だと思われるでしょう。しかし、ファイルシステムは一度読み取ったデータをキャッシュしているため、最低限ブロック単位のデータがキャッシュされます。たとえブロックサイズより小さいデータを取得しても、同じブロック内のデータであれば、ファイルシステムにキャッシュされているデータにアクセスするため、一度にブロック単位でデータを取得しても小さいデータを複数回読み取っても、ハードウェアストレージへの追加アクセスは発生しないため、速度低下はほとんどありません。

데이터는 여러 블록에 분산 저장되기 때문에, 작은 데이터를 여러 번 읽는다고 해서 항상 하나의 블록 내 데이터를 읽는다는 보장은 없다. 블록 단위로 캐시가 이루어진다고 하더라도, 데이터가 서로 다른 블록에 분산되어 있다면 캐시에서 데이터를 불러올 수 없고, 결국 기억 장치에 다시 접근하여 데이터를 가져와야 한다.

データは複数のブロックに分散して保存されるため、小さなデータを何度も読み取ったとしても、必ずしも1つのブロック内のデータを読み取るとは限りません。たとえブロック単位でキャッシュが行われていても、データが異なるブロックに分散している場合、キャッシュからデータを取得することはできず、最終的に記憶装置に再びアクセスしてデータを取得しなければなりません。

이를 해결하기 위해 파일 시스템은 하드웨어 데이터를 그대로 캐시하지 않고, 논리적으로 연속된 데이터를 구성하여 캐시하는 알고리즘을 사용하기도 한다. 또한, 새로운 파일 데이터를 생성할 때 저장 공간에 여유가 있다면 가능한 연속적인 데이터를 저장하려고 시도한다. 파일 데이터를 변경할 경우에도 쓰기 모드에서 데이터를 수정하면, 여유 저장 공간이 있을 때 빈 블록에 새 데이터를 쓰는 방식으로 연속적인 저장이 이루어질 수 있다.

これを解決するために、ファイルシステムはハードウェアのデータをそのままキャッシュすることではなく、論理的に連続したデータを構成してキャッシュするアルゴリズムを使用することがあります。また、新しいファイルデータを作成する際、保存領域に余裕がある場合は、可能な限り連続したデータを保存するよう試みます。ファイルデータを変更する場合でも、書き込みモードでデータを修正すると、空き領域があるときには空ブロックに新しいデータを書き込むことで連続的な保存ができます。

이와 같이 디스크 데이터가 연속적으로 저장되면, 파일 시스템이 논리적으로 연속된 데이터로 구성하기 위한 알고리즘 리소스를 줄여 효율성을 높일 수 있다. 연속된 데이터를 캐시한 파일 시스템은 블록 단위보다 작은 데이터를 여러 번 읽는 경우에도 캐시된 데이터를 활용할 수 있다.

このように、ディスク上のデータが連続して保存されることで、ファイルシステムが論理的に連続したデータを構成するためのアルゴリズムのリソースを減らせて、効率性を高めることができます。連続したデータをキャッシュしたファイルシステムでは、ブロック単位より小さいデータを複数回読み取る場合でも、キャッシュされたデータを活用することが可能です。

서버에서 하드디스크 조각 모음을 주기적으로 하던 시기에는 데이터를 연속적으로 저장할 수 있었기 때문에 파일 시스템의 연속적인 데이터 재구성에 필요한 리소스를 줄여 속도 향상에 도움이 됐다. 그러나 조각 모음을 하지 않으면 파일 시스템이 논리적으로 연속된 데이터를 만들기 위한 리소스를 소모해야 하기 때문에 효율이 좋지 않았고, SSD를 사용하는 최근에는 파편화 되어 있어도 디스크에서 데이터를 가져오는 속도가 빠르므로 파일 시스템이 논리적으로 연속된 데이터를 만들기 위한 속도가 빨라 성능에 미치는 영향이 거의 없다.

かつて、サーバーで定期的にハードディスクのデフラグを行っていた時代には、データを連続して保存できたため、ファイルシステムが連続データを再構成する際に必要なリソースを削減し、速度向上に貢献していました。しかし、デフラグを行わない場合、ファイルシステムが論理的に連続したデータを作成するためにリソースを消費する必要があり、効率が良くありませんでした。最近では、SSDを使用することで、データが断片化していてもディスクからデータを取得する速度が速く、ファイルシステムが論理的な連続データを作成する速度も速いため、性能への影響はほとんどありません。

#### 512, 1024, 2048, 4096, 8192 ?

파일 핸들러에 관한 예제를 보면 파일 데이터를 읽을 때 512, 1024, 2048, 4096, 8192의 단위를 자주 사용하는 것을 볼 수 있다. 이는 저장장치에서 데이터를 블록 단위로 읽어오는 방식과 관련이 있다. 보통 하나의 블록은 4096 바이트 크기를 가지며, 파일 시스템은 효율적인 데이터 관리를 위해 이 블록 단위의 배수로 캐시를 한다. 디스크의 데이터가 파편화 되어 있더라도 파일 시스템은 논리적으로 연속된 데이터 캐시하므로 4096 바이트의 배수 값으로 데이터를 캐시한다. 따라서 4096 바이트의 약수나 배수를 사용하여 읽는 것이 더 효율적일 수 있다. 

ファイルハンドラーに関する例を見ると、ファイルデータを読み取る際に、512、1024、2048、4096、8192といった単位がよく使われていることがわかります。これは、ストレージがデータをブロック単位で読み込む仕組みと関係しています。通常、1つのブロックは4096バイトの大きさを持ち、ファイルシステムは効率的なデータ管理のために、このブロック単位の倍数でキャッシュを行います。ディスクのデータが断片化されていても、ファイルシステムは論理的に連続したデータをキャッシュするため、4096バイトの倍数でデータをキャッシュします。そのため、4096バイトの約数や倍数を用いてデータを読み取る方が効率的である場合があります。

예를 들어, 4096 바이트의 데이터가 파일 시스템 캐시에 저장하면, 이후 1000, 1000, 1000, 1000, 96으로 나눠 5번 접근하는 것보다 1024로 4번 캐시 데이터를 가져오는 것이 캐시 효율을 높인다. 또한 파일 시스템이 여러 블록의 데이터를 캐시할 수 있으므로, 경우에 따라 8192 바이트와 같은 더 큰 단위로 읽는 것도 효율적이다.

例えば、4096 バイトのデータがファイル システム キャッシュに保存されると、この後、1000バイトずつ4回と96バイトを追加でアクセスするよりも、1024バイトずつ4回キャッシュからデータを取得する方がキャッシュ効率が向上します。また、ファイルシステムが複数のブロックをキャッシュできるため、場合によっては8192バイトのようなより大きな単位で読み取ることも効率的です。

### 인코딩
### エンコーディング

파일을 읽을 때는 바이트 단위로 읽는다고 읽는데 문자열 인코딩은 때로는 한 바이트가 아닌 하나의 문자가 여러 바이트로 구성되는 경우가 있다. 또한 언어에 따라 바이트가 나타내는 값(비트 값)과 언어 문자 사이의 매핑은 인코딩 방식에 따라 다르다.

ファイルを読み込む際、バイト単位で読み取るとされますが、文字列のエンコーディングによっては、1つの文字が複数のバイトで構成される場合があります。また、言語ごとにバイトが示す値（ビット値）とその言語の文字との対応は、エンコーディング方式によって異なります。

php에서 바이트를 읽은 결과를 나타내는 `fget()`, `fread()` 등의 함수로 바이트를 읽은 결과는 특별한 지시가 없는 보통 알고 있는 문자열로 보여지는 상태는 아니다. echo 등을 통해서 이 데이터의 문자열을 확인하려고 한다면 php는 single byte set으로 문자열을 보여주며, 이 때 사용하는 single byte set은 'ISO-8859-1', 'US-ASCII' 인코딩을 사용한다. php의 default 변환 문자는 ISO-8859-1 방식이므로 `À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï D Ð Ñ Ò Ó Ô Õ Ö × Ø Ù Ú Û Ü Ý Þ à á â ã ä å æ ç è é ê ë ì í î ï ð ñ ò ó ô õ ö ÷ ø ù ú û ü ý þ ÿ`와 같은 문자를 보여준다.

phpで`fget()`や`fread()`などの関数を使ってバイトを読み取った結果は、特別な指示がない限り、普通知っている文字列として表示されるわけではありません。echoなどを用いてこのデータを文字列として表示しようとすると、phpはシングルバイトセットで文字列を表示します。デフォルトではこのシングルバイトセットは「ISO-8859-1」や「US-ASCII」エンコディングが使用され、「ISO-8859-1」形式の`À Á Â Ã Ä Å Æ Ç È É Ê Ë Ì Í Î Ï D Ð Ñ Ò Ó Ô Õ Ö × Ø Ù Ú Û Ü Ý Þ à á â ã ä å æ ç è é ê ë ì í î ï ð ñ ò ó ô õ ö ÷ ø ù ú û ü ý þ ÿ`といった文字が表示されます。

UTF-8, SJIS, ECU-KR 등의 멀티 바이트 인코딩의 문자열이 들어 있던 파일이라면 이 바이트 데이터의 문자열을 제대로 나타내기 위해서는 멀티 바이트 데이터를 적절하게 묶어 주는 인코딩을 사용하여 원하는 문자열로 출력해야 한다. php에서는 다양한 인코딩의 문자를 읽을 수 있도록 'mb_'로 시작하는 함수를 제공한다.

UTF-8やSJISなどのマルチバイトエンコーディングの文字列が含まれているファイルであれば、このバイトデータを正確に文字列として表示するには、マルチバイトデータを適切に縛ってくれるエンコーディングを用いて、正しい文字列として出力する必要があります。phpでは、様々なエンコーディングの文字を読み取るために、「mb_」で始まる関数が提供されています。

## さいごに

명철한 자의 마음은 지식을 얻고 지혜로운 자의 귀는 지식을 구하느니라

悟りのある者の心は知識を得、知恵のある者の耳は知識を求める。

## References
- https://www.php.net/manual/en/function.fopen.php
- https://stackoverflow.com/questions/5249279/file-get-contents-php-fatal-error-allowed-memory-exhausted
- https://en.wikipedia.org/wiki/Byte
- https://www.php.net/manual/en/xml.encoding.php
