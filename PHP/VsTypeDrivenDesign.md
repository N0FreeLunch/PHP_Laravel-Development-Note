# 타입 주도 설계

## 대수적인 프로그래핑

대수학이란 직접적인 수를 대신한 문자를 사용해서 어떤 식을 만드는 것을 의미한다. 수를 대신한 문자를 통해서 수들 간의 관계성을 나타낼 수 있고, 방정식을 만들면 특정 수의 범위에 대해 특정한 관계성을 만족한다는 것을 표현할 수 있다.

프로그래밍에서도 대수란 변수의 범위에 대해서 각각의 시그니처의 코드들의 연관 관계를 통해서 어떤 로직의 변수들 간의 관계성을 만들어 낼 수 있다. 수학에서 변수의 범위가 자연수, 정수, 소수, 음의 정수, {x | x는 ... 조건}, a <= x < b 등으로 나타낼 수 있는 것에 반해서, 프로그래밍에서 대수의 범위는 타입이란 것으로 타나낸다.

### 좀 더 엄밀한 정의

대수를 영어로는 argebric이라고 하는데, 카테고리 이론에 기반을 두고 있는 수학적인 개념이다.

카테고리를 프로그래밍 언어에서는 타입으로 표기하고, 변수의 값은 하나의 타입이지만 변수가 가지는 타입의 범위가 두 가지 이상인 경우를 타입의 합으로, 변수가 가지는 타입이 둘 모두의 타입으로 구성되어 있으면 곱으로 본다.

#### 합 타입과 곱 타입의 예

- 유니온 타입 (합 타입) : A 타입 또는 B 타입 또는 C 타입의 여러 타입으로 하나의 변수를 나타낼 수 있다.
- Enum 타입 (합 타입) : Enum의 각 case는 하나의 타입이다. 하나의 Enum은 여러 case로 구성되어 있고 이들 case 중 하나가 변수의 값이 된다. Enum의 하나의 case는 값이자 타입으로 별도의 타입으로 뽑아낼 수 없고 Enum이란 집합 타입을 만들기 위한 타입이다.
- 튜플 (곱 타입) : 튜플은 php의 배열과 유사하지만 데이터의 길이가 정해져 있고, 각 원소를 구성하는 타입이 정해져 있으며, 선언된 값을 변경할 수 없는 특성을 가진 대상이다. 예를 들어 `[Person, Company]`으로 타입이 구성되어 있다면 `Person` 타입과 `Company` 타입이 하나의 원소를 구성하고 이들을 베이스로 한 값 `[Person1, Company1]`, `[Person2, Company2]`, `[Person3, Company3]`... 원소의 집합이 튜플으로 여러 타입이 복합적으로 하나의 값을 만든다.

## 타입리스 언어의 문제

타입이 없는 언어의 문제는 코드가 처음 생성된 부분부터 데이터가 어떻게 변했는지를 추적해야 한다.

타입을 사용하면 값의 생성을 처음부터 추적하지 않고, 코드의 일부분만으로 변수가 가진 타입을 알고, 해당 타입에 대한 로직을 만들면 되기 때문에 코드를 해석하는데 피로도가 줄어든다.

## 타입을 사용하는 것의 장점

컴파일러 및 정적 분석은 타입 검사를 한다. 이는 런타임에 직접 실행을 하지 않고서도 코드에서 타입 문제가 있다는 것을 알려준다.

런타임의 코드 실행은 모든 분기 및 조건에 대한 코드의 실행을 해봐야 하지만, 타입을 사용하면 타입간의 상위 하위 타입의 관계 및 코드에서 타입에 대한 모든 분기 처리 및 특정 타입을 받는 파라메터에 잘못된 타입이 전달 될 수 있는 코드를 알려 준다.

컴파일러 및 정적 분석으로 분석 가능한 코드를 만든다면, 코드의 타입만을 검사하여 타입 안정적인 코드를 작성할 수 있다.

### 타입리스의 변경 취약성

타입이 없는 동적 언어의 경우, 전체 코드의 타입을 검사하지 않기 때문에 코드를 변경했을 때, 시그니처 변경이 이뤄지면 이를 사용한 모든 코드를 실행해서 오류가 발생하지는 않는지 확인을 해야 한다.

반환값이 A와 B라는 두 타입에서 A와 C라는 두 가지 타입으로 변경 했을 때, 연결되는 코드는 A와 B에 대한 처리를 하기 위해 분기문을 구성해야 하는 것에서 B에 대한 처리 로직을 지우고 C에 대한 처리 로직을 만드는 작업을 해야 한다. 만약 연결되는 코드를 변경하지 않는다면, 타입이 있는 언어는 컴파일러나 정적 분석 툴은 문제가 있다고 지적하지만 타입이 없는 언어는 테스트 코드를 실행하거나 연관된 모든 코드를 실행해야 한다. 이 때문에 테스트 코드 및 테스트 커버리지가 중요해서 테스트 커버리지를 80~90%으로 만들기도 한다.

## 하나의 변수가 가질 수 있는 타입

변수는 대수적인 특징인 값의 범위를 갖는다. 기본적으로 값의 범위는 타입으로 나타내고, 동적 타입 언어에서 타입을 추가한 경우 하나의 변수는 여러 타입을 가질 수 있다. (이를 유니온 타입이라고 한다.)

유니온 타입이 없는 언어라고 하더라도 상속 관계를 통해서 포함 관계를 만들 수 있기 때문에 하나의 변수가 여러 타입을 갖는 것을 표현할 수 있다.

## 타입이 강력한 언어들의 특징

#### 정적 분석이 강력한 언어

타입이 강력한 언어는 일반적으로 컴파일 언어로 컴파일 시간이 많이 걸린다. 타입스크립트는 동적 언어에 고급 타입이론을 적용했지만, 언어에 타입을 부여하기 위해서 장황한 코드를 추가적으로 적어 주어야 한다.

타입스크립트는 ESlint와 같은 정적 분석에 여전히 의존적인 부분이 크며 정적 분석에서는 감지하지 못한 타입 에러를 컴파일러가 감지하는 등 정적 분석은 완전하지 못한 부분이 때때로 나타나기도 한다.

#### 강력한 컴파일러가 있는 언어

코틀린과 같은 언어는 강력한 타입을 가지고 있고 표현력이 풍부한 문법 및 내장 라이브러리를 가지고 있다. 언어가 강력한 대신 컴파일 시간이 훨씬 많이 걸리는 문제가 있다. 코드를 작성하고 빠르게 확인을 하는 것은 개발에 있어 중요하다. 코틀린은 컴파일 시간이 많이 걸리는 문제를 타입을 적극적으로 활용한 코딩을 통해서 극복할 수 있다. 강력한 타입을 통해서 런타임에서 발견되는 오류를 최소화하는 것이다. 이 외에도 전체 코드가 빌드되어 있다면 변경된 부분과 그에 영향을 주는 코드만 빌드하는 방식으로 컴파일 속도를 늘린다. 또한 유닛 테스트를 통해서 라이브러리 및 전체 프로젝트를 빌드하지 않고 일부 코드만 빌드하여 컴파일 속도를 높일 수 있다.

## 타입이 강력한 언어의 문제

타입은 그 자체로 항상 강력하고 문제가 되지 않는다. 하지만, 강력한 타입 체계를 가진 언어일수록 컴파일하는 시간의 문제, 타입으로 인한 코드의 장황성 문제, 컴파일 시간으로 인한 런타임 확인이 늦어지는 문제를 가지고 있다.

프로그래밍의 로직은 타입만으로 해결할 수 있지 않다. 타입은 어디까지나 타입이 가진 범위를 통해서 코드와 코드 간의 잘못될 가능성이 있는 부분을 찾아내어 이를 고칠 수 있도록 하지만, 모든 로직 에러를 고쳐주지 않는다. 로직 에러는 애초에 잘 생각을 해서 코드를 작성하거나 런타임의 실행된 결과와 작성된 코드의 관계를 분석하면서 문제를 해결하는 경우가 많다. 짧은 단위의 피드백을 반복하는 것이다.

### 웹 프로그래밍

웹 프로그래밍은 서버로 전달되는 각종 값들에 대한 벨리데이션 처리를 하고 이들 값을 이용해야 하는 분야이다. 각종 값들의 벨리데이션은 타입을 분석하는 것으로는 해결할 수 없는, 런타임에 직접 코드를 실행해서 문제를 해결하는 수 밖에 없는 부분이다.

## 타입 주도 설계

타입 주도 설계는 프로그래밍에서 다루는 각각의 항목들에 고유한 타입을 부여하고, 이들 타입을 프로그램에서 전달하는 것을 통해서 타입 안정성으로 평가될 수 있는 코드를 만드는 것을 의미한다.

예를 들어 전화번호, 이메일, 우편번호 이런 문자열은 특수한 포멧을 요구하는 문자열이다. 이들은 몇 가지 케이스로 분류할 수 없기 때문에 Enum으로도 만들 수 없는 특수한 문자열 포멧이 제한되는 대상이다.

각각의 타입에 값을 할당할 때만 런타임 체크를 한 후, 이후에는 가능한 항목 명칭이 부여된 타입을 통해서만 데이터를 전달하는 코드를 작성하여, 타입 검사를 통해서 코드에 잘못된 값이 들어 왔는지 들어오지 않았는지 알 수 있도록 하는 방법을 통해서 한 번 런타임 검사가 끝난 로직에 대해서는 타입 체크를 통해서 로직의 미스를 확인할 수 있도록 코드를 작성하는 것이다.

프로그래밍 언어의 내장된 타입으로 표시 가능한 값이지만, 특정 포멧을 요구하는 값의 경우에는 언어에 내장된 타입을 그대로 이용하는 것이 아니라, 커스텀 타입으로 각각의 항목에 각각의 타입을 사용해서 타입 안정한 코드를 만들 수 있다.

## 커스텀 타입 만들기

### Smart Constructor

```php
class StrYmType
{
    private function __construct(private readonly string $yyyymm) {}

    public static function new(string $yyyymm): self
    {
        $year = intval(substr($yyyymm, 0, 4));
        $month = intval(substr($yyyymm, 4, 2));

        if (strlen($yyyymm) === 6 && checkdate($month, 1, $year)) {
            $new = new self($year.$month);
        } else {
            throw new Error('invalid Ym');
        }
        
        return $new;
    }
    
    public function value(): string
    {
    	return $this->yyyymm;
    }
}

$fn = function (StrYmType $yearMonth) {
    echo 'result: '.$yearMonth->value().PHP_EOL;
};

$fn(StrYmType::new('202406')); // result: 202406
$fn(StrYmType::new('2024-06')); // Uncaught Error: invalid Ym
```

Refinement Type 없이 (바로 다음에 나올 문법), Smart Constructor등 다른 방식으로 타입을 정의할 경우, 이 타입을 그대로 연산에 사용할 수는 없고, 연산이 가능한 타입(언어에 내장된 기본 타입)으로 변환한 뒤에 연산을 수행해야 한다.

곧, 양의 정수 타입을 만들어 나눗셈을 할 때도, int 타입으로 변환을 해서 연산하기 때문에, 그리고 타입시스템 자체가 Refinement Type가 정의된 언어만큼의 타입 확인 기능을 제공하지 않기 때문에, 0으로 나누는 것에 대한 컴파일러 또는 정적 분석에 의한 확인이 불가능한 문제가 있다.

### Refinement Type

학교 수학에서 조건 제시법을 통해서 변수의 조건을 표기한다. {x | x는 ... 조건} 이와 비슷하게, 어떤 타입에 대해 해당 타입의 값이면서도 특정 조건만을 만족하는 대상을 표기할 수 있는 문법을 가진 것을 Refinement Type이라고 부른다.

양의 정수는 int 타입에서 x > 0이란 조건을 추가한 것이고, 이메일이나 전화번호는 문자열에서 특정 정규식을 만족하는 조건을 추가한 것이다. 기존 타입을 이용하되, 해당 타입의 좀 더 좁은 범위의 값을 조건문으로 제한할 수 있는 타입을 만든다.

일반적인 언어에서 볼 수 있지는 않고, Idris와 같은 특수한 언어들에서 이러한 커스텀 타입을 정의할 수 있다. 타입의 조건에 맞지 않는 연산이 있다면 컴파일러가 에러를 발생시킨다.

```idrid
data Positive : Type where
  MkPositive : (n : Int) -> (0 < n) -> Positive

safeDivide : Int -> Positive -> Int
safeDivide x (MkPositive y _) = x `div` y
```

양의 정수 타입 Positive으로 정의했다. 양수 y에 대해서만 x 나누기 y를 할 수 있도록 하여 0으로 나누는 경우를 배제하는 것을 타입을 통해서 표현할 수 있어 런타임 확인 없이 컴파일 단계에서 안정성을 보장할 수 있다.

## 타입의 한계

아무리 타입으로 각각의 값들에 타입을 부여해서 안정성을 추구한다고 하더라도, 웹이란 분야는 유저의 입력 값, 데이터베이스 레디스와 같은 외부 시스템과의 연동을 통한 값 전달 등이 많은 비중을 차지한다. 이들 값은 언어의 내장된 기본 타입들을 언어 내부로 가져오는데 커스텀 타입으로 변환을 할 때는 런타임의 동작 확인이 필요하다.

모든 값을 타입으로 정의하는 것은, 때때로 비효율적이다. 일반적인 객체지향 중심의 언어에서 커스텀 타입을 정의하기 위해서는 클래스를 정의해야 하는데, 클래스는 많은 양의 보일러 플레이트 작성을 요구한다. 정말 여러 코드 맥락에서 공통으로 사용되는 값에 한해서 타입을 정의하지 않는다면 어떤 기능을 추가하기 위해서 너무 많은 코드 작성이 요구된다.

또한 타입 주도 설계를 적극 지원하지 않는 일반적인 언어를 사용할 경우 세분화된 타입을 정의하더라도 타입의 포함 관계만을 체크할 수 있을 뿐, 이들 타입으로 연산을 수행하기 위해서는 언어의 기본 타입으로 다시 변환 하거나, 연산자 오버로딩 또는 연산을 위한 메소드를 정의해야 하는 등의 타입간의 연산 가능/불가능을 체크할 수 없다. 이는 런타임의 동작 확인을 통해서만 가능하다. 언어의 연산자를 커스텀 타입에도 적용할 수 있도록 확장할 수 있는 언어가 아닌한 런타임 동작 확인이 수반된다.

타입이란 것은 하나의 값이 타입이 되는 경우도 있지만, 일반적으로는 값의 범위를 의미한다. 타입과 타입 사이의 연산을 정의하기 위해서는 특정 값이 아닌 값의 범위에 대한 연산을 정의해야 하기 때문에 수학적인 증명 수준의 타입간의 연산 성립 여부를 증명해야 하고 연산을 별도로 정의해서 사용해야 한다. 때때로 이 과정은 간단해서 이점을 제공할 수 있지만, 타입 주도 설계의 목표가 런타임의 타입 확인을 최소화하는 것이기 때문에 가능한 많은 타입과 타입 간의 연산 관계를 정의해야 하므로 굉장히 까다로울 수 있다.

덧셈을 하기 위해서 초등학교 정도의 수학을 알면 되는데, 자연수, 정수의 범위 결합 법칙, 교환 법칙, 방정식, 증명 방법 (정리, 보조정리, 따름정리, 공식, 명제) 등을 알아야 하고 이를 통해서 타입과 타입 간의 관계성을 설명할 수 있을 정도로 굳이 배워야 할까?

일반적인 비즈니스 수준의 문제 해결은, 논리적으로 모순된 기획과 운용이 난무한다. 프로그래머의 일은 이들을 최대한 논리적으로 풀어내어 시스템의 정합성과 논리적 완결성을 만들어내는 과정이다. 수학적인 타입은 엄밀하지만, 실세계의 로직은 완벽하지 않다. 엄밀한 체계를 만들어서 논리적으로 잘못된 기획과 설계를 지적하고 개선할 수 있겠지만, 실셰계의 로직을 수학적 엄밀함을 갖춘 타입 체계로 만들기 위해서는 일반적인 로직을 만드는 것 보다 훨씬 많은 시간과 지적 수준을 요구하므로 현실적으로 적절한 방법론인지 의문이 있을 수 밖에 없다.

일반적으로는 도메인 전문가와 개발자가 나눠져 있고, 개발자는 도메인에 대한 이해가 부족하기 때문에 최종적으로 어떤 연산 체계의 시스템을 만들지 알 수 없는 경우가 있다. 이 때문에 잘못된 타입 정의와 연산 체계를 만들 수 있다. 추상화는 추상화를 이해하기 위한 별도의 노력이 수반된다. 어설프거나 잘못된 추상화는 잘못된 개념을 이해하기 위한 노력을 요구하기 때문에 이를 바로 잡기 위해 훨씬 많은 시간을 요구한다. 또한 이런 수리적 논리 시스템을 다른 사람들에게 이해를 시켜야하고 다른 사람들이 이를 이해하고 메인테인스해야 한다. 실제로 간단히 구현할 수 있는 기능을, 엄격한 타입 체계를 만들기 위해서 많은 시간을 사용해야 할 수도 있다.

실제로 수학을 배우는데 드는 시간을 생각해 봐야 하고, 수 많은 수포자가 만들어지고, 증명에 관련된 수학 과목을 회피하는 수 많은 사람이 있다는 것을 기억하자.

### 타입 한계 뛰어 넘기

타입으로 런타임의 각종 연산 로직을 대체할 수는 없지만 타입은 여전히 중요하다. 연산 로직이 아닌, 값의 전달, 함수의 파라메터와 반환값에서 타입 입치는 무척 중요하며, 이를 통해서, 잘못된 값이 전달되는 것을 컴파일 또는 정적 분석을 통해서 미연에 방지할 수 있다.

각종 유닛 테스트는 주로 하나의 시그니처 단위로 만들어지는데 유닛 테스트로 연산 로직을 검증하고, 각 시그니처 간의 결합은 타입 구성에 맡기는 방식을 통해서, 통합 테스트를 어느 정도 생략할 수 있다는 장점이 있다. 이를 위해서는 유닛 테스트가 가능한 대상을 늘리고, 유닛 테스트가 된 로직을 퇴대한 단순하게 조합해서 타입 체커로 통합 테스트의 필요성을 최소한으로 하는 방식을 쓸 수 있다.

## 사양서와 테스트로 타입 엄밀성 생략하기

런타임의 실행 결과가 올바르다는 것을 보증하기 위해서는 테스트 뿐만 아니라, 각 기능이 요구하는 정확한 결과를 만들어 낼 수 있는지 사양서를 잘 만족하는지 확인을 하는 것도 필요하다.

문제는 테스트 코드와 사양서가 제대로 갖춰지지 않은 무수한 프로젝트가 존재한다는 것이고, 실제 개발 시간과 여건이 불충분한 경우도 많고, 시간의 흐름에 따라 각종 기능들이 변경되지만 업데이트 되지 못한다는 문제 등 많은 실무에서 발생하는 어쩔 수 없는 문제점들이 있다.

또한 문제는 애플리케이션의 기능은 각종 조건에 따라 다양한 분기 처리를 갖기 때문에, 모든 분기 로직을 실행하는 것이 어려울 수 있고, 현실적으로 불가능한 경우도 많다는 것이다. 모든 케이스에 대한 테스트 작성은 불가능하고 일부 값에 대한 테스트만을 작성하기 때문에 테스트의 누락이 필연적으로 발생할 수 밖에 없다.

이를 최대한 해결하는 것은, 코드를 작성할 때 도메인의 의도를 최대한 잘 드러낼 수 있도록 추상화를 하는 것이고, 테스트 사양서을 잘 작성하고, BDD를 통해서 테스트 코드를 작성하는 등 시스템이 요구하는 요구사항을 한 부분이 누락되더라도 다른 부분을 통해서 의도를 추측할 수 있게 하고, 시스템을 만든 의도를 파악할 수 있게 만드는 것이 중요하다.

## php가 웹의 왕이라고 불리는 이유

### 런타임 확인의 필요성

아무리 타입으로 안정된 설계를 하려고 하더라도, 커스텀 타입에 대한 연산을 해야 하기 때문에 타입으로 로직을 표현하는 것에는 한계가 있다. 타입만으로는 부족하고 프로덕션 환경에서 사용되는 언어의 런타임 타입 확인은 필수적이다. 웹 프로그래밍은 다양한 외부 환경과의 상호작용으로 이뤄져 있고, 외부의 값을 프로그래밍 언어의 값으로 매핑하는 과정은 개발시의 최소한의 런타임 확인이 요구된다.

### 실패를 통한 확인

php는 FastFail이란 철학으로 만들어 져 있다. 이 철학은 작성된 코드를 빠르게 실행하여 그 결과를 확인하여 에러가 발생하면 코드를 수정하고, 에러가 발생하지 않았다면, 코드가 입력 값에 대한 출력 값을 잘 산출하는지 확인하는 과정을 통해서 점차 의도한 로직을 만드는 것이다. 인터프리터 언어는 로직을 빠르게 실행하고 결과를 확인할 수 있는 장점이 있으므로 외부에서 전달된 값이 프로그래밍 언어에서 어떻게 변환되어 전달되는지 쉽게 알 수 있다는 장점이 있다. 또한 php는 거의 대부분의 타입을 런타임에 특정할 수 있기 때문에, 런타임 타입 확인을 통해서 실제로 전달되는 값과 전달되지 않는 값이 어떻게 구분되는지 알 수 있다.

### php의 한계 극복

인터프리터 언어의 변경에 대해서 테스트 코드를 동작시켜 변경할 의도가 없는 동작이 변경되지 않도록 하는 것이 중요하다. 코드를 작성할 때 가능한 타입을 이용한다면, IDE를 통해 타입을 사용하는 코드와 연결되는 모든 코드를 확인할 수 있다. 이를 통해서 모든 연결되는 코드에 영향이 있는지 확인할 수 있다. 하지만, 타입은 코드 간의 연결성을 알려주고, 다른 타입의 값이 전달될 수 없게 제한을 할 뿐, 타입으로는 알 수 없는 타입 내의 값들 간의 논리적인 정확성을 담보하지는 못한다. 이를 확인하기 위해서는 런타임의 실행을 통한 확인이 필요하다.

php는 타입 정의에 있어서 약한 면모를 가지고 있고, 언어의 내장된 타입 또는 클래스를 통한 타입 정의만 가능하고, 각종 타입 별칭이나 제네릭 타입 등을 정의할 수 없는 언어이다. (phpdoc의 템플릿 문법으로 제네릭을 모방할 수도 있지만, 템플릿 문법을 사용한 코드는 지저분하거나 지나치게 장황하게 만들기 때문에 써야하는지에 대해서는 논란의 여지가 있다.) 타입으로 도메인과 시스템의 제약을 표기하기 어려운 측면이 많기 때문에, 런타임의 타입 검증, 런타임의 로직 검증이 필수적이다. 인터프리터 언어는 타입 선언이 부족한만큼 런타임 확인이 빠르다.

php의 런타임 확인 기능을 잘 활용하기 위해서는, 개발 환경에서 의도하여 확인한 동작 이외에는 실제 프로덕션 환경에서는 동작하지 않도록, 런타임에서 검증된 로직만 동작하도록 해야 한다. 만약 의도하지 않은 동작이 일어나는 경우라면 에러가 발생해서 이를 바로 캐치하여 수정할 수 있도록 만들어야 한다.

### php의 장점

웹 프로그래밍은 결국에는 런타임 확인이 중요한 분야이다. php는 쉽게 런타임 확인을 할 수 있는 언어로 각종 외부 값을 확인하는데 장점을 가진 언어이다. 런타임 이전에 컴파일러나 IDE를 통해 강력한 타입으로 로직의 안정성을 검토할 수 있는 여러 언어들이 있지만, 불가피하게 런타임 확인을 해야 할 수 밖에 없는 없는 분야가 웹이다. 웹 분야에서 php가 아직까지도 건재한 것은 쉽게 런타임 확인을 할 수 있는 언어이기 때문이고 타입만으로는 웹의 각종 데이터 전달의 타입을 정확하게 보증할 수 없기 때문에 런타임 확인이 수반되어야 하는데 어차피 런타임 확인이 필요한 것이라면 php가 큰 단점은 아니다.

### php의 단점

사실상 웹 분야의 일반적인 비즈니스 로직을 구현하는 제품을 만드는 것에는 아무런 문제가 없고, 오히려 다른 언어 보다 빠른 생산성을 가져다주기도 한다. 하지만, 타입 안정성이나 성능을 추구하는 프로그래밍을 하기에는 어려움이 있다. 프로그래머로서 단순히 제품을 만드는 것 이상으로 프로그래밍 언어에 대해서 깊이 공부하고, 성능적인 측면을 고려해서 시스템을 만들고 싶은 경우, php 개발 환경에서의 성장은 제한된다.

개발자가 개인의 지적 성장을 희생하면서 회사의 시스템을 위해서 더 투자하게 하는 언어이기 때문에, 다른 언어의 개발자보다 더 많은 급여를 받아야 한다고 생각한다. 하지만 그 만큼의 급여를 받을 수 없다면, php 개발보다는 개발자로서 더 나은 성장 환경을 제공하는 언어를 경험할 수 있는 회사로 가는 게 맞다고 본다.

### 왜 php의 인식은 나쁜가?

php는 런타임 로직 검증에 최적화된 언어이기 때문에, 그 만큼 비즈니스 로직적인 측면, 사양서를 비록한 각종 문서 정리, 시큐리티적인 측면, 테스트 자동화 등을 적극 도입해서 타입이 있는 언어의 부족함을 보완하는 것이 필요하다. 타입이 강력한 언어도 이런 측면에서는 비슷한데, 다만 어느정도 생략을 해도 시스템의 안정성을 어느 정도 담보할 수 있는 반면에, 인터프리터 언어들은 이런 측면에서 생략이 이뤄지면 코드 수정에 따른 문제가 발생할 확률이 아주 높아질 수 있다는 문제점이 있다.

하지만, 많은 개발 현장에서 빠른 스피드를 추구한 나머지, 일단 돌아가는 기능만 만들면 OK인 경우가 많고, 언어의 부족한 면을 개발 프로세스로 채워넣기 보다는 생략하는 경우가 많아지면서 점점 메인테인스가 어려운 시스템을 만들어 내는 경우가 많다.

시스템 개발에서 당연히 해야 할 것들을 생략하기 때문에 php 개발으로 인한 문제점이 더욱 부각될 수 밖에 없다.

### 올바른 개발 문화를 가진 회사라면

올바른 개발 문화를 가진 회사라면, 사양서, 비즈니스 로직의 정확성과 적절성 검토, 사양서를 비롯한 각종 문서 정리, 시큐리티 측면의 고려, 테스트 코드의 도입 등으로 php의 문제점을 잘 보완하면서 개발하는 회사가 있을 수 있고, 타입이 부족한 언어의 문제점을 잘 보완할 수 있기 때문에 php의 장점을 잘 살릴 수 있다. 하지만 지나치게 속도를 중시해야 하는 경우라면 이런 해야 할 것들이 생략되면서 그나마 타입 보증이라도 잘 되는 컴파일 언어를 했어야 한다고 생각할 것이다.

