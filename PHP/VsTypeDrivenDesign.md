# 타입 주도 설계

## 대수적인 프로그래핑

대수학이란 직접적인 수를 대신한 문자를 사용해서 어떤 식을 만드는 것을 의미한다. 수를 대신한 문자를 통해서 수들 간의 관계성을 나타낼 수 있고, 방정식을 만들면 특정 수의 범위에 대해 특정한 관계성을 만족한다는 것을 표현할 수 있다.

프로그래밍에서도 대수란 변수의 범위에 대해서 각각의 시그니처의 코드들의 연관 관계를 통해서 어떤 로직의 변수들 간의 관계성을 만들어 낼 수 있다. 수학에서 변수의 범위가 자연수, 정수, 소수, 음의 정수, {x | x는 ... 조건}, a <= x < b 등으로 나타낼 수 있는 것에 반해서, 프로그래밍에서 대수의 범위는 타입이란 것으로 타나낸다.

### 좀 더 엄밀한 정의

대수를 영어로는 argebric이라고 하는데, 카테고리 이론에 기반을 두고 있는 수학적인 개념이다.

카테고리를 프로그래밍 언어에서는 타입으로 표기하고, 변수의 값은 하나의 타입이지만 변수가 가지는 타입의 범위가 두 가지 이상인 경우를 타입의 합으로, 변수가 가지는 타입이 둘 모두의 타입으로 구성되어 있으면 곱으로 본다.

#### 합 타입과 곱 타입의 예

- 유니온 타입 (합 타입) : A 타입 또는 B 타입 또는 C 타입의 여러 타입으로 하나의 변수를 나타낼 수 있다.
- Enum 타입 (합 타입) : Enum의 각 case는 하나의 타입이다. 하나의 Enum은 여러 case로 구성되어 있고 이들 case 중 하나가 변수의 값이 된다. Enum의 하나의 case는 값이자 타입이다.
- 튜플 (곱 타입) : 튜플은 php의 배열과 유사하지만 데이터의 길이가 정해져 있고, 각 원소를 구성하는 타입이 정해져 있으며, 선언된 값을 변경할 수 없는 특성을 가진 대상이다. 예를 들어 `[Person, Company]`으로 타입이 구성되어 있다면 `Person` 타입과 `Company` 타입이 하나의 원소를 구성하고 이들을 베이스로 한 값 `[Person1, Company1]`, `[Person2, Company2]`, `[Person3, Company3]`... 원소의 집합이 튜플으로 여러 타입이 복합적으로 하나의 값을 만든다.

## 타입리스 언어의 문제

타입이 없는 언어의 문제는 코드가 처음 생성된 부분부터 데이터가 어떻게 변했는지를 추적해야 한다.

타입을 사용하면 값의 생성을 처음부터 추적하지 않고, 코드의 일부분만으로 변수가 가진 타입을 알고, 해당 타입에 대한 로직을 만들면 되기 때문에 코드를 해석하는데 피로도가 줄어든다.

## 타입을 사용하는 것의 장점

컴파일러 및 정적 분석은 타입 검사를 한다. 이는 런타임에 직접 실행을 하지 않고서도 코드에서 타입 문제가 있다는 것을 알려준다.

런타임의 코드 실행은 모든 분기 및 조건에 대한 코드의 실행을 해봐야 하지만, 타입을 사용하면 타입간의 상위 하위 타입의 관계 및 코드에서 타입에 대한 모든 분기 처리 및 특정 타입을 받는 파라메터에 잘못된 타입이 전달 될 수 있는 코드를 알려 준다.

컴파일러 및 정적 분석으로 분석 가능한 코드를 만든다면, 코드의 타입만을 검사하여 타입 안정적인 코드를 작성할 수 있다.

### 타입리스의 변경 취약성

타입이 없는 동적 언어의 경우, 전체 코드의 타입을 검사하지 않기 때문에 코드를 변경했을 때, 시그니처 변경이 이뤄지면 이를 사용한 모든 코드를 실행해서 오류가 발생하지는 않는지 확인을 해야 한다.

반환값이 A와 B라는 두 타입에서 A와 C라는 두 가지 타입으로 변경 했을 때, 연결되는 코드는 A와 B에 대한 처리를 하기 위해 분기문을 구성해야 하는 것에서 B에 대한 처리 로직을 지우고 C에 대한 처리 로직을 만드는 작업을 해야 한다. 만약 연결되는 코드를 변경하지 않는다면, 타입이 있는 언어는 컴파일러나 정적 분석 툴은 문제가 있다고 지적하지만 타입이 없는 언어는 테스트 코드를 실행하거나 연관된 모든 코드를 실행해야 한다. 이 때문에 테스트 코드 및 테스트 커버리지가 중요해서 테스트 커버리지를 80~90%으로 만들기도 한다.

## 하나의 변수가 가질 수 있는 타입

변수는 대수적인 특징인 값의 범위를 갖는다. 기본적으로 값의 범위는 타입으로 나타내고, 동적 타입 언어에서 타입을 추가한 경우 하나의 변수는 여러 타입을 가질 수 있다. (이를 유니온 타입이라고 한다.)

유니온 타입이 없는 언어라고 하더라도 상속 관계를 통해서 포함 관계를 만들 수 있기 때문에 하나의 변수가 여러 타입을 갖는 것을 표현할 수 있다.

## 타입이 강력한 언어들의 특징

#### 정적 분석이 강력한 언어

타입이 강력한 언어는 일반적으로 컴파일 언어로 컴파일 시간이 많이 걸린다. 타입스크립트는 동적 언어에 고급 타입이론을 적용했지만, 언어에 타입을 부여하기 위해서 장황한 코드를 추가적으로 적어 주어야 한다.

타입스크립트는 ESlint와 같은 정적 분석에 여전히 의존적인 부분이 크며 정적 분석에서는 감지하지 못한 타입 에러를 컴파일러가 감지하는 등 정적 분석은 완전하지 못한 부분이 때때로 나타나기도 한다.

#### 강력한 컴파일러가 있는 언어

코틀린과 같은 언어는 강력한 타입을 가지고 있고 표현력이 풍부한 문법 및 내장 라이브러리를 가지고 있다. 언어가 강력한 대신 컴파일 시간이 훨씬 많이 걸리는 문제가 있다. 코드를 작성하고 빠르게 확인을 하는 것은 개발에 있어 중요하다. 코틀린은 컴파일 시간이 많이 걸리는 문제를 타입을 적극적으로 활용한 코딩을 통해서 극복할 수 있다. 강력한 타입을 통해서 런타임에서 발견되는 오류를 최소화하는 것이다. 이 외에도 전체 코드가 빌드되어 있다면 변경된 부분과 그에 영향을 주는 코드만 빌드하는 방식으로 컴파일 속도를 늘린다. 또한 유닛 테스트를 통해서 라이브러리 및 전체 프로젝트를 빌드하지 않고 일부 코드만 빌드하여 컴파일 속도를 높일 수 있다.

## 타입이 강력한 언어의 문제

타입은 그 자체로 항상 강력하고 문제가 되지 않는다. 하지만, 강력한 타입 체계를 가진 언어일수록 컴파일하는 시간의 문제, 타입으로 인한 코드의 장황성 문제, 컴파일 시간으로 인한 런타임 확인이 늦어지는 문제를 가지고 있다.

프로그래밍의 로직은 타입만으로 해결할 수 있지 않다. 타입은 어디까지나 타입이 가진 범위를 통해서 코드와 코드 간의 잘못될 가능성이 있는 부분을 찾아내어 이를 고칠 수 있도록 하지만, 모든 로직 에러를 고쳐주지 않는다. 로직 에러는 애초에 잘 생각을 해서 코드를 작성하거나 런타임의 실행된 결과와 작성된 코드의 관계를 분석하면서 문제를 해결하는 경우가 많다. 짧은 단위의 피드백을 반복하는 것이다.

### 웹 프로그래밍

웹 프로그래밍은 서버로 전달되는 각종 값들에 대한 벨리데이션 처리를 하고 이들 값을 이용해야 하는 분야이다. 각종 값들의 벨리데이션은 타입을 분석하는 것으로는 해결할 수 없는, 런타임에 직접 코드를 실행해서 문제를 해결하는 수 밖에 없는 부분이다.

## 타입 주도 설계

타입 주도 설계는 프로그래밍에서 다루는 각각의 항목들에 고유한 타입을 부여하고, 이들 타입을 프로그램에서 전달하는 것을 통해서 타입 안정성으로 평가될 수 있는 코드를 만드는 것을 의미한다.

예를 들어 전화번호, 이메일, 우편번호 이런 문자열은 특수한 포멧을 요구하는 문자열이다. 이들은 몇 가지 케이스로 분류할 수 없기 때문에 Enum으로도 만들 수 없는 특수한 문자열 포멧이 제한되는 대상이다.

각각의 타입에 값을 할당할 때만 런타임 체크를 한 후, 이후에는 가능한 항목 명칭이 부여된 타입을 통해서만 데이터를 전달하는 코드를 작성하여, 타입 검사를 통해서 코드에 잘못된 값이 들어 왔는지 들어오지 않았는지 알 수 있도록 하는 방법을 통해서 한 번 런타임 검사가 끝난 로직에 대해서는 타입 체크를 통해서 로직의 미스를 확인할 수 있도록 코드를 작성하는 것이다.

프로그래밍 언어의 내장된 타입으로 표시 가능한 값이지만, 특정 포멧을 요구하는 값의 경우에는 언어에 내장된 타입을 그대로 이용하는 것이 아니라, 커스텀 타입으로 각각의 항목에 각각의 타입을 사용해서 타입 안정한 코드를 만들 수 있다.

## 커스텀 타입 만들기

### Smart Constructor

```php
class StrYmType
{
    private function __construct(private readonly string $yyyymm) {}

    public static function new(string $yyyymm): self
    {
        $year = intval(substr($yyyymm, 0, 4));
        $month = intval(substr($yyyymm, 4, 2));

        if (strlen($yyyymm) === 6 && checkdate($month, 1, $year)) {
            $new = new self($year.$month);
        } else {
            throw new Error('invalid Ym');
        }
        
        return $new;
    }
    
    public function value(): string
    {
    	return $this->yyyymm;
    }
}

$fn = function (StrYmType $yearMonth) {
    echo 'result: '.$yearMonth->value().PHP_EOL;
};

$fn(StrYmType::new('202406')); // result: 202406
$fn(StrYmType::new('2024-06')); // Uncaught Error: invalid Ym
```

Refinement Type 없이 (바로 다음에 나올 문법), Smart Constructor등 다른 방식으로 타입을 정의할 경우, 이 타입을 그대로 연산에 사용할 수는 없고, 연산이 가능한 타입(언어에 내장된 기본 타입)으로 변환한 뒤에 연산을 수행해야 한다.

곧, 양의 정수 타입을 만들어 나눗셈을 할 때도, int 타입으로 변환을 해서 연산하기 때문에, 그리고 타입시스템 자체가 Refinement Type가 정의된 언어만큼의 타입 확인 기능을 제공하지 않기 때문에, 0으로 나누는 것에 대한 컴파일러 또는 정적 분석에 의한 확인이 불가능한 문제가 있다.

### Refinement Type

학교 수학에서 조건 제시법을 통해서 변수의 조건을 표기한다. {x | x는 ... 조건} 이와 비슷하게, 어떤 타입에 대해 해당 타입의 값이면서도 특정 조건만을 만족하는 대상을 표기할 수 있는 문법을 가진 것을 Refinement Type이라고 부른다.

양의 정수는 int 타입에서 x > 0이란 조건을 추가한 것이고, 이메일이나 전화번호는 문자열에서 특정 정규식을 만족하는 조건을 추가한 것이다. 기존 타입을 이용하되, 해당 타입의 좀 더 좁은 범위의 값을 조건문으로 제한할 수 있는 타입을 만든다.

일반적인 언어에서 볼 수 있지는 않고, Idris와 같은 특수한 언어들에서 이러한 커스텀 타입을 정의할 수 있다. 타입의 조건에 맞지 않는 연산이 있다면 컴파일러가 에러를 발생시킨다.

```idrid
data Positive : Type where
  MkPositive : (n : Int) -> (0 < n) -> Positive

safeDivide : Int -> Positive -> Int
safeDivide x (MkPositive y _) = x `div` y
```

양의 정수 타입 Positive으로 정의했다. 양수 y에 대해서만 x 나누기 y를 할 수 있도록 하여 0으로 나누는 경우를 배제하는 것을 타입을 통해서 표현할 수 있어 런타임 확인 없이 컴파일 단계에서 안정성을 보장할 수 있다.

## 타입의 한계

아무리 타입으로 각각의 값들에 타입을 부여해서 안정성을 추구한다고 하더라도, 웹이란 분야는 유저의 입력 값, 데이터베이스 레디스와 같은 외부 시스템과의 연동을 통한 값 전달 등이 많은 비중을 차지한다. 이들 값은 언어의 내장된 기본 타입들을 언어 내부로 가져오는데 커스텀 타입으로 변환을 할 때는 런타임의 동작 확인이 필요하다.

모든 값을 타입으로 정의하는 것은, 때때로 비효율적이다. 일반적인 객체지향 중심의 언어에서 커스텀 타입을 정의하기 위해서는 클래스를 정의해야 하는데, 클래스는 많은 양의 보일러 플레이트 작성을 요구한다. 정말 여러 코드 맥락에서 공통으로 사용되는 값에 한해서 타입을 정의하지 않는다면 어떤 기능을 추가하기 위해서 너무 많은 코드 작성이 요구된다.

또한 타입 주도 설계를 적극 지원하지 않는 일반적인 언어를 사용할 경우 세분화된 타입을 정의하더라도 타입의 포함 관계만을 체크할 수 있을 뿐, 이들 타입으로 연산을 수행하기 위해서는 언어의 기본 타입으로 다시 변환 하거나, 연산자 오버로딩 또는 연산을 위한 메소드를 정의해야 하는 등의 타입간의 연산 가능/불가능을 체크할 수 없다. 이는 런타임의 동작 확인을 통해서만 가능하다. 언어의 연산자를 커스텀 타입에도 적용할 수 있게 만들 수 있는 특수한 언어가 아닌 이상 런타임 동작 확인이 수반된다.

### 타입 한계 뛰어 넘기

타입으로 런타임의 각종 연산 로직을 대체할 수는 없지만, 타입은 여전히 중요한데 연산 로직이 아닌, 값의 전달, 함수의 파라메터와 반환값에서 타입 입치는 무척 중요하며, 이를 통해서, 잘못된 값이 전달되는 것을 컴파일 또는 정적 분석을 통해서 미연에 방지할 수 있다.

각종 유닛 테스트는 주로 하나의 시그니처 단위로 만들어지는데 유닛 테스트로 연산 로직을 검증하고, 각 시그니처 간의 결합은 타입 구성에 맡기는 방식을 통해서, 통합 테스트를 어느 정도 생략할 수 있다는 장점이 있다. 이를 위해서는 유닛 테스트가 가능한 대상을 늘리고, 유닛 테스트가 된 로직을 퇴대한 단순하게 조합해서 타입 체커로 통합 테스트의 필요성을 최소한으로 하는 방식을 쓸 수 있다.

## php가 웹의 왕이라고 불리는 이유

### 런타임 확인의 필요성

아무리 타입으로 안정된 설계를 하려고 하더라도, 커스텀 타입에 대한 연산을 해야 하기 때문에 타입으로 로직을 표현하는 것에는 한계가 있다. 타입만으로는 부족하고 프로덕션 환경에서 사용되는 언어의 런타임 타입 확인은 필수적이다. 웹 프로그래밍은 다양한 외부 환경과의 상호작용으로 이뤄져 있고, 외부의 값을 프로그래밍 언어의 값으로 매핑하는 과정은 개발시의 최소한의 런타임 확인이 요구된다.

### 실패를 통한 확인

php는 fastfail이란 철학으로 만들어 져 있다. 이 철학은 작성된 코드를 빠르게 실행하여 그 결과를 확인하여 에러가 발생하면 코드를 수정하고, 에러가 발생하지 않았다면, 코드가 입력 값에 대한 출력 값을 잘 산출하는지 확인하는 과정을 통해서 점차 의도한 로직을 만드는 것이다. 인터프리터 언어는 로직을 빠르게 실행하고 결과를 확인할 수 있는 장점이 있다

### php의 한계 극복

인터프리터 언어의 변경에 대해서 테스트 코드를 동작시켜 변경할 의도가 없는 동작이 변경되지 않도록 하는 것이 중요하다. 코드를 작성할 때 가능한 타입을 이용한다면, IDE를 통해 타입을 사용하는 코드와 연결되는 모든 코드를 확인할 수 있다. 이를 통해서 모든 연결되는 코드에 영향이 있는지 확인할 수 있다. 하지만, 타입은 코드 간의 연결성을 알려 줄 뿐 타입으로는 알 수 없는 타입 내의 값들 간의 논리적인 정확성을 담보하지는 못한다. 이를 확인하기 위해서는 런타임의 실행을 통한 확인이 필요하다.
