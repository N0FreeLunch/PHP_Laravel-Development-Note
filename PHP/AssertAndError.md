## Assert란?

assert는 어떤 값의 조건을 검사하는 기능으로, assert 문에 부여한 조건이 거짓일 경우 에러를 내거나 프로그램의 실행을 중단하는 등의 역할을 한다.

자바나 C#과 같은 언어에서는 예외를 부여하며, C++의 경우는 메시지와 함께 프로세스의 실행을 종료한다.

보통 assert는 개발 환경 및 테스트 환경에서 동작하며, 프로덕션 환경에서는 비활성화 되도록 설정이 된다. 이는 assert를 사용하는 코드가 프로그램의 실행 속도를 늦추기 때문이다.

로컬의 개발 환경에서 동작을 확인할 때 테스트 코드가 동작을 할 때 활성화하여 실수나, 버그를 방지하는데 사용한다.

### assert를 어떻게 사용해야 할까?

어떤 함수가 있다고 하자. 함수 내부로 들어오는 모든 케이스를 대비하는 코드를 만들 수도 있지만 이는 코드들 장황하게 만든다. 함수 내로 들어올 수 있는 값의 범위를 한정해서 해당 범위에서만 동작하는 로직을 만드는 것으로 코드를 좀 더 간결하게 만들 수 있다. `assert`문에 전달된 값이 조건을 통과하지 못하면 `assert` 에러나 프로세스가 종료 되므로 이후의 코드는 실행되지 않는다.

`assert`는 어떤 값이 전달 되었을 때 이 부분에서는 반드시 이런 값이 전달 되어야 동작할 수 있어라는 것을 알려준다. 에러를 발생시키거나 예외를 정의하는 등의 수고 없이 간단한 문법으로 사용할 수 있으므로 코드를 간결하게 짜는데 도움을 준다.

### assert를 통한 타입 확인

타입스크립트에서는 [type narrowing](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)이라는 기능이 있다. 이 타입 narrowing 기능은, 타입은 상위 타입인데 하위 타입의 값이 전달되거나 또는 유니온 타입으로 지정된 타입 중 어떤 하나만 전달되는 경우 타입을 좁혀서 이 코드 맥락에서 전달된 값은 이런 하위 타입, 유니온 타입 중에서 특정한 타입이니까 다른 타입에 관한 코드 작성 없이 이 타입에 대한 처리만으로 충분하다는 것을 알려주기 위해서 사용한다.

정적 분석 도구나 phpstorm과 같은 IDE를 사용하면, `assert`로 변수의 타입이 좁혀진 경우, 이후의 코드는 `assert`로 제한된 타입에 대해서만 코드를 판단해 주기 때문에 코드를 작성할 때 타입 불일치로 인한 실수를 많이 예뱅할 수 있다. 이때, IDE나 정적 분석 도구가 타입을 제한하도록 하려면 `assert`에서 확인하는 타입 확인 코드가 `assert(is_type($var))`, `assert($var instanceof SomeClass)` 등의 간단한 코드여야 한다.

php의 경우 지역 변수 선언시 타입을 지정할 수 없어서 IDE의 타입 추론이 잘못되는 경우가 생길 수 있는데, assert를 사용하여 타입을 확인해 주면 IDE의 타입이 assert에서 지정한 타입 범위로 제한되어 추론되기 때문에 변수 사용시 타입이 잘못되어 발생하는 실수를 줄일 수 있다.

### 전제 조건과 사후 조건

예를 들어 어떤 함수를 만든다고 하자. 함수에 들어오는 인자나 클로저의 캡쳐된 값은 전제 조건에 해당하고 함수의 반환 값은 사후 조건에 해당한다. 전제 조건에 대한 함수의 반환 값이 어느 정도의 유효한 범위 내에 있는지 확인할 때, 전제 조건과 사후 조건을 확인하는 용도로 assert를 사용하여 동작이 어떻게 이뤄지는지를 판단하는 로직을 만들어 낼 수 있다.

```php
function payPrice(int $fixedPrice, int $discountPrice = 0): int
{
    assert($fixedPrice >= 0, 'The total fixed price must be 0 or greater.');
    assert($discountPrice <= 0, 'The discount amount must be 0 or less.');

    $result = $fixedPrice + $discountPrice;

    assert($result >= 0, 'The payment amount must be greater than 0.');

    return $result;
}
```

assert를 사용하면, 사전 조건과 사후 조건을 알 수 있으므로 개발자가 어떤 범위의 값을 가정하고 코드를 작성했는지 명확하게 알 수 있게 해 준다는 장점이 있다.

프로덕션 환경에서는 `assert`가 제외된 코드가 실행될 것이다. `assert` 부분의 코드를 제외해 보자. 그러면 일반적으로 코드를 짜는 것과 동일하다는 것을 알 수 있다. assert는 개발자가 로직에 대해서 사전 조건과 사후 조건을 파악하는데만 이용할 뿐, 실제 코드의 동작에 영향을 주는 요인이 되지 않는 코드로 프로덕션 환경에서 실행되지 않아도 코드의 실행에 문제가 없도록 만들어져야 한다.

`assert`는 프로덕션 환경에서 런타임 비용 없이 주석 없이 코드로 동작 범위를 나타낼 수 있고, 함수가 동작하는 사양을 정확하고 구체적으로 표현할 수 있다는 장점이 있다.

### 타입에 대한 assert

컴파일 언어에서 주로 검사하는 대상은 타입이 올바른지를 검사하기 보다는 값의 범위를 검사한다. 타입의 경우에는 컴파일러에서 검증하면 되기 때문에 굳이 assert를 사용할 필요가 없으며, 논리적으로 허용되는 범위의 값인지 아닌지 검사하거나 작은 단위의 로직이 만들어낸 결과 값의 유효성을 판별하는데 사용된다. 그러나 동적 타입의 언어에서는 IDE가 타입을 올바로 추론하지 못하는 문제가 있기 때문에 타입을 검증하고 IDE에 타입을 알려 줄 때도 assert를 사용한다.

### assert의 역사

하드웨어 스펙이 좋지 않았던 과거의 컴퓨터 또는 임베디드 기기와 같은 제한적인 프로그래밍을 할 때에 런타임에서 예외를 처리하는 것은 많은 리소스를 소비했기 때문에 프로덕션의 런타임에서는 예외를 발생시키는 것 보다 프로그램의 작동을 멈추거나 그냥 버그를 발생시키는 편이 나은 경우가 있었다.

에외를 처리하기 위한 로직을 구비하는 것은 프로그램의 용량을 늘리고 런타임의 리소스를 더 사용한다. 따라서 가능한 개발할 때 조건의 설정을 통해서 허용되지 않는 스펙의 가능성의 값이 들어가는 것을 줄이되, 그럼에도 조건에서 설정한 범위 이외의 값이 전달되는 경우에는 버그를 발생시키던가 프로그램이 멈추던가 하는 편이 예외 발생 및 처리로 리소스를 소모하는 것 보다 나은 경우가 있었다. 이 때, `assert`를 사용하여 개발할 때의 문제를 확인하고 테스트 할 때 확인하지 못했던 일부 조건에 대해서 실제 프로덕션에서는 버그를 발생 시키는 쪽으로 개발을 했다.

### assert의 장점과 단점

#### 장점

어떤 기능에 대해 유효한 범위에 대한 각종 처리를 함수에 넣는 것 대신에 특정 조건에서만 성립하는 코드를 작성할 때 `assert`를 통해서 기능의 동작 범위를 표기할 수 있다. 지정한 범위 이외의 값이 전달될 때 개발 과정에서 에러를 포착할 수 있으므로 코드를 실행하는 과정에서 실수를 감지할 수 있다.

#### 단점

`assert`는 런타임에 확인하는 동작이므로 새로운 기능을 추가한 사람이 해당 로직에 대한 충분한 실행을 했을 때 감지할 수 있으며, 각종 케이스에 대한 동작 확인을 충분히 하지 않을 때가 있으므로 `assert`가 버그를 완전히 잡아준다는 기대를 할 수는 없다. 왜냐면 `assert`는 실제 환경에서는 무시되는 코드이기 때문에 개발 환경에서 충분한 경우의 수의 로직을 실행하지 못할 수도 있고, QA에서도 포착하지 못하는 케이스에 대해서 프로덕션 환경에서 동작이 이뤄질 수 있기 때문에 버그가 발생할 수 있다.

`assert`는 프로그램의 실행에 의해서만 조건을 판단할 수 있기 때문에 모든 케이스에 대해서 로직을 실행하지 않는다면, `assert`를 사용한다고 하더라도 개발 환경에서 에러를 감지하지 못할 경우가 생길 수 있다. 모든 케이스에 대한 실행은 때때로 불가능할 수 있기 때문에 `assert`가 있다고 해서 버그를 완전히 잡아 주는 것은 아니다.

### assert는 만능이 아니다.

어떤 사람이 어떤 로직에 대해 개발을 했다면 그가 짠 로직의 모든 케이스를 검증했다고 가정한다. 그렇다면 그 다음에 코드를 짜는 사람도 그 사람이 짠 모든 케이스에 대해 검증을 했다고 가정한다. 그런데 두 경우에서 공통적으로 사용하는 기능의 변경이 일어난 경우, 앞서 짠 로직의 코드는 코드 변경에 대해 충분한 검토가 이뤄지지 않게 된다. 이런 부분까지 `assert`가 확인해 주지는 않는다. `assert`는 단지 사람의 실수를 줄여줄 뿐이다.

다양한 케이스에 대해서 검증을 할 수 있는 테스트 코드가 있다면 `assert`는 버그의 원인을 찾는데 도움이 될 수 있다. (주의 : 테스트 코드에서 사용하는 `assert`와 현재 말하고 있는 `assert`는 약간 다르다. 로직의 인풋에 대한 아웃풋을 검증하는 테스트 코드와 달리 그냥 `assert`는 로직 내부의 코드가 실행 될 때의 값을 검증하는 것이다.)

### 프로덕션에서 확인하고 싶다면 에러를 사용하라

`assert`는 프로덕션 환경에서는 설정하지 않는데, 이는 `assert`라는 문법이 도입된 목적인 프로덕션 환경에서의 리소스를 소모하지 않기 위한 용도로 만들어졌기 때문이다. 프로덕션 환경에서 에러를 띄우려면 도입된 목적에 맞지 않는 `assert` 문법을 사용하지 않고, 커스텀 에러를 만들어 프로세스를 멈추면 된다.

또한 `assert`는 `php.ini`의 설정에 따라 에러를 발생시키도록 설정할 수도 있고, 에러를 발생시키지 않게 설정할 수도 있다. 이는 동일한 환경(프로덕션, 개발, 테스트, 로컬 환경을 의미) 프로젝트에 사용된 모든 `assert`의 기능을 변경하는 것으로, 일부 `assert`는 에러를 발생하게 하고 일부 `assert`는 에러를 발생하지 않도록 설정하게 만들어진 것이 아니다.

프로덕션 환경에서 무조건 `assert`를 통과하지 못했을 때 에러가 발생하도록 했다면 일부 케이스에 관해서는 에러가 발생하지 않도록 하고 싶어도 할 수 없기 때문에 프로덕션 환경에서 에러를 발생시키고자 하는 것은 `assert`가 아닌 커스텀 에러로 처리하는 것이 옳다.

#### 😠 잘못된 생각들

기본적으로 `assert`는 개발환경에서 사용하는 것을 기원으로 두지만, 어차피 특정한 입력을 전제로 하기 위해서 `assert`를 사용하는 것이라면 잘못된 값이 들어왔을 때는 실행되지 않아야 하므로 프로덕션 환경에서 `assert`를 활성화하여 에러를 발생시키자라는 생각을 할 수 있다.

언어에 따라 `assert`를 통과하지 않으면 프로세스를 종료하는 동작을 하기도 하며, 자바나 php의 경우는 `assert`가 에러를 던지는 동작을 하기도 한다. 보통 컴파일 언어는 속도를 중시하여 프로덕션에서 `assert`를 에러로 던지도록 활성화하지 않지만, php는 어차피 느린 언어라서 조금 느려도 큰 지장이 없는 비즈니스의 경우에는 `assert`를 사용해서 프로덕션에서 입력된 값을 검증하는 것이 나쁘지 않을까라는 생각을 할 수 있다.

또는 테스트 코드가 충분히 도입이 될 때까지 `assert`를 사용해서 임시적으로 로직의 결점을 찾아내는 방법이 있을 것이다. 테스트 코드의 도입이 충분히 이뤄지지 않은 경우라면, 트레픽이 많지 않은 서비스일 가능성이 높고, 이 경우 속도가 좀 느려도 괜찮은 경우가 있을 것이다. 서비스의 트레픽 정도 따라서 `assert`를 프로덕션에서 활성화 해도 괜찮을까라는 생각을 할 수 있다.

프로덕션에서 사용할 코드라면 굳이 `assert`라는 것을 사용할 필요가 없고 그냥 커스텀 에러를 만들면 된다. 하지만 `assert`가 커스텀 에러를 만들어 던지는 것에 비해 간결한 문법을 갖고 있기 때문에 `assert`가 커스텀 에러를 대체할 수 있을 거라 생각해 볼 수도 있을 것이다.

기본적으로 `assert`는 `catch`로 잡아서 처리하는 에러는 아니라 완전 프로세스를 정지한 후 이를 발생 시킨 로직의 원인을 찾아 코드를 수정해야 하는 에러이다. php에서는 `assert`를 통과하지 못했을 때 예외가 아닌 `AssertionError`라는 에러가 발생한다. 일반적으로 `catch` 문에 잡는 것은 예외인 `Exception` 류를 잡는데 `Error`가 발생했으므로 이에 유의하여 `catch` 문에 예외만을 포착하도록 잘 만들어 두었다면 에러를 캡쳐하지 않을 것이고 의도된 프로세스의 실행 중단에 이르므로 Assert가 커스텀 예외/에러를 대체할 수 있을 거라 생각할 수도 있을 것이다.

### php에서의 assert

[공식문서](https://www.php.net/manual/en/function.assert.php)에서는 다음과 같이 설명하고 있다.

> assert() allows for the definition of expectations: assertions that take effect in development and testing environments, but are optimised away to have zero cost in production.

> Assertions should be used as a debugging feature only. One use case for them is to act as sanity-checks for preconditions that should always be true and that if they aren't upheld this indicates some programming errors. Another use case is to ensure the presence of certain features like extension functions or certain system limits and features.

> As assertions can be configured to be eliminated, they should not be used for normal runtime operations like input parameter checks. As a rule of thumb code should behave as expected even if assertion checking is deactivated.

위의 내용을 요약하면
  1. assertion의 목적은 개발환경이나 테스팅환경에서는 적용되지만, 프로덕션 환경에서는 실행을 하지 않아 리소스를 소모하는 비용을 없애는 것에 있다.
  2. assertion은 디버깅용으로만 사용되어야 하며, 어떤 기능의 전제조건이 만족되지 않으면 에러를 발생시키는 목적 또는 어떤 기능을 실행하는데 필요한 확장 기능의 설치 및 활성화 여부, 시스템의 제약사항을 나타내는 용도로 사용된다.
  3. assertion은 제거되어도 런타임의 기능에 영향을 주지 않는 방식으로 사용되어야 한다.

곧, 시스템의 논리상 발생해서는 안 되는 케이스가 발생했을 때 이를 알리기 위해서 존재하는 기능으로, 정상적으로 동작하고 있다면 `assert` 부분이 실행되지 않을 것이므로 `assert`를 사용하든 사용하지 않든 동일하다는 것을 의미한다.

### 주석을 코드로 옮긴 개념

많은 경우 런타임에 발생할 수 있는 모든 케이스를 개발 환경에서 모두 테스트 할 수는 없을 것이다. 그로 인해서 `assert`가 있더라도 개발 환경에서 포착하지 못한 버그가 존재할 수 있다. 그렇기에 `assert`는 버그를 완전히 없애기 위한 용도로 사용되는 것이라고는 할 수 없다.

이런 불완전한 기능을 프로그래밍 언어의 문법으로 추가한 것은, 이 코드가 동작하기 위한 전제 조건 및 이러한 코드는 실행될 수 없다 등의 의미의 용도로서 런타임의 버그를 확실하게 잡겠다는 것이 아닌, 어떤 상황 조건 하에서 동작한다라는 주석을 코드화하여 표현한 것이라고 할 수 있다.

개발자는 `assert`를 읽고 해당 기능의 전제 조건 및 제약사항을 이해하고 그에 맞게 개발하는 것이며, 단순히 주석을 코드화한 것이므로 개발자에게 기능의 전제 조건 및 제약사항을 알리기 위한 용도일 뿐, 버그를 원천 차단하는 목적이 아니라는 것에 주의하자.

### 조건을 실행하는 코드를 assert에 전달하라

assert의 문법은 'assert(통과할_조건문, 통과_조건문이_실패했을_때의_에러_메시지)'로 구성되어 있다. 예외가 조건을 외부로 두고 조건에 따라 실행되는 코드에서 생성되는 것에 반해 assert는 조건식이 함수의 인자로 할당된다. 만약 조건식이 복잡한 경우 조건문을 assert 함수 밖에서 만들어 결과를 변수로 전달할 수 있을 것이다. 이렇게 되면 검증할 조건이 assert문 밖에 있으므로 실행되어 버린다. 프로덕션 환경에서 코드 실행 맥락과는 상관 없는 검증에만 사용되는 불필요한 코드를 실행하여 리소스를 소모하게 된다. 따라서 조건이 길어지는 경우 실행한 결과를 assert에 전달해서는 안되고 assert 문의 인자에서 조건을 실행할 수 있도록 함수를 만드는 편이 좋다.

### 예외나 에러로 assert를 대체할 수 없는 이유

예외나 에러를 설계하는 것은 번거로운 일이다. 예외와 에러는 꼭 만들어야 할 이유가 있을 때 만드는 것이고 특별히 만들어야 할 이유가 없을 때는 만들지도 사용하지도 않는 편이 낫다. 런타임에서 각종 조건을 확인하기 위해서 이런 저런 지저분한 코드를 넣기 보다는 `assert` 정도로 깔끔하게 조건만 파악할 수 있도록 코드를 작성하는 것이 유용하다.

에러나 예외는 단순히 어떤 양상이 발생하지 않도록 코드를 작성하는 것 뿐만 아니라, 발생한 에러나 예외를 잡아서 처리하는 해야 하는 방향성도 고려하게 만든다. 물론 에러의 경우에는 주로 잡아서 처리하는 방향을 생각하지 않지만, 예외는 잡아서 처리하는 방향을 때때로 고민해야 하는 대상이다. 하지만 `assert`는 확실히 조건만을 확인하기 위한 것으로 잡아서 처리할 대상은 명확하게 아니며, `AssertionError`는 발생하지 않도록 명확한 로직 설계 지침을 제시한다.

### 왜 Error이 아닌 Assert를 사용할까?

런타임에 동작을 멈추기 위한 동작으로는 에러를 사용하거나 전역 예외를 사용하는 방법이 있다.

전역 예외를 사용하는 방법은 `Exception` 클래스를 하위 클래스를 정의하지 않고 그냥 그대로 사용하는 것이다. 전역 에외를 일으키는 `Exception` 클래스의 인스턴스는 `catch` 문에서는 `Exception`의 하위 타입을 사용하며 `Exception` 클래스를 그대로 잡지 않는 코딩 방식을 사용하기 때문에 `catch` 문에서 잡지 않는 `Exception` 클래스를 이용해서 처리를 멈추는 스타일의 코딩을 할 수 있다. 하지만 예외는 잡아서 처리를 하거나 예외가 발생하지 않는 로직을 만들어 사용하는 것이며, 에러는 발생해서는 안 되는 상황이 잘못되 로직으로 발생했다는 것을 알려주기 위해 사용한다.

에러와 assert의 근본적인 차이점은 프로덕션 환경에서 실행을 할 것인지 실행을 하지 않을 것인지의 차이점도 있지만, 프로덕션에서 삭제해도 되는 로직을 assert로 처리하여 누가 봐도 이러한 값은 들어오지 않을 거라고 생각하는 부분에서 그냥 아무런 전제 조건 없이 두는 것 보다는 assert를 사용해서 실행의 전제 조건을 명확하게 하여 주석을 대체하는 효과를 만들기에 적합하다는 이점도 있다.

어떤 기능을 개발할 때 assert로 전제 조건을 지정하여 해당 범위에서만 개발을 하고, 해당 기능 뿐만 아니라 맥락적으로 해당 부분의 고려하여 확실히 멈춰야 하는 경우 특별한 에러 케이스를 만드는 것이 올바른 경우 에러를 사용할 수 있다.

### assert로 주석을 대체하기

큰 규모의 프로그램을 짤 경우에는 개발자가 전체적인 흐름을 이해하지 못하는 경우가 생길 수 있다. 특정 부분에서의 코드를 작성하는데 확실하게 에러로 멈추게 해야하는 코드인지 확신이 없는 경우, 개인적으로는 이렇게 전제 조건을 두고 코드를 짰어라고 표시해 둘 때 Assert를 사용할 수 있다.

전제를 두고 짠 것이기 때문에 만약 좀 더 거시적인 관점에서 속해 있는 기능의 전제 조건이 가정하는 범위를 넓히거나 좁히면서 기능을 수정할 수도 있고, assert로 가정한 전제 조건이 옳아라는 확신이 생겼을 때 에러나 좀 더 세분화된 타입을 사용한 코드로 바꿀 수도 있을 것이다. 코드 리뷰 등을 통해서 코드를 짠 사람이 가정한 assert에 대해서 검토자는 코드를 짠 사람이 가정한 생각이 올바른지 그른지 조언을 해 줄 수도 있다.

### Error를 사용해야 할 때

assert와 error의 명확한 차이점은 프로덕션에서 처리를 멈출 것인지 멈추지 않을 것인지 확인하기 위한 용도에 있다. 테스트코드가 구비되지 않았거나 다양한 분기 처리나 복잡한 전제 조건이 필요해서 충분한 동작 검증이 부족한 프로젝트에서는 실제 데이터를 통해서 검증을 할 수 밖에 없는 경우가 있다. 이런 경우에는 프로덕션에서 에러를 발생시켜 개발자는 에러를 보고 받고 이를 개선하는 코드를 짜는 방법을 사용할 수 있다. 하지만, 테스트 코드가 구비되어 있고, 다양한 분기 처리 및 복잡한 전제 조건의 설정이 가능해서 충분히 검증할 수 있는 경우에는 프로덕션에서 리소스를 소비하는 에러 대신 assert를 쓰는 것이 나을 수도 있다.

처리가 올바르게 일어날지 확신을 할 수 없는 라이브러리나 코드를 사용할 때, 또는 외부에서 주어지는 데이터의 사양이 명확하지 않을 때, 프로덕션에서 직접 실행을 해서 확인을 해야 할 경우가 있을 수 있다. 이런 경우 에러를 발생을 시켜 개발자가 미처 예상하지 못한 케이스에 대한 처리를 하고 싶은 경우 프로덕션의 데이터를 이용해야 하므로 assert는 사용할 수 없고 Error롤 처리할 수 밖에 없는 부분이 존재할 수 있다.
