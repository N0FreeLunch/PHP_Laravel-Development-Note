## swoole에서의 코루틴
- 코루틴은 스레드와 비슷한 동작 방식을 가지는 것으로 봐도 된다. 하지만 스레드 보다는 훨씬 경량화 된 대상이다. 
- 하나의 프로세스가 스레드에 할당하고 해제하는 과정 또는 복수의 프로세스 간의 컨텍스트 스위칭을 위해 OS가 스케쥴링 하는 비용에 비해 코루틴의 생성, 파괴, 전환 비용은 OS가 전혀 관여하지 않기 때문에 매우 낮다.
- 스레드는 CPU의 스레드 별로 할당이 되는 방식을 가지고 있는 반면, 코루틴은 필요할 때 마다 스레드를 사용한다. 스레드 할당 방식은 스레드를 점유하면 다른 스레드가 점유된 스레드의 자원을 획득할 수 없는 비선점 구조인 것에 반해, 코루틴은 스레드를 점유하지 않고 필요할 때마다 사용하기 때문에 비선점 멀티태스킹 방식이라고 불린다. 선점형이 아니기 때문에 하드웨어 스레드 자원을 더욱 스레드 방식 보다 더 효율적으로 사용할 수 있다.
- 코루틴은 유저 공간(user space : 프로그래밍으로 프로세스 내에서의 실행을 유저가 정의한다는 의미)에서 작동한다. 코루틴은 프로세스 내에서 형성되는 것이기 때문에 하나의 루틴이 여러개의 스레드를 사용할 수는 없다. 오히려 하나의 스레드를 시간에 따라 잘게 나눠 사용한다. 하지만 병렬 프로그래밍을 가능하게 하기 위해서 다중 프로세스 모델을 제공한다.

## 코루틴의 원리
- 코루틴은 특정 프로세스를 중단하고 재개하는 기능을 가지고 있다. 코루틴이 중단되었을 경우 다시 재개 가능한 대상이다.
- 코루틴의 중단은 루틴이 I/O 작업과 같은 요청을 통해 작업의 반환을 기다릴 때 일어난다.
- 일반적인 순차적 실행과는 달리 코루틴을 사용하면 작업의 반환을 기다릴 때, 다른 코루틴이 CPU 자원을 사용하는 처리를 실행하도록 구성되어 있다.
- 코루틴의 반환 대기 상태에 다른 코루틴이 시스템의 리소스를 소모하는 작업을 하도록 대체되기 때문에 하나의 루틴의 작업이 끝나기 전에 다른 루틴의 작업도 같이 실행되어 동시성 상태가 이뤄진다.

## swoole에서 코루틴
- swoole 서버는 들어오는 리퀘스트에 대해서 하나의 코루틴을 형성한다. I/O 상태에 따라 반환 대기 상태인 코루틴을 반환 대기 상태가 아닌 다른 코루틴으로 전환한다.

## 왜 코루틴인가?
- 기존의 동기식 PHP 코드를 작성해도 swoole 서버가 코루틴의 스위칭을 해 주기 때문에 함수형과 같은 특별한 코드의 변화, 설정 없이도 I/O 반환 대기 시간에 시스템 자원을 최대한 사용하게 할 수 있다.
- 코루틴 방식은 동기식으로 작성하면 되기 때문에 콜백지옥을 피할 수 있다. (콜백 안에 콜백, 그 안의 콜백, 그 안의 콜백...)

## swoole 코루틴과 php 코어의 코루틴
- php 코어는 yield/generator 코루틴 문법을 제공한다. 이 또한 코루틴을 중단 시킬 수 있고 다시 재개 시킬 수 있다.
- 하지만 yield/generator는 I/O 반환 대기 상황에서 자동적으로 다른 작업으로 전환 되는 원리는 아니다. 코드 작성하면서 타 작업 전환을 할 수 있게 할 수 있을지는 몰라도 (확인이 필요) swoole 코루틴은 자동적으로 수 많은 반환 대기 상태에서 자동적으로 전환 되기 때문에 서버 프로그래밍에서 효율이 압도적이다. (생산성, 편의성, 가독성 등등)
- swoole은 HTTP 서버, HTTP 클라이언트, MySQL 클라이언트, Redis 클라이언트 등 코루틴 방식으로 동작하는 코루틴 클라이언트를 제공한다.

## 코루틴의 기본 예제
```
<?php
Co\run(function()
{
    go(function()
    {
        Co::sleep(1);
        echo "Done 1\n";
    });

    go(function()
    {
        Co::sleep(1);
        echo "Done 2\n";
    });
});
```
- go 함수는 코루틴을 실행하는 생성하는 함수이다. 위의 예제는 go함수를 2개 사용했기 때문에 2개의 코루틴을 만든 것.
- go 함수는 익명함수를 인자로 받으며 익명함수 내부에 코루틴의 로직을 동기식으로 작성한다.
- `Co::sleep(1)`는 php의 sleep() 함수와는 다르다. php의 sleep 함수는 php 프로세스의 코드 실행 자체를 잠시 멈추는 것인데 프로세스 내의 여러 코루틴이 반환 대기 상태일 때 서로 프로세서를 할당받기 위해서는 php의 sleep() 함수를 사용하면 안 되기 때문에 `Co::sleep()`이라는 코루틴의 실행을 지정한 시간동안 멈추는 코루틴용 sleep 함수를 만든 것.
- 위의 코드를 실행하면 콘솔 창에 찍히는 `Done 1` 과 `Done 2`의 순서가 매번 다르게 나올 것 (확인 필요)

## 코루틴 실행 컨텍스트
- `Co\run`함수는 swoole 코루틴의 실행 컨텍스트를 설정하는 역할을 한다.
- `Co\run`을 사용하지 않더라도 코루틴 컨텍스트는 콜백 함수 request, receive, Swoole\Server, Swoole\HTTP\Server로 생성되므로 해당 콜백 내에서 바로 코루틴 사용할 수 있다.
- 서버 환경의 실행 컨텍스트가 없을 경우 사용하는 것이 `Co\run`라는 코루틴 실행 컨텍스트이다.
- 코루틴 실행 컨텍스트는 중첩해서 사용할 수 없다. 

## chennel
- 서로 다른 코루틴은 동일한 메모리 공간에 엑세스 할 수 있다. 하지만, 코루틴의 실행은 예측할 수 없는 순서를 가지고 있다. 메모리의 데이터 접근에 대한 섬세한 컨트롤을 하기 힘든 환경인 것.
- 채널은 코루틴끼리의 메모리 충돌 문제를 해결하기 위해 나온 개념이다. 채널은 2개 이상의 코루틴 간의 데이터 교환을 위한 도구이다.
- 

## Reference
- https://openswoole.com/docs/modules/swoole-coroutine
