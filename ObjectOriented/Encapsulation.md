## 객체란 무엇인가?
- 주인과 개의 관계를 떠올려 보자.
- 이 관계에서 주인이란 객체가 있고, 개라는 객체가 있다.
- 객체 간에는 상호작용이 일어난다.

## 상호작용
- 주인이 '앉아'라고 말하면 개는 앉는다.
- 주인이 인형을 던지면 개는 물어온다.
- 주인이 개를 데리고 산책을 나가면 개는 알아서 걷는다.

### 주인이 개에 대해 알 필요가 없는 것
-  앉아라는 소리를 듣고 뇌가 이를 신경에서 처리해서 뇌의 판단을 통해서 근육의 움직임을 조절 하는 것
-  주인이 인형을 던질 때, 개가 달려나가고 개가 물어 오는 과정은 알 필요가 없다.
-  개를 데리고 산택을 나갈 때, 개가 어떻게 4족 보행을 하는지 균형을 어떻게 유지하고 걷는지 개는 알 필요가 없다.

## 외부에서 객체를 바라볼 때
- 주인과 개의 상호작용에서 주인은 개에게 명령을 내릴 뿐 개의 몸에서 일어나는 수 많은 움직임이 어떻게 일어나는지 주인은 알 필요가 없다.
- 개와 주인간의 상호 작용에서 주인이 개에게 근육의 움직임 뇌의 판단 신경의 전달을 세세하게 정의할 필요가 없고 개에게 명령만 전달하면 된다.
- 외부에서 객체를 바라볼 때 객체에게 명하는 명령만 알면 객체와의 상호작용이 이뤄지며 객체 내부에서 일어나는 동작은 몰라도 객체에 명령하기만 하면 객체로부터 원하는 것을 얻을 수 있다.
- 프로그래밍 언어에서의 객체도 조작할 수 있도록 제공되는 퍼블릭 메소드로 명령만 내리면 되고 명령의 동작을 위해 객체 내부에서 이뤄지는 코드에 대해서는 구체적으로 어떻게 동작하는지 몰라도 된다.
- 이를 통해 객체의 중요한 특징을 알 수 있는데 객체는 객체를 사용할 수 있는 명령과 해당 명령을 수행하기 위해 외부에 공개하지 않아도 되는 내부 동작으로 이뤄져 있다는 것이다.

## 캡슐화의 두 가지 요소
- 인터페이스
- 정보 은닉

## 인터페이스란?
- 여기서 말하는 인터페이스는 OOP 언어의 문법 인터페이스를 의미하지는 않는다.
- 인터페이스란 객체 간의 상호작용을 정의하는 규약을 의미한다.
- 인터페이스의 구성은 일반적으로 지시와 결과로 이뤄진다.

### 인터페이스의 예시
- 주인이 '앉아'라고 했을 때 개가 앉는 것이 인터페이스이다.
- 주인이 인형을 던졌을 때, 개가 인형을 물어 오는 것이 인터페이스이다.
- 주인이 개를 데이고 산책을 나갔을 때, 알아서 걸어서 따라오는 것이 인터페이스이다.

### 인터페이스는 객체를 향한 명령이다.
- 개라는 객체는 '앉아'라는 명령을 수행하여 앉는 동작을 취한다.
- 개라는 객체는 '주인 반경 X미터 안의 임의의 지점으로 인형을 던진다'라는 명령을 수행하여 해당 지점으로 달려가서 인형을 물어서 주인에게 가져온다.
- 개라는 객체는 'N미터의 목줄을 하고 산책한다.'라는 명령을 수행하여 주인의 위치가 변함에 따라서 주인 주변 반경 N 미터 내에 위치하게 된다.

## 정보은닉이란?
- 객체 내부에서 일어나는 일으로 외부 객체가 알 필요가 없는 것이다.
- 주인은 개 내부에 일어나는 일에 대해 알 필요가 없으며 개는 주인의 명령에 따라 내부적으로 알아서 처리 하는 움직임이 정보은닉이다.

### 정보은닉의 예시
- 주인의 '앉아'라는 말을 귀로 듣고 뇌가 인지해서 뇌가 근육의 움직임을 조절해서 앉는 행동을 만드는 개 내부의 과정
- 주인이 인형을 던질 때, 개가 인형을 던진 위치를 눈으로 보고 뇌가 위치를 가늠하고 근육을 움직이고 달려나가서 인형을 물어 주인의 위치로 오는 개가 판단해서 일어나는 모든 개 내부의 움직임
- 주인이 개를 데리고 산책을 나갈 때, 4족 보행 균형을 맞춰서 이동하는 과정으로 주인이 이끄는 위치대로 걷기 위해 개의 소뇌가 균형을 유지하기 위해 처리를 하는 과정 각 근육들을 조절하는 과정

## OOP 언어로 캡슐화 구현 해 보기
```php
class Dog
{
  protected bool $sitStatus = false;
  protected int $positionX;
  protected int $positionY;
  protected Target $target;
  protected bool $biteingTargetFlag = false;
  
  public function sit(): void
  {
    $this->sitStatus = true;
  }
  
  public function isSit(): bool
  {
    return $this->sitStatus;
  }
  
  public function standUp(): void
  {
    $this->sitStatus = false;
  }
  
  public function setTarget(Target $target): self
  {
    $this->target = $target;
    return $this;
  }
  
  public function bringTo(Owner $owner): Target
  {
    $this->moveTo($this->target->positoinX, $this->target->positoinY);
    $this->biteingTargetFlag = true;
    $this->moveTo($owner->positoinX, $owner->positionY);
    return $target;
  }
  
  public function getStatuses(): array
  {
    return [
      'sit_flag' => $this->sitStatus,
      'x_position' => $this->positionX,
      'y_position' => $this->positionY,
      'target' => $this->target
    ];
  }
}
```

### '앉아' 명령의 예
```php
$this->dog->sit();
```
- `$dog` 객체에 앉으라는 상태를 명령하였다.
- `$dog` 객체를 이용하는 사람은 `$sitStatus`의 변수가 어떻게 변했는지 알 필요는 없다.
- `isSit` 메소드 또는 `getStatuses` 메소드를 통해서 개가 앉아 있는지 아닌지 확인하면 된다.

### 공을 던지는 명령의 예
```php
public function throwItem($ballObj)
{
  $ballObj->setRandomDirection()->setDistance(50)->move();
  $this->dog->setTarget($ballObj)->bringTo($this);
}
```
- 주인이 던진 공을 개가 가져오는 명령을 내려보자. 주인 객체는 `throwItem` 메소드를 통해서 던지는 공을 던지는 명령을 내린다.
- 이는 개에게 있어 던진 공을 물고 주인의 위치로 가져오라는 지시이기도 하다. 따라서 `throwItem` 메소드는 개가 공을 가지고 `setTarget($ballObj)` 주인의 위치로 이동 `bringTo($this)` 시키는 동작을 하게 된다.
- 이때 `$dog` 객체가 가지고 있는 타겟은 `$ballObj`가 되고, 공을 가지고 주인에게 오게 되기 때문에 `$dog` 개체의 위치정보가 주인의 위치로 이동하게 된다.
- 주인이 개의 동작을 지시할 때 주인 객체의 `throwItem` 메소드 내부의 동작이 어떻게 일어나는지 알 필요가 없다. `$ownerObj->throwItem($ballObj);`으로 주인 객체는 공을 던지라는 명령만을 내리면 된다.
- 또한 개의 동작을 지시할 때도 타겟과 주인 객체만을 지정하였다. 주인은 개에게 가져오라는 명령만 내리면 되며 개의 위치가 어떻게 변하는지 신경을 쓰지 않아도 된다.

## OOP 언어의 문법적인 특징
### 인터페이스
- 인터페이스는 객체를 사용하는 사용설명서이다.
- 객체는 객체 내부의 퍼블릭 메소드의 조합으로 사용할 수 있어야 한다. 객체의 퍼블릭 메소드에 적절한 인풋값을 넣으면 인풋 값에 대한 결과 값을 알 수 있다는 것이 인터페이스의 본질이다.
- 객체를 사용하는 것이 인터페이스의 본질이기 때문에 문법적인 인터페이스는 public 메소드만으로 구성된다.
- 문법적인 인터페이스는 명령과 명령을 지시하기 위한 인자의 종류를 정하고 해당 명령의 결과가 나타내는 값의 종류를 알려준다. 이를 위해 OOP 언어에서 인터페이스는 퍼블릭 메소드와 인자의 타입 리턴 타입을 사용할 수 있도록 만들어진 졌다.
- 문법적인 인터페이스는 퍼블릭 메소드의 형태를 문법적으로 제약하는 역할을 한다. 문법적인 인터페이스는 객체를 만들 때 반드시 필요하지는 않다.

### 정보은닉
- 객체에서 외부에서 사용할 메소드와 내부에서 처리할 메소드를 public 메소드와 private/protected 메소드로 구분한다.
- private 또는 protected 메소드는 내부 처리를 위해 사용한며 public 메소드는 객체의 외부에서 객체를 다루기 위해 제공되는 기능이다.

## 의미론적 프로그래밍
### 단순성
- 인터페이스는 객체의 사용설명서이기 때문에 인터페이스를 정의할 때는 객체를 어떻게 사용하는지 알 수 있도록 의미를 나타내도록 메소드의 명칭을 정의하는 것이 중요하다.
- 객체를 사용하는 입장에서는 개에게 타겟을 지정하고 가져와라고 명령을 하면 충분하다. 개의 움직임에 대한 세부 사항을 모두 일일이 지정하지 않아도 된다. 인터페이스는 사용설명서이기 때문에 사용법은 단순한 편이 좋다. 개가 공을 물어오기까지의 과정을 일일이 하나씩 기술한다면 객체의 사용법이 복잡해지므로 단순한 명령으로 나타내는 것이 좋다. 개가 공을 물어 오기까지의 세부적인 절차는 정보 은닉을 통해서 객체 내부로 감추도록 하자.
- 단어가 모이면 문장이 된다. 문장은 하나하나가 가진 뜻 뿐만 아닌 새로운 의미를 제공한다. 인형을 바라보고, 인형을 향해 달려가고, 인형을 물고, 다시 주인에게 달려오는 개의 행동은 '인형을 가져온다'라는 한 마디 말로 표현이 가능하다. 여러 구체적인 과정의 기술없이 단순한 표현만으로 해당 과정을 설명할 수 있는 것이 의미론이 가지는 힘이다. 의미론적인 단순화는 객체의 행동을 단순하게 표현 객체를 좀 더 사용하기 쉽게 하기 위한 방법이다.
- 객체를 만든다는 것은 객체에 대한 사용 설명서를 퍼블릭 메소드로 만든다는 의미를 가지고 있다. 퍼블릭 메소드로 제공될 것은 직관적으로 어떤 메소드를 사용할 것인지 알게 하는 것이 필요하다.

### 조합성
- 메소드가 여러 인자를 가지게 되면 메소드의 역할을 직관적으로 이해하기 어렵고 인자의 순서도 헷갈리기 쉽다. 따라서 여러개의 인자를 받아야 한다면 여러 메소드로 분리해서 이를 받는 것이 좋다.
- 주인이 공을 던지는 행동을 할 때 개에게 타겟을 지정해 주고 가져와라는 동작을 시켰다. `$this->dog->setTarget($ballObj)->bringTo($this);` 여러개의 메소드가 모여 던진다는 의미를 형성하고 있는 것이다.
- 단어와 단어를 엮어서 문장을 만들어 내듯이 메소드와 메소드를 엮어서 객체로 하여금 결과를 만들어 내는 것이 프로그래밍이다. 메소드들의 조합으로 하나의 의미를 형성해 낼 수 있도록 메소드를 정의하도록 하자.

### 프로그래밍은 글쓰기이다.
- 프로그래밍은 글쓰기라고 생각한다. 객체지향은 글을 쓰기 위한 단어를 정의하고 문장을 정의하는데 탁월한 도구를 제공한다.
- 마치 글을 읽듯이 읽어 내려 갈 수 있는 프로그래밍이야 말로 가독성이 좋고 이해하기 쉽고 관리하기 쉬운 코드를 만들어 낼 수 있다.
- 객체와 메소드의 조합으로 코드로 표현하는 멋진 글을 써 보자.

## 도메인 주도 설계
- 도메인 주도설계의 핵심은 유비쿼터스 언어를 만드는 것이다.
- 유비쿼터스 언어란 컴퓨터 시스템을 설계하기 위해서 비즈니스 영역의 로직을 논리적인 관계가 맞아들어가도록 구체적으로 하나하나 잘 풀어 설명한 것이다.
- 객체 지향을 통해서 유비쿼터스 언어에 대응하는 객체와 메소드들을 만들고 이를 엮어서 프로그램을 만드는 것이 도메인 주도 설계이다.
- 객체지향의 캡슐화와 의미론적 프로그래밍에 대한 이해는 도메인 주도 설계를 만들어나가는 기초 개념을 만들어 줄 것이다.
