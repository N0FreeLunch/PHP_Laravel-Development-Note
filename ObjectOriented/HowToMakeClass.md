## 어떻게 클래스를 만들 것인가?
- 클래스를 만들 때의 가장 큰 문제점은 클래스는 다양한 방식으로 퍼블릭 메소드를 만들 수 있기 때문에 클래스가 제공하는 퍼블릭 메소드를 어떻게 조합해서 사용해야 할지 알 수 없다면 클래스를 만드는 이점이 크지 않을 수 있다.
- 프로그래밍에서 추상화를 하는 것은 코드를 관리하기 쉽게 만들기 위한 것이다. 관리하기 쉬운 코드란 코드의 동작을 쉽게 이해할 수 있는 코드를 의미한다. 클래스를 만드는 것으로 동작을 이해하기 쉽게 하기 위한 방법은 클래스의 이름과 퍼블릭 메소드를 어떻게 짓느냐가 중요하다. 어떤 목적을 위해 클래스가 사용되는지를 나타낼 수 있는 이름을 클래스명으로 하고, 목적을 수행하기 위한 일련의 과정을 퍼블릭 메소드로 나타낼 수 있어야 코드가 어떻게 동작하는지 알 수 있다.

### 책임의 범위를 줄이기
- 클래스는 이름을 갖는 순간 책임의 범위를 결정하게 된다. 클래스 이름을 넓은 범위의 역할을 담당하는 것으로 짓는 순간, 메소드는 어떤 목적을 위해 연결되어야 하는 일련의 과정이 아닌, A라는 기능을 실행하기 위해서는 어떤 메소드 조합을, B라는 기능을 실행하기 위해서는 어떤 메소드 조합을, C라는 기능을 실행하기 위해서는 어떤 메소드 조합을 사용하도록 하면서 하나의 클래스가 갖는 메소드가 목적에 따라 쓰이고 안 쓰이고 하는 메소드가 중구난방으로 생겨나면서 클래스의 퍼블릭 메소드만 보았을 때는 어떤 메소드를 조합해야 하는지 알 수 없게 만드는 경우가 생길 수 있다. 따라서 클래스는 하나의 목적을 위해서 요구되는 메소드들의 조합으로 만들어질 수 있도록 책임의 범위 최대한 줄이는 방식으로 만드는 것이 중요하다.

### 클래스와 함수
- 책임의 범위를 줄여나가다 보면, 함수와 클래스의 차이가 없는 것이 아닌가? 라고 생각할 수도 있다. 함수는 함수의 인자를 통해서 조건에 해당하는 값을 전달 받고, 클래스는 클래스의 생성자의 인자나 메소드를 통해서 조건에 해당하는 값을 전달 받고, 해당 조건에 따른 어떤 기능을 수행하기 때문이다.
- 함수를 사용하지 않고 객체를 사용하는 이유는 함수의 경우 기본적으로 인자를 순서대로 할당해야 했기 때문이다. 특정 인자를 스킵하고 싶더라도 할당을 해 주어야 하므로 인자를 할당하는 과정에서 생각하지 않아야 하는 것을 생각하게 만들도록 한다는 문제점이 있다. 또한 함수의 파라메터가 늘어날 수록 할당해야 하는 인자의 수도 늘어나기 때문에 순서상 나중에 할당해야 하는 인자가 있다면 스킵할 수 없기 때문에 불편함이 생긴다. 이에 반해 객체는 메소드를 갖고 있고, 메소드를 통해서 인자를 할당한다. 객체를 사용하는 쪽에서는 메소드의 이름을 기술해야 하므로 무엇을 할당해야 하는지 알 수 있게 해 주고, 하나의 메소드로 할당할 수 있는 인자들의 묶음을 통해서 할당할 인자간의 연관성을 생각할 수 있게 해 준다.
- 요즘에는 함수도 명명된 인수(Named Arguments)를 통해서 함수의 동작에 필요한 값을 마치 메소드처럼 순서를 바꾸어 값을 받을 수도 있고, 메소드를 기술하는 것 처럼 파라메터명을 기술할 수 있다. 따라서 함수를 마치 클래스와 같은 방식으로 사용할 수 있다. 또한 하나의 인자가 오브젝트 또는 배열을 통해서 값의 묶음을 전달 받을 수도 있다. JS나 TS를 사용하는 경우 리터럴 오브젝트를 인자로 할당하는 방식의 코딩 스타일을 사용하여 리터럴 오브젝트의 키에 값을 매핑하여 전달하는 것을 통해 명명된 인수(Named Arguments)와 유사한 개념을 사용할 수 있고, 여러 파라메터를 리터럴 오브젝트를 할당하는 방식을 통해서 서로 연관성 있는 데이터를 묶어 처리할 수 있다. 함수의 인자를 세팅하는 것을 통해서 객체의 메소드를 대체하는 코딩 스타일을 보여주기도 한다.

### 함수와 객체의 상태
- 객체는 상태라는 것을 저장할 수 있는 특성을 가졌다. 퍼블릭 메소드의 실행에 따라 그에 따른 내부 멤버 값의 변경이 일어나게 되고 해당 객체를 복사하면 동일한 상태의 객체를 얻을 수 있고 특정 상태를 기준으로 로직을 전개할 수 있다는 장점이 있다. 그런데 함수도 함수형 프로그래밍을 사용하게 되면, 함수가 커링을 통해서 인자를 머금고 있는 상태를 만들 수 있다. 커링된 함수는 평가 되기 전에 상태라는 것을 가지게 되고 이를 통해서 특정 상태를 기준으로 로직을 전개할 수 있다.

### 엑션의 반복
- 함수는 평가가 되지 않았다면 커링을 통해서 상태를 저장할 수 있지만, 한 번 평가되면 결과 값이 반환되기 때문에 엑션의 반복이 일어날 수 없다. 하지만 객체의 메소드는 사용을 했더라도 다시 사용할 수 있는 경우도 있고, 다른 메소드로 사용하여 또 다른 반환 값을 얻을 수도 있다. 하지만 함수는 한 번 평가가 되면 결과 값이 반환 되거나 실행이 완료 되므로 반복적으로 사용할 수 없다. 물론 어떤 특정 상태로 커링된 함수를 복사하여 평가하는 방식으로 재사용을 할 수 있겠지만, 객체가 메소드를 다시 실행하면 되는 것에 반해 특정 상태의 함수를 캡쳐를 해야 하고 이를 재사용할 수 있도록 코드를 추가 해 줘야 한다는 불편함이 있다.

### 엑션의 다양성
- 객체는 메소드의 결과를 얻고 나서도 객체의 메소드를 새롭게 호출하는 것을 통해서 새로운 엑션을 사용할 수 있다. 하지만 함수는 평가가 끝나면 더이상 무언가를 할 수 없다. 객체는 멤버의 상태 변화를 유도하는 메서드와 엑션 메소드를 사용해서 서로 다른 상태에서의 엑션을 게속 만들어낼 수 있지만, 함수는 한 번 커링되었다면 다른 상태 값으로 바꾸지 못한다는 단점이 있다. 객체는 계속적인 상태 변화에 따른 엑션을 구성하는데 도움이 된다.

### 단일 엑션 클래스
- 단일 엑션 클래스라는 것은, 객체의 상태에 관여하는 여러 요인들을 메소드를 통해서 받지만, 상태가 세팅이 되고 나서 객체를 통해서 실현하고자 하는 목적 로직을 담당하는 메소드는 하나인 경우를 의미한다.
- 단일 엑션 클래스를 만드는 것은 객체가 하려는 목적의 범위를 최소화하여 객체의 퍼블릭 메소드를 하나의 목적을 위해 존재하는 것으로 생각할 수 있기 때문에 좀 더 객체의 사용법을 쉽게 유추할 수 있게 해 준다.
- 무조건 단일 엑션 클래스를 만드는 원칙을 만들자는 것은 아니다. 클래스의 사용법을 최대한 알기 쉽게 하기 위해서 단일 엑션을 위주로 클래스를 설계를 하되, 클래스의 어떤 특정 조건에서의 상태를 확인하는 메소드들은 추가 될 수 있다. 곧, 핵심 로직을 담당하는 기능은 클래스에 하나만 만들고, 부수적인 로직을 담당하는 엑션을 추가로 만드는 방식을 사용한다. 이를 통해서 클래스의 복잡성을 줄일 수 있다.

### 단일 엑션이라면 함수와 같은가?
- 단일 엑션 클래스는 객체의 상태를 전달 받는 여러 메소드와 객체의 핵심 로직을 표현하는 하나의 메소드로 구성된다. 이는 여러 인자를 파라메터를 통해서 받아 상태를 구성하고 하나의 평가 결과를 갖는 함수로 대체할 수 있다. 그럼에도 단일 엑션 함수를 만들어야 할까?라는 생각을 할 수 있다.
- 이는 언어가 제공하는 문법적인 특징에 따라 달라질 수 있다. 커링을 통해서 상태를 자유롭게 구성하기 편한 언어의 경우 단일 엑션 클래스 대신 함수로 단일 엑션 클래스를 대체할 수 있다.
- 일반적으로 함수는 함수의 이름이 붙여진 정도의 기능만을 가지는 것이 좋은데, 이는 함수의 이름으로 함수가 하고자 하는 로직이 어떤 것인지 명료하게 알 수 있게 하기 때문이다. 또한 함수의 파라메터 수가 많아지는 것을 추천하지 않는데, 이는 함수의 복잡성을 증가시키기 때문이다. 함수형 언어에서 함수를 컴포지션 하는 것도 하나의 거대한 함수를 만드는 것 보다는 의미가 명료한 작은 함수를 나열하여 컴포지션 하는 것이 더 알기 쉽기 때문이다.
- 명명된 인자가 언어에 도입되지 않았다면, 함수를 사용할 때 인자가 많다는 것은 함수를 사용한 맥락에서 파라메터로 어떤 값을 어떤 목적으로 받는지를 드러내지 않기 때문에 함수의 의미를 이해하기 어렵게 한다. 따라서 함수의 파라메터가 늘어나는 경우 클래스로 만드는 것을 고려하는 것을 보통 추천한다.
- 함수가 클래스의 역할을 대신할 수 있다고 해서 함수로 대체하는 것은 좋지 않은데 함수는 앞서 설명했듯이 로직의 간결성을 추구하기 때문이다. 로직이 비대해지면 함수가 아닌 클래스를 만들라고 하는 것은 클래스의 메소드을 통해서 값을 전달 받을 값과 그 목적을 밝힐 수 있으며 이를 통해서 로직이 비대해지더라도 그 의미를 메소드의 서술을 통해서 알 수 있기 때문이다.
- 함수로 처리할 것이 비대해진다면 클래스를 사용하는 것으로, 단일 엑션을 가진 함수를 확장하는 클래스라면 이 클래스도 단일 엑션을 가지는 것은 자연스런 일이다. 함수의 비대함을 방지하기 위해 클래스를 사용하며, 구조상 함수를 조합할 수 있는 단위로 쪼개거나 클래스로 리펙토링하기 어려운 상황에서 명명된 인자를 사용하여 함수의 파라메터에 무엇을 어떤 목적으로 할당할지를 명확히하여 데이터를 처리하는 방법을 사용할 수 있다.

### php의 경우
- php의 경우에는 명명된 인자를 사용하기 보다는 메소드로 값을 받는 것이 좋은데 이는 한 번에 받아야 할 값을 묶음으로 받을 경우에는 묶을 수 있기 때문이다. php는 함수의 인자로 묶음 데이터를 전달할 때는 타입힌트를 적용하기 까다로운 문제가 있다. 배열을 사용해서 전달할 수도 있지만, 별도의 클래스로 함수의 파라메터 타입을 주어 여러 인자를 받는 것은 지나친 보일러플레이트를 유발한다. php에서 값을 전달하는데 있어 배열이 좋은 선택은 아니다. 함수는 재사용을 위한 목적이 있다. 재사용을 하기 위해서는 파라메터로 받는 값을 정확히 받아야 하는데, 배열에는 여러 종류의 타입을 자유롭게 할당할 수 있기 때문에 함수가 재사용될 때 잘못된 값이 할당될 수 있는 문제가 있다. 따라서 객체의 메소드를 사용해서 데이터를 묶어 받는 것이 좋다.

### 객체를 사용해야 할까?
- 객체를 사용하는 대표적인 분야는 게임인데, 게임은 유저의 조작을 통해서 객체의 인터페이스를 통해서 상태를 변경하고 그에 따른 행동을 보여주기 때문이다. 엑션을 반복할 수도 있고 엑션을 다양하게 사용할 수도 있다.

### 클래스가 변경 될 때를 생각하기
- 도메인의 변화 또는 더 적절한 이름이나 조작 방식의 등장 또는 발견에 맞춰 클래스의 기능을 변경하는 경우도 있으며, 어떤 기능을 좀 더 확장 하거나 버그 수정이나 개념을 쪼개는 등의 리펙토링을 해야 하는 경우도 있다. 코드의 변경시 하나의 기능에 대해서 이를 사용하는 다양한 기능 모두에 대한 테스트 또는 동작의 확인이 이뤄져야 하는 것은 번거로운 일이다. 코드의 변경점에 대해서 가능한 적은 케이스의 테스트가 이뤄질 수 있도록 코드를 만드는 것이 좋다.
- 이를 위해서 클래스는 하나의 목적을 위해서 만들어 지는 것이 중요하고, 클래스의 코드 변경이 이뤄질 때는 해당 목적을 생각하는 것으로 어떤 변경이 어떤 영향을 초래하게 될지 예상 및 추론 하면서 코드 변경이 전체 클래스의 동작에 어떤 영향을 미칠지를 파악하면서 코드 변경을 할 수 있다. 하지만 클래스가 가지는 목적이 여럿일 경우에는 한 부분의 변경 사항이 생각하던 목적과 다른 목적을 수행하는데 있어서 어떤 영향을 미칠지 생각해야 하는 범위가 늘어나게 된다. 다양한 목적을 만족하는 변경 방식을 생각해야 해야 하고 때로는 일부의 목적에 한하여 동작하는 코드가 추가되면서 연관성이 떨어지는 로직이 많아지게 되고 다른 목적을 가진 대상의 코드를 해석할 때 이 코드는 왜 존재하지 무엇을 위해 존재하지? 등의 판단을 내려야 하기 때문에 어떤 변경을 수행하는데 좀 더 많은 시간을 소모하고 로직을 생각하는 주의력을 떨어뜨릴 수 있다.
- 클래스에서 하나의 목적이 중요한 것은 클래스의 퍼블릭 메소드인 인터페이스는 클래스가 행해야 할 일련의 동작을 정의하는 것이기 때문이다. 객체는 퍼블릭 메소드를 통해서 다양한 상태를 만들어 낼 수 있다. 프로그래머는 이 상태 변화를 추론할 수 있어야 하고 (대략적으로라도) 객체의 상태 변화를 만들고 해당 상태에서의 어떤 결과를 얻는 과정이므로 클래스의 목적이 복수로 존재한다면 목적에 따라 사용하는 퍼블릭 메소드가 많이 달라질 수 있기 때문에 하나의 목적을 생각했을 때 다른 목적을 위해 존재하는 메소드는 관계 없는 대상이 되므로 객체를 사용하는데 있어서 혼란을 준다.

### 다수의 목적을 가지는 클래스
- 클래스는 목적이 단일한 것이 좋지만, 퍼블릭 메소드를 어떻게 조합할지 생각할 필요가 없도록 만들면 다양한 목적을 가지는 클래스를 정의할 수도 있다고 본다. 상태를 생성자에서 모두 할당을 하고, 메소드를 엑션으로만 정의하여 필요한 엑션만을 사용하도록 하는 것이다. 곧, 함수의 집합의 개념으로 클래스를 정의하는 것이다.
- 함수가 평가를 위해 상태를 받기 위해서 파라메터를 사용하는 것과 달리, 함수 집합인 객체를 인스턴스화 한 것에서 공통적으로 필요한 상태를 정의를 한 상태이며 이를 통해서 함수가 받아야 할 인자의 수를 좀 더 줄일 수 있다는 장점이 있다. 이런 객체를 정의할 때는 엑션을 실행했을 때 가능한 상태의 변경이 이뤄지지 않도록 만드는 것이 중요하며 클래스의 기능을 확장할 때 모든 엑션에서 공통의 요소로 사용할 수 있는 메소드가 아니라면 해당 클래스에서 확장하지 않고 별도의 특정 목적을 위한 별도의 클래스를 만다는 편이 좋다. 공통적인 요소가 아닌 각 엑션에서 고유하게 사용하는 값은 엑션 메소드의 파라메터를 통해서 처리를 할 수 있도록 하자.
- 함수의 집합으로 클래스를 정의하는 것은 확장성에 제한적인 특성을 갖으며, 공통적인 설정을 하지 않고 각각의 엑션에 따라 설정되는 값은 파라메터를 확장하는 방식을 통해서 이뤄져야 한다. 파라메터를 사용하는 것은 파라메터의 크기가 커질 수록 함수를 사용하기 까다로워는 문제점을 가진다.

### 단일 책임 원칙 이해하기
- 앞서 객체를 만들 때는 책임의 범위를 줄인다고 하였다. 그리고 책임의 범위를 최대한 줄인 단일 엑션 클래스를 만드는 것이 좋다고 하였다. 단일 책임 원칙은 객체를 만들 때 하나의 책무를 수행해야 한다는 의미를 가진다.
