## 어떻게 클래스를 만들 것인가?
- 클래스를 만들 때의 가장 큰 문제점은 클래스는 다양한 방식으로 퍼블릭 메소드를 만들 수 있기 때문에 클래스가 제공하는 퍼블릭 메소드를 어떻게 조합해서 사용해야 할지 알 수 없다면 클래스를 만드는 이점이 크지 않을 수 있다.
- 프로그래밍에서 추상화를 하는 것은 코드를 관리하기 쉽게 만들기 위한 것이다. 관리하기 쉬운 코드란 코드의 동작을 쉽게 이해할 수 있는 코드를 의미한다. 클래스를 만드는 것으로 동작을 이해하기 쉽게 하기 위한 방법은 클래스의 이름과 퍼블릭 메소드를 어떻게 짓느냐가 중요하다. 어떤 목적을 위해 클래스가 사용되는지를 나타낼 수 있는 이름을 클래스명으로 하고, 목적을 수행하기 위한 일련의 과정을 퍼블릭 메소드로 나타낼 수 있어야 코드가 어떻게 동작하는지 알 수 있다.

### 책임의 범위를 줄이기
- 클래스는 이름을 갖는 순간 책임의 범위를 결정하게 된다. 클래스 이름을 넓은 범위의 역할을 담당하는 것으로 짓는 순간, 메소드는 어떤 목적을 위해 연결되어야 하는 일련의 과정이 아닌, A라는 기능을 실행하기 위해서는 어떤 메소드 조합을, B라는 기능을 실행하기 위해서는 어떤 메소드 조합을, C라는 기능을 실행하기 위해서는 어떤 메소드 조합을 사용하도록 하면서 하나의 클래스가 갖는 메소드가 목적에 따라 쓰이고 안 쓰이고 하는 메소드가 중구난방으로 생겨나면서 클래스의 퍼블릭 메소드만 보았을 때는 어떤 메소드를 조합해야 하는지 알 수 없게 만드는 경우가 생길 수 있다. 따라서 클래스는 하나의 목적을 위해서 요구되는 메소드들의 조합으로 만들어질 수 있도록 책임의 범위 최대한 줄이는 방식으로 만드는 것이 중요하다.

### 클래스와 함수
- 책임의 범위를 줄여나가다 보면, 함수와 클래스의 차이가 없는 것이 아닌가? 라고 생각할 수도 있다. 함수는 함수의 인자를 통해서 조건에 해당하는 값을 전달 받고, 클래스는 클래스의 생성자의 인자나 메소드를 통해서 조건에 해당하는 값을 전달 받고, 해당 조건에 따른 어떤 기능을 수행하기 때문이다.
- 함수를 사용하지 않고 객체를 사용하는 이유는 함수의 경우 기본적으로 인자를 순서대로 할당해야 했기 때문이다. 특정 인자를 스킵하고 싶더라도 할당을 해 주어야 하므로 인자를 할당하는 과정에서 생각하지 않아야 하는 것을 생각하게 만들도록 한다는 문제점이 있다. 또한 함수의 파라메터가 늘어날 수록 할당해야 하는 인자의 수도 늘어나기 때문에 순서상 나중에 할당해야 하는 인자가 있다면 스킵할 수 없기 때문에 불편함이 생긴다. 이에 반해 객체는 메소드를 갖고 있고, 메소드를 통해서 인자를 할당한다. 객체를 사용하는 쪽에서는 메소드의 이름을 기술해야 하므로 무엇을 할당해야 하는지 알 수 있게 해 주고, 하나의 메소드로 할당할 수 있는 인자들의 묶음을 통해서 할당할 인자간의 연관성을 생각할 수 있게 해 준다.
- 요즘에는 함수도 명명된 인수(Named Arguments)를 통해서 함수의 동작에 필요한 값을 마치 메소드처럼 순서를 바꾸어 값을 받을 수도 있고, 메소드를 기술하는 것 처럼 파라메터명을 기술할 수 있다. 따라서 함수를 마치 클래스와 같은 방식으로 사용할 수 있다. 또한 하나의 인자가 오브젝트 또는 배열을 통해서 값의 묶음을 전달 받을 수도 있다. JS나 TS를 사용하는 경우 리터럴 오브젝트를 인자로 할당하는 방식의 코딩 스타일을 사용하여 리터럴 오브젝트의 키에 값을 매핑하여 전달하는 것을 통해 명명된 인수(Named Arguments)와 유사한 개념을 사용할 수 있고, 리터럴 오브젝트의 키에 리터럴 오브젝트를 할당하는 것을 통해서 서로 연관성 있는 데이터를 묶어 처리할 수 있다. 함수의 인자를 세팅하는 것을 통해서 객체의 메소드를 대체하는 코딩 스타일을 보여주기도 한다.

### 함수와 객체의 상태
- 객체는 상태라는 것을 저장할 수 있는 특성을 가졌다. 퍼블릭 메소드의 실행에 따라 그에 따른 내부 멤버 값의 변경이 일어나게 되고 해당 객체를 복사하면 동일한 상태의 객체를 얻을 수 있고 특정 상태를 기준으로 로직을 전개할 수 있다는 장점이 있다. 그런데 함수도 함수형 프로그래밍을 사용하게 되면, 함수가 커링을 통해서 인자를 머금고 있는 상태를 만들 수 있다. 커링된 함수는 평가 되기 전에 상태라는 것을 가지게 되고 이를 통해서 특정 상태를 기준으로 로직을 전개할 수 있다.

### 엑션의 반복
- 함수는 평가가 되지 않았다면 커링을 통해서 상태를 저장할 수 있지만, 한 번 평가되면 결과 값이 반환되기 때문에 엑션의 반복이 일어날 수 없다. 하지만 객체의 메소드는 사용을 했더라도 다시 사용할 수 있는 경우도 있고, 다른 메소드로 사용하여 또 다른 반환 값을 얻을 수도 있다. 하지만 함수는 한 번 평가가 되면 결과 값이 반환 되거나 실행이 완료 되므로 반복적으로 사용할 수 없다. 물론 어떤 특정 상태로 커링된 함수를 복사하여 평가하는 방식으로 재사용을 할 수 있겠지만, 객체가 메소드를 다시 실행하면 되는 것에 반해 특정 상태의 함수를 캡쳐를 해야 하고 이를 재사용할 수 있도록 코드를 추가 해 줘야 한다는 불편함이 있다.

### 엑션의 다양성
- 객체는 메소드의 결과를 얻고 나서도 객체의 메소드를 새롭게 호출하는 것을 통해서 새로운 엑션을 사용할 수 있다. 하지만 함수는 평가가 끝나면 더이상 무언가를 할 수 없다. 객체는 멤버의 상태 변화를 유도하는 메서드와 엑션 메소드를 사용해서 서로 다른 상태에서의 엑션을 게속 만들어낼 수 있지만, 함수는 한 번 커링되었다면 다른 상태 값으로 바꾸지 못한다는 단점이 있다. 객체는 계속적인 상태 변화에 따른 엑션을 구성하는데 도움이 된다.

### 단일 엑션 클래스
- 단일 엑션 클래스라는 것은, 객체의 상태에 관여하는 여러 요인들을 메소드를 통해서 받지만, 상태가 세팅이 되고 나서 객체를 통해서 실현하고자 하는 목적 로직을 담당하는 메소드는 하나인 경우를 의미한다.
- 단일 엑션 클래스를 만드는 것은 객체가 하려는 목적의 범위를 최소화하여 객체의 퍼블릭 메소드를 하나의 목적을 위해 존재하는 것으로 생각할 수 있기 때문에 좀 더 객체의 사용법을 쉽게 유추할 수 있게 해 준다.
- 무조건 단일 엑션 클래스를 만드는 원칙을 만들자는 것은 아니다. 클래스의 사용법을 최대한 알기 쉽게 하기 위해서 단일 엑션을 위주로 클래스를 설계를 하되, 클래스의 어떤 특정 조건에서의 상태를 확인하는 메소드들은 추가 될 수 있다. 곧, 핵심 로직을 담당하는 기능은 클래스에 하나만 만들고, 부수적인 로직을 담당하는 엑션을 추가로 만드는 방식을 사용한다. 이를 통해서 클래스의 복잡성을 줄일 수 있다.

### 단일 엑션이라면 함수와 같은가?
- 단일 엑션 클래스는 객체의 상태를 전달 받는 여러 메소드와 객체의 핵심 로직을 표현하는 하나의 메소드로 구성된다. 이는 여러 인자를 파라메터를 통해서 받아 상태를 구성하고 하나의 평가 결과를 갖는 함수로 대체할 수 있다. 그럼에도 단일 엑션 함수를 만들어야 할까?라는 생각을 할 수 있다.
- 이는 언어가 제공하는 문법적인 특징에 따라 달라질 수 있다. 커링을 통해서 상태를 자유롭게 구성하기 편한 언어의 경우 단일 엑션 클래스 대신 함수로 단일 엑션 클래스를 대체할 수 있다.

### 객체를 사용해야 할까?
- 객체를 사용하는 대표적인 분야는 게임인데, 게임은 유저의 조작을 통해서 객체의 인터페이스를 통해서 상태를 변경하고 그에 따른 행동을 보여주기 때문이다. 엑션을 반복할 수도 있고 엑션을 다양하게 사용할 수도 있다.



