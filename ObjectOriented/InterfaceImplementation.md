## 객체
- 객체는 서로 상태를 공유하는 작업들을 정의한 대상이다.
- 외부에서 객체에게 객체 내부의 상태 변화를 유도할 수 있도록 객체는 작업 명령 집합을 가지고 있으며, 외부에서 특정 상태의 객체에게 시켜야 할 작업 집합을 가진 것이 객체이다.

## 프로그래밍 언어에서의 객체
- 객체는 퍼블릭 맴버와 프라이빗 멤버를 가지고 있다.
- 퍼블릭 멤버를 통해서 객체의 상태를 정의하여 객체를 특정 조건으로 유도하고, 퍼블릭 멤버를 통해서 유도된 조건에서의 객체에게 작업의 결과를 얻는다.
- 객체를 사용하는 외부의 입장에서는 객체 내부에 정의된 프라이빗 멤버가 어떻게 동작하는지 알 필요 없이 제공되는 퍼블릭 멤버를 통해서 객체를 통해 하고자 하는 바를 이룰 수 있어야 한다.

## 인터페이스
- 서비스나 물건을 다루는 대상이 서비스나 물건을 좀 더 쉽게 다룰 수 있도록 다루는 방식을 정의한 것을 인터페이스라고 한다.

## 프로그래밍 언어에서 인터페이스
- 프로그래밍 언어에서 클래스로 만들어진 객체를 사용하기 위한 규칙을 정의한 것이 인터페이스이다.
- 객체 내부의 세부적인 구현을 이해할 필요 없이 인터페이스만을 보고도 객체를 어떻게 다뤄야 할지 알 수 있도록 만드는 것이 객체에서의 인터페이스를 정의하는 방법이다.
- 프로그래밍 언어에서 인터페이스는 퍼블릭 멤버 메소드의 이름과 타입 그리고 이 메소드가 가진 매개변수의 이름과 타입을 갖는다.
- 프로그래밍 언어에서 제공되는 인터페이스는 퍼블릭 멤버 변수에는 사용할 수 없고 퍼블릭 멤버 메소드에만 사용할 수 있다. 이는 객체의 상태 변화의 유도가 메소드로 이뤄져야 한다는 것을 뜻하며 객체의 상태변화에 있어서 멤버 변수와 멤버 메소드의 차이는 의미론적인 인터페이스를 제공하느냐 제공하지 않는냐의 차이를 갖는다. 퍼블릭 멤버의 값을 변경하는 일은 객체 내부의 상태 변화 방식을 이해하는 사람에게 제공하면 객체를 원하는 방식으로 사용할 수 있게 하지만, 객체 내부의 구체적인 상태 변화 방식을 모르는 인터페이스만을 제공받은 사람이 사용하기에는 적절하지 않다. 따라서 이름과 타입 등을 통해 의미론적 상태변화를 정의할 수 있는 퍼블릭 메소드를 통해서 객체를 다루게 하기 위해서 프로그래밍 언어에서 인터페이스는 퍼블릭 메소드에만 적용할 수 있도록 만들어져 있다.

## 왜 인터페이스를 사용하는가?
### 객체를 다루는 방식을 미리 설계를 했을 때
- 큰 규모의 객체지향 프로젝트의 경우 설계자에 의해 미리 객체가 설계가 되고 이를 코더에게 맡겨 구현을 하게 된다. 객체를 만드는 사람과 객체를 사용하는 사람이 서로의 코드를 볼 수 없는 상황에서 코드를 짜게 되면 객체를 사용하는 쪽에서는 해당 객체의 메소드명, 타입, 인자의 수 등이 일치하지 않게 되어 나중에 코드를 합칠 경우 문제가 발생할 수 있다. 이를 미연에 방지하기 위하여 설계자는 인터페이스를 정의하여 코더들이 서로 다르게 만들 수 있는 객체의 퍼블릭 메소드를 일치시켜 독립적으로 만들어진 객체 간의 연결을 매끄럽게 할 수 있다.

### 서로 다른 객체를 다룰 때 일관성을 제공하려고 할 때
- 서로 다른 책임을 담당하고 있는 클래스이지만 클래스들 간의 비슷한 기능을 가질 경우가 있다. 이 때 유저에게 객체 메소드 사용의 일관성을 제공하기 위해서 비슷한 기능을 제공한다면 같은 형태의 코드로 만들어 준다. 이를 위해 서로 다른 객체라더라도 동일한 인터페이스를 사용하여 같은 형태의 퍼블릭 메소드를 제공하여 통일성을 제공하는 방식으로 사용된다.
- 이런 방식의 대표적인 예로 리포지토리 패턴을 들 수 있다. `findById`, `get`등의 함수는 서로 다른 리포지토리 클래스들이 공통으로 갖는 인터페이스이다. 공통으로 갖는 인터페이스는 서로 다른 클래스더라도 조금씩 다르게 인터페이스를 제공할 것이 아니라, 동일한 형태의 인터페이스로 제공하면 코드 통일성이 생겨 리포지토리라면 `someRepositoryObj->findById(number)->get()` 방식으로 사용한다는 것을 알 수 있기 때문에 일관성 있게 기능을 사용할 수 있다.

### 서로 다른 객체 간에 동일한 타입힌트로 그룹화 하고 싶을 때
- 두 객체가 리스코프 치환 원칙을 만족한다면 공통의 조상 클래스를 통해서 객체의 타입을 알 수 있고 타입을 사용하여 조상 클래스에 정의된 퍼블릭 멤버에 접근하는 코드를 짤 수 있다.
- 하지만 두 객체가 리스코프 치환 원칙을 만족하지 못할 때는 서로의 공통 조상이 없기 때문에 동일한 클래스 타입을 사용하지 못하게 된다. 서로 타입이 다른 두 객체가 가지는 퍼블릭 메소드의 형태가 동일하다면 이를 같은 타입힌트로 묶어 사용할 수 있도록 만들어 주면 타입의 일치를 통한 애플리케이션의 안정성 확보가 가능하다. 서로 공통 조상을 공유하지 않는 객체 간의 공통 타입을 정의하고자 할 때 인터페이스를 사용한다.

### 객체 간의 의존성을 줄일 때
- 객체에서 객체를 직접 사용하게 될 경우 사용하는 객체의 코드를 직접 실행하게 될 수 있다. 인터페이스를 사용하여 객체의 형태를 대신한 방법으로 사용한다면 동일한 인터페이스를 가진 객체를 교환하여 사용할 수 있다. 객체를 사용할 때 특정 클래스에 대한 의존성을 갖는 것이 아니라 인터페이스에 대한 의존성을 갖게 하여 동일 인터페이스를 가진 다양한 서로 다른 객체를 교환할 수 있게 만든다. 
- 이를 이용하면 태스트 객체를 만들어 실제 코드의 실행 시 의존되는 객체가 아닌 태스트 객체를 실행하여 의존 대상인 원본 객체에 대한 직접적인 실행을 하지 않고도 객체에 대한 태스트를 수행할 수 있는 등의 장점을 가진다.

### 실제 구현이 숨겨진 상태로 객체가 제공되어야 할 때
- 컴파일을 할 수 있는 OOP 언어의 경우 라이브러리나 패키지 등을 제공할 때 구현 사항을 숨기기 위해 컴파일 된 패키지를 제공하게 된다.
- 컴파일 된 패키지나 라이브러리의 사용자는 내부 코드를 알 수 없기 때문에 제공되는 인터페이스에 의존할 수 밖에 없다.
- IDE에서 객체의 메소드 및 타입 등을 사용할 수 있기 때문에 패키지나 라이브러리의 인자와 타입 등의 자동완성 기능을 쉽게 사용할 수 있다.

## 인터페이스의 정의 단위
- 객체란 상태 변화를 공유하는 작업을 정의한 대상이다. 객체에는 특정 상태를 지정했을 때 결과를 얻는 여러 메소드들이 함께 정의되어 있다. 객체가 갖는 상태 지정의 중복을 최소화하고 해당 상태에서 다양한 작업을 통해 다양한 결과 값을 만들어 내려고 하는 편이 좋기 때문이다.
- 인터페이스는 객체의 사용 방법을 기술한 것이다. 단순히 사용 방법을 정의한 것이기 때문에 단일한 작업의 결과를 얻기 위한 과정을 정의하는 것으로도 충분하다. 결과를 내는 다양한 작업들에 대한 상태 정의 및 변경 메소드들을 모두 정의하려고 하면 특정 작업에 필요하지 않은 상태 정의 및 변경 메소드도 포함이 되기 때문에 객체의 사용법을 드러내야 하는 인터페이스가 모호하게 정의될 수 있다.
- 하나의 클래스는 여러 인터페이스를 받을 수 있고 인터페이스들 간의 동일한 메소드 형태를 가져도 클래스는 중복된 메소드 형태를 가진 인터페이스들을 받는데 문제가 없기 때문에 인터페이스 하나에 상태 정의 및 변경 코드를 정의할 필요가 없고, 각각의 인터페이스는 하나의 작업에 대한 결과를 얻기 위한 과정을 나타내는데 충실하면 된다.
- 인터페이스를 단순히 공통의 퍼블릭 메소드를 묶는 교집합의 의미로만 사용하게 된다면 하나의 작업 단위의 프로세스를 나타내야하는 본질적 의미와 멀어질 수 있으니 주의해야 한다. 이런 관점에서 여러 인터페이스들 간의 공통 메소드가 존재할 수 있으나 이를 묶는 것 보다는 인터페이스 별로 중복으로 정의하는 편이 불필요한 인터페이스를 늘려 복잡하게 만드는 것을 줄일 수 있는 방법이라 본다.

