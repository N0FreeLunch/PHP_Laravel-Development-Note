## 객체
- 객체는 서로 상태를 공유하는 작업들을 정의한 대상이다.
- 외부에서 객체에게 객체 내부의 상태 변화를 유도할 수 있도록 객체는 작업 명령 집합을 가지고 있으며, 외부에서 특정 상태의 객체에게 시켜야 할 작업 집합을 가진 것이 객체이다.

## 프로그래밍 언어에서의 객체
- 객체는 퍼블릭 맴버와 프라이빗 멤버를 가지고 있다.
- 퍼블릭 멤버를 통해서 객체의 상태를 정의하여 객체를 특정 조건으로 유도하고, 퍼블릭 멤버를 통해서 유도된 조건에서의 객체에게 작업의 결과를 얻는다.
- 객체를 사용하는 외부의 입장에서는 객체 내부에 정의된 프라이빗 멤버가 어떻게 동작하는지 알 필요 없이 제공되는 퍼블릭 멤버를 통해서 객체를 통해 하고자 하는 바를 이룰 수 있어야 한다.

## 인터페이스
- 서비스나 물건을 다루는 대상이 서비스나 물건을 좀 더 쉽게 다룰 수 있도록 다루는 방식을 정의한 것을 인터페이스라고 한다.

## 프로그래밍 언어에서 인터페이스
- 프로그래밍 언어에서 클래스로 만들어진 객체를 사용하기 위한 규칙을 정의한 것이 인터페이스이다.
- 객체 내부의 세부적인 구현을 이해할 필요 없이 인터페이스만을 보고도 객체를 어떻게 다뤄야 할지 알 수 있도록 만드는 것이 객체에서의 인터페이스를 정의하는 방법이다.
- 프로그래밍 언어에서 인터페이스는 퍼블릭 멤버 메소드의 이름과 타입 그리고 이 메소드가 가진 매개변수의 이름과 타입을 갖는다.
- 프로그래밍 언어에서 제공되는 인터페이스는 퍼블릭 멤버 변수에는 사용할 수 없고 퍼블릭 멤버 메소드에만 사용할 수 있다. 이는 객체의 상태 변화의 유도가 메소드로 이뤄져야 한다는 것을 뜻하며 객체의 상태변화에 있어서 멤버 변수와 멤버 메소드의 차이는 의미론적인 인터페이스를 제공하느냐 제공하지 않는냐의 차이를 갖는다. 퍼블릭 멤버의 값을 변경하는 일은 객체 내부의 상태 변화 방식을 이해하는 사람에게 제공하면 객체를 원하는 방식으로 사용할 수 있게 하지만, 객체 내부의 구체적인 상태 변화 방식을 모르는 인터페이스만을 제공받은 사람이 사용하기에는 적절하지 않다. 따라서 이름과 타입 등을 통해 의미론적 상태변화를 정의할 수 있는 퍼블릭 메소드를 통해서 객체를 다루게 하기 위해서 프로그래밍 언어에서 인터페이스는 퍼블릭 메소드에만 적용할 수 있도록 만들어져 있다.

## 왜 인터페이스를 사용하는가?
### 객체를 다루는 방식을 미리 설계를 했을 때
- 큰 규모의 객체지향 프로젝트의 경우 설계자에 의해 미리 객체가 설계가 되고 이를 코더에게 맡겨 구현을 하게 된다. 객체를 만드는 사람과 객체를 사용하는 사람이 서로의 코드를 볼 수 없는 상황에서 코드를 짜게 되면 객체를 사용하는 쪽에서는 해당 객체의 메소드명, 타입, 인자의 수 등이 일치하지 않게 되어 나중에 코드를 합칠 경우 문제가 발생할 수 있다. 이를 미연에 방지하기 위하여 설계자는 인터페이스를 정의하여 코더들이 서로 다르게 만들 수 있는 객체의 퍼블릭 메소드를 일치시켜 전체 프로젝트 객체 간의 연결을 매끄럽게 할 수 있다.

### 서로 다른 객체를 다룰 때 일관성을 제공하려고 할 때
- 서로 다른 책임을 담당하고 있는 클래스이지만 클래스들 간의 비슷한 기능을 가질 경우가 있다. 이 때 유저에게 객체 메소드 사용의 일관성을 제공하기 위해서 비슷한 기능을 제공한다면 같은 형태의 코드로 만들어 준다. 이를 위해 서로 다른 객체라더라도 동일한 인터페이스를 사용하여 같은 형태의 퍼블릭 메소드를 제공하여 통일성을 제공하는 방식으로 사용된다.
- 이런 방식의 대표적인 예로 리포지토리 패턴을 들 수 있다. `findById`, `get`등의 함수는 서로 다른 리포지토리 클래스들이 공통으로 갖는 인터페이스이다. 공통으로 갖는 인터페이스는 서로 다른 클래스더라도 조금씩 다르게 인터페이스를 제공할 것이 아니라, 동일한 형태의 인터페이스로 제공하면 코드 통일성이 생겨 리포지토리라면 `someRepositoryObj->findById(number)->get()` 방식으로 사용한다는 것을 알 수 있기 때문에 일관성 있게 기능을 사용할 수 있다.

### 서로 다른 객체 간에 동일한 타입힌트로 그룹화 하고 싶을 때
- 두 객체가 리스코프 치환 원칙을 만족한다면 공통의 조상 클래스를 통해서 객체의 타입을 알 수 있고 타입을 사용하여 조상 클래스에 정의된 퍼블릭 멤버에 접근하는 코드를 짤 수 있다.
- 하지만 두 객체가 리스코프 치환 원칙을 만족하지 못할 때는 서로의 공통 조상이 없기 때문에 동일한 클래스 타입을 사용하지 못하게 된다. 서로 타입이 다른 두 객체가 가지는 퍼블릭 메소드의 형태가 동일하다면 이를 같은 타입힌트로 묶어 사용할 수 있도록 만들어 주면 타입의 일치를 통한 애플리케이션의 안정성 확보가 가능하다. 서로 공통 조상을 공유하지 않는 객체 간의 공통 타입을 정의하고자 할 때 인터페이스를 사용한다.

### 실제 구현이 숨겨진 상태로 객체가 제공되어야 할 때
- 컴파일을 할 수 있는 OOP 언어의 경우 라이브러리나 패키지 등을 제공할 때 구현 사항을 숨기기 위해 컴파일 된 패키지를 제공하게 된다.
- 컴파일 된 패키지나 라이브러리의 사용자는 내부 코드를 알 수 없기 때문에 제공되는 인터페이스에 의존할 수 밖에 없다.
- IDE에서 객체의 메소드 및 타입 등을 사용할 수 있기 때문에 패키지나 라이브러리의 인자와 타입 등의 자동완성 기능을 쉽게 사용할 수 있다.
