## 상속

### 시그니처

클래스의 멤버 및 메소드, 함수의 이름, 매개변수, 매개변수의 타입, 반환 타입 등 내부 구현이 아니라 어떤 기능을 묶은 사양을 나타내는 정보를 시그니처라고 한다.

시그니처를 통해서 명명 규칙, 추상화 패턴, 도메인 지식, 이미 기능을 사용해 본 사람이라면 사용된 시그니처를 보고 시그니처 내부에 구현된 소스 코드의 세부 사항을 모두 이해하지 않더라도 해당 기능이 대략 어떻게 동작할지를 알 수 있어야 한다.

시그니처를 조합, 연결하여 코드를 나타내는 것을 통해서 원하는 목적의 기능이 어떻게 동작하는지 내부 구현을 안 보고도 대략적인 추론을 할 수 있는 것이 좋은 코드이다.

시그니처는 코드를 짜기 위한 규약이기도 하며, 코드의 시그니처만으로도 연결되는 코드를 작성할 수 있도록 코드를 작성하는 것이 좋다. 시그니처만으로는 기능의 동작이 무엇을 목적으로 하며 목적을 이루기 위해 필요한 구현이 시그니처의 내부에 구현되어 있을 것으로 예상할 수 있어야 하며, 시그니처로 예상할 수 없는 시그니처가 나타내는 의미와 관련 없는 기능이 내부에 구현되지 않는 것이 좋다.

### 상속이란?

기준이 되는 클래스를 기준으로 동일한 멤버의 시그니처를 가지면서 기본적으로는 동일한 시그니처의 내부 구현을 가지나, 시그니처를 바꾸거나 새로운 시그니처를 추가할 수 있는 클래스를 만들 수 있도록 원본 클래스를 커스터마이징 할 수 있는 새로운 클래스를 정의할 수 있게 제공되는 기능이 상속이다.

### 멤버의 구현

멤버의 구현에서 중요한 것은 동일한 시그니처를 갖는다는 것인데, 메소드를 생각해 보자. 동일한 시그니처를 유지하면서 클래스의 상속 계층과 그에 따라 부여된 클래스의 명칭에 적합한 내부 코드의 구현만 바뀌기 때문에 시그니처가 변하지 않는 것으로 인해서 클래스의 상속이 이뤄지고 이를 통해서 메소드의 내부 구현이 변경되더라도 해당 메소드를 사용하는 코드에서는 시그니처를 바탕으로 코드가 작성되었으므로 내부 구현의 변화에 관계없이 사용할 수 있어야 한다. 따라서 메소드의 내부 구현을 정할 때도 해당 시그니처가 담당하는 기능 이외의 다른 기능이 동작하지 않도록 정의하는 것이 중요하다.

### 접근제한자

접근제한자는 public, private, protected가 존재한다. public는 외부에 객체의 인터페이스를 정의하는 것이며 private, protected는 클래스 내부에서 상속과 관련된 기능이다. private는 상속된 클래스가 재정의 할 수 없도록 제한하는 접근 제한자이고, protected는 상속된 클래스에서 이 메소드를 재정의 할 수 있도록 허용하는 접근제한자이다.

protected로 정의된 메소드는 재정의가 될 수 있으므로 protected 메소드를 사용하는 코드에서는 가능한 시그니처를 기반으로 코드의 동작이 구현되어야 하며 그렇지 않다면 동일 시그니처의 메소드의 오버라이딩에 의해 메소드의 내부 구현이 달라지면서 코드의 연결 동작이 잘못 이뤄지면서 코드의 예기치 않은 코드 동작이 이뤄지고 서브 클래스를 자유롭게 교체할 수 있는 다형성과 리스코프 치환 원칙을 위반하는 코드를 작성하게 된다.

protected도 재정의 될 수 있지만 public으도 된 멤버도 재정의 할 수 있다. 재정의 할 수 있는 코드는 클래스의 핵심 로직이 포함되면 안 되고 단순하고 간단한 로직으로 재정의 하기 쉽게 만들어져야 한다. private로 정의한 코드에 핵심 로직을 담고 protected나 public에서는 private의 로직을 가져와서 메소드의 인자를 바꿔서 전달하거나, private 메소드를 간단하게 조합하는 등의 방식으로 오버라이딩으로 메소드를 대체해도 대체한 동작으로 클래스가 만들어진 의도에 부합하는 동작이 되도록 만들어져야 하고, 의도에 부합하는 동작이 만들어 지게끔 개발자가 알아채기 쉽고 부합하는 기능으로 만들 수 있게 유도할 수 있는 코드를 만들어야 한다. 또는 단순한 멤버의 입출력의 로직이 될 수도 있을 것이다.

만약 하위 클래스에서만 생성되는 특별한 클래스의 경우, 이들을 private로 정의를 한 뒤 상위 클래스의 오버라이딩 가능한 메소드에서 불러서 사용하는 방식으로 해야 다형성에 맞는 동작이 이뤄진다. php에서는 객체의 메소드가 존재하는지 확인을 하고 해당 메소드를 호출할 수 있지만 하위 클래스의 특별한 기능이 추가 될 때마다 다형성을 사용하여 인스턴스의 교체가 가능한 코드에서 특정 케이스에 대한 분기 처리가 늘어나기 때문에 좋지는 않다.

### 계층 설계

서로 상속 관계에 있는 클래스들은 트리 구조를 갖는다. 계층이 많을수록 각 계층에서 담당하는 역할의 세분화가 가능하고, 필요한 만큼의 기능을 정의해서 사용할 수 있기 때문에 컴퓨팅 리소스를 아낄 수 있다는 장점이 있지만, 계층이 많아질수록 디버깅이 어려워지고 너무 많은 계층이 존재하면 수 많은 계층을 알아야 하므로 메인테인스가 좋지 않은 단점이 존재한다.

서브 클래스는 원본 클래스가 갖는 기능을 좀 더 상세히 구현하고자하는 목적으로 사용해야 한다. 서브클래스의 설계는 슈퍼 클래스의 시그니처와 동일한 시그니처를 가지면서 상세 기능 구현을 위해 메소드를 오버라이딩 하는 방식으로 이뤄지는 것이 의미상 적절하다.
