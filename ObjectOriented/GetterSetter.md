## 객체
- 객체란 공유되는 상태에 의존하는 작업들을 정의한 집합이다.

## 멤버
- 멤버는 객체의 상태 정보를 저장해 두는 역할을 한다.
- 인스턴스는 인스턴스가 사용하고 있는 다양한 조건과 다양한 외부 변화에 따라 다양한 상태를 가진다.
- 멤버는 다양한 상태를 가지기 때문에 멤버에 저장된 값을 통해 객체만의 특별함을 만들어 낸다.

## Getter 와 Setter
- 객체는 멤버 변수의 상태를 변경하고 멤버 변수의 상태에 의존하는 작업들을 정의하기 위한 것이다.
- setter는 멤버 변수의 상태를 할당하거나 변경하는데 사용하며, getter은 멤버 변수에 의존한 결과 값을 얻기 위해서 사용한다.

## Getter와 Setter 에 대한 오해
- 흔히 setter와 getter를 특정 멤버 변수의 값을 할당하거나 변경하는 용도로 이해하는 경우가 있다. 하지만 단순히 값을 할당하고 변경하고 가져오는 것이라면 메소드를 사용할 필요 없이 멤버 변수에 직접 접근하는 방식으로 변경해도 되므로 메소드를 사용할 필요가 없다. 그런데 왜 getter와 setter가 존재하는가?
- 일반적으로 멤버 변수로의 직접 접근을 차단하고 메소드를 통해서 멤버에 직접 접근하는 이유는 캡슐화 때문이라고 설명한다. 멤버 변수로의 직접적인 접근을 막고 변수의 변경을 제한적으로 이뤄지게 하여 객체 내부의 공유되는 작업 간의 로직 처리에 예상되지 않은 값이 오지 않게 하려는 의도가 있다고 설명한다.
- 객체지향에서 중요한 것은 객체를 사용하는 사람은 객체의 인터페이스로 노출된 메서드들에 대한 이해만으로 객체를 사용할 수 있어야 한다는 것이며, 객체를 사용하는 사람은 객체 내부에서 일어나는 로직에 대해서는 잘 몰라도 된다는 것이다. 따라서 객체 내부의 상태가 어떤 로직에 따라 움직이는지 정확하게 알 필요가 없다. 객체를 사용하는 입장에서 객체의 상태를 변화 시킨다는 것은 외부에서 주어지는 값에 변경이 있다는 것이며 객체의 인터페이스를 통해서 받은 값으로 반드시 객체 내부의 멤버 지정된 멤버를 변경하겠다는 뜻을 가지고 있지는 않다. 객체의 인터페이스를 통해서 상태 변화를 예측 추론 할 수 있다면 내부 상태를 변화 시키는 메소드는 어떠한 것을 사용해도 괜찮다. 객체의 인터페이스로 받은 값은 내부의 상태 변경 로직에 따라 다양한 방식으로 저장될 수 있다.
- 따라서 현재의 특정 멤버의 값을 할당하고 변경하는 setter나 특정 멤버의 값을 표시하는 getter는 일반적인 상태 변경이 아니라 객체의 멤버의 변경을 나타낸다는 더 좁은 의미를 가지고 있다고 보면 된다. 특정 멤버를 정해서 변경하는 메소드가 아니라면 상태를 변경할 때 쓸만한 접미어 결과를 가져올 때 쓰는 접미어를 따로 정해서 써도 된다.

### 객체의 사용자가 멤버 변수의 상태 변화를 알아야 하는가?
- 객체의 상태가 어떤 것을 할 수 있는 상태인지만 알면 되지 멤버 하나하나의 값의 변경을 알 필요는 없다.
- 하지만 객체의 공유 상태가 어떤지 알고 있다면 각 멤버와 이 멤버의 값의 변경과 메소드와의 관계성을 훨씬 이해하기 쉽다는 장점이 있다.
- 직접적인 멤버 변수의 변화를 드러내지 않고 상태 변화를 이끌어내는 객체의 인터페이스의 의미론적인 정의가 어려울 수 있기 때문에 공유 멤버의 상태를 직접 변경하는 것을 기본으로 하여 사용하면 객체의 인터페이스를 어떻게 표현해야 할지에 대한 고민이 줄어 들 수 있기 때문에 멤버 변수의 상태를 직접 변경하고 가져오는 setter와 getter를 사용하는 편이 좋을 수 있다.

### Setter
- 멤버 변수를 직접 변경할 때 사용한다. setMemberVariableName과 같은 명칭으로 메소드를 만든다.
- 객체의 메소드의 변경을 통한 상태 변화가 정확히 어떻게 되는지 알 수 있다.
- setter를 통해서 객체의 멤버의 상태 변경을 할 경우에는 객체의 메소드들이 어떤 멤버의 변경으로 상태가 변경되었는지 쉽게 알 수 있도록 하는 편이 좋다.

### Getter
- 멤버 변수의 값을 직접 가져올 때 사용한다. getMemberVariableName과 같은 명칭으로 메소드를 만든다.
- 멤버 변수의 값을 직접 가져오기 위한 용도로 사용하기 때문에 객체를 사용하는 도중에 계산이 있다면 계산의 결과를 멤버에 저장하고 이를 꺼내 쓰는 방식으로 사용하는 편이 멤버의 값을 직접 가져다 쓰는 것이 되기 때문에 좀 더 직관적이다.

### 객체의 상태 변화를 유도하는 메소드
- 객체의 상태를 변경하기 위한 용도로 사용되기 때문에 객체의 상태 변화를 어떻게 이끌어 내는지를 잘 알려줄 수 있는 이름을 지어주도록 하고 접미어를 메소드의 기능에 맞게 동사로 한다.
- 단순히 객체의 상태의 변화를 이끄는 메소드라면 리턴 타입을 self나 void를 사용하여 객체의 상태 변화만을 이끄는 메소드라는 것을 표현할 수 있다.

### 상태를 저장하지 않는 결과를 얻기 위한 메소드
- 공개 메소드를 통해서 객체에 지시를 할 때 지시한 연산을 수행할 때마다 값을 멤버에 저장을 하게되면 불필요한 멤버가 늘어나게 되고 이는 객체를 관리하는데 부담이 될 수 있다. 따라서 굳이 멤버 변수로 저장할 필요가 없는 객체에 공유 상태를 만들 필요가 없는 연산 결과라면 지시와 동시에 값을 가져오는 것이 좋은 방법이다.
- 적절한 동사를 통해서 어떤 지시를 할지를 정하고 retrun 타입을 self, void 이외의 것을 사용하여 지시한 결과가 리턴되는 것을 정한다면 상태를 공유할 필요가 없는 명령의 결과를 획득하는 것을 표현할 수 있는 메소드를 만들 수 있다.
- 상태를 저장하지 않기 때문에 접미사 get을 쓰기 보다는 메소드가 수행하는 동작을 나타내는 네이밍을 하고 리턴 타입을 통해서 결과를 임시로 받는다는 것을 나타내는 편이 좋다. 하지만 동작의 수행을 통해서 발생할 수 있는 결과가 어떤 결과인지 알 수 있도록 표현해야 하기 때문에 어떤 결과를 얻기 위한 메소드인지를 나타낼 수 있는 지시어를 사용하는 것이 좋다.

