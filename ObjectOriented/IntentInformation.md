## 의도를 드러내는 프로그래밍
- 프로그래밍 언어는 여러가지 문법적인 장치들을 가지고 있다. 하지만 이들 문법적인 장치를 꼭 써야 로직이 움직이는 것은 아니다. 똑같은 기능을 만든다고 해도 문법적인 요소를 많이 활용하여 만들 수 있고 구현에 필요한 최소한의 문법만 써서 만들 수도 있다.
- 기능을 만들 때 문법적인 요소를 최대한 활용한다는 것은 해당 기능이 가진 여러 가능성 중에 일부 가능성을 제한하는 역할을 하게 된다. 예를 들어 객체 내의 모든 멤버는 public 접근제한자를 써서 구현할 수 있다. 하지만 private, protected 라는 접근제한자를 가미하여 객체 외부에서 객체의 기능을 호출하는 멤버인지, 객체 내부에서 로직을 따로 분리 시키기 위해 사용되는 멤버인지 구분할 수 있게 해 준다.
- 개발자는 코드를 짤 때 객체를 사용하기 위해 공개해야 할 멤버와 숨겨야 할 멤버를 구분하여 객체를 사용하기 위해서 쓰는 멤버가 무엇인지 객체 내부의 구현을 위해 만든 멤버가 무엇인지 구별해 둔다. 개발자는 프로그래밍 언어의 기능을 짜기 위한 필수적인 문법적 요소만을 사용하는 것이 아니라 여러 제약을 가하는 문법적인 요소들을 활용해서 의도를 더 분명하게 드러낼 수 있다.

### 다른 것으로 해석될 여지를 줄이기
- 객체의 멤버를 정의할 때 접근 제한자로 public 만을 쓰게 되면 객체의 의미를 해석하게 될 때 무엇이 객체의 외부에서 객체를 다루기 위해서 사용해야 하는 멤버인지 무엇이 객체 내부에서 사용하는 것인지 구분하기가 어렵게 된다. 적절한 접근 제한자로 객체 외부에서 객체를 다루기 위해 사용할 것과 객체 내부에서 외부에 공개하지 않고 사용할 것을 구분하는 것은 해석의 경우의 수를 줄이는 역할을 한다.
- 해석의 경우의 수를 줄이는 것은 코드를 어떤 의도로 만들었는지 좀 더 알기 쉽게하는 역할을 한다.

## 의도 정보 (intent information)
- 정보라는 것은 많은 가능성 중에서 일부의 가능성의 여지를 제한하여 가능성을 높이는 역할을 한다. 정보가 있다라는 표현은 수 많은 경우의 수가 있지만 정보를 통해서 일부 케이스로 경우의 수를 줄일 수 있을 때 정보가 있다는 말을 사용한다.
- 프로그래밍 언어에서 구현에 필수적인 문법이 아닌 코드의 의도를 드러내기 위해서 활용되는 문법적인 요소들은 정보에 해당한다.
- 이를 코드의 의도를 드러내기 위한 정보로 '의도 정보'라고 부르자.

## 의도 정보의 예

### 타입힌트
- 변수를 사용하거나 변수를 전달할 때 타입힌트로 전달되는 값의 타입을 제한하는 방식을 통해서 어떤 값이 전달되고 있는지 명확하게 알 수 있다.

### 상수의 대문자 표기
- php에서는 `const`등의 키워드를 통해서 상수를 정의할 때 `$`를 상수 앞에 붙이지 않는다. 이를 통해서 사용하려는 값을 포함하고 있는 대상이 상수인지 변수인지 구분할 수 있다.
- 자바와 같은 언어에서는 변수에 `$`를 붙이지 않기 때문에 상수를 구분하기 위해 대문자를 사용하지만 php의 경우에는 상수를 대문자로 정의해도 소문자로 정의해도 문제가 없다.

### 객체에서의 순수함수
- 순수함수는 객체 내부의 멤버 변수에 영향을 주지 않는다. 그렇다면 객체의 상태변화에 영향을 주지 않는다는 것을 표현하기 위해서 순수함수는 클래스에서 정의할 때 static으로 정의하면 객체에서 해당 멤버 메소드를 사용할 때 객체의 상태 변화에 영향을 받지 않는 함수인 것을 알게 되기 때문에 순수함수가 아닌 다른 것으로 해석될 여지를 줄여준다. 물론 static 메소드로 정의를 했기 때문에 인스턴스가 아닌 클래스의 멤버를 변화 시킬 수 있는 가능성도 가지고 있지만 적어도 객체의 상태 변화와는 관련 없다는 것을 드러낼 수 있다.

### 클래스 외부에 정의한 함수와 내부에 정의한 함수
- 클래스 내부에 함수를 정의하는 것은 클래스의 로직을 전개하기 위한 메소드를 정의한다. 만약 해당 클래스 뿐만 아닌 다른 클래스에서도 클래스의 의존성 없이 사용될 수 있는 기능이라면 특정 목적을 이루는 로직의 클래스와 분리하여 외부에 함수를 정의한다.
- 이렇게 클래스의 로직이나 상태 변화에 의존적인 함수는 클래스 내부에 정의하고 의존적이지 않은 범용적인 기능을 하는 함수는 별도로 정의한다면 클래스를 해석할 때 의존성이 있는 현재 클래스에 의존적인 함수와 그렇지 않은 함수를 명확하게 알 수 있다는 장점이 있다.


