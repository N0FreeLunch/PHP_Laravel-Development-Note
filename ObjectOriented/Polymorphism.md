## 다형성

### 인터페이스
- 객체가 갖는 퍼블릭 메소드의 시그니처를 강제하기 위한 문법적 기능을 제공한다.
- 다양한 클래스는 인터페이스를 구현(implement)하여 동일한 시그니처를 가질 수 있다.
- 인터페이스를 타입으로 사용하여, 인터페이스를 구현한 클래스의 인스턴스를 함수의 인자로 전달할 수 있다. 이를 통해서 서로 다른 클래스 기반의 객체를 전달 받아도 동일한 인터페이스를 사용하므로 서로 다른 클래스 기반의 대상별로 별도의 로직을 구현할 필요없이 인터페이스에 정의된 방식에 따라 동일한 로직을 사용할 수 있다.
- 인터페이스는 시그니처(메소드/함수명, 매개 변수의 이름, 매개 변수의 타입, 반환 타입)로 구성되어 있으며, 세부 구현에 따라 동일한 시그니처라도 서로 다른 값을 반환할 수 있다.
- 인터페이스를 통해 하나의 로직으로 다양한 클래스 기반의 인스턴스를 교체할 수 있는 특징을 다형성이라 할 수 있다.

### 상속
- 어떤 클래스 A를 상속한 클래스 B가 있을 때, 어떤 클래스 A를 부모 클래스, B를 자식클래스라고 부른다. B를 상속한 클래스 C가 있다면 C는 A의 자손 클래스이며, A는 C의 조상 클래스라 부를 수 있다.
- 조상 클래스를 함수의 매개변수 타입힌트로 사용하는 경우, 자식 자손 클래스로 생성된 인스턴스도 매개변수의 값으로 받을 수 있다. 이 때, 함수 내부의 구현은 부모 클래스에 정의된 가진 퍼블릭 멤버의 시그니처에만 접근할 수 있으며, 부모 클래스에는 없는 자식/자손 클래스의 시그니처에 접근할 수 없도록 되어 있다. 이런 규칙을 리스코프 치환 원칙이라고 한다.
- 물론 php에서는 리스코프치환을 무시한 코드를 만들 수 있다. 함수의 매개 변수의 타입이 가진 퍼블릭 멤버에는 없는 매개 변수 타입의 자식/자손 클래스만이 갖는 퍼블릭 멤버에 접근할 수 있다. IDE의 감지처리 및 정적 분석 등을 통해서 리스코프 치환을 위반하는지 성립하는지를 확인한다.
- 부모 클래스를 상속할 때 부모 클래스에서 정의된 멤버의 시그니처를 변경하는 것은 문법적으로 금지되어 있는데, 이는 자식 클래스의 인스턴스로 교환할 수 있게 만들려는 목적이 있다. 동일한 시그니처를 통해서 함수 내부의 구현은 같지만 다양한 서브 클래스로 교체할 수 있는 특징이 상속에서의 다형성이다.
- 부모 자식의 클래스 관계 뿐만 아니라, 추상 클래스도 상속을 통한 퍼블릭 멤버의 시그니처가 일치하는 것으로 추상 클래스의 상속을 받는 서로 다른 타입 베이스의 인스턴스를 교체할 수 있다.

### 제네릭
- php에는 제네릭이 없지만, phpdoc을 사용한 정적 분석 및 IDE를 통해서 제네릭을 사용할 수 있다.
- 제네릭은 제네릭 설정을 할 수 있는 문법 단위인 클래스나 함수에 대해 다양한 타입을 받아 처리할 목적으로 만들어진다. 따라서 특정 타입에 얽매인 동작을 하지 않아야 한다. 물론 특정 클래스에 상속을 받는 제네릭을 만들어 해당 클래스의 퍼블릭 멤버의 시그니처에 의존적인 코드를 만들 수도 있다.
- 제네릭은 다양한 타입의 값을 교체하여 사용할 수 있도록 하는 다형성의 특징을 갖는다.
