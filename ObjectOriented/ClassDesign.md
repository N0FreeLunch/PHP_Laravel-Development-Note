## 트리거
- 클래스는 퍼블릭메소드와 비퍼블릭메소드로 나뉜다. 클래스나 객체라는 것은 기본적으로 외부에 제공되는 인터페이스에 의해서 실행이 된다. 따라서 어떤 기능의 트리거가 되는 부분은 퍼블릭 메소드의 어떤 부분에 존재한다.
- 객체의 외부에서 객체에 필요한 정보를 생성자나 setter로 세팅을 한 다음 객체로 하여금 필요한 동작을 시키는 코드가 퍼블릭 메소드이다. 퍼블릭 메소드는 외부에 의해서 명령 실행을 전달받고 객체 내부에 정의된 코드들을 실행시킨다.

## 퍼블릭과 비퍼블릭의 구분 한계
- 클래스의 메소드는 기본적으로 'public'과 'public이 아닌 메소드'로 구분된다. public 메소드는 객체 외부에서 객체를 다룰 때 사용하기 위해 제공되는 인터페이스의 역할을 하며, public이 아닌 메소드는 객체 내부의 코드 묶음을 정의할 때 사용한다.
- 일반적으로는 퍼블릭 메소드는 동작에 필요한 값을 객체에 세팅하거나 값을 세팅한 후 동작을 수행하는 트리거 역할을 한다. 이에 반해 비퍼블릭 메소드는 객체의 트리거 메소드에서 호출되며 객체 내부에서 일어나야 할 동작들을 기능별 역할별로 동작을 수행한다.
- 문제는 하나의 클래스의 기능이 비대해 질수록 메소드와 멤버들을 구조화 해야 하는데 public과 public이 아닌 메소드로만 구분하기에는 한계가 있다는 것이다. 클래스 내부의 기능이 비대해질수록 클래스의 코드 해석은 점점 더 어려워지게 된다.

## 트리구조의 코드
- 코드의 플로우를 읽을 때 어떤식으로 읽어야 하느냐의 문제이다.
- 클래스의 로직을 읽을 때 트리구조라는 것은 메소드 안의 메소드를 읽고 또 해당 메소드 안의 메소드를 읽으면서 해석이 이뤄지는 과정을 의미한다. 하나의 메소드는 트리의 노드에 해당하고 기능을 만들다 보면 상위 노드의 의미와 하위 노드의 의미가 달라지는 경우가 생긴다. 어떤 특정한 기능의 코드를 수정 및 변경을 하려고 할 때 트리구조로 되어 있다면 해당 기능이 어디에 있는지 모르기 때문에 트리 탐색을 하듯 각각의 하위 노드에 접근해서 기능을 확인해야 하므로 코드의 의미를 해석하는데 상당한 시간이 걸리게 된다.
- 이런 트리구조에서 발생하는 문제를 해결하기 위해서는 우선은 메소드에 메소드를 타고 넘어가는 횟수가 많아지지 않도록 해야 한다. 이를 위해서 메소드의 하위에 계속적인 기능을 추가하기 보다는 하나의 메소드에 여러 메소드들을 사용해서 로직 전달의 플로우를 알기 쉽게 표현하는 방법으로 코드를 짜는 편이 좋다. 어떤 특정한 부분의 로직을 찾기 위해서 또는 문제가 발생한 부분 또는 코드 변경이 필요한 부분을 찾기 위해서 트리거 코드로 부터 메소드를 여러번 거쳐서 다다르지 않도록 코드를 작성한다. 이를 위해서는 하나의 트리거 부분 또는 컨트롤러 역할을 하는 메소드에 다른 메소드들을 여러 개 넣고 이를 조합하는 방향으로 코드를 전개하도록 하자.
- 또한 상위 노드가 가지고 있는 의미에 하위 노드의 의미가 부합한다면 하위 노드를 찾기 위해서 상위노드로 접근하는 방법은 코드 탐색의 시간을 줄여주지만, 상위 노드와 하위 노드의 의미가 서로 다르다면 해당 메소드를 하위 노드로 배치하지 않고 별도의 노드로 분기하여 깊이가 트리 구조의 깊이가 깊어지는 구조가 아니라 너비가 넓어지는 구조로 짜는 것이 좋다. 메소드에서 메소드를 호출하는 방식은 트리 구조의 깊이를 깊게하므로 동일한 역할을 가진 하위 노드가 아니라면 깊은 곳의 어떤 로직을 찾아내기 힘들기 때문이다. 하지만 동일한 역할이라면 깊이를 충분히 주어도 상위 노드의 역할로서 하위 노드를 찾을 수 있기 때문에 괜찮다.

## 트리거를 컨트롤러화 하라
- 컨트롤러는 여러가지 기능들을 조합해서 원하는 로직을 만들고자 하는 것이다. 여러 기능을 조합하기 때문에 각각의 기능들의 조합으로 로직이 어떻게 전개되는지 보여줄 수 있다는 장점이 있다.
- 객체 내부의 코드를 다루어야 하는 입장에서는 먼저 메인 메소드에 해당하는 것이 무엇인지 로직의 포인트나 중요한 분기점이 되는 메소드가 무엇인지 아는 것이 중요하다. 객체가 어떤 역할을 수행하고 있는지 내부적으로 어떤 흐름으로 동작하는지 파악하기 쉬우려면 로직의 흐름에서 중요한 메소드와 그렇지 않은 것을 구분해야 하며 컨트롤러 역할을 하는 메소드에 적힌 메소드를 통해서 객체의 중요한 흐름을 나타내는 메소드가 무엇인지 알 수 있다.

## 지나친 메소드화를 지양
- 객체 내에서 여러 메소드에서 반복적으로 사용되지 않는 코드는 메소드화를 지양하고 한 번만 사용할 것들은 메소드 내의 함수를 만들어 사용하자.
- 객체 내에서 확실하게 여러 번 사용될 것 또는 여러번 사용될 가능성이 충분히 있는 것만 메소드화한다. 여러 번 사용될까?라는 의문이 드는 코드라면 과감하게 메소드가 아닌 함수로 정의해서 사용하도록 하자.
- 객체의 메소드가 많아진다는 것은 그 만큼 객체를 해석하는데 어려움을 겪게 하기 때문에 여러번 사용할지 의문이 든다면 메소드화 하지 않는 것이 객체의 복잡성을 줄이는 방법이 된다.

## 책임
- 역할을 부여하면 해당 역할을 수행하기 위해 책임이 따라온다. 일반적으로 클래스에 책임을 부여한다는 것은 클래스가 담당하고 있는 역할이 있다는 것이고 해당 역할을 충실히 수행하는 것이 곧 책임을 갖는다고 말한다.

## 상태공유
- 기본적으로 클래스란 상태를 공유하는 기능들이 모인 곳이라고 할 수 있다.

## 클래스 분리를 고려하라
- 하지만 객체를 단순히 상태 공유를 하는 기능들의 집합이라고만 한다면 프로그래밍 언어에서 클래스라는 언어가 제공하는 상태공유가 되는 만큼 기능을 계속적으로 추가하게되고 이는 클래스의 비대화를 야기한다. 클래스가 비대해지면 클래스의 코드의 의미를 해석하기 점점 더 어려워지므로 클래스를 작게 만들기 위한 방편이 필요하다. 이 방법 중 하나는 클래스를 책임 단위로 나누어 하나의 클래스가 비대해지는 대신 각각의 책임을 가진 여러개의 클래스로 나누는 방법이다.
