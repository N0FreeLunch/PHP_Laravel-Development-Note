# 시리얼라이제이션에 의한 취약점 이해

# 시작하며

# はじめに

회사에서 사내 스터디로 安全なWebアプリケーションの作り方[^1]라는 책을 선정하였고, 시리얼라이제이션에 대한 설명 부분을 맡게 되어 정리 해 보았다. 책의 내용을 참고 하였으나 대부분의 내용을 재구성하였다.

会社の社内勉強会で『安全なWebアプリケーションの作り方』[^1]という本を選定し、シリアライゼーションに関する解説部分を担当することになって整理して見ました。本の内容を参考にしつつも、ほとんどの部分を自分なりに再構成してまとめました。

이 글에서는, 프로그램간에 데이터를 교환할 때에 이용되는 시리얼라이제이션의 종류와, 시리얼라이제이션에서 사용하는 매개체(데이터 포멧) 를 다룰 때 취약점을 방어하는 방법을 설명한다.

本記事では、プログラム間でデータを交換する際に利用されるシリアライゼーションの種類と、シリアライゼーションで使用される媒介（データフォーマット）を扱う際に脆弱性を防ぐ方法について説明します。

# 본론

## 프로그래밍 언어의 동작
## プログラミング言語の動作

1. 작성된 코드를 컴퓨터가 실행 가능한 형태로 변경한다. (컴파일/인터프리팅)
2. 실행 파일이나 바이트코드가 메모리에 올라간다.
3. 변수나 값은 메모리에 저장되고, 각 값에는 주소가 있다.
4. CPU는 명령어의 지시대로 주소를 참조하여 실행한다.


1. 作成したコードはコンピューターが実行可能な形に変換します（コンパイル／インタプリティングを行います）。
2. 実行ファイルやバイトコードはメモリにロードされます。
3. 変数や値はメモリに保存され、それぞれの値にはアドレスが割り当てられます。
4. CPUは命令に従ってアドレスを参照しながら実行します。

사람이 작성하는 프로그램은 메모리의 주소를 직접 적지 않고, 컴퓨터가 코드를 실행하면서 자동으로 값 각각에 대한 메모리를 할당된다.

人間が書くプログラムはメモリのアドレスを直接記述せず、コンピューターがコードを実行する際に自動的に各値に対してメモリを割り当てます。

## 서로 다른 두 프로그램 간의 데이터 교환
## 異なる2つのプログラム間のデータ交換

하나의 프로그램이 다른 프로그램의 코드를 실행하기 위해서는 어떤 값이 어떤 메모리 주소에 있는지 알 수 있어야 한다. 하지만 이는 컴퓨터 내부에서 이뤄지는 동작이므로 다른 프로그램의 값의 주소를 알 수 없기 때문에 다른 프로그램의 값에 직접적인 참조를 하는 코드를 짜기 어렵고, OS는 기본적으로 보안을 위해서 하나의 프로그램이 다른 프로그램의 메모리에 접근하는 것을 차단하기 위해, 각각의 프로그램이 갖는 메모리 영역을 격리하므로 다른 프로그램의 메모리에 엑세스 할 수 없다.

1つのプログラムが他のプログラムのコードを実行するには、どの値がどのメモリアドレスにあるかを知る必要があります。しかし、これはコンピューター内部で行われる動作なので、他のプログラムの値のアドレスを知ることはできません。他のプログラムの値を直接参照するコードを書くことは難しいです。OSは基本的にセキュリティのため、1つのプログラムが他のプログラムのメモリにアクセスすることを遮断し、それぞれのプログラムが持つメモリ領域を分離しますので、他のプログラムのメモリにアクセスすることはできません。

서로 다른 프로그램 간의 데이터를 교환하기 위해서는 특정 데이터 교환을 위해 마련된 특정한 프로토콜(소켓, HTTP 통신, gRPC, 메시징 큐, 공유메모리, 파일 등)을 이용해야한다.

異なるプログラム間でデータを交換するためには、特定のデータ交換のために用意されたプロトコル（ソケット、HTTP通信、gRPC、メッセージキュー、共有メモリ、ファイルなど）を使用する必要があります。

### 웹 프로그래밍
### ウェブプログラミング

웹 프로그래밍은 서버는 클라이언트라는 별개의 프로그램 간의 HTTP(S) 통신이라는 프로토콜을 통해서 데이터를 교환하는 구조를 가지고 있다. 또한 경우에 따라 서버와 서버간의 통신, 서버 내의 다른 프로그램과의 통신이 이뤄지므로 이들 간의 데이터 교환을 위해 여러 프로토콜을 사용하며 이 때 시리얼라이제이션이 사용된다. 웹 애플리케이션과 데이터베이스, 웹 애플리케이션과 레디스, 웹 애플리케이션과 다른 웹 애플리케이션의 통신은 모두 시리얼라이징 과정을 거쳐 데이터를 교환을 한다.

ウェブプログラミングは、サーバーとクライアントという別々のプログラム間でHTTP(S)通信というプロトコルを使ってデータを交換する構造を持っています。また、場合によってはサーバー間通信やサーバー内の他のプログラムとの通信も行われますので、これらのデータ交換のために様々なプロトコルが利用され、その際にシリアライゼーションが使用されます。ウェブアプリケーションとデータベース、ウェブアプリケーションとRedis、ウェブアプリケーションと他のウェブアプリケーション間の通信もすべてシリアライズの過程を経てデータが交換されます。

## 시리얼라이징
## シリアライゼーション

시리얼라이징(serializing)은 프로그래밍 언어에서 사용되는 값을 다른 프로그램이나 시스템에 전달하거나 저장하기 위해, 해당 값을 다른 프로그램에서 다룰 수 있는 값으로 재구성할 수 있는 문자열이나 바이트 데이터로 변환하는 과정이다.

シリアライゼーション（serializing）は、プログラミング言語で使用される値を他のプログラムやシステムに渡したり保存したりするために、その値を他のプログラムで扱える値として再構成可能な文字列やバイトデータに変換する過程です。

프로그래밍 언어는 시리얼라이징 된 문자열이나 바이트 데이터를 전달 받아, 전달 받은 프로그램의 언어에서 사용되는 값으로 받아 쓸 수 있다.

プログラミング言語はシリアライズされた文字列やバイトデータを受け取り、受け取ったプログラムの言語で使用できる値として利用できます。

디시리얼라이징(deserializing)은 시리얼라이징된 데이터를 다시 프로그래밍 언어에서 사용할 수 있는 값으로 변환하는 과정이다.

デシリアライゼーション（deserializing）は、シリアライズされたデータを再びプログラミング言語で使用できる値に戻す過程です。

## 시리얼라이징 취약점

## シリアライゼーション脆弱性

프로그램밍 언어는 로직을 실행하는 역할을 한다. 시리얼라이징 된 데이터에 악의적인 코드가 포함되어 있다면 디시리얼라이징된 값을 처리할 때 부주의하게 처리하면 악의적인 코드가 프로그래밍 언어에 의해 실행될 가능성이 있다.

プログラミング言語はロジックを実行する役割を持っています。シリアライズされたデータに悪意のあるコードが含まれている場合、デシリアライズされた値を不注意に処理すると、その悪意のあるコードがプログラミング言語によって実行される可能性があります。

## 디시리얼라이징 주의점
## デシリアライゼーションの注意点

디시리얼라이징된 데이터는 프로그래밍 언어에서 직접 이용가능한 형태의 값이므로 이를 취약성을 유발할 수 있는 다른 코드와 결합할 때 유의할 필요가 있다.

デシリアライズされたデータは、プログラミング言語で直接利用可能な形の値ですので、脆弱性を引き起こす可能性のある他のコードと組み合わせる際には注意が必要です。

### eval

eval은 문자열로 된 코드를 실행하는 기능이다. 디시리얼라이징 된 문자열에 eval을 결합하면 해당 문자열이 코드로 실행되어 버린다. 이 때 악의적인 코드가 포함되어 있다면 악의적인 로직이 실행된다.

evalは文字列として記述されたコードを実行する機能です。デシリアライズされた文字列にevalを組み合わせると、その文字列がコードとして実行されてしまいます。このとき悪意のあるコードが含まれていれば、悪意のあるロジックが実行されます。

#### eval을 안전하게 이용하기

- 꼭 eval을 사용하는 상황이 아니라면 eval을 사용하지 않는 방식으로 로직을 구성한다.
- 必要がない限り、evalを使わない方法でロジックを構成します。
- 디시리얼라이징 된 데이터를 사용하기에 앞서 처리하기에 적절한 포멧의 데이터인지 확인하는 벨리데이션 로직을 포함한다. 코드가 포함되지 않도록 특수문자를 포함할 수 없는 형태의 벨리데이션 등을 고려할 수 있다.
- デシリアライズされたデータを使用する前に、適切なフォーマットのデータであるかどうかを検証するバリデーションロジックを含めます。コードが含まれないように特殊文字を含めない形式のバリデーションなどを考慮します。

#### eval을 대체하기

#### evalの代替方法

데이터가 특정 포멧으로 구성될 수 있다면 코드를 직접 실행하는 것 보다는 특수한 패턴의 문자열이나 바이트를 값으로 변환해 주는 기능을 사용하는 편이좋다.

データが特定のフォーマットで構成できるのであれば、コードを直接実行するよりも、特殊なパターンの文字列やバイトを値に変換する機能を使用した方が良いです。

이러한 기능으로는 explode, json_decode, unserialize 등이 존재한다. 이들은 문자열 데이터를 프로그래밍 언어의 값으로 사용할 수 있게 하지만, (unserialize를 제외한 나머지는) 코드를 실행하지는 않기 때문에 더 안전하다.

このような機能にはexplode、json_decode、unserializeなどがあります。これらは文字列データをプログラミング言語の値として利用できますが（unserializeを除く）、コードを実行しないためより安全です。

#### eval 코드의 예

#### evalコードの例

🙅 나쁜 예 : 전달 받은 코드 안에 `$arrInCode`이라는 변수가 있다고 가정한다. eval을 리퀘스트로 전달 받은 값 그대로 실행하므로 임의 코드 실행의 취약점이 있다.

🙅 悪い例：受け取ったコードの中に `$arrInCode` という変数があると仮定します。evalでリクエストで受け取った値をそのまま実行しますので、任意コード実行の脆弱性があります。

```php
use Illuminate\Http\Request;

Route::post('/extract-arr', function (Request $request) {
    $input = $request->input('code');
    eval($input);

    if (!isset($arrInCode)) {
        return response()->json(['error' => 'No result from code execution.'], 400);
    }

    return response()->json(['result' => var_export($arrInCode, true)]);
});
```

🙆‍♂️ 좋은 예 : data 파라메터의 데이터 전달의 매개체를 json 포멧으로 하였으므로 임의 코드 실행의 취약점이 없다.

🙆‍♂️ 良い例：dataパラメータのデータの受け渡しをjsonフォーマットで行いますので、任意コード実行の脆弱性がありません。

```php
use Illuminate\Http\Request;

Route::post('/extract-arr', function (Request $request) {
    $input = $request->input('data');

    if (!is_string($input)) {
        return response()->json(['error' => 'Input must be a JSON string.'], 400);
    }

    $decoded = json_decode($input, true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        return response()->json(['error' => 'Invalid JSON format.'], 400);
    }

    if (!is_array($decoded)) {
        return response()->json(['error' => 'Decoded value is not an array.'], 400);
    }

    return response()->json(['result' => var_export($decoded, true)]);
});
```

### unserialize의 주의점

### unserializeの注意点

json_encode/json_decode는 json에서 파싱 가능한 문자열로 변환하고 복원하는 기능을 한다. php의 클래스를 기반으로 한 객체를 시리얼라이징하고자 할 때는 serialize/unserialize를 사용한다. 객체의 클래스 정보와 상태 정보를 나타내는 문자열로 변환하여, 동일한 상태의 객체를 복원할 때 사용하는 기능이다. 

json_encode/json_decodeはjsonでパース可能な文字列への変換と復元機能を持ちます。phpのクラスをベースとしたオブジェクトをシリアライズしたい場合はserialize/unserializeを使います。オブジェクトのクラス情報と状態情報を表す文字列へ変換し、同じ状態のオブジェクトを復元するための機能です。

객체 뿐만 아니라 다른 값에 대해서도 사용가능하지만, 객체를 시리얼라이징할 때는 php에서 제공되는 다른 기능 보다도 serialize/unserialize를 사용하는 것이 가장 간단하고 확실한 방법이다.

オブジェクトだけでなく他の値にも利用できますが、オブジェクトをシリアライズする際は、phpの他の機能よりもserialize/unserializeを使うのが最も簡単かつ確実な方法です。

unserialize로 객체를 복원할 때는 코드를 자동 실행할 수 있는 케이스가 있다. 객체에 `__destruct` 메소드가 존재하는 경우인데, 이 메소드는 객체가 소멸될 때 (의도적 삭제 또는 가비지 컬렉터에 의해 수거되거나, php 프로세스가 정상 종료될 때) `__destruct` 메소드 블럭 내의 코드를 실행한다.

unserializeでオブジェクトを復元する際に、自動でコードが実行されるケースがあります。オブジェクトに `__destruct` メソッドが存在する場合、このメソッドはオブジェクトが消滅する際（意図的削除、ガベージコレクタによる回収、phpプロセスが正常終了する時）に `__destruct` メソッド内のコードを実行します。

unserialize로 시리얼라이즈 된 데이터의 객체를 복원하고, 복원을 통해 생성된 객체가 소멸할 때 `__destruct` 메소드 블록의 코드가 실행되면서 디시리얼라이즈 한 것만으로도 eval 처럼 문자열을 통해 코드를 실행하는 문제점이 발생한다.

unserializeによってシリアライズされたデータのオブジェクトを復元し、生成されたオブジェクトが消滅する際に `__destruct` メソッドのコードが実行されることで、デシリアライズしただけでevalのように文字列からコードが実行される問題が発生します。

시리얼라이즈 된 데이터에서 객체를 복원할 때는 클래스 정보가 필요하기 때문에 php 코드가 실행될 때 디시리얼라이즈 대상 객체의 클래스를 담은 코드를 먼저 실행해야 한다는 제약 사항이 존재하기 때문에 항상 디시리얼라이즈 되는 것은 아니지만, php 코드의 클래스 정보가 노출이 되거나 파일 인젝션을 통해서 올려진 php 파일이 오토 로딩을 통해 생성된 클래스의 코드가 php 엔진에 의해 읽혀질 경우, 객체가 생성되면서 `__destruct` 메소드가 호출될 수 있다.

シリアライズされたデータからオブジェクトを復元する際はクラス情報が必要ですので、phpコードが実行される時にデシリアライズ対象オブジェクトのクラスを含むコードを先に読み込む必要があります。しかし、常にデシリアライズされるわけではありませんが、phpコードのクラス情報が漏洩したり、ファイルインジェクションを通じてアップロードされたphpファイルがオートローディングでクラスコードとしてphpエンジンに読み込まれると、オブジェクト生成時に `__destruct` メソッドが呼び出されることがあります。

#### unserialize 취약점 해결
#### unserialize脆弱性の対策

serialize/unserialize 보다는 가능한 json_encode/json_decode 쪽을 사용하자. 애플리케이션 외부에서 정의할 수 있는 데이터는 unserialize 대상에서 제외한다.

serialize/unserializeよりも可能な限りjson_encode/json_decodeを使用します。アプリケーション外部で定義可能なデータはunserializeの対象から除外します。

객체를 unserialize하기 위해서는 애플리케이션 측의 클래스가 정의되어야 하기 때문에 객체를 시리얼라이징 할 필요가 있다면 애플리케이션 내부에서만 공유가 되도록 외부 서버나 클라이언트에 노출하지 말고 서버 세션이나 레디스 디비 정도에서 사용하도록 하자.

オブジェクトをunserializeするにはアプリケーション側のクラス定義が必要ですので、オブジェクトをシリアライズする必要がある場合はアプリケーション内部だけで共有し、外部サーバやクライアントに公開せず、サーバセッションやRedis DBなどで利用します。

#### unserialize 코드의 예시
#### unserializeコードの例

🙅 나쁜 예 : `$data`에 시리얼라이즈 된 객체가 들어 왔다면 `__destruct` 메소드에 의한 취약점이 실행될 수 있다.

🙅 悪い例：`$data` にシリアライズされたオブジェクトが入っていれば、`__destruct` メソッドによる脆弱性が実行される可能性があります。

```php
use Illuminate\Http\Request;

Route::post('/bad-unserialize', function (Request $request) {
    $data = $request->input('payload');
    $result = unserialize($data);
    return response()->json(['result' => 'unserialization succeed']);
});
```

🙆‍♂️ 좋은 예 : SafeClass의 코드는 개발자 측에서 확인할 수 있으므로 안전한 상태이다. 이 주형에 맞게 시리얼라이즈 된 데이터에서 상태를 가져와서 객체를 만들기 때문에 시리얼라이즈 된 데이터에 클래스에 맞지 않는 부분이 있다면 무시되어 객체화 되기 때문에 취약점이 발생하지 않는다.

🙆‍♂️ 良い例：SafeClassのコードは開発者が確認できますので安全です。テンプレート通りにシリアライズされたデータの状態を読み込んでオブジェクトを生成しますので、シリアライズデータにクラスに合わない部分があれば無視されてオブジェクト化されるため、脆弱性が発生しません。

```php
use App\Models\SafeClass;
use Illuminate\Http\Request;

Route::post('/good-unserialize', function (Request $request) {
    $data = $request->input('payload');

    if (!is_string($data)) {
        return response('payload must be a string', 400);
    }

	/**
     * @link https://www.php.net/manual/en/function.unserialize.php
     */
    $result = @unserialize($data, ['allowed_classes' => [SafeClass::class]]);

    if ($result === false && $data !== serialize(false)) {
        return response('unserialize failed: invalid data', 400);
    }

    return response()->json(['result' => 'unserialization succeed']);
});
```

### XML

마크업 방식의 문서 파일을 통해서 데이터를 교환하는 방식이 있는데, 대표적으로 XML이 존재한다. 시스템 간 데이터 교환을 위한 매개체로 XML을 사용하는 경우, XML의 외부 파일을 읽는 기능이 취약점을 유발할 수 있다. 실행하지 않고 읽는 기능만으로 왜 문제가 되는지 다음을 보자.

マークアップ方式の文書ファイルを通じてデータを交換する方法として、代表的なのがXMLです。システム間のデータ交換手段としてXMLを使う場合、XMLの外部ファイルを読む機能が脆弱性を引き起こすことがあります。実行せずに読み込む機能だけでなぜ問題になるのか、次を見てみます。

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
  <!ENTITY variable SYSTEM "file:///etc/passwd">
]>
```

위와 같은 XML 파일이 있다고 하자. 이 파일을 파싱하면 리눅스 유저의 정보(사용자 이름, UID, 홈 디렉터리, 디폴트 셸 등)가 적혀 있는 etc/passwd 파일을 읽어서 표시할 수 있다는 문제가 있다. 이를 통해서 해커는 서버의 여러 정보에 접근할 수 있으며 이러한 정보가 쌓이면 시스템을 해킹할 가능성이 높아지므로 가능한 서버의 정보를 유출하지 않는 대책을 세우는 것이 필요하다.

このようなXMLファイルがあるとします。このファイルをパースすると、Linuxユーザーの情報（ユーザー名、UID、ホームディレクトリ、デフォルトシェルなど）が書かれている/etc/passwdファイルを読み込んで表示する問題が発生します。これによって攻撃者はサーバの様々な情報にアクセスでき、情報が集まるとシステムがハッキングされる可能性が高まりますので、サーバ情報の漏洩を防ぐ対策が必要です。

단순히 정보 유출 뿐만 아니라, 외부 파일을 파싱하는데 리소스가 드는 점을 이용해서 ENTITY가 외부 파일을 순환 참조하는 것을 통해 서버의 부하를 일으켜 장애를 일으킬 수 있다.

単なる情報漏洩だけでなく、外部ファイルをパースする際にリソースが消費されることを利用し、ENTITYが外部ファイルを循環参照することでサーバに負荷をかけ障害を起こすこともできます。

또한 `<!ENTITY xxe SYSTEM "http://internal-server/access_keys">`와 같이 내부망에서만 엑세스가 가능한 경로의 데이터를 취득할 수도 있다.

また `<!ENTITY xxe SYSTEM "http://internal-server/access_keys">` のように、内部ネットワークでのみアクセス可能なパスのデータを取得することもできます。

또한 XML은 시리얼라이즈/디시리얼라이즈를 통한 데이터 교환의 매개체로 사용되므로 프로그래밍 언어의 객체로도 디시리얼라이즈 될 수 있다. 이 때문에 unserialize 취약점에서와 같은 `__destruct` 메소드의 호출에 의한 코드 실행 등의 문제도 발생할 수 있다.

さらにXMLはシリアライズ／デシリアライズによるデータ交換の手段としても使われますので、プログラミング言語のオブジェクトにもデシリアライズ可能です。このため、unserialize脆弱性のような`__destruct`メソッドの呼び出しによるコード実行の問題も発生することがあります。

이러한 XML의 Entity 태그를 이용한 공격 방식을 ***XXE***(External XML Entity Injection)라고 부른다.

このようなXMLのEntityタグを利用した攻撃手法を ***XXE***（External XML Entity Injection）と呼びます。

#### XXE 공격의 대책
#### XXE攻撃の対策

1. 가능한 XML 파일을 시리얼라이제이션의 중간 매개체가 아닌, JSON을 중간 매개체로 사용하는 방식을 고려한다.
2. 기본적으로 XML 파일이 외부 데이터를 참조할 수 없도록 XML 파서에서 외부 ENTITY 해석을 비활성화하도록 설정하는 방법을 사용한다. 
	- XML 파일을 다루는 libxml2 라이브러리의 버전을 2.9 이상으로 하면 XML이 디폴트로 외부 파일을 참조하지 않는다.
	- PHP의 경우에는 `libxml_disable_entity_loader(true)`로 비활성화를 한다. 기본적으로 php8 부터는 외부 파일 참조가 기본 비활성화 되므로 이 내장함수는 Deprecated 상태이다.

1. 可能な限りXMLファイルをシリアライゼーションの中間手段ではなく、JSONを中間手段として利用する方法を検討します。
2. 基本的にXMLファイルが外部データを参照できないよう、XMLパーサーで外部ENTITYの解釈を無効化する設定を行います。
    - XMLファイルを扱うlibxml2ライブラリのバージョンを2.9以上にすると、XMLはデフォルトで外部ファイルを参照しません。
    - PHPの場合は `libxml_disable_entity_loader(true)` で無効化できます。基本的にphp8以降は外部ファイル参照がデフォルトで無効化されているため、この組み込み関数は非推奨扱いです。

# 마지막으로

현명한 사람은 위험을 미리 보고 피하지만 우둔한 사람은 그대로 가다가 고난을 당한다.

何かを始めるとき、思慮深い人はきちんと見通しを立てますが、考えの足りない人は向こう見ずに手をつけて失敗します。

[^1]: 『安全なWebアプリケーションの作り方』 構造化データの読み込みにまつわる問題、ISBN: 978-4-7973-9316-3
