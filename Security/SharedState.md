# 공유변수

## 상태

상태라는 것은 대상이 표현하는 것을 의미한다. 나무라는 대상은, 여름에는 파란 잎을 가지고, 가을에는 빨갛거나 노란 잎을 가지고, 겨울에는 나뭇잎을 가지지 않듯이 나무의 드러나는 표현, 곧 모습이 바뀐다. 이는 나무의 상태가 바뀐다고 표현할 수 있다.

## 프로그래밍 언어의 상태

프로그래밍 언어에서 상태라는 것은 변수에 저장된 데이터의 변화에 따라 동작이 달라지는 어떤 로직의 단위를 의미하기도 하고, 객체의 멤버 변수에 저장된 값을 의미하기도 한다. 객체는 멤버 변수의 변화에 따라 메소드의 결과값이 달라지고, 어떤 로직의 단위는 전달된 값에 따라 처리 결과가 달라지는 특성을 갖는다. 전달되는 값에 따라, 멤버 변수의 값에 따라 동작의 결과가 달라지는데 결과에 영향을 주는 변경 가능한 요인이 상태이다.

## 애플리케이션의 상태

애플리케이션이 가동될 때, 유저의 입력 값 또는 시스템 내부의 어떤 요인에 의해 애플리케이션 내부의 값들이 바뀌고 이에 따라 애플리케이션이 표현하는 각종 결과값이 달라진다. 이런 표현의 결과에 영향을 주는 각종 세팅을 상태라고 표현을 한다.

## 웹 애플리케이션의 상태

웹 애플리케이션은 리퀘스트를 처리하여 리스폰스를 만들어내는 일련의 과정이다. 서로 다른 리퀘스트 각각에 대해 애플리케이션의 동작의 결과가 달라지기 위해서는 (난수 방식을 제외하고서는) 상태라는 것이 변경되어야 한다. 상태가 변경 되어야 결과 값이 달라지는 것이다.

### 스테이트리스와 스테이트풀

일반적으로 php는 하나의 리퀘스트를 하나의 php 프로세스가 실행을 한다. (이러한 php의 처리 방식을 CGI 방식이라 한다.) 서로 다른 리퀘스트를 처리할 때는 서로 다른 php 프로세스가 실행된다. 이 두 php 프로세스 간의 데이터 공유, 디비, 레디스, 파일 시스템 등을 사용하지 않는다면, 동일 리퀘스트에 대해서 동일한 애플리케이션 로직이 동작하므로 서로 동일한 결과를 갖는다.

이에 반해, NodeJS, JAVA, C# 등의 언어에서 웹 애플리케이션은 서로 다른 리퀘스트를 처리할 때는 동일한 애플리케이션에서 처리된다. 이 때 하나의 리퀘스트에 의해서 변수의 값이 변경되면, 다른 리퀘스트의 결과에 영향을 줄 수 있고, 결과를 바꿀 수 있다.

php는 서로 다른 리퀘스트를 처리하는데 php 애플리케이션은 상태 공유가 일어나지 않기 때문에 스테이트리스라고 부르고, 서로 다른 리퀘스트를 처리할 때 언어 자체의 상태 공유가 있어 동일 리퀘스트의 후속 리퀘스트의 결과가 앞선 리퀘스트의 영향을 받는 것을 스테이트풀이라고 부른다.

물론, 일반적으로 php에 디비, 레디스, 파일 등을 이용하여 php프로세스 간의 데이터 공유를 하므로 일반적인 php 애플리케이션은 스테이트풀하다. 하지만, CGI 방식의 리퀘스트 처리 그 자체만으로는 스테이트리스하다고 표현한다.

## 다룰 취약점

서로 다른 리퀘스트를 처리할 때, 애플리이션 내부의 상태공유로 인해 발생하는 취약점에 대해서 알아보도록 하자.

### 애플리케이션 언어의 변수 공유로 인한 취약점

일반적인 php 개발에서 이 문제는 발생하지 않는데, 서로 다른 리퀘스트는 서로 다른 php 프로세스로 실행되기 때문이다. 물론 서로 다른 리퀘스트를 동일한 애플리케이션에서 다루는 Swoole, roadrunner 등을 사용한다면 이러한 취약점이 발생할 수 있다.

```js
let currentUserID = null;

exports.setUserID = (id) => {
  currentUserID = id;
};

exports.getUserID = () => {
  return currentUserID;
};

// authController.js
const userState = require('./userState');

exports.login = (req, res, next) => {
  const authenticatedUserID = req.body.userID;
  userState.setUserID(authenticatedUserID);
  next();
};

// dataController.js
const userState = require('./userState');

exports.getUserData = (req, res) => {
  const userID = userState.getUserID();

  /**
   * retrieve user data matched userID
   */
  res.json({ message: `User ${userID}'s data.` });
};
```

`currentUserID`라는 변수는 컨트롤러 외부 스코프의 코드로 컨트롤러 간 공유되는 변수이다. 서로 다른 리퀘스트가 거의 동시에 실행 되면서 `currentUserID`는 애플리케이션의 공유 변수가 다음으로 들어온 리퀘스트에 의해 덮어 씌워지면서 A 리퀘스트에서 전달된 값이 B 리스폰스에 영향을 주게 되는 문제가 발생한다.

| 시간 | 사용자 A의 리퀘스트 (ID: 100) | 사용자 B의 리퀘스트 (ID: 200) | 공유 변수 `currentUserID` 상태 |
| :--- | :--- | :--- | :--- |
| **t1** | `authController.login` 진입 | | **null** |
| **t2** | `userState.setUserID(100)` 호출 | | **100** |
| **t3** | | `authController.login` 진입 | **100** |
| **t4** | | `userState.setUserID(200)` 호출 (**A의 ID를 덮어씀**) | **200** |
| **t5** | A의 리퀘스트가 `dataController.getUserData` 진입 | | **200** |
| **t6** | `userState.getUserID()` 호출 | | **200** |
| **t7** | **결과:** 사용자 A(ID 100)는 **사용자 B(ID 200)**의 ID로 데이터를 조회한다. | | **200** |

이런 문제가 발생하지 않게 하기 위해서는 서로 다른 두 리퀘스트 간의 변수의 공유가 일어나지 않도록 주의해야 한다. CGI 방식의 php는 이런 부분을 신경쓰지 않아도 된다.

### 해결방안

- 가능한 서로 다른 리퀘스트 간의 변수 공유가 일어나지 않게 코드를 작성하는 것이 가장 중요하다.

- 어쩔 수 없이 변수 공유를 해야 하는 경우 한 리퀘스트 사이클(리퀘스트에서 리스폰스를 반환하기의 과정)에서 공유 변수를 사용하고 있을 때, 다른 리퀘스트 사이클의 처리 과정에서 처리 중인 변수에 접근하지 못하도록 관리하는 배타적 제어 기법을 사용해야 한다.

## 애플리케이션 저장소에 의한 문제로 인한 취약점

### 세션

세션이란 서버가 클라이언트(브라우저) 각각을 고유한 유저로 판별할 수 있는 방법이다.

1. 먼저 브라우저에 특별한 유저 식별 키를 보낸다. (이 때 리스폰스의 헤더에는 쿠키 값으로 유저 식별 키를 보내고 브라우저는 이 값을 쿠키에 세팅한다.)
2. 브라우저는 서버에서 발급 받은 유저 식별 키를 쿠키에 저장한다.
3. 리퀘스트가 서버로 전송한다. 이 때 동일 도메인에서 발행한 쿠키는 별다른 설정 없이도 리퀘스트에 헤더에 붙어서 전송이 되는데, 서버에서는 앞서 브라우저에 보낸 유저 식별 키를 다시 받게 된다. (브라우저의 쿠키가 초기화 되거나 만료되었다면 브라우저는 서버로 쿠키를 전송하지 않는다.)
4. 서버는 브라우저 쿠키에 유저 식별 키가 있는지 확인하고, 앞서 발급한 유저 식별 키와 일치하면 동일 유저로 파악한다.
5. 쿠키가 노출되면 제3자가 로그인을 할 수 있기 때문에, 서버는 리스폰스의 쿠키에 새로운 유저 식별 키를 발급하고, 쿠키가 노출 되더라도 새로운 유저 식별 키를 쿠키에 갱신하는 방법을 통해 제 3자의 동일 유저로의 접근을 방지할 수 있다. 이를 세션 인젝션이라고 한다.

이 방법으로 로그인 하지 않은 유저가 동일한 유저인지 식별할 수 있으며, 로그인 한 유저도 앞서 로그인 한 대상인지 확인할 수 있다.

시크릿 탭을 또는 다른 브라우저의 장바구니가 초기화 되어 있고, 로그인이 별도로 동작하는 이유는 쿠키를 별도로 저장하기 때문에 유저 식별 키가 서로 다르기 때문이다.

### 세션 무효화에 의한 취약점

서버는 리스폰스 헤더의 정보를 통해서 브라우저에 쿠키를 세팅하라고 지시한다. 그런데 리스폰스 헤더가 잘못 설정되어 있다면, 브라우저는 쿠키를 저장하지 않거나 잘못 저장을 하게 되고, 새로운 유저의 식별 키가 쿠키에 저장되지 않고, 로그아웃 한 유저의 식별 키가 서버로 전송되어 이전 유저의 정보를 열람 하는 등의 문제가 발생할 수 있다.

### Nginx 등의 설정 주의하기

Nginx, Apache 등을 이용할 때, 이들은 쿠키를 저장할지 말지에 대한 옵션을 리스폰스 헤더에 붙일 수 있는 옵션이 있다. 유저 식별키를 갱신해서 로그인 로그아웃 정보를 갱신할 수 있도록 브라우저에 지시해야 하는데 Nginx, Apache 등의 중간 서버 설정으로 인해서 갱신이 제대로 되지 않는다면 위의 취약점이 발생할 수 있다.

### 리스폰스 헤더 세팅의 유의점

서버의 리스폰스에는 Cache-Control 이라는 헤더가 있다. 이를 통해서 캐시 설정을 할 수 있다.

pulbic, private 옵션은 브라우저가 리스폰스 정보를 저장할지 말지를 정할 수 있다. 민감한 정보는 private 설정을 통해서 브라우저가 저장하지 않도록 하는 편이 좋다.

쿠키의 유효 기간을 설정하는 max-age, 쿠키의 유효 기간이 만료된 뒤 서버에 재 검증을 거쳐야 유효하다고 판별하는 must-revalidate 등의 옵션이 서버의 쿠키 발행 로직과 잘 맞물리는지 확인해야 한다.
